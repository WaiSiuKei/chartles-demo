var t=Object.defineProperty,e=(e,i,n)=>((e,i,n)=>i in e?t(e,i,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[i]=n)(e,"symbol"!=typeof i?i+"":i,n);import{bD as i,bG as n,u as s,bH as a,y as r,z as o,A as l,e as d}from"./index-5gyre0hA.js";import{P as c}from"./priceLabelPriceAxisView-CKrbEFjY.js";import{T as h}from"./timeLabelTimeAxisView-DLVMuesT.js";import{P as p,T as u}from"./axisPaneView-B6qY_qE1.js";import{a as _}from"./toolPaneView-BkZhzbTB.js";import{V as P,H as m}from"./text-BhorOBkg.js";import{C as f}from"./composite-CCMtJLBO.js";import{L as b}from"./line-BKuOqRrm.js";import{F as w}from"./paneView-MhvZ7TYs.js";class g extends i{hitTest(t){if(null===this._data)return null;const e=t.subtract(this._data.center),i=e.length();if(Math.abs(i-this._data.radius)<=4){const e=t.subtract(this._data.p1).length(),i=t.subtract(this._data.p2).length();if(Math.max(e,i)<=this._data.p1.subtract(this._data.p2).length())return this._hitTest}if(this._data.fillBackground&&i<=this._data.radius){const t=this._data.p1.subtract(this._data.center).normalized(),i=this._data.p2.subtract(this._data.center).normalized(),n=e.normalized(),s=t.dotProduct(i),a=n.dotProduct(t),r=n.dotProduct(i);if(a>=s&&r>=s)return this._backgroundHitTest}return null}drawImpl(t){if(null===this._data)return;const e=t.context;if(e.beginPath(),e.strokeStyle=this._data.color,e.lineWidth=this._data.linewidth,e.arc(this._data.center.x,this._data.center.y,this._data.radius,this._data.angle1,this._data.angle2),e.stroke(),this._data.fillBackground){if(e.arc(this._data.center.x,this._data.center.y,this._data.prevRadius,this._data.angle2,this._data.angle1,!0),this._data.gradient){const t=e.createRadialGradient(this._data.center.x,this._data.center.y,this._data.prevRadius,this._data.center.x,this._data.center.y,this._data.radius);t.addColorStop(0,n(this._data.color1,this._data.transparency)),t.addColorStop(1,n(this._data.color2,this._data.transparency)),e.fillStyle=t}else e.fillStyle=n(this._data.color,this._data.transparency,!0);e.fill()}}}class x extends w{constructor(){super(...arguments),e(this,"_renderer",new f(this._hitTestCollector)),e(this,"_baseTrendRenderer",new b),e(this,"_edgeTrendRenderer",new b)}renderer(){return this._renderer}_updateImpl(){this._renderer.clear();const t=this.points();if(!(null==t?void 0:t.length))return;if(t.length<3)return void this._updateRenderer();const[e,i,n]=t,a=i.subtract(e).normalized(),r=n.subtract(e).normalized(),o=new s(1,0),l=new s(0,1);let d=Math.acos(a.dotProduct(o));a.dotProduct(l)<0&&(d=2*Math.PI-d);let c=Math.acos(r.dotProduct(o));if(r.dotProduct(l)<0&&(c=2*Math.PI-c),c<d&&([d,c]=[c,d]),Math.abs(d-c)>Math.PI){const t=Math.min(d,c);d=Math.max(d,c),c=t+2*Math.PI}const h=this._source.properties();if(t.length>=2){const t=h.levels.reduce(((t,n,s)=>{const o=n.coeff,l=n.color,d=Math.abs(i.subtract(e).length()*o),c=a.add(r).scaled(.5).normalized().scaled(d),p=e.add(c),u=e.add(a.scaled(d)),_=e.add(r.scaled(d));return t.push({coeff:o,color:l,radius:d,labelPoint:p,p1:u,p2:_,linewidth:h.levelsStyle.linewidth,linestyle:h.levelsStyle.linestyle,index:s}),t}),[]);this._updateRenderer(d,c,t)}}_updateRenderer(t=NaN,e=NaN,i=[]){var n;if((null==(n=this.points())?void 0:n.length)<2)return;const s=this._source.properties(),[d,c]=this.points(),h=s.trendline.visible?s.trendline.linewidth:0,p=s.trendline.linestyle;if(this._baseTrendRenderer.setData({points:[d,c],lineColor:s.trendline.color,lineWidth:h,lineStyle:p,extendLeft:!1,extendRight:!1,leftEnd:a.Normal,rightEnd:a.Normal}),this._renderer.append(this._baseTrendRenderer),this.points().length<3)return void this.addAnchors(this._renderer);let u=this.points()[2];const _=c.subtract(d).length(),f=u.subtract(d).normalized();u=d.add(f.scaled(_)),this._edgeTrendRenderer.setData({points:[d,u],lineColor:s.trendline.color,lineWidth:h,lineStyle:p,extendLeft:!1,extendRight:!1,leftEnd:a.Normal,rightEnd:a.Normal}),this._renderer.append(this._edgeTrendRenderer);for(let a=i.length-1;a>=0;a--){const n=i[a],l=new g;l.setData({center:this.points()[0],radius:n.radius,prevRadius:a>0?i[a-1].radius:0,color:n.color,linewidth:n.linewidth,angle1:t,angle2:e,p1:n.p1,p2:n.p2,fillBackground:s.fillBackground,transparency:s.transparency,color1:"",color2:""}),l.setHitTest(new r(o.MovePoint)),this._renderer.append(l);const d=this._updateLabelForLevel({levelIndex:n.index,coeff:n.coeff,color:n.color,leftPoint:n.labelPoint,rightPoint:n.labelPoint,price:"",horzAlign:m.Left,vertAlign:P.Middle});d&&this._renderer.append(d)}const b=[d,c];this._model.currentCreating!==this._source&&b.push(new l(u,{pointIndex:2}));const w=this.createLineAnchor({points:b},0);this._renderer.append(w)}}class y extends _{constructor(){super(...arguments),e(this,"_lines",new x(this,this.model)),e(this,"_paneView",[this._lines]),e(this,"_priceAxisPaneViews",[new p(Object.create(null))]),e(this,"_timeAxisPaneViews",[new u(Object.create(null))]),e(this,"_timeAxisViews",[new h(Object.create(null)),new h(Object.create(null)),new h(Object.create(null))]),e(this,"_priceAxisViews",[new c(Object.create(null)),new c(Object.create(null)),new c(Object.create(null))])}pointsCount(){return 3}setPoint(t,e,i){if(super.setPoint(t,e,i),2===t){const t=d(this.pointToScreenPoint(this.controlPoints[0]));let e=d(this.pointToScreenPoint(this.controlPoints[1]));const i=d(this.pointToScreenPoint(this.controlPoints[2])).subtract(t).length();let n=e.subtract(t);n.length()<=0&&(n=new s(1,0)),e=t.add(n.normalized().scaled(i));const a=d(this.screenPointToPoint(e));this.controlPoints[1]=a}else{const t=d(this.pointToScreenPoint(this.controlPoints[0])),e=d(this.pointToScreenPoint(this.controlPoints[1]));let i=d(this.pointToScreenPoint(this.controlPoints[2]));const n=e.subtract(t).length();let a=i.subtract(t);a.length()<=0&&(a=new s(1,0)),i=t.add(a.normalized().scaled(n));const r=d(this.screenPointToPoint(i));this.controlPoints[2]=r}}addPoint(t,e){if(2===e){const e=d(this.pointToScreenPoint(this.controlPoints[0])),i=d(this.pointToScreenPoint(this.controlPoints[1]));let n=d(this.pointToScreenPoint(t));const s=i.subtract(e).length(),a=n.subtract(e).normalized();n=e.add(a.scaled(s)),t=this.screenPointToPoint(n)}return super.addPoint(t,e)}updateAllViews(){if(!this.controlPoints.length)return;const t=[];for(let n=0;n<this.controlPoints.length;n++){const e=this.controlPoints[n],i=this.pointToScreenPoint(e);if(!i)return;t.push(new l(i,{pointIndex:n}))}const e=t.map((t=>t.x)),i=t.map((t=>t.y));this.controlPoints.forEach(((e,i)=>{this._timeAxisViews[i].update(this._calculateTimeAxisViewData(e.time,t[i].x)),this._priceAxisViews[i].update(this._calculatePriceAxisViewData(e.price,t[i].y))})),e.length>1&&this._timeAxisPaneViews[0].update(this._calculateTimeAxisPaneViewsData(Math.min.apply(null,e),Math.max.apply(null,e))),i.length>1&&this._priceAxisPaneViews[0].update(this._calculatePriceAxisPaneViewData(Math.min.apply(null,i),Math.max.apply(null,i))),this._lines.update({points:t})}}export{g as A,y as F,x as a};
