var e=Object.defineProperty,t=(t,i,s)=>((t,i,s)=>i in t?e(t,i,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[i]=s)(t,"symbol"!=typeof i?i+"":i,s);import{bH as i,L as s,A as n,e as r}from"./index-5gyre0hA.js";import{T as o,a,D as l}from"./toolPaneView-BkZhzbTB.js";import{o as c}from"./index-iNH1zFVl.js";import{P as h}from"./priceLabelPriceAxisView-CKrbEFjY.js";import{T as p}from"./timeLabelTimeAxisView-DLVMuesT.js";import{P as d,T as m}from"./axisPaneView-B6qY_qE1.js";import{C as u}from"./composite-CCMtJLBO.js";import{L as x}from"./line-BKuOqRrm.js";import{V as _}from"./verticalLine-EvGXqPib.js";import"./baseTool-BM5mqL4_.js";class w extends o{constructor(){super(...arguments),t(this,"_renderer",new u(this._hitTestCollector)),t(this,"_trendRenderer",new x)}renderer(){return this._renderer}_updateImpl(){this._renderer.clear();const e=this.points();if((null==e?void 0:e.length)<2)return;const t=this._source.properties(),n={points:e,lineColor:"#808080",lineWidth:1,lineStyle:s.dashed,extendLeft:!1,extendRight:!1,leftEnd:i.Normal,rightEnd:i.Normal};this._trendRenderer.setData(n),this._renderer.append(this._trendRenderer);for(let i=0;i<this._data.coordinates.length;i++){const e={x:this._data.coordinates[i],lineColor:t.lineColor,lineWidth:t.lineWidth,lineStyle:t.lineStyle},s=new _;s.setData(e),this._renderer.append(s)}2===e.length?this._renderer.append(this.createLineAnchor({points:e},0)):this._renderer.append(this.createLineAnchor({points:e},1))}}class f extends a{constructor(){super(...arguments),t(this,"_lines",new w(this,this.model)),t(this,"_paneView",[this._lines]),t(this,"_priceAxisPaneViews",[new d(Object.create(null))]),t(this,"_timeAxisPaneViews",[new m(Object.create(null))]),t(this,"_timeAxisViews",[new p(Object.create(null)),new p(Object.create(null))]),t(this,"_priceAxisViews",[new h(Object.create(null)),new h(Object.create(null))])}pointsCount(){return 2}updateAllViews(){if(!this.controlPoints.length)return;const e=[];for(let r=0;r<this.controlPoints.length;r++){const t=this.controlPoints[r],i=this.pointToScreenPoint(t);if(!i)return;e.push(new n(i,{pointIndex:r}))}const t=e.map((e=>e.x)),i=e.map((e=>e.y));this.controlPoints.forEach(((t,i)=>{this._timeAxisViews[i].update(this._calculateTimeAxisViewData(t.time,e[i].x)),this._priceAxisViews[i].update(this._calculatePriceAxisViewData(t.price,e[i].y))})),t.length>1&&this._timeAxisPaneViews[0].update(this._calculateTimeAxisPaneViewsData(Math.min.apply(null,t),Math.max.apply(null,t))),i.length>1&&this._priceAxisPaneViews[0].update(this._calculatePriceAxisPaneViewData(Math.min.apply(null,i),Math.max.apply(null,i)));const s={points:e,coordinates:[]},o=this.controlPoints[0],a=this.controlPoints[1],l=r(this.chart.timeScale().timeToIndexEx(o.time)),c=a?this.chart.timeScale().timeToIndexEx(a.time):null,h=a?r(c)-l:1;if(0===h)return;const p=this.chart.timeScale().getVisibleLogicalRange();if(null!==p){if(h>0)for(let e=l;e<=p.to;e+=h)s.coordinates.push(r(this.chart.timeScale().logicalToCoordinate(e)));else for(let e=l;e>=p.from;e+=h)s.coordinates.push(r(this.chart.timeScale().logicalToCoordinate(e)));this._lines.update(s)}}}class P extends l{constructor(){super(...arguments),t(this,"type",c)}createPrimitive(){return new f({id:this.id,points:[],lineColor:"#80CCDBFF",lineWidth:2,lineStyle:s.solid},...this.resetArgs)}}export{P as CyclicLinesTool};
