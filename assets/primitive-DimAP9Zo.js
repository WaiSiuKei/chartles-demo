var e=Object.defineProperty,t=(t,r,i)=>((t,r,i)=>r in t?e(t,r,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[r]=i)(t,"symbol"!=typeof r?r+"":r,i);import{e as r,A as i,u as s,cm as n,J as o,z as a,bH as c,L as l,ck as h,bW as d,ch as p,r as u,cr as _}from"./index-5gyre0hA.js";import{a as f,b as m,g}from"./formatter-BMswhHnL.js";import{P}from"./priceLabelPriceAxisView-CKrbEFjY.js";import{T as y}from"./timeLabelTimeAxisView-DLVMuesT.js";import{T as x,a as b,A as w}from"./toolPaneView-BkZhzbTB.js";import{P as L,T as S}from"./axisPaneView-B6qY_qE1.js";import{B as R,V as C}from"./text-BhorOBkg.js";import{f as M}from"./text-BFLAaZ9z.js";import{C as k}from"./composite-CCMtJLBO.js";import{L as v}from"./line-BKuOqRrm.js";import{R as B}from"./rectangle-E0x1RaIQ.js";function A(e){const t=r(e.chartService.chartApi.timeScale().getVisibleLogicalRange());let i=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY;const n=e.chartService.mainSeriesApi.getSeries();for(let r=t.from;r<=t.to;r++){const e=n.dataByIndex(Math.round(r));if(!e)break;const{high:t,low:o}=e.customValues;i=Math.min(o,i),s=Math.max(t,s)}const o=Math.abs(s-i),a=e.chartService.symbolInfo(),c=a.pricescale/a.minmov;return Math.round(.2*o*c)}var T=(e=>(e[e.Entry=0]="Entry",e[e.Close=1]="Close",e[e.ActualEntry=2]="ActualEntry",e[e.ActualClose=3]="ActualClose",e))(T||{}),I=(e=>(e.Percentage="percents",e.Money="money",e))(I||{});class N extends x{constructor(){super(...arguments),t(this,"_entryLineRenderer",new v),t(this,"_stopLineRenderer",new v),t(this,"_targetLineRenderer",new v),t(this,"_positionLineRenderer",new v),t(this,"_fullStopBgRenderer",new B),t(this,"_stopBgRenderer",new B),t(this,"_fullTargetBgRenderer",new B),t(this,"_targetBgRenderer",new B),t(this,"_stopLabelRenderer",new R),t(this,"_middleLabelRenderer",new R),t(this,"_profitLabelRenderer",new R),t(this,"_renderer",new k(this._hitTestCollector))}isLabelVisible(){return this.isHoveredSource()||this.isSelectedSource()||this._source.properties().alwaysShowStats}renderer(){return this._renderer}_updateImpl(){this._renderer.clear();const e=this.points();if((null==e?void 0:e.length)<2)return;const t=4===e.length,a=this._source.lastBarData();if(!a)return;const c=a.closePrice,l=this._source.stopPrice(),h=this._source.profitPrice(),d=this._source.calculatePL(c),p=this._source.symbolInfo();if(!p)return;const u=this._source.priceScale(),_=this._source.timeScale(),m=e[T.Entry].y,g=r(u.priceToCoordinate(l)),P=r(u.priceToCoordinate(h)),y=r(u.priceToCoordinate(c)),x=r(_.logicalToCoordinate(a.index)),b=e[T.Entry].x,w=e[T.ActualEntry]?e[T.ActualEntry].x:e[T.Close].x,L=e[T.ActualClose]?e[T.ActualClose].x:e[T.Close].x,S=e[T.Close].x,R={pl:d,isClosed:t,entryLevel:m,stopLevel:g,profitLevel:P,closeLevel:y,closeBar:x,left:b,entryX:w,right:L,edge:S,entryPrice:this._source.entryPrice(),stopPrice:this._source.stopPrice(),profitPrice:this._source.profitPrice(),currentPrice:c},{mediaSize:{width:C,height:M}}=this._source.getScope();let k=S<-5||b>C+5;this._createBackgroundRenderers(R),this._createLinesRenderers(R);const v=f(p);if(this._createLabelsRenderers(R,v),k=[this._profitLabelRenderer,this._stopLabelRenderer,this._middleLabelRenderer].reduce(((e,t)=>e&&t.isOutOfScreen(C,M)),k),k)return;const[B]=e,A=[new i(new s(b,B.y),{pointIndex:0}),new i(new s(S,B.y),{pointIndex:1,resizeDirections:n}),new i(new s(b,g),{pointIndex:2,resizeDirections:o}),new i(new s(b,P),{pointIndex:3,resizeDirections:o})];this._renderer.append(this.createLineAnchor({points:A},0))}_createBackgroundRenderers(e){const t=this._source.properties();{const r={points:[new s(e.left,e.entryLevel),new s(e.edge,e.stopLevel)],color:"white",lineWidth:0,backColor:t.stopBackground,transparency:t.stopBackgroundTransparency,extendLeft:!1,extendRight:!1,fillBackground:!0,backgroundHitTarget:a.MovePoint};this._fullStopBgRenderer.setData(r),this._renderer.append(this._fullStopBgRenderer)}if(e.pl<0&&e.entryX!==e.right){const r=new s(e.entryX,e.entryLevel),i=new s(e.right,e.closeLevel),n=100-100*(1-(.01*t.stopBackgroundTransparency)**3),o={points:[r,i],color:"white",lineWidth:0,backColor:t.stopBackground,fillBackground:!0,transparency:n,extendLeft:!1,extendRight:!1,backgroundHitTarget:a.MovePoint};this._stopBgRenderer.setData(o),this._renderer.append(this._stopBgRenderer)}{const r={points:[new s(e.left,e.entryLevel),new s(e.edge,e.profitLevel)],color:"white",lineWidth:0,backColor:t.profitBackground,fillBackground:!0,transparency:t.profitBackgroundTransparency,extendLeft:!1,extendRight:!1,backgroundHitTarget:a.MovePoint};this._fullTargetBgRenderer.setData(r),this._renderer.append(this._fullTargetBgRenderer)}if(e.pl>0&&e.entryX!==e.right){const r=new s(e.entryX,e.entryLevel),i=new s(e.right,e.closeLevel),n=100-100*(1-(.01*t.profitBackgroundTransparency)**3),o={points:[r,i],color:"white",lineWidth:0,backColor:t.profitBackground,fillBackground:!0,transparency:n,extendLeft:!1,extendRight:!1,backgroundHitTarget:a.MovePoint};this._targetBgRenderer.setData(o),this._renderer.append(this._targetBgRenderer)}}_createLinesRenderers(e){const t=this.points(),r=this._source.properties(),i=(e,t,i,s)=>{const n={points:[t,i],lineColor:s??r.linecolor,lineWidth:r.linewidth,lineStyle:l.solid,extendLeft:!1,extendRight:!1,leftEnd:c.Normal,rightEnd:c.Normal};e.setData(n),this._renderer.append(e)};if(t[T.ActualEntry]){const i={points:[t[T.ActualEntry],e.isClosed?t[T.ActualClose]:new s(e.closeBar,e.closeLevel)],lineColor:r.linecolor,lineWidth:1,lineStyle:l.dashed,extendLeft:!1,extendRight:!1,leftEnd:c.Normal,rightEnd:c.Arrow};this._positionLineRenderer.setData(i),this._renderer.append(this._positionLineRenderer)}{const r=new s(e.left,t[T.Entry].y),n=new s(e.edge,t[T.Entry].y);i(this._entryLineRenderer,r,n)}{const t=new s(e.left,e.stopLevel),n=new s(e.edge,e.stopLevel);i(this._stopLineRenderer,t,n,r.stopBackground)}{const t=new s(e.left,e.profitLevel),n=new s(e.edge,e.profitLevel);i(this._targetLineRenderer,t,n,r.profitBackground)}}_createLabelsRenderers(e,t){if(!this.isLabelVisible())return;const i=this.points(),n=this._creareMiddleLabel(e),o=this._createStopLabel(e,t),a=this._createTargetLabel(e,t),c=[this._profitLabelRenderer,this._stopLabelRenderer,this._middleLabelRenderer].reduce(((e,t)=>Math.max(e,t.measure().width)),0),l=e.edge-e.left,d=this._anchorRadius();if(l-c-d<=8&&(a&&(a.offsetY+=d+8,this._profitLabelRenderer.setData(a)),o&&(o.offsetY+=d+8,this._stopLabelRenderer.setData(o)),n)){let t;if(this._source.chart.options().rightPriceScale.mode===h.Logarithmic){const r=Math.abs(i[0].y-e.stopLevel);t=Math.abs(i[0].y-e.profitLevel)-r>1?-1:1}else{const r=Math.abs(e.stopPrice-e.entryPrice);t=Math.abs(e.profitPrice-e.entryPrice)-r>1?-1:1}const o=e.profitLevel<e.stopLevel?1:-1,a=r(n.points)[0],c=.5*this._middleLabelRenderer.measure().height+d+8,l=a.add(new s(0,o*t*c));n.points=[l],this._middleLabelRenderer.setData(n)}}_creareMiddleLabel(e){const{entryPrice:t,profitPrice:r,stopPrice:i,currentPrice:n,pl:o,left:a,edge:c,isClosed:l}=e,h=Math.abs(t-r)/Math.abs(t-i),p=this._source.properties(),u=new s((a+c)/2,Math.round(this.points()[0].y));let _="",f="";const g=m().format(Math.round(100*h)/100);if(this.points()[1]){const e=this._source.series.priceFormatter();if("formatChange"in e&&d(e.formatChange)){const r=Math.max(n,t),i=Math.min(n,t);f=o>=0?e.formatChange(r,i):e.formatChange(i,r)}else f=e.format(o)}const P=this._data.qty/p.lotSize,y=Math.floor(P);if(p.compact)f&&(_+=f+" ~ "),_+=y+"\n",_+=g;else{const e=l?p.closeText:p.openText;f&&(_+=p.formatStatusAndPnl({status:e,pnl:f})+", "),_+=p.formatQty({qty:String(y)})+"\n",_+=p.formatRatio({riskRewardRatio:g})+" "}let x=p.linecolor;return o<0?x=p.stopBackground:o>0&&(x=p.profitBackground),this._addCenterLabel(this._middleLabelRenderer,{p:u,txt:_,color:x,vertAlign:C.Middle,offsetY:0,border:"white"})}_addCenterLabel(e,t){const r=this._source.properties(),i={fontFamily:u,offsetX:3,horzAlign:"center",backgroundRoundRect:4,points:[t.p],text:t.txt,color:r.textcolor,offsetY:t.offsetY,vertAlign:t.vertAlign,backgroundColor:p(t.color),fontSize:r.fontsize,borderColor:t.border};return e.setData(i),this._renderer.append(e),i}_createStopLabel(e,t){var r;const{stopPrice:i,entryPrice:n,left:o,edge:a,stopLevel:c}=e,l=this._source.properties(),h=Math.abs(i-n),p=Math.round(h/n*1e4)/100,u=new s((o+a)/2,c),_=this._source.series.priceFormatter(),f="formatChange"in _&&d(_.formatChange)?null==(r=_.formatChange)?void 0:r.call(_,Math.max(i,n),Math.min(i,n)):_.format(h),m=g().format(p);let P="";return P=l.compact?`${f} (${m}) ${this._data.amountStop}`:l.formatTextStop({stopChange:M(f),stopChangePercent:M(m),stopChangePip:t?M(t.format(h)):"",amount:M(String(this._data.amountStop))}),this._addCenterLabel(this._stopLabelRenderer,{p:u,txt:P,color:l.stopBackground,vertAlign:n<i?C.Bottom:C.Top,offsetY:0})}_createTargetLabel(e,t){var r;const{profitPrice:i,entryPrice:n,stopPrice:o,left:a,edge:c,profitLevel:l}=e,h=this._source.properties(),p=Math.abs(i-n),u=Math.round(p/n*1e4)/100,_=new s((a+c)/2,l),f=this._source.series.priceFormatter(),m="formatChange"in f&&d(f.formatChange)?null==(r=f.formatChange)?void 0:r.call(f,Math.max(i,n),Math.min(i,n)):f.format(p),P=g(),y=P.format(u);let x="";return x=h.compact?`${m} (${y}) ${this._data.amountTarget}`:h.formatTextTarget({profitChange:m,profitChangePercent:M(P.format(u)),profitChangePip:t?M(t.format(p)):"",amount:M(""+this._data.amountTarget)}),this._addCenterLabel(this._profitLabelRenderer,{p:_,txt:x,color:h.profitBackground,vertAlign:n<o?C.Top:C.Bottom,offsetY:0})}}class V extends b{constructor(){super(...arguments),t(this,"_lines",new N(this,this.model)),t(this,"_paneView",[this._lines]),t(this,"_priceAxisPaneViews",[new L(Object.create(null))]),t(this,"_timeAxisPaneViews",[new S(Object.create(null))]),t(this,"_timeAxisViews",[new y(Object.create(null)),new y(Object.create(null))]),t(this,"_priceAxisViews",[new P(Object.create(null)),new P(Object.create(null)),new P(Object.create(null))]),t(this,"_data",Object.defineProperties({riskSize:NaN,qty:NaN,amountStop:NaN,amountTarget:NaN,_stopPrice:NaN,stopPrice:NaN,_targetPrice:NaN,targetPrice:NaN},{stopPrice:{get:()=>this._data._stopPrice,set:e=>(this._props.stopLevel=Math.round(Math.abs(e-this.entryPrice())*this.ownerSourceBase()),this._data._stopPrice=e,!0)},targetPrice:{get:()=>this._data._targetPrice,set:e=>(this._props.profitLevel=Math.round(Math.abs(e-this.entryPrice())*this.ownerSourceBase()),this._data._targetPrice=e,!0)}}))}pointsCount(){return 1}addPoint(e,t){e.price=this._roundPrice(e.price),super.addPoint(e,t);const r=this._getClosePointIndex(this.getIndex(e)),i=this.series.dataByIndex(r),s={price:e.price,time:i.time};this.controlPoints[1]=s;const n=this._calculateActualEntry(e,s);if(n){this.controlPoints[2]=n;const e=this._findClosePoint(n,s);e&&(this.controlPoints[3]=e)}return this._data._stopPrice=this.stopPrice(),this._data._targetPrice=this.profitPrice(),w.Accept}setPoint(e,t,r){switch(e){case 0:this._changeEntryPoint(t);break;case 2:this._data.stopPrice=this.prepareStopPrice(t.price);break;case 3:this._data.targetPrice=this.prepareProfitPrice(t.price);break;case 1:t.price=this.controlPoints[0].price,super.setPoint(1,t,r),this.recalculate()}}move(){this.recalculate()}_getClosePointIndex(e){const t=this.timeScale(),r=Math.round(t.width()/t.barSpacing());return e+Math.max(3,Math.round(.15*r))}lastBarData(){const e=this.series.barsProvider(),t=e.firstIndex(),i=e.lastIndex();if(null===t||null===i||isNaN(t)||isNaN(i))return null;const s=this.controlPoints;if(4===s.length){const e=s[T.ActualClose],r=this.getIndex(e);return r<t?null:{closePrice:e.price,index:Math.min(i,r)}}const n=s[T.Close],o=this.getIndex(n);if(o<t)return null;const a=Math.min(i,o),c=this.series.dataByIndex(a,_.NearestLeft);return null===c?null:{closePrice:r(c.customValues.close),index:r(this.timeScale().timeToIndexEx(c.time))}}isLogPriceScale(){return this.chart.options().rightPriceScale.mode===h.Logarithmic}symbolInfo(){return this._ctx.chartService.symbolInfo()}ownerSourceBase(){const e=this._ctx.chartService.symbolInfo();return e?e.pricescale/e.minmov:100}_roundPrice(e){const t=this.ownerSourceBase();return Math.round(e*t)/t}entryPrice(){return this.controlPoints[0].price}_riskFormatter(e){return e===I.Percentage?m(2):m()}recalculate(){const e=this.controlPoints;if(0===e.length)return;const t=[e[0],e[1]],r=this._calculateActualEntry(e[0],e[1]);if(r){t.push(r);const i=this._findClosePoint(r,e[1]);i&&t.push(i)}this.controlPoints.length=0,this.controlPoints.push(...t),this._data._stopPrice=this.stopPrice(),this._data._targetPrice=this.profitPrice()}_recalculateRiskSize(){const e=this.properties(),t=e.risk,r=e.riskDisplayMode,i=e.accountSize;"percents"===r?this._data.riskSize=t/100*i:t>i?(e.risk=i,this._data.riskSize=i):this._data.riskSize=t}_recalculateRisk(){const e=this.properties(),t=e.riskDisplayMode,r=this._data.riskSize,i=e.accountSize;let s=e.risk;s=E("percents"===t?r/i*100:i/100*s),e.risk=parseFloat(this._riskFormatter(t).format(s,{ignoreLocaleNumberFormat:!0}))}_recalculateAmount(){if(0===this.controlPoints.length)return;const e=this.properties().accountSize,t=this.entryPrice(),r=this._data.qty,i=this.stopPrice(),s=this.profitPrice(),n=this._ownerSourcePointValue();this._data.amountTarget=this._amountTarget(e,s,t,r,n),this._data.amountStop=this._amountStop(e,i,t,r,n)}_recalculateQty(){if(0===this.controlPoints.length)return;const e=this.entryPrice(),t=this.stopPrice(),r=this._data.riskSize,i=this._entryPointCurrencyRate(),s=null===i?NaN:r/(Math.abs(e-t)*this._ownerSourcePointValue()*i);this._data.qty=s}_entryPointCurrencyRate(){return 1}_closePointCurrencyRate(){return 1}_ownerSourcePointValue(){return 1}_changeEntryPoint(e){const t=this._data.stopPrice,r=this._data.targetPrice,i=1/this.ownerSourceBase(),s=Math.min(t,r)+i,n=Math.max(t,r)-i;e.price=Math.max(s,Math.min(n,this._roundPrice(e.price))),this.controlPoints[0]=e,this.controlPoints[1]={...this.controlPoints[1],price:e.price},this._data.stopPrice=t,this._data.targetPrice=r,this.recalculate()}_calculateActualEntry(e,t){const i=this.series.barsProvider(),s=r(i.firstIndex()),n=this.getIndex(e),o=Math.max(n,s),a=e.price,c=r(i.lastIndex()),l=this.getIndex(t),h=Math.min(c,l-1);if(o>h)return null;for(let r=o;r<h+1;r++){const e=this.series.dataByIndex(r);if(e.customValues.high>=a&&e.customValues.low<=a)return{time:e.time,price:a}}return null}_findClosePoint(e,t){const i=this.series.barsProvider(),s=r(i.firstIndex()),n=Math.max(this.getIndex(e),s),o=r(i.lastIndex()),a=Math.min(o,this.getIndex(t)-1);if(n>a)return null;for(let r=n;r<a+1;r++){const e=this.series.dataByIndex(r),t=this._checkStopPrice(e);if(null!=t)return{time:e.time,price:t}}return null}updateAllViews(){if(!this.controlPoints.length)return;this._recalculateRiskSize(),this._recalculateRisk(),this._recalculateQty(),this._recalculateAmount();const e=[];for(let s=0;s<this.controlPoints.length;s++){const t=this.controlPoints[s],r=this.pointToScreenPoint(t);if(!r)return;e.push(new i(r,{pointIndex:s}))}const t=e.map((e=>e.x)),r=e.map((e=>e.y));this.controlPoints.forEach(((t,r)=>{r>1||(this._timeAxisViews[r].update(this._calculateTimeAxisViewData(t.time,e[r].x)),this._priceAxisViews[r].update(this._calculatePriceAxisViewData(t.price,e[r].y)))})),t.length>1&&this._timeAxisPaneViews[0].update(this._calculateTimeAxisPaneViewsData(Math.min.apply(null,t),Math.max.apply(null,t))),r.length>1&&this._priceAxisPaneViews[0].update(this._calculatePriceAxisPaneViewData(Math.min.apply(null,r),Math.max.apply(null,r))),this._paneView[0].update({points:e,...this._data})}}function E(e){return parseFloat(e.toFixed(2))}export{V as P,A as c,E as r};
