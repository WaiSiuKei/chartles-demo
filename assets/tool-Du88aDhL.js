var t=Object.defineProperty,i=(i,e,s)=>((i,e,s)=>e in i?t(i,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):i[e]=s)(i,"symbol"!=typeof e?e+"":e,s);import{T as e,a as s,D as n}from"./toolPaneView-BkZhzbTB.js";import{al as o}from"./index-iNH1zFVl.js";import{c8 as r,u as a,A as c,bD as l,cs as h,y as d,z as p,bK as P,e as u}from"./index-5gyre0hA.js";import{P as m}from"./priceLabelPriceAxisView-CKrbEFjY.js";import{T as _}from"./timeLabelTimeAxisView-DLVMuesT.js";import{P as x,T as w}from"./axisPaneView-B6qY_qE1.js";import{a as T,t as y,r as f,s as b}from"./transform-CddyjF1Y.js";import{t as A}from"./handle-C11jaV9I.js";import{C as g}from"./composite-CCMtJLBO.js";import"./baseTool-BM5mqL4_.js";class V extends l{drawImpl(t){if(!this._data||this._data.points.length<2)return;const i=t.context,[e,s]=this._data.points;if(this._data.points.length<3)return i.strokeStyle=this._data.color,i.lineWidth=this._data.lineWidth,i.beginPath(),i.moveTo(e.x,e.y),i.lineTo(s.x,s.y),void i.stroke();const n=this._data.points[2],o=r(e,s,n).distance;if(o<1)return i.strokeStyle=this._data.color,i.lineWidth=this._data.lineWidth,i.beginPath(),i.moveTo(e.x,e.y),i.lineTo(s.x,s.y),void i.stroke();const a=s.subtract(e),c=e.add(s).scaled(.5);i.strokeStyle=this._data.color,i.lineWidth=this._data.lineWidth;const l=a.length(),d=a.x/l,p=a.y/l;let P=Math.acos(d);p<0&&(P=-P);let u=this._data.points[2],m=T(-c.x,-c.y);u=y(m,u),m=f(-P),u=y(m,u),m=b(1,l/(2*o)),u=y(m,u);const _=u.y<0;i.save(),i.beginPath(),i.translate(c.x,c.y),i.rotate(P),i.scale(1,2*o/l),i.arc(0,0,.5*l,0,h,_),i.restore(),i.stroke(),i.fillStyle=this._data.background,i.fill()}hitTest(t){if(!this._data||this._data.points.length<3)return null;const[i,e,s]=this._data.points,n=e.subtract(i),o=i.add(e).scaled(.5),a=r(i,e,s).distance,c=n.length(),l=n.x/c,h=n.y/c;let u=Math.acos(l);h<0&&(u=-u);let m=T(-o.x,-o.y),_=y(m,t);m=f(-u),_=y(m,_),m=b(1,c/(2*a)),_=y(m,_);const x=.5*c,w=P().curve,A=_.length();return Math.abs(A-x)<=w?new d(p.MovePoint):null}}class k extends e{constructor(){super(...arguments),i(this,"_renderer",new g(this._hitTestCollector)),i(this,"_ellipseRenderer",new V)}renderer(){return this._renderer}_updateImpl(){if(this._renderer.clear(),this.points().length<2)return;const t=this._source.properties();if(this._ellipseRenderer.setData({points:this.points(),color:t.lineColor,lineWidth:t.lineWidth,background:t.backgroundColor}),this._renderer.append(this._ellipseRenderer),2===this.points().length)return void this.addAnchors(this._renderer);const[i,e,s]=this.points(),n=r(i,e,s).distance,o=e.subtract(i),l=i.add(e).scaled(.5),h=new a(-o.y,o.x).normalized(),d=l.add(h.scaled(n)),p=l.add(h.scaled(-n)),P=A(i,e),u=[i,e,new c(d,{pointIndex:2,cursorType:P}),new c(p,{pointIndex:3,cursorType:P})];this._renderer.append(this.createLineAnchor({points:u}))}}class S extends s{constructor(){super(...arguments),i(this,"_lines",new k(this,this.model)),i(this,"_paneView",[this._lines]),i(this,"_priceAxisPaneViews",[new x(Object.create(null))]),i(this,"_timeAxisPaneViews",[new w(Object.create(null))]),i(this,"_timeAxisViews",[new _(Object.create(null)),new _(Object.create(null)),new _(Object.create(null))]),i(this,"_priceAxisViews",[new m(Object.create(null)),new m(Object.create(null)),new m(Object.create(null))]),i(this,"_fakePointAdded",!1),i(this,"_dist",null)}pointsCount(){return 3}startChanging(){const t=u(this.pointToScreenPoint(this.controlPoints[0])),i=u(this.pointToScreenPoint(this.controlPoints[1])),e=u(this.pointToScreenPoint(this.controlPoints[2]));this._dist=r(t,i,e).distance}onDragEnd(){super.onDragEnd(),this._dist=null}setPoint(t,i,e){switch(t){case 0:{const t={time:u(e.startPoint).time+e.deltaTime,price:u(e.startPoint).price+e.deltaPrice};if(e.shiftkey)this._snapPoint45Degree(t,this.controlPoints[1]),this.controlPoints[0]=t,this.controlPoints[2]=this._preparePointInternal(this.controlPoints[2],e,!0),this.controlPoints[0].time===this.controlPoints[1].time&&this._fixVerticalDiameterPoints(this.controlPoints[0],this.controlPoints[1],this.controlPoints[2]);else{const i=u(this.pointToScreenPoint(t)),e=u(this.pointToScreenPoint(this.controlPoints[1])),s=e.subtract(i),n=i.add(e).scaled(.5),o=new a(-s.y,s.x).normalized().scaled(u(this._dist)),r=n.add(o);this.controlPoints[0]=t,this.controlPoints[2]=this.screenPointToPoint(r)}break}case 1:{const t={time:u(e.startPoint).time+e.deltaTime,price:u(e.startPoint).price+e.deltaPrice};if(e.shiftkey)this._snapPoint45Degree(t,this.controlPoints[0]),this.controlPoints[1]=t,this.controlPoints[2]=this._preparePointInternal(this.controlPoints[2],e,!0),this.controlPoints[0].time===this.controlPoints[1].time&&this._fixVerticalDiameterPoints(this.controlPoints[1],this.controlPoints[0],this.controlPoints[2]);else{const i=u(this.pointToScreenPoint(this.controlPoints[0])),e=u(this.pointToScreenPoint(t)),s=e.subtract(i),n=i.add(e).scaled(.5),o=new a(-s.y,s.x).normalized().scaled(u(this._dist)),r=n.add(o);this.controlPoints[1]=t,this.controlPoints[2]=this.screenPointToPoint(r)}break}case 2:case 3:{const t=new a(e.screenPoint),i=u(this.pointToScreenPoint(this.controlPoints[0])),s=u(this.pointToScreenPoint(this.controlPoints[1])),n=s.subtract(i),o=i.add(s).scaled(.5),c=new a(-n.y,n.x).normalized(),l=r(i,s,t).distance,h=o.add(c.scaled(l));this.controlPoints[2]=this.screenPointToPoint(h);break}}}_fixVerticalDiameterPoints(t,i,e){const s=u(this.pointToScreenPoint(t)),n=u(this.pointToScreenPoint(i)),o=this.chart.timeScale(),r=u(o.timeToCoordinateEx(t.time)),c=u(o.timeToCoordinateEx(e.time));let l=2*Math.abs(r-c);l*=i.price>t.price?1:-1;const h=this.screenPointToPoint(new a(s.x,n.y+l));t.price=h.price}_snapPoint45Degree(t,i){const e=this.chart.timeScale(),s=u(this.pointToScreenPoint(t)),n=u(this.pointToScreenPoint(i)),o=s.x-n.x,r=s.y-n.y,a=o<0?-1:1,c=r<0?-1:1,l=Math.max(Math.abs(o),Math.abs(r)),h=u(e.coordinateToTimeEx(n.x+l*a)),d=u(e.timeToCoordinateEx(h)),p=Math.abs(d-n.x),P=u(this.series.coordinateToPrice(n.y+p*c));t.time=h,t.price=P}_preparePointInternal(t,i,e=!1){let s={...t};if(null==i?void 0:i.shiftkey){const i=this.controlPoints.length,n=this._fakePointAdded||2===i||e;if(!this._fakePointAdded&&3===i&&!e)return s;if(n){this._snapPoint45Degree(t,this.controlPoints[0]),this._fakePointAdded?this.controlPoints[1]=t:e||(this._fakePointAdded=!0,this.controlPoints.push(t));const i=u(this.pointToScreenPoint(this.controlPoints[0])),n=u(this.pointToScreenPoint(this.controlPoints[1])),o=n.x-i.x,r=n.y-i.y,c=Math.sqrt(o*o+r*r)/2,l=n.subtract(i),h=i.add(n).scaled(.5),d=new a(-l.y,l.x).normalized(),p=h.add(d.scaled(c));let P=this.screenPointToPoint(p);(isNaN(P.price)||isNaN(P.time))&&(P=this.screenPointToPoint(h)),s=P}}else this._fakePointAdded&&(this.controlPoints.splice(1,1),this._fakePointAdded=!1);return s}updateAllViews(){if(!this.controlPoints.length)return;const t=[],i=[],[e,s,n]=this.controlPoints,o=[];for(let r=0;r<this.controlPoints.length;r++){const e=this.controlPoints[r],s=this.pointToScreenPoint(e);if(!s)return;t.push(s.x),i.push(s.y);const n=new c(s,{pointIndex:r,hitTarget:p.ChangePoint});o.push(n)}this._timeAxisViews[0].update(this._calculateTimeAxisViewData(e.time,o[0].x)),this._priceAxisViews[0].update(this._calculatePriceAxisViewData(e.price,o[0].y)),s&&(this._timeAxisViews[1].update(this._calculateTimeAxisViewData(s.time,o[1].x)),this._priceAxisViews[1].update(this._calculatePriceAxisViewData(s.price,o[1].y))),n&&(this._timeAxisViews[2].update(this._calculateTimeAxisViewData(n.time,o[2].x)),this._priceAxisViews[2].update(this._calculatePriceAxisViewData(n.price,o[2].y))),t.length&&this._timeAxisPaneViews[0].update(this._calculateTimeAxisPaneViewsData(Math.min.apply(null,t),Math.max.apply(null,t))),i.length&&this._priceAxisPaneViews[0].update(this._calculatePriceAxisPaneViewData(Math.min.apply(null,i),Math.max.apply(null,i))),this._lines.update({points:o})}}class D extends n{constructor(){super(...arguments),i(this,"type",o)}createPrimitive(){return new S({id:this.id,points:[],lineColor:"#F23645FF",lineWidth:2,backgroundColor:"#F2364533"},...this.resetArgs)}}export{D as EllipseTool};
