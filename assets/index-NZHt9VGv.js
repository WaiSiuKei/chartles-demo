const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./Left-DFGFkdAK.js","./index-TSHQCVD9.js","./baseTool-CHlzZht2.js","./index-DMTsRJKV.js","./toolPaneView-3wj_on-u.js","./adjustValue-CiEFCu0u.js","./index-Dzc6L2mL.js","./priceLabelPriceAxisView-d9Maj5lR.js","./composite-tvPrNHN0.js","./text-CtvZov1L.js","./text-8RrTwjoh.js","./ctx-Bv0u81rl.js"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __publicField = (obj, key2, value) => __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _a2, _b, _previous, _callbacks, _pending, _deferred, _neutered, _async_effects, _boundary_async_effects, _render_effects, _effects, _block_effects, _dirty_effects, _maybe_dirty_effects, _Batch_instances, traverse_effect_tree_fn, defer_effects_fn, commit_fn, _c, _d;
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link2 of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link2);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link2) {
    const fetchOpts = {};
    if (link2.integrity) fetchOpts.integrity = link2.integrity;
    if (link2.referrerPolicy) fetchOpts.referrerPolicy = link2.referrerPolicy;
    if (link2.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link2.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link2) {
    if (link2.ep)
      return;
    link2.ep = true;
    const fetchOpts = getFetchOpts(link2);
    fetch(link2.href, fetchOpts);
  }
})();
function findFirstIdxMonotonousOrArrLen(array, predicate, startIdx = 0, endIdxEx = array.length) {
  let i2 = startIdx;
  let j2 = endIdxEx;
  while (i2 < j2) {
    const k2 = Math.floor((i2 + j2) / 2);
    if (predicate(array[k2])) {
      j2 = k2;
    } else {
      i2 = k2 + 1;
    }
  }
  return i2;
}
function coalesce(array) {
  return array.filter((e2) => !!e2);
}
function topStep(array, compare, result, i2, m2) {
  for (const n2 = result.length; i2 < m2; i2++) {
    const element2 = array[i2];
    if (compare(element2, result[n2 - 1]) < 0) {
      result.pop();
      const j2 = findFirstIdxMonotonousOrArrLen(result, (e2) => compare(element2, e2) < 0);
      result.splice(j2, 0, element2);
    }
  }
}
function top(array, compare, n2) {
  const result = array.slice(0, n2).sort(compare);
  topStep(array, compare, result, n2, array.length);
  return result;
}
function upperbound(array, value, compare, start2 = 0, end = array.length) {
  let count = end - start2;
  while (count > 0) {
    const step = count >> 1;
    const index2 = start2 + step;
    if (compare(value, array[index2])) {
      count = step;
    } else {
      start2 = index2 + 1;
      count -= step + 1;
    }
  }
  return start2;
}
function binarySearch(accessor, target, comparator, start2, end) {
  let length = end - start2;
  while (length > 0) {
    const half = length >> 1;
    const mid = start2 + half;
    if (comparator(accessor(mid), target)) {
      start2 = mid + 1;
      length -= half + 1;
    } else {
      length = half;
    }
  }
  return start2;
}
function lowerbound(array, target, comparator, start2 = 0, end = array.length) {
  return binarySearch((index2) => array[index2], target, comparator, start2, end);
}
function format$2(message2, args) {
  let result;
  if (args.length === 0) {
    result = message2;
  } else {
    result = message2.replace(/\{(\d+)\}/g, (match2, rest) => {
      const index2 = rest[0];
      return typeof args[index2] !== "undefined" ? args[index2] : match2;
    });
  }
  return result;
}
function localize$1(key2, message2, ...args) {
  return format$2(message2, args);
}
const nls = {
  localize: localize$1
};
function isString$1(str) {
  return typeof str === "string";
}
function isFiniteNumber(obj) {
  return typeof obj === "number" && !isNaN(obj);
}
function isNumber(obj) {
  return typeof obj === "number";
}
function isUndefined(obj) {
  return typeof obj === "undefined";
}
function isUndefinedOrNull(obj) {
  return isUndefined(obj) || obj === null;
}
function illegalState(name) {
  {
    return new Error(`Illegal state: ${name}`);
  }
}
class ErrorHandler {
  constructor() {
    __publicField(this, "unexpectedErrorHandler");
    __publicField(this, "listeners");
    this.listeners = [];
    this.unexpectedErrorHandler = function(e2) {
      setTimeout(() => {
        if (e2.stack) {
          throw new Error(e2.message + "\n\n" + e2.stack);
        }
        throw e2;
      }, 0);
    };
  }
  addListener(listener) {
    this.listeners.push(listener);
    return () => {
      this._removeListener(listener);
    };
  }
  emit(e2) {
    this.listeners.forEach((listener) => {
      listener(e2);
    });
  }
  _removeListener(listener) {
    this.listeners.splice(this.listeners.indexOf(listener), 1);
  }
  setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
    this.unexpectedErrorHandler = newUnexpectedErrorHandler;
  }
  getUnexpectedErrorHandler() {
    return this.unexpectedErrorHandler;
  }
  onUnexpectedError(e2) {
    this.unexpectedErrorHandler(e2);
    this.emit(e2);
  }
  // For external errors, we don't want the listeners to be called
  onUnexpectedExternalError(e2) {
    this.unexpectedErrorHandler(e2);
  }
}
const errorHandler = new ErrorHandler();
function onUnexpectedError(e2) {
  if (!isCancellationError(e2)) {
    errorHandler.onUnexpectedError(e2);
  }
  return void 0;
}
const canceledName = "Canceled";
function isCancellationError(error) {
  if (error instanceof CancellationError) {
    return true;
  }
  return error instanceof Error && error.name === canceledName && error.message === canceledName;
}
function illegalArgument(name) {
  {
    return new Error(`Illegal argument: ${name}`);
  }
}
class CancellationError extends Error {
  constructor() {
    super(canceledName);
    this.name = this.message;
  }
}
class BugIndicatingError extends Error {
  constructor(message2) {
    super(message2 || "An unexpected bug occurred.");
    Object.setPrototypeOf(this, BugIndicatingError.prototype);
  }
}
function NOTREACHED(...msgs) {
  if (msgs.length) {
    console.error(...msgs);
  }
  throw new Error("not reached");
}
function NOTIMPLEMENTED(...msgs) {
  if (msgs.length) {
    console.error(...msgs);
  }
}
function toErrorMessage(error = null, verbose = false) {
  if (!error) {
    return nls.localize(
      "error.defaultMessage",
      "An unknown error occurred. Please consult the log for more details."
    );
  }
  if (Array.isArray(error)) {
    const errors = coalesce(error);
    const msg = toErrorMessage(errors[0], verbose);
    if (errors.length > 1) {
      return nls.localize("error.moreErrors", "{0} ({1} errors in total)", msg, errors.length);
    }
    return msg;
  }
  if (isString$1(error)) {
    return error;
  }
  if (error.detail) {
    const detail = error.detail;
    if (detail.error) {
      return exceptionToErrorMessage(detail.error, verbose);
    }
    if (detail.exception) {
      return exceptionToErrorMessage(detail.exception, verbose);
    }
  }
  if (error.stack) {
    return exceptionToErrorMessage(error, verbose);
  }
  if (error.message) {
    return error.message;
  }
  return nls.localize(
    "error.defaultMessage",
    "An unknown error occurred. Please consult the log for more details."
  );
}
function exceptionToErrorMessage(exception, verbose) {
  if (verbose && (exception.stack || exception.stacktrace)) {
    return nls.localize(
      "stackTrace.format",
      "{0}: {1}",
      detectSystemErrorMessage(exception),
      stackToString(exception.stack) || stackToString(exception.stacktrace)
    );
  }
  return detectSystemErrorMessage(exception);
}
function stackToString(stack) {
  if (Array.isArray(stack)) {
    return stack.join("\n");
  }
  return stack;
}
function detectSystemErrorMessage(exception) {
  return exception.message || nls.localize(
    "error.defaultMessage",
    "An unknown error occurred. Please consult the log for more details."
  );
}
const { userAgent: userAgent$1 } = navigator;
const isWindows = userAgent$1.indexOf("Windows") >= 0;
const isMacintosh = userAgent$1.indexOf("Macintosh") >= 0;
userAgent$1.indexOf("Linux") >= 0;
const isMobile = userAgent$1.indexOf("Mobi") >= 0;
const isIOS = (userAgent$1.indexOf("Macintosh") >= 0 || userAgent$1.indexOf("iPad") >= 0 || userAgent$1.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
const isAndroid = !!(userAgent$1 && userAgent$1.indexOf("Android") >= 0);
var OperatingSystem = /* @__PURE__ */ ((OperatingSystem2) => {
  OperatingSystem2[OperatingSystem2["Windows"] = 1] = "Windows";
  OperatingSystem2[OperatingSystem2["Macintosh"] = 2] = "Macintosh";
  OperatingSystem2[OperatingSystem2["Linux"] = 3] = "Linux";
  return OperatingSystem2;
})(OperatingSystem || {});
const OS = isMacintosh || isIOS ? 2 : isWindows ? 1 : 3;
const $globalThis = globalThis;
const setTimeout0IsFaster = typeof $globalThis.postMessage === "function" && !$globalThis.importScripts;
const setTimeout0 = (() => {
  if (setTimeout0IsFaster) {
    const pending = [];
    $globalThis.addEventListener("message", (e2) => {
      if (e2.data && e2.data.vscodeScheduleAsyncWork) {
        for (let i2 = 0, len = pending.length; i2 < len; i2++) {
          const candidate = pending[i2];
          if (candidate.id === e2.data.vscodeScheduleAsyncWork) {
            pending.splice(i2, 1);
            candidate.callback();
            return;
          }
        }
      }
    });
    let lastId = 0;
    return (callback) => {
      const myId = ++lastId;
      pending.push({
        id: myId,
        callback
      });
      $globalThis.postMessage({ vscodeScheduleAsyncWork: myId }, "*");
    };
  }
  return (callback) => setTimeout(callback);
})();
function isThenable(obj) {
  return !!obj && typeof obj.then === "function";
}
let _runWhenIdle;
class IdleDeadline {
  constructor(didTimeout, timeRemaining) {
    this.didTimeout = didTimeout;
    this.timeRemaining = timeRemaining;
  }
}
(function() {
  if (typeof globalThis.requestIdleCallback !== "function" || typeof globalThis.cancelIdleCallback !== "function") {
    _runWhenIdle = (_targetWindow, runner, timeout) => {
      setTimeout0(() => {
        if (disposed) {
          return;
        }
        const end = Date.now() + 15;
        const deadline = new IdleDeadline(true, () => Math.max(0, end - Date.now()));
        runner(Object.freeze(deadline));
      });
      let disposed = false;
      return {
        dispose() {
          if (disposed) {
            return;
          }
          disposed = true;
        }
      };
    };
  } else {
    _runWhenIdle = (targetWindow, runner, timeout) => {
      const handle = targetWindow.requestIdleCallback(
        runner,
        typeof timeout === "number" ? { timeout } : void 0
      );
      let disposed = false;
      return {
        dispose() {
          if (disposed) {
            return;
          }
          disposed = true;
          targetWindow.cancelIdleCallback(handle);
        }
      };
    };
  }
})();
class AbstractIdleValue {
  constructor(targetWindow, executor) {
    __publicField(this, "_executor");
    __publicField(this, "_handle");
    __publicField(this, "_didRun", false);
    __publicField(this, "_value");
    __publicField(this, "_error");
    this._executor = () => {
      try {
        this._value = executor();
      } catch (err) {
        this._error = err;
      } finally {
        this._didRun = true;
      }
    };
    this._handle = _runWhenIdle(targetWindow, () => this._executor());
  }
  dispose() {
    this._handle.dispose();
  }
  get value() {
    if (!this._didRun) {
      this._handle.dispose();
      this._executor();
    }
    if (this._error) {
      throw this._error;
    }
    return this._value;
  }
  get isInitialized() {
    return this._didRun;
  }
}
class GlobalIdleValue extends AbstractIdleValue {
  constructor(executor) {
    super(globalThis, executor);
  }
}
let DeferredPromise$1 = class DeferredPromise {
  constructor() {
    __publicField(this, "completeCallback");
    __publicField(this, "errorCallback");
    __publicField(this, "outcome");
    __publicField(this, "p");
    this.p = new Promise((c2, e2) => {
      this.completeCallback = c2;
      this.errorCallback = e2;
    });
  }
  get isRejected() {
    var _a3;
    return ((_a3 = this.outcome) == null ? void 0 : _a3.outcome) === 1;
  }
  get isResolved() {
    var _a3;
    return ((_a3 = this.outcome) == null ? void 0 : _a3.outcome) === 0;
  }
  get isSettled() {
    return !!this.outcome;
  }
  get value() {
    var _a3, _b3;
    return ((_a3 = this.outcome) == null ? void 0 : _a3.outcome) === 0 ? (_b3 = this.outcome) == null ? void 0 : _b3.value : void 0;
  }
  complete(value) {
    return new Promise((resolve) => {
      this.completeCallback(value);
      this.outcome = { outcome: 0, value };
      resolve();
    });
  }
  error(err) {
    return new Promise((resolve) => {
      this.errorCallback(err);
      this.outcome = { outcome: 1, value: err };
      resolve();
    });
  }
  cancel() {
    return this.error(new CancellationError());
  }
};
class Barrier {
  constructor() {
    __publicField(this, "_isOpen");
    __publicField(this, "_promise");
    __publicField(this, "_completePromise");
    this._isOpen = false;
    this._promise = new Promise((c2) => {
      this._completePromise = c2;
    });
  }
  isOpen() {
    return this._isOpen;
  }
  open() {
    this._isOpen = true;
    this._completePromise(true);
  }
  wait() {
    return this._promise;
  }
}
class RunOnceScheduler {
  constructor(runner, delay) {
    __publicField(this, "runner");
    __publicField(this, "timeoutToken");
    __publicField(this, "timeout");
    __publicField(this, "timeoutHandler");
    this.timeoutToken = -1;
    this.runner = runner;
    this.timeout = delay;
    this.timeoutHandler = this.onTimeout.bind(this);
  }
  /**
   * Dispose RunOnceScheduler
   */
  dispose() {
    this.cancel();
    this.runner = null;
  }
  /**
   * Cancel current scheduled runner (if any).
   */
  cancel() {
    if (this.isScheduled()) {
      clearTimeout(this.timeoutToken);
      this.timeoutToken = -1;
    }
  }
  /**
   * Cancel previous runner (if any) & schedule a new runner.
   */
  schedule(delay = this.timeout) {
    this.cancel();
    this.timeoutToken = setTimeout(this.timeoutHandler, delay);
  }
  get delay() {
    return this.timeout;
  }
  set delay(value) {
    this.timeout = value;
  }
  /**
   * Returns true if scheduled.
   */
  isScheduled() {
    return this.timeoutToken !== -1;
  }
  flush() {
    if (this.isScheduled()) {
      this.cancel();
      this.doRun();
    }
  }
  onTimeout() {
    this.timeoutToken = -1;
    if (this.runner) {
      this.doRun();
    }
  }
  doRun() {
    var _a3;
    (_a3 = this.runner) == null ? void 0 : _a3.call(this);
  }
}
var Promises;
((Promises2) => {
  async function settled(promises) {
    let firstError = void 0;
    const result = await Promise.all(
      promises.map(
        (promise) => promise.then(
          (value) => value,
          (error) => {
            if (!firstError) {
              firstError = error;
            }
            return void 0;
          }
        )
      )
    );
    if (typeof firstError !== "undefined") {
      throw firstError;
    }
    return result;
  }
  Promises2.settled = settled;
})(Promises || (Promises = {}));
function wait(ms2) {
  return new Promise((c2) => {
    setTimeout(() => c2(), ms2);
  });
}
function tick$1(cb) {
  Promise.resolve().then(() => cb());
}
class IntervalCounter {
  constructor(interval, nowFn = () => Date.now()) {
    __publicField(this, "lastIncrementTime", 0);
    __publicField(this, "value", 0);
    this.interval = interval;
    this.nowFn = nowFn;
  }
  increment() {
    const now2 = this.nowFn();
    if (now2 - this.lastIncrementTime > this.interval) {
      this.lastIncrementTime = now2;
      this.value = 0;
    }
    this.value++;
    return this.value;
  }
}
const scriptRel = "modulepreload";
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    let allSettled2 = function(promises) {
      return Promise.all(
        promises.map(
          (p2) => Promise.resolve(p2).then(
            (value) => ({ status: "fulfilled", value }),
            (reason) => ({ status: "rejected", reason })
          )
        )
      );
    };
    const links = document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
    promise = allSettled2(
      deps.map((dep) => {
        dep = assetsURL(dep, importerUrl);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        const isBaseRelative = !!importerUrl;
        if (isBaseRelative) {
          for (let i2 = links.length - 1; i2 >= 0; i2--) {
            const link22 = links[i2];
            if (link22.href === dep && (!isCss || link22.rel === "stylesheet")) {
              return;
            }
          }
        } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link2 = document.createElement("link");
        link2.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link2.as = "script";
        }
        link2.crossOrigin = "";
        link2.href = dep;
        if (cspNonce) {
          link2.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link2);
        if (isCss) {
          return new Promise((res, rej) => {
            link2.addEventListener("load", res);
            link2.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  function handlePreloadError(err) {
    const e2 = new Event("vite:preloadError", {
      cancelable: true
    });
    e2.payload = err;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err;
    }
  }
  return promise.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
class GenericRegistry {
  constructor() {
    __publicField(this, "map", /* @__PURE__ */ new Map());
  }
  add(item) {
    const id2 = item.id;
    const exists = this.map.has(id2);
    if (exists) {
      NOTIMPLEMENTED();
    }
    this.map.set(id2, item);
  }
  remove(id2) {
    this.map.delete(id2);
  }
  has(id2) {
    return this.map.has(id2);
  }
  value(id2) {
    return this.map.get(id2);
  }
  values() {
    return Array.from(this.map.values());
  }
  dispose() {
    this.map.clear();
  }
}
var ChartStyleType = /* @__PURE__ */ ((ChartStyleType2) => {
  ChartStyleType2[ChartStyleType2["Bar"] = 0] = "Bar";
  ChartStyleType2[ChartStyleType2["Candle"] = 1] = "Candle";
  ChartStyleType2[ChartStyleType2["Line"] = 2] = "Line";
  ChartStyleType2[ChartStyleType2["Area"] = 3] = "Area";
  ChartStyleType2[ChartStyleType2["HollowCandle"] = 9] = "HollowCandle";
  return ChartStyleType2;
})(ChartStyleType || {});
const chartStyleRegistry = new class extends GenericRegistry {
}();
function isOhlcSeries(type) {
  return [
    0,
    1,
    9
    /* HollowCandle */
  ].includes(type);
}
const iconArea = () => __vitePreload(() => import("./area-mEaLdL1M.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const iconBar = () => __vitePreload(() => import("./bar-DwcNyvYB.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const iconCandle = () => __vitePreload(() => import("./candle-CjDvT3HN.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const iconHollowCandle = () => __vitePreload(() => import("./hollowCandle-Dl1CS1mY.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const iconLine = () => __vitePreload(() => import("./line-Btg7CKJm.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const chartStylePreset = [
  {
    id: ChartStyleType.Candle,
    icon: iconCandle,
    label: "chartStyle.candle"
  },
  {
    id: ChartStyleType.HollowCandle,
    icon: iconHollowCandle,
    label: "chartStyle.hollowCandle"
  },
  {
    id: ChartStyleType.Bar,
    icon: iconBar,
    label: "chartStyle.bar"
  },
  {
    id: ChartStyleType.Line,
    icon: iconLine,
    label: "chartStyle.line"
  },
  {
    id: ChartStyleType.Area,
    icon: iconArea,
    label: "chartStyle.area"
  }
];
chartStylePreset.forEach((i2) => {
  chartStyleRegistry.add(i2);
});
const chartLayoutRegistry = new class extends GenericRegistry {
}();
const i1 = () => __vitePreload(() => import("./1-DBCnvNHR.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i2_1 = () => __vitePreload(() => import("./2-1-YVwWoGXs.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i2_2 = () => __vitePreload(() => import("./2-2-CHz9bDzD.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i3_1 = () => __vitePreload(() => import("./3-1-BC_gen9M.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i3_2 = () => __vitePreload(() => import("./3-2-DlAUAe2-.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i3_3 = () => __vitePreload(() => import("./3-3-BX4KINP2.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i3_4 = () => __vitePreload(() => import("./3-4-BqfkkT6D.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i3_5 = () => __vitePreload(() => import("./3-5-DFSgFFwJ.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i3_6 = () => __vitePreload(() => import("./3-6-_J2W1RrB.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i4_1 = () => __vitePreload(() => import("./4-1-BIYNcaTP.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i4_1_3 = () => __vitePreload(() => import("./4-1-3-CYU7nkOZ.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i4_3_1 = () => __vitePreload(() => import("./4-3-1-BRLTXR55.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i4_4h = () => __vitePreload(() => import("./4-4h-Bqy8R_tJ.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i4_4s = () => __vitePreload(() => import("./4-4s-CshnFOd0.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i4_4s_l = () => __vitePreload(() => import("./4-4s-l-CiDGx5Ji.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i4_4v = () => __vitePreload(() => import("./4-4v-D-kN7dOI.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i4_7 = () => __vitePreload(() => import("./4-7-BzaE2E5N.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i4_8 = () => __vitePreload(() => import("./4-8-CREj0-r_.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i5_1 = () => __vitePreload(() => import("./5-1-CwDs5AmM.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i5_2 = () => __vitePreload(() => import("./5-2-CDWKF3O8.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i5_3 = () => __vitePreload(() => import("./5-3-Bz1gjvBM.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i5_4 = () => __vitePreload(() => import("./5-4-CCYi0MoA.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i5_5 = () => __vitePreload(() => import("./5-5-BZaPXXMp.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i5_6 = () => __vitePreload(() => import("./5-6-CEUue-n1.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i6_1 = () => __vitePreload(() => import("./6-1-CI8nuu0T.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i6_2 = () => __vitePreload(() => import("./6-2-L90LjgOm.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i6_3 = () => __vitePreload(() => import("./6-3-CohWp5XK.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i6_4 = () => __vitePreload(() => import("./6-4-Cj952Kc2.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i6_5 = () => __vitePreload(() => import("./6-5-LPDJcEAr.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i7_1 = () => __vitePreload(() => import("./7-1-q0Xt_gbh.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i8_1 = () => __vitePreload(() => import("./8-1-CxGvUVj2.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i8_2 = () => __vitePreload(() => import("./8-2-BzTr1lfN.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i8_3 = () => __vitePreload(() => import("./8-3-BuvAxoiD.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i8_4 = () => __vitePreload(() => import("./8-4-BC1G6Fgb.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i9_1 = () => __vitePreload(() => import("./9-1-C3TxHN4b.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i9_2 = () => __vitePreload(() => import("./9-2-q9zJywYT.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i9_3 = () => __vitePreload(() => import("./9-3-Damfp71p.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i10_1 = () => __vitePreload(() => import("./10-1-Cr6O60oC.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i10_2 = () => __vitePreload(() => import("./10-2-snkofV5W.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i10_3 = () => __vitePreload(() => import("./10-3-CHsMNk8x.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i12_1 = () => __vitePreload(() => import("./12-1-BuOZcqSv.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i12_2 = () => __vitePreload(() => import("./12-2-BeAeh5oo.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i14_1 = () => __vitePreload(() => import("./14-1-DUAaLite.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i16_1 = () => __vitePreload(() => import("./16-1-DxsxWW2d.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const i16_2 = () => __vitePreload(() => import("./16-2-nSwv0EkO.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default);
const layoutPresets = {
  1: [
    {
      id: "s",
      slotCount: 1,
      icon: i1,
      layout: {
        gridTemplate: `
"a"`
      }
    }
  ],
  2: [
    {
      id: "2h",
      slotCount: 2,
      icon: i2_1,
      layout: {
        gridTemplate: `
"a b"`
      }
    },
    {
      id: "2v",
      slotCount: 2,
      icon: i2_2,
      layout: {
        gridTemplate: `
"a"
"b"`
      }
    }
  ],
  3: [
    {
      id: "3v",
      slotCount: 3,
      icon: i3_1,
      layout: {
        gridTemplate: `
"a"
"b"
"c"`
      }
    },
    {
      id: "3h",
      slotCount: 3,
      icon: i3_2,
      layout: {
        gridTemplate: `
"a b c"`
      }
    },
    {
      id: "3s",
      slotCount: 3,
      icon: i3_3,
      layout: {
        gridTemplate: `
"a b"
"a c"`
      }
    },
    {
      id: "2-1",
      slotCount: 3,
      icon: i3_4,
      layout: {
        gridTemplate: `
"a b"
"c c"`
      }
    },
    {
      id: "1-2",
      slotCount: 3,
      icon: i3_5,
      layout: {
        gridTemplate: `
"a a"
"b c"`
      }
    },
    {
      id: "3r",
      slotCount: 3,
      icon: i3_6,
      layout: {
        gridTemplate: `
"a c"
"b c"`
      }
    }
  ],
  4: [
    {
      id: "4",
      slotCount: 4,
      icon: i4_1,
      layout: {
        gridTemplate: `
"a b"
"c d"`
      }
    },
    {
      id: "4h",
      slotCount: 4,
      icon: i4_4v,
      layout: {
        gridTemplate: `
"a b c d"`
      }
    },
    {
      id: "4v",
      slotCount: 4,
      icon: i4_4h,
      layout: {
        gridTemplate: `
"a"
"b"
"c"
"d"`
      }
    },
    {
      id: "4s",
      slotCount: 4,
      icon: i4_4s,
      layout: {
        gridTemplate: `
"a b"
"a c"
"a d"`
      }
    },
    {
      id: "4s-l",
      slotCount: 4,
      icon: i4_4s_l,
      layout: {
        gridTemplate: `
"a d"
"b d"
"c d"`
      }
    },
    {
      id: "1-3",
      slotCount: 4,
      icon: i4_1_3,
      layout: {
        gridTemplate: `
"a a a"
"b c d"`
      }
    },
    {
      id: "3-1",
      slotCount: 4,
      icon: i4_3_1,
      layout: {
        gridTemplate: `
"a b c"
"d d d"`
      }
    },
    {
      id: "2-2",
      slotCount: 4,
      icon: i4_7,
      layout: {
        gridTemplate: `
"a b" 2fr
"c c" 1fr
"d d" 1fr
`
      }
    },
    {
      id: "2-2-l",
      slotCount: 4,
      icon: i4_8,
      layout: {
        gridTemplate: `
"a b c"
"a b d" / 1fr 1fr 2fr
`
      }
    }
  ],
  5: [
    {
      id: "1-4",
      slotCount: 5,
      icon: i5_1,
      layout: {
        gridTemplate: `
"a a a a"
"b c d e"
`
      }
    },
    {
      id: "5s",
      slotCount: 5,
      icon: i5_2,
      layout: {
        gridTemplate: `
"a b"
"a c"
"a d"
"a e"
`
      }
    },
    {
      id: "2-3",
      slotCount: 5,
      icon: i5_3,
      layout: {
        gridTemplate: `
"a a a b b b"
"c c d d e e"`
      }
    },
    {
      id: "3-2",
      slotCount: 5,
      icon: i5_4,
      layout: {
        gridTemplate: `
"a a b b c c"
"d d d e e e"`
      }
    },
    {
      id: "5h",
      slotCount: 5,
      icon: i5_5,
      layout: {
        gridTemplate: `
"a b c d e"`
      }
    },
    {
      id: "5v",
      slotCount: 5,
      icon: i5_6,
      layout: {
        gridTemplate: `
"a"
"b"
"c"
"d"
"e"
`
      }
    }
  ],
  6: [
    {
      id: "6",
      slotCount: 6,
      icon: i6_1,
      layout: {
        gridTemplate: `
"a b c"
"d e f"`
      }
    },
    {
      id: "6c",
      slotCount: 6,
      icon: i6_2,
      layout: {
        gridTemplate: `
"a b"
"c d"
"e f"`
      }
    },
    {
      id: "2-4",
      slotCount: 6,
      icon: i6_3,
      layout: {
        gridTemplate: `
"a a b b"
"c d e f"`
      }
    },
    {
      id: "6h",
      slotCount: 6,
      icon: i6_4,
      layout: {
        gridTemplate: `
"a b c d e f"`
      }
    },
    {
      id: "6v",
      slotCount: 6,
      icon: i6_5,
      layout: {
        gridTemplate: `
"a"
"b"
"c"
"d"
"e"
"f"`
      }
    }
  ],
  7: [
    {
      id: "7h",
      slotCount: 7,
      icon: i7_1,
      layout: {
        gridTemplate: `
"a b c d e f g"`
      }
    }
  ],
  8: [
    {
      id: "8",
      slotCount: 8,
      icon: i8_1,
      layout: {
        gridTemplate: `
"a b c d"
"e f g h"
`
      }
    },
    {
      id: "8c",
      slotCount: 8,
      icon: i8_2,
      layout: {
        gridTemplate: `
"a b"
"c d"
"e f"
"g h"
`
      }
    },
    {
      id: "8h",
      slotCount: 8,
      icon: i8_3,
      layout: {
        gridTemplate: `
"a b c d e f g h"`
      }
    },
    {
      id: "8v",
      slotCount: 8,
      icon: i8_4,
      layout: {
        gridTemplate: `
"a"
"b"
"c"
"d"
"e"
"f"
"g"
"h"`
      }
    }
  ],
  9: [
    {
      id: "9s",
      slotCount: 9,
      icon: i9_1,
      layout: {
        gridTemplate: `
  "a b c"
  "d e f"
  "g h i"`
      }
    },
    {
      id: "9h",
      slotCount: 9,
      icon: i9_2,
      layout: {
        gridTemplate: `
  "a b c d e f g h i"`
      }
    },
    {
      id: "9v",
      slotCount: 9,
      icon: i9_3,
      layout: {
        gridTemplate: `
  "a"
  "b"
  "c"
  "d"
  "e"
  "f"
  "g"
  "h"
  "i"`
      }
    }
  ],
  10: [
    {
      id: "10c5",
      slotCount: 10,
      icon: i10_1,
      layout: {
        gridTemplate: `
  "a b c d e"
  "f g h i j"`
      }
    },
    {
      id: "10h",
      slotCount: 10,
      icon: i10_2,
      layout: {
        gridTemplate: `
  "a b c d e f g h i j"`
      }
    },
    {
      id: "10v",
      slotCount: 10,
      icon: i10_3,
      layout: {
        gridTemplate: `
  "a"
  "b"
  "c"
  "d"
  "e"
  "f"
  "g"
  "h"
  "i"
  "j"`
      }
    }
  ],
  12: [
    {
      id: "12c6",
      slotCount: 12,
      icon: i12_1,
      layout: {
        gridTemplate: `
  "a b c d e f"
  "g h i j k l"`
      }
    },
    {
      id: "12c4",
      slotCount: 12,
      icon: i12_2,
      layout: {
        gridTemplate: `
  "a b c"
  "d e f"
  "g h i"
  "j k l"`
      }
    }
  ],
  14: [
    {
      id: "14c7",
      slotCount: 14,
      icon: i14_1,
      layout: {
        gridTemplate: `
  "a b c d e f g"
  "h i j k l m n"`
      }
    }
  ],
  16: [
    {
      id: "16c8",
      slotCount: 16,
      icon: i16_1,
      layout: {
        gridTemplate: `
  "a b c d e f g h"
  "i j k l m n o p"`
      }
    },
    {
      id: "16c4",
      slotCount: 16,
      icon: i16_2,
      layout: {
        gridTemplate: `
  "a b c d"
  "e f g h"
  "i j k l"
  "m n o p"`
      }
    }
  ],
  get length() {
    const keys2 = Object.keys(this).map((k2) => parseInt(k2)).filter(isFinite);
    return Math.max(...keys2) + 1;
  }
};
Array.from(layoutPresets).forEach((group) => {
  if (!group) return;
  group.forEach((i2) => {
    chartLayoutRegistry.add(i2);
  });
});
var KeyCode = /* @__PURE__ */ ((KeyCode2) => {
  KeyCode2[KeyCode2["Unknown"] = 0] = "Unknown";
  KeyCode2[KeyCode2["Backspace"] = 8] = "Backspace";
  KeyCode2[KeyCode2["Tab"] = 9] = "Tab";
  KeyCode2[KeyCode2["Enter"] = 13] = "Enter";
  KeyCode2[KeyCode2["Shift"] = 16] = "Shift";
  KeyCode2[KeyCode2["Ctrl"] = 17] = "Ctrl";
  KeyCode2[KeyCode2["Alt"] = 18] = "Alt";
  KeyCode2[KeyCode2["Esc"] = 27] = "Esc";
  KeyCode2[KeyCode2["Space"] = 32] = "Space";
  KeyCode2[KeyCode2["LeftArrow"] = 37] = "LeftArrow";
  KeyCode2[KeyCode2["UpArrow"] = 38] = "UpArrow";
  KeyCode2[KeyCode2["RightArrow"] = 39] = "RightArrow";
  KeyCode2[KeyCode2["DownArrow"] = 40] = "DownArrow";
  KeyCode2[KeyCode2["Delete"] = 46] = "Delete";
  KeyCode2[KeyCode2["Digit0"] = 48] = "Digit0";
  KeyCode2[KeyCode2["Digit1"] = 49] = "Digit1";
  KeyCode2[KeyCode2["Digit2"] = 50] = "Digit2";
  KeyCode2[KeyCode2["Digit3"] = 51] = "Digit3";
  KeyCode2[KeyCode2["Digit4"] = 52] = "Digit4";
  KeyCode2[KeyCode2["Digit5"] = 53] = "Digit5";
  KeyCode2[KeyCode2["Digit6"] = 54] = "Digit6";
  KeyCode2[KeyCode2["Digit7"] = 55] = "Digit7";
  KeyCode2[KeyCode2["Digit8"] = 56] = "Digit8";
  KeyCode2[KeyCode2["Digit9"] = 57] = "Digit9";
  KeyCode2[KeyCode2["KeyA"] = 65] = "KeyA";
  KeyCode2[KeyCode2["KeyB"] = 66] = "KeyB";
  KeyCode2[KeyCode2["KeyC"] = 67] = "KeyC";
  KeyCode2[KeyCode2["KeyD"] = 68] = "KeyD";
  KeyCode2[KeyCode2["KeyE"] = 69] = "KeyE";
  KeyCode2[KeyCode2["KeyF"] = 70] = "KeyF";
  KeyCode2[KeyCode2["KeyG"] = 71] = "KeyG";
  KeyCode2[KeyCode2["KeyH"] = 72] = "KeyH";
  KeyCode2[KeyCode2["KeyI"] = 73] = "KeyI";
  KeyCode2[KeyCode2["KeyJ"] = 74] = "KeyJ";
  KeyCode2[KeyCode2["KeyK"] = 75] = "KeyK";
  KeyCode2[KeyCode2["KeyL"] = 76] = "KeyL";
  KeyCode2[KeyCode2["KeyM"] = 77] = "KeyM";
  KeyCode2[KeyCode2["KeyN"] = 78] = "KeyN";
  KeyCode2[KeyCode2["KeyO"] = 79] = "KeyO";
  KeyCode2[KeyCode2["KeyP"] = 80] = "KeyP";
  KeyCode2[KeyCode2["KeyQ"] = 81] = "KeyQ";
  KeyCode2[KeyCode2["KeyR"] = 82] = "KeyR";
  KeyCode2[KeyCode2["KeyS"] = 83] = "KeyS";
  KeyCode2[KeyCode2["KeyT"] = 84] = "KeyT";
  KeyCode2[KeyCode2["KeyU"] = 85] = "KeyU";
  KeyCode2[KeyCode2["KeyV"] = 86] = "KeyV";
  KeyCode2[KeyCode2["KeyW"] = 87] = "KeyW";
  KeyCode2[KeyCode2["KeyX"] = 88] = "KeyX";
  KeyCode2[KeyCode2["KeyY"] = 89] = "KeyY";
  KeyCode2[KeyCode2["KeyZ"] = 90] = "KeyZ";
  KeyCode2[KeyCode2["Meta"] = 91] = "Meta";
  KeyCode2[KeyCode2["Equal"] = 187] = "Equal";
  KeyCode2[KeyCode2["Minus"] = 189] = "Minus";
  KeyCode2[KeyCode2["Slash"] = 191] = "Slash";
  KeyCode2[KeyCode2["Backslash"] = 220] = "Backslash";
  return KeyCode2;
})(KeyCode || {});
var KeyMod = /* @__PURE__ */ ((KeyMod2) => {
  KeyMod2[KeyMod2["CtrlCmd"] = 2048] = "CtrlCmd";
  KeyMod2[KeyMod2["Shift"] = 1024] = "Shift";
  KeyMod2[KeyMod2["Alt"] = 512] = "Alt";
  KeyMod2[KeyMod2["WinCtrl"] = 256] = "WinCtrl";
  return KeyMod2;
})(KeyMod || {});
const keyCodeToChar = {
  [
    8
    /* Backspace */
  ]: "Backspace",
  [
    9
    /* Tab */
  ]: "Tab",
  [
    13
    /* Enter */
  ]: "Enter",
  [
    46
    /* Delete */
  ]: "Del",
  [
    27
    /* Esc */
  ]: "Esc",
  [
    32
    /* Space */
  ]: "Space",
  [
    37
    /* LeftArrow */
  ]: "←",
  [
    39
    /* RightArrow */
  ]: "→",
  [
    38
    /* UpArrow */
  ]: "↑",
  [
    40
    /* DownArrow */
  ]: "↓",
  [
    48
    /* Digit0 */
  ]: "0",
  [
    49
    /* Digit1 */
  ]: "1",
  [
    50
    /* Digit2 */
  ]: "2",
  [
    51
    /* Digit3 */
  ]: "3",
  [
    52
    /* Digit4 */
  ]: "4",
  [
    53
    /* Digit5 */
  ]: "5",
  [
    54
    /* Digit6 */
  ]: "6",
  [
    55
    /* Digit7 */
  ]: "7",
  [
    56
    /* Digit8 */
  ]: "8",
  [
    57
    /* Digit9 */
  ]: "9",
  [
    65
    /* KeyA */
  ]: "A",
  [
    66
    /* KeyB */
  ]: "B",
  [
    67
    /* KeyC */
  ]: "C",
  [
    68
    /* KeyD */
  ]: "D",
  [
    69
    /* KeyE */
  ]: "E",
  [
    70
    /* KeyF */
  ]: "F",
  [
    71
    /* KeyG */
  ]: "G",
  [
    72
    /* KeyH */
  ]: "H",
  [
    73
    /* KeyI */
  ]: "I",
  [
    74
    /* KeyJ */
  ]: "J",
  [
    75
    /* KeyK */
  ]: "K",
  [
    76
    /* KeyL */
  ]: "L",
  [
    77
    /* KeyM */
  ]: "M",
  [
    78
    /* KeyN */
  ]: "N",
  [
    79
    /* KeyO */
  ]: "O",
  [
    80
    /* KeyP */
  ]: "P",
  [
    81
    /* KeyQ */
  ]: "Q",
  [
    82
    /* KeyR */
  ]: "R",
  [
    83
    /* KeyS */
  ]: "S",
  [
    84
    /* KeyT */
  ]: "T",
  [
    85
    /* KeyU */
  ]: "U",
  [
    86
    /* KeyV */
  ]: "V",
  [
    87
    /* KeyW */
  ]: "W",
  [
    88
    /* KeyX */
  ]: "X",
  [
    89
    /* KeyY */
  ]: "Y",
  [
    90
    /* KeyZ */
  ]: "Z",
  // [KeyCode.F1]: 'F1',
  // [KeyCode.F2]: 'F2',
  // [KeyCode.F3]: 'F3',
  // [KeyCode.F4]: 'F4',
  // [KeyCode.F5]: 'F5',
  // [KeyCode.F6]: 'F6',
  // [KeyCode.F7]: 'F7',
  // [KeyCode.F8]: 'F8',
  // [KeyCode.F9]: 'F9',
  // [KeyCode.F10]: 'F10',
  // [KeyCode.F11]: 'F11',
  // [KeyCode.F12]: 'F12',
  [
    189
    /* Minus */
  ]: "-",
  [
    187
    /* Equal */
  ]: "=",
  // [KeyCode.Period]: '.',
  // [KeyCode.Comma]: ',',
  [
    191
    /* Slash */
  ]: "/"
  // [KeyCode.Backslash]: '\\',
};
var KeyCodeUtils;
((KeyCodeUtils2) => {
  function toString2(keyCode) {
    return keyCodeToChar[keyCode];
  }
  KeyCodeUtils2.toString = toString2;
})(KeyCodeUtils || (KeyCodeUtils = {}));
function decodeKeybinding(keybinding, os2 = OS) {
  if (typeof keybinding === "number") {
    if (keybinding === 0) {
      return null;
    }
    const firstChord = (keybinding & 65535) >>> 0;
    const secondChord = (keybinding & 4294901760) >>> 16;
    if (secondChord !== 0) {
      return new Keybinding([
        createSimpleKeybinding(firstChord, os2),
        createSimpleKeybinding(secondChord, os2)
      ]);
    }
    return new Keybinding([createSimpleKeybinding(firstChord, os2)]);
  } else {
    const chords = [];
    for (let i2 = 0; i2 < keybinding.length; i2++) {
      chords.push(createSimpleKeybinding(keybinding[i2], os2));
    }
    return new Keybinding(chords);
  }
}
function createSimpleKeybinding(keybinding, OS2) {
  const ctrlCmd = keybinding & 2048 ? true : false;
  const winCtrl = keybinding & 256 ? true : false;
  const ctrlKey = OS2 === OperatingSystem.Macintosh ? winCtrl : ctrlCmd;
  const shiftKey = keybinding & 1024 ? true : false;
  const altKey = keybinding & 512 ? true : false;
  const metaKey = OS2 === OperatingSystem.Macintosh ? ctrlCmd : winCtrl;
  const keyCode = keybinding & 255;
  return new KeyCodeChord(ctrlKey, shiftKey, altKey, metaKey, keyCode);
}
class KeyCodeChord {
  constructor(ctrlKey, shiftKey, altKey, metaKey, keyCode) {
    this.ctrlKey = ctrlKey;
    this.shiftKey = shiftKey;
    this.altKey = altKey;
    this.metaKey = metaKey;
    this.keyCode = keyCode;
  }
  equals(other) {
    return other instanceof KeyCodeChord && this.ctrlKey === other.ctrlKey && this.shiftKey === other.shiftKey && this.altKey === other.altKey && this.metaKey === other.metaKey && this.keyCode === other.keyCode;
  }
  getHashCode() {
    const ctrl = this.ctrlKey ? "1" : "0";
    const shift = this.shiftKey ? "1" : "0";
    const alt = this.altKey ? "1" : "0";
    const meta = this.metaKey ? "1" : "0";
    return `K${ctrl}${shift}${alt}${meta}${this.keyCode}`;
  }
  isModifierKey() {
    return this.keyCode === KeyCode.Unknown || this.keyCode === KeyCode.Ctrl || this.keyCode === KeyCode.Meta || this.keyCode === KeyCode.Alt || this.keyCode === KeyCode.Shift;
  }
  toKeybinding() {
    return new Keybinding([this]);
  }
  /**
   * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?
   */
  isDuplicateModifierCase() {
    return this.ctrlKey && this.keyCode === KeyCode.Ctrl || this.shiftKey && this.keyCode === KeyCode.Shift || this.altKey && this.keyCode === KeyCode.Alt || this.metaKey && this.keyCode === KeyCode.Meta;
  }
}
class Keybinding {
  constructor(chords) {
    __publicField(this, "chords");
    if (chords.length === 0) {
      throw illegalArgument(`chords`);
    }
    this.chords = chords;
  }
  getHashCode() {
    let result = "";
    for (let i2 = 0, len = this.chords.length; i2 < len; i2++) {
      if (i2 !== 0) {
        result += ";";
      }
      result += this.chords[i2].getHashCode();
    }
    return result;
  }
  equals(other) {
    if (other === null) {
      return false;
    }
    if (this.chords.length !== other.chords.length) {
      return false;
    }
    for (let i2 = 0; i2 < this.chords.length; i2++) {
      if (!this.chords[i2].equals(other.chords[i2])) {
        return false;
      }
    }
    return true;
  }
}
const userAgent = navigator.userAgent;
const isFirefox = userAgent.indexOf("Firefox") >= 0;
const isWebKit = userAgent.indexOf("AppleWebKit") >= 0;
const isChrome = userAgent.indexOf("Chrome") >= 0;
const isSafari = !isChrome && userAgent.indexOf("Safari") >= 0;
userAgent.indexOf("Electron/") >= 0;
function extractKeyCode(e2) {
  const keyCode = e2.keyCode;
  if (keyCode === 3) ;
  else if (isFirefox) ;
  else if (isWebKit) {
    if (isMacintosh && keyCode === 93) {
      return KeyCode.Meta;
    } else if (!isMacintosh && keyCode === 92) {
      return KeyCode.Meta;
    }
  }
  return keyCode;
}
const ctrlKeyMod = isMacintosh ? KeyMod.WinCtrl : KeyMod.CtrlCmd;
const altKeyMod = KeyMod.Alt;
const shiftKeyMod = KeyMod.Shift;
const metaKeyMod = isMacintosh ? KeyMod.CtrlCmd : KeyMod.WinCtrl;
class StandardKeyboardEvent {
  constructor(source2) {
    __publicField(this, "_standardKeyboardEventBrand", true);
    __publicField(this, "browserEvent");
    __publicField(this, "target");
    __publicField(this, "ctrlKey");
    __publicField(this, "shiftKey");
    __publicField(this, "altKey");
    __publicField(this, "metaKey");
    __publicField(this, "altGraphKey");
    __publicField(this, "keyCode");
    __publicField(this, "code");
    __publicField(this, "_asKeybinding");
    __publicField(this, "_asKeyCodeChord");
    var _a3;
    const e2 = source2;
    this.browserEvent = e2;
    this.target = e2.target;
    this.ctrlKey = e2.ctrlKey;
    this.shiftKey = e2.shiftKey;
    this.altKey = e2.altKey;
    this.metaKey = e2.metaKey;
    this.altGraphKey = (_a3 = e2.getModifierState) == null ? void 0 : _a3.call(e2, "AltGraph");
    this.keyCode = extractKeyCode(e2);
    this.code = e2.code;
    this.ctrlKey = this.ctrlKey || this.keyCode === KeyCode.Ctrl;
    this.altKey = this.altKey || this.keyCode === KeyCode.Alt;
    this.shiftKey = this.shiftKey || this.keyCode === KeyCode.Shift;
    this.metaKey = this.metaKey || this.keyCode === KeyCode.Meta;
    this._asKeybinding = this._computeKeybinding();
    this._asKeyCodeChord = this._computeKeyCodeChord();
  }
  preventDefault() {
    if (this.browserEvent && this.browserEvent.preventDefault) {
      this.browserEvent.preventDefault();
    }
  }
  stopPropagation() {
    if (this.browserEvent && this.browserEvent.stopPropagation) {
      this.browserEvent.stopPropagation();
    }
  }
  toKeyCodeChord() {
    return this._asKeyCodeChord;
  }
  equals(other) {
    return this._asKeybinding === other;
  }
  _computeKeybinding() {
    let key2 = KeyCode.Unknown;
    if (this.keyCode !== KeyCode.Ctrl && this.keyCode !== KeyCode.Shift && this.keyCode !== KeyCode.Alt && this.keyCode !== KeyCode.Meta) {
      key2 = this.keyCode;
    }
    let result = 0;
    if (this.ctrlKey) {
      result |= ctrlKeyMod;
    }
    if (this.altKey) {
      result |= altKeyMod;
    }
    if (this.shiftKey) {
      result |= shiftKeyMod;
    }
    if (this.metaKey) {
      result |= metaKeyMod;
    }
    result |= key2;
    return result;
  }
  _computeKeyCodeChord() {
    let key2 = KeyCode.Unknown;
    if (this.keyCode !== KeyCode.Ctrl && this.keyCode !== KeyCode.Shift && this.keyCode !== KeyCode.Alt && this.keyCode !== KeyCode.Meta) {
      key2 = this.keyCode;
    }
    return new KeyCodeChord(this.ctrlKey, this.shiftKey, this.altKey, this.metaKey, key2);
  }
}
class StandardMouseEvent {
  constructor(e2) {
    __publicField(this, "browserEvent");
    __publicField(this, "leftButton");
    __publicField(this, "middleButton");
    __publicField(this, "rightButton");
    __publicField(this, "buttons");
    __publicField(this, "target");
    __publicField(this, "detail");
    __publicField(this, "posx");
    __publicField(this, "posy");
    __publicField(this, "ctrlKey");
    __publicField(this, "shiftKey");
    __publicField(this, "altKey");
    __publicField(this, "metaKey");
    __publicField(this, "timestamp");
    this.timestamp = e2.timeStamp;
    this.browserEvent = e2;
    this.leftButton = e2.button === 0;
    this.middleButton = e2.button === 1;
    this.rightButton = e2.button === 2;
    this.buttons = e2.buttons;
    this.target = e2.target;
    this.detail = e2.detail || 1;
    if (e2.type === "dblclick") {
      this.detail = 2;
    }
    this.ctrlKey = e2.ctrlKey;
    this.shiftKey = e2.shiftKey;
    this.altKey = e2.altKey;
    this.metaKey = e2.metaKey;
    this.posx = e2.clientX;
    this.posy = e2.clientY;
  }
  preventDefault() {
    this.browserEvent.preventDefault();
  }
  stopPropagation() {
    this.browserEvent.stopPropagation();
  }
}
function isLeftClick(e2) {
  return e2.button === 0;
}
function ifLeftClick(cb) {
  return (e2) => {
    if (!isLeftClick(e2)) return;
    cb(e2);
  };
}
const { getWindow } = /* @__PURE__ */ function() {
  return {
    getWindow(e2) {
      var _a3;
      const candidateNode = e2;
      if ((_a3 = candidateNode == null ? void 0 : candidateNode.ownerDocument) == null ? void 0 : _a3.defaultView) {
        return candidateNode.ownerDocument.defaultView.window;
      }
      const candidateEvent = e2;
      if (candidateEvent == null ? void 0 : candidateEvent.view) {
        return candidateEvent.view.window;
      }
      return window;
    }
  };
}();
const EventType$1 = {
  // Mouse
  CLICK: "click",
  MOUSE_UP: "mouseup",
  MOUSE_DOWN: "mousedown",
  MOUSE_MOVE: "mousemove",
  MOUSE_LEAVE: "mouseleave",
  POINTER_UP: "pointerup",
  POINTER_DOWN: "pointerdown",
  POINTER_MOVE: "pointermove",
  POINTER_LEAVE: "pointerleave",
  CONTEXT_MENU: "contextmenu",
  // Keyboard
  KEY_DOWN: "keydown",
  KEY_UP: "keyup",
  // Drag
  DRAG_START: "dragstart",
  DRAG: "drag",
  DROP: "drop",
  DRAG_END: "dragend"
};
class DomListener {
  constructor(node, type, handler, options) {
    __publicField(this, "_handler");
    __publicField(this, "_node");
    __publicField(this, "_type");
    __publicField(this, "_options");
    this._node = node;
    this._type = type;
    this._handler = handler;
    this._options = options || false;
    this._node.addEventListener(this._type, this._handler, this._options);
  }
  dispose() {
    if (!this._handler) {
      return;
    }
    this._node.removeEventListener(this._type, this._handler, this._options);
    this._node = null;
    this._handler = null;
  }
}
function addDisposableListener(node, type, handler, useCaptureOrOptions) {
  return new DomListener(node, type, handler, useCaptureOrOptions);
}
function _wrapAsStandardMouseEvent(handler) {
  return function(e2) {
    return handler(new StandardMouseEvent(e2));
  };
}
function _wrapAsStandardKeyboardEvent(handler) {
  return function(e2) {
    return handler(new StandardKeyboardEvent(e2));
  };
}
const addStandardDisposableListener = function addStandardDisposableListener2(node, type, handler, useCapture) {
  let wrapHandler = handler;
  if (type === "click" || type === "mousedown") {
    wrapHandler = _wrapAsStandardMouseEvent(handler);
  } else if (type === "keydown" || type === "keypress" || type === "keyup") {
    wrapHandler = _wrapAsStandardKeyboardEvent(handler);
  }
  return addDisposableListener(node, type, wrapHandler, useCapture);
};
function isKeyboardEvent(e2) {
  return e2 instanceof KeyboardEvent || e2 instanceof getWindow(e2).KeyboardEvent;
}
let scheduleAtNextAnimationFrame;
class AnimationFrameQueueItem {
  constructor(runner, priority = 0) {
    __publicField(this, "_runner");
    __publicField(this, "priority");
    __publicField(this, "_canceled");
    this._runner = runner;
    this.priority = priority;
    this._canceled = false;
  }
  dispose() {
    this._canceled = true;
  }
  execute() {
    if (this._canceled) {
      return;
    }
    try {
      this._runner();
    } catch (e2) {
      onUnexpectedError(e2);
    }
  }
  // Sort by priority (largest to lowest)
  static sort(a2, b2) {
    return b2.priority - a2.priority;
  }
}
(function() {
  let NEXT_QUEUE;
  let animFrameRequested = false;
  const animationFrameRunner = () => {
    animFrameRequested = false;
    const currentQueue = NEXT_QUEUE.slice();
    NEXT_QUEUE.length = 0;
    while (currentQueue.length > 0) {
      currentQueue.sort(AnimationFrameQueueItem.sort);
      const top2 = currentQueue.shift();
      top2.execute();
    }
  };
  scheduleAtNextAnimationFrame = (runner, priority = 0) => {
    const item = new AnimationFrameQueueItem(runner, priority);
    let nextQueue = NEXT_QUEUE;
    if (!nextQueue) {
      nextQueue = [];
      NEXT_QUEUE = nextQueue;
    }
    nextQueue.push(item);
    if (!animFrameRequested) {
      animFrameRequested = true;
      window.requestAnimationFrame(() => animationFrameRunner());
    }
    return item;
  };
})();
function runWhenIdle(callback, timeout) {
  return _runWhenIdle(window, callback, timeout);
}
function getDomNodePagePosition(domNode) {
  const bb = domNode.getBoundingClientRect();
  const window2 = getWindow(domNode);
  return {
    left: bb.left + window2.scrollX,
    top: bb.top + window2.scrollY,
    width: bb.width,
    height: bb.height
  };
}
function ensure(value) {
  if (value === null) {
    throw new Error("Value is null");
  }
  if (value === void 0) {
    throw new Error("Value is undefined");
  }
  if (value === false) {
    throw new Error("Value is falsy");
  }
  return value;
}
function should(condition, messageOrError = "unexpected state") {
  if (condition === false || isUndefinedOrNull(condition)) {
    const errorToThrow = typeof messageOrError === "string" ? new BugIndicatingError(`Assertion Failed: ${messageOrError}`) : messageOrError;
    throw errorToThrow;
  }
}
function createSingleCallFunction(fn2, fnDidRunCallback) {
  const _this = this;
  let didCall = false;
  let result;
  return function() {
    if (didCall) {
      return result;
    }
    didCall = true;
    {
      result = fn2.apply(_this, arguments);
    }
    return result;
  };
}
var Iterable;
((Iterable2) => {
  function is2(thing) {
    return thing && typeof thing === "object" && typeof thing[Symbol.iterator] === "function";
  }
  Iterable2.is = is2;
  function first(iterable) {
    return iterable[Symbol.iterator]().next().value;
  }
  Iterable2.first = first;
})(Iterable || (Iterable = {}));
function isDisposable(thing) {
  return typeof thing === "object" && thing !== null && typeof thing.dispose === "function" && thing.dispose.length === 0;
}
function dispose(arg) {
  if (Iterable.is(arg)) {
    const errors = [];
    for (const d3 of arg) {
      if (d3) {
        try {
          d3.dispose();
        } catch (e2) {
          errors.push(e2);
        }
      }
    }
    if (errors.length === 1) {
      throw errors[0];
    } else if (errors.length > 1) {
      throw new AggregateError(errors, "Encountered errors while disposing of store");
    }
    return Array.isArray(arg) ? [] : arg;
  } else if (arg) {
    arg.dispose();
    return arg;
  }
}
function toDisposable(fn2) {
  return {
    dispose: createSingleCallFunction(() => {
      fn2();
    })
  };
}
function combinedDisposable(...disposables) {
  const parent2 = toDisposable(() => dispose(disposables));
  return parent2;
}
class DisposableStore {
  constructor() {
    __publicField(this, "_toDispose", /* @__PURE__ */ new Set());
    __publicField(this, "_isDisposed", false);
  }
  /**
   * Dispose of all registered disposables and mark this object as disposed.
   *
   * Any future disposables added to this object will be disposed of on `add`.
   */
  dispose() {
    if (this._isDisposed) {
      return;
    }
    this._isDisposed = true;
    this.clear();
  }
  /**
   * @return `true` if this object has been disposed of.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Dispose of all registered disposables but do not mark this object as disposed.
   */
  clear() {
    if (this._toDispose.size === 0) {
      return;
    }
    try {
      dispose(this._toDispose);
    } finally {
      this._toDispose.clear();
    }
  }
  /**
   * Add a new {@link IDisposable disposable} to the collection.
   */
  add(o2) {
    if (!o2) {
      return o2;
    }
    if (o2 === this) {
      throw new Error("Cannot register a disposable on itself!");
    }
    if (this._isDisposed) {
      {
        console.warn(
          new Error(
            "Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!"
          ).stack
        );
      }
    } else {
      this._toDispose.add(o2);
    }
    return o2;
  }
  /**
   * Deletes a disposable from store and disposes of it. This will not throw or warn and proceed to dispose the
   * disposable even when the disposable is not part in the store.
   */
  delete(o2) {
    if (!o2) {
      return;
    }
    if (o2 === this) {
      throw new Error("Cannot dispose a disposable on itself!");
    }
    this._toDispose.delete(o2);
    o2.dispose();
  }
  /**
   * Deletes the value from the store, but does not dispose it.
   */
  deleteAndLeak(o2) {
    if (!o2) {
      return;
    }
    if (this._toDispose.has(o2)) {
      this._toDispose.delete(o2);
    }
  }
}
__publicField(DisposableStore, "DISABLE_DISPOSED_WARNING", false);
class Disposable {
  constructor() {
    __publicField(this, "_store", new DisposableStore());
    __publicField(this, "_disposed", false);
  }
  dispose() {
    this._disposed = true;
    this._store.dispose();
  }
  /**
   * Adds `o` to the collection of disposables managed by this object.
   */
  _register(o2) {
    if (o2 === this) {
      throw new Error("Cannot register a disposable on itself!");
    }
    return this._store.add(o2);
  }
}
/**
 * A disposable that does nothing when it is disposed of.
 *
 * TODO: This should not be a static property.
 */
__publicField(Disposable, "None", Object.freeze({ dispose() {
} }));
class DisposableMap {
  constructor() {
    __publicField(this, "_store", /* @__PURE__ */ new Map());
    __publicField(this, "_isDisposed", false);
  }
  /**
   * Disposes of all stored values and mark this object as disposed.
   *
   * Trying to use this object after it has been disposed of is an error.
   */
  dispose() {
    this._isDisposed = true;
    this.clearAndDisposeAll();
  }
  /**
   * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.
   */
  clearAndDisposeAll() {
    if (!this._store.size) {
      return;
    }
    try {
      dispose(this._store.values());
    } finally {
      this._store.clear();
    }
  }
  has(key2) {
    return this._store.has(key2);
  }
  get size() {
    return this._store.size;
  }
  get(key2) {
    return this._store.get(key2);
  }
  set(key2, value, skipDisposeOnOverwrite = false) {
    var _a3;
    if (this._isDisposed) {
      console.warn(
        new Error(
          "Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!"
        ).stack
      );
    }
    if (!skipDisposeOnOverwrite) {
      (_a3 = this._store.get(key2)) == null ? void 0 : _a3.dispose();
    }
    this._store.set(key2, value);
  }
  /**
   * Delete the value stored for `key` from this map and also dispose of it.
   */
  deleteAndDispose(key2) {
    var _a3;
    (_a3 = this._store.get(key2)) == null ? void 0 : _a3.dispose();
    this._store.delete(key2);
  }
  /**
   * Delete the value stored for `key` from this map but return it. The caller is
   * responsible for disposing of the value.
   */
  deleteAndLeak(key2) {
    const value = this._store.get(key2);
    this._store.delete(key2);
    return value;
  }
  keys() {
    return this._store.keys();
  }
  values() {
    return this._store.values();
  }
  [Symbol.iterator]() {
    return this._store[Symbol.iterator]();
  }
}
const generateUuid = function() {
  if (typeof crypto.randomUUID === "function") {
    return crypto.randomUUID.bind(crypto);
  }
  const _data = new Uint8Array(16);
  const _hex = [];
  for (let i2 = 0; i2 < 256; i2++) {
    _hex.push(i2.toString(16).padStart(2, "0"));
  }
  return function generateUuid2() {
    crypto.getRandomValues(_data);
    _data[6] = _data[6] & 15 | 64;
    _data[8] = _data[8] & 63 | 128;
    let i2 = 0;
    let result = "";
    result += _hex[_data[i2++]];
    result += _hex[_data[i2++]];
    result += _hex[_data[i2++]];
    result += _hex[_data[i2++]];
    result += "-";
    result += _hex[_data[i2++]];
    result += _hex[_data[i2++]];
    result += "-";
    result += _hex[_data[i2++]];
    result += _hex[_data[i2++]];
    result += "-";
    result += _hex[_data[i2++]];
    result += _hex[_data[i2++]];
    result += "-";
    result += _hex[_data[i2++]];
    result += _hex[_data[i2++]];
    result += _hex[_data[i2++]];
    result += _hex[_data[i2++]];
    result += _hex[_data[i2++]];
    result += _hex[_data[i2++]];
    return result;
  };
}();
const DEV = false;
var scheduler = { exports: {} };
var scheduler_production = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredScheduler_production;
function requireScheduler_production() {
  if (hasRequiredScheduler_production) return scheduler_production;
  hasRequiredScheduler_production = 1;
  (function(exports2) {
    function push2(heap, node) {
      var index2 = heap.length;
      heap.push(node);
      a: for (; 0 < index2; ) {
        var parentIndex = index2 - 1 >>> 1, parent2 = heap[parentIndex];
        if (0 < compare(parent2, node))
          heap[parentIndex] = node, heap[index2] = parent2, index2 = parentIndex;
        else break a;
      }
    }
    function peek(heap) {
      return 0 === heap.length ? null : heap[0];
    }
    function pop2(heap) {
      if (0 === heap.length) return null;
      var first = heap[0], last2 = heap.pop();
      if (last2 !== first) {
        heap[0] = last2;
        a: for (var index2 = 0, length = heap.length, halfLength = length >>> 1; index2 < halfLength; ) {
          var leftIndex = 2 * (index2 + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
          if (0 > compare(left, last2))
            rightIndex < length && 0 > compare(right, left) ? (heap[index2] = right, heap[rightIndex] = last2, index2 = rightIndex) : (heap[index2] = left, heap[leftIndex] = last2, index2 = leftIndex);
          else if (rightIndex < length && 0 > compare(right, last2))
            heap[index2] = right, heap[rightIndex] = last2, index2 = rightIndex;
          else break a;
        }
      }
      return first;
    }
    function compare(a2, b2) {
      var diff = a2.sortIndex - b2.sortIndex;
      return 0 !== diff ? diff : a2.id - b2.id;
    }
    exports2.unstable_now = void 0;
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var localPerformance = performance;
      exports2.unstable_now = function() {
        return localPerformance.now();
      };
    } else {
      var localDate = Date, initialTime = localDate.now();
      exports2.unstable_now = function() {
        return localDate.now() - initialTime;
      };
    }
    var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
    function advanceTimers(currentTime) {
      for (var timer = peek(timerQueue); null !== timer; ) {
        if (null === timer.callback) pop2(timerQueue);
        else if (timer.startTime <= currentTime)
          pop2(timerQueue), timer.sortIndex = timer.expirationTime, push2(taskQueue, timer);
        else break;
        timer = peek(timerQueue);
      }
    }
    function handleTimeout(currentTime) {
      isHostTimeoutScheduled = false;
      advanceTimers(currentTime);
      if (!isHostCallbackScheduled)
        if (null !== peek(taskQueue))
          isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
        else {
          var firstTimer = peek(timerQueue);
          null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
        }
    }
    var isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
    function shouldYieldToHost() {
      return needsPaint ? true : exports2.unstable_now() - startTime < frameInterval ? false : true;
    }
    function performWorkUntilDeadline() {
      needsPaint = false;
      if (isMessageLoopRunning) {
        var currentTime = exports2.unstable_now();
        startTime = currentTime;
        var hasMoreWork = true;
        try {
          a: {
            isHostCallbackScheduled = false;
            isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
            isPerformingWork = true;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              b: {
                advanceTimers(currentTime);
                for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                  var callback = currentTask.callback;
                  if ("function" === typeof callback) {
                    currentTask.callback = null;
                    currentPriorityLevel = currentTask.priorityLevel;
                    var continuationCallback = callback(
                      currentTask.expirationTime <= currentTime
                    );
                    currentTime = exports2.unstable_now();
                    if ("function" === typeof continuationCallback) {
                      currentTask.callback = continuationCallback;
                      advanceTimers(currentTime);
                      hasMoreWork = true;
                      break b;
                    }
                    currentTask === peek(taskQueue) && pop2(taskQueue);
                    advanceTimers(currentTime);
                  } else pop2(taskQueue);
                  currentTask = peek(taskQueue);
                }
                if (null !== currentTask) hasMoreWork = true;
                else {
                  var firstTimer = peek(timerQueue);
                  null !== firstTimer && requestHostTimeout(
                    handleTimeout,
                    firstTimer.startTime - currentTime
                  );
                  hasMoreWork = false;
                }
              }
              break a;
            } finally {
              currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
            }
            hasMoreWork = void 0;
          }
        } finally {
          hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
        }
      }
    }
    var schedulePerformWorkUntilDeadline;
    if ("function" === typeof localSetImmediate)
      schedulePerformWorkUntilDeadline = function() {
        localSetImmediate(performWorkUntilDeadline);
      };
    else if ("undefined" !== typeof MessageChannel) {
      var channel = new MessageChannel(), port = channel.port2;
      channel.port1.onmessage = performWorkUntilDeadline;
      schedulePerformWorkUntilDeadline = function() {
        port.postMessage(null);
      };
    } else
      schedulePerformWorkUntilDeadline = function() {
        localSetTimeout(performWorkUntilDeadline, 0);
      };
    function requestHostTimeout(callback, ms2) {
      taskTimeoutID = localSetTimeout(function() {
        callback(exports2.unstable_now());
      }, ms2);
    }
    exports2.unstable_IdlePriority = 5;
    exports2.unstable_ImmediatePriority = 1;
    exports2.unstable_LowPriority = 4;
    exports2.unstable_NormalPriority = 3;
    exports2.unstable_Profiling = null;
    exports2.unstable_UserBlockingPriority = 2;
    exports2.unstable_cancelCallback = function(task) {
      task.callback = null;
    };
    exports2.unstable_forceFrameRate = function(fps) {
      0 > fps || 125 < fps ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
    };
    exports2.unstable_getCurrentPriorityLevel = function() {
      return currentPriorityLevel;
    };
    exports2.unstable_next = function(eventHandler) {
      switch (currentPriorityLevel) {
        case 1:
        case 2:
        case 3:
          var priorityLevel = 3;
          break;
        default:
          priorityLevel = currentPriorityLevel;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports2.unstable_requestPaint = function() {
      needsPaint = true;
    };
    exports2.unstable_runWithPriority = function(priorityLevel, eventHandler) {
      switch (priorityLevel) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          priorityLevel = 3;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports2.unstable_scheduleCallback = function(priorityLevel, callback, options) {
      var currentTime = exports2.unstable_now();
      "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
      switch (priorityLevel) {
        case 1:
          var timeout = -1;
          break;
        case 2:
          timeout = 250;
          break;
        case 5:
          timeout = 1073741823;
          break;
        case 4:
          timeout = 1e4;
          break;
        default:
          timeout = 5e3;
      }
      timeout = options + timeout;
      priorityLevel = {
        id: taskIdCounter++,
        callback,
        priorityLevel,
        startTime: options,
        expirationTime: timeout,
        sortIndex: -1
      };
      options > currentTime ? (priorityLevel.sortIndex = options, push2(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push2(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
      return priorityLevel;
    };
    exports2.unstable_shouldYield = shouldYieldToHost;
    exports2.unstable_wrapCallback = function(callback) {
      var parentPriorityLevel = currentPriorityLevel;
      return function() {
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = parentPriorityLevel;
        try {
          return callback.apply(this, arguments);
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
    };
  })(scheduler_production);
  return scheduler_production;
}
var hasRequiredScheduler;
function requireScheduler() {
  if (hasRequiredScheduler) return scheduler.exports;
  hasRequiredScheduler = 1;
  {
    scheduler.exports = requireScheduler_production();
  }
  return scheduler.exports;
}
var schedulerExports = requireScheduler();
function size$1(_a3) {
  var width = _a3.width, height = _a3.height;
  if (width < 0) {
    throw new Error("Negative width is not allowed for Size");
  }
  if (height < 0) {
    throw new Error("Negative height is not allowed for Size");
  }
  return {
    width,
    height
  };
}
function equalSizes(first, second) {
  return first.width === second.width && first.height === second.height;
}
var Observable$1 = (
  /** @class */
  function() {
    function Observable2(win) {
      var _this = this;
      this._resolutionListener = function() {
        return _this._onResolutionChanged();
      };
      this._resolutionMediaQueryList = null;
      this._observers = [];
      this._window = win;
      this._installResolutionListener();
    }
    Observable2.prototype.dispose = function() {
      this._uninstallResolutionListener();
      this._window = null;
    };
    Object.defineProperty(Observable2.prototype, "value", {
      get: function() {
        return this._window.devicePixelRatio;
      },
      enumerable: false,
      configurable: true
    });
    Observable2.prototype.subscribe = function(next) {
      var _this = this;
      var observer = { next };
      this._observers.push(observer);
      return {
        unsubscribe: function() {
          _this._observers = _this._observers.filter(function(o2) {
            return o2 !== observer;
          });
        }
      };
    };
    Observable2.prototype._installResolutionListener = function() {
      if (this._resolutionMediaQueryList !== null) {
        throw new Error("Resolution listener is already installed");
      }
      var dppx = this._window.devicePixelRatio;
      this._resolutionMediaQueryList = this._window.matchMedia("all and (resolution: ".concat(dppx, "dppx)"));
      this._resolutionMediaQueryList.addListener(this._resolutionListener);
    };
    Observable2.prototype._uninstallResolutionListener = function() {
      if (this._resolutionMediaQueryList !== null) {
        this._resolutionMediaQueryList.removeListener(this._resolutionListener);
        this._resolutionMediaQueryList = null;
      }
    };
    Observable2.prototype._reinstallResolutionListener = function() {
      this._uninstallResolutionListener();
      this._installResolutionListener();
    };
    Observable2.prototype._onResolutionChanged = function() {
      var _this = this;
      this._observers.forEach(function(observer) {
        return observer.next(_this._window.devicePixelRatio);
      });
      this._reinstallResolutionListener();
    };
    return Observable2;
  }()
);
function createObservable(win) {
  return new Observable$1(win);
}
var DevicePixelContentBoxBinding = (
  /** @class */
  function() {
    function DevicePixelContentBoxBinding2(canvasElement, transformBitmapSize, options) {
      var _a3;
      this._canvasElement = null;
      this._bitmapSizeChangedListeners = [];
      this._suggestedBitmapSize = null;
      this._suggestedBitmapSizeChangedListeners = [];
      this._devicePixelRatioObservable = null;
      this._canvasElementResizeObserver = null;
      this._canvasElement = canvasElement;
      this._canvasElementClientSize = size$1({
        width: this._canvasElement.clientWidth,
        height: this._canvasElement.clientHeight
      });
      this._transformBitmapSize = transformBitmapSize !== null && transformBitmapSize !== void 0 ? transformBitmapSize : function(size2) {
        return size2;
      };
      this._allowResizeObserver = (_a3 = options === null || options === void 0 ? void 0 : options.allowResizeObserver) !== null && _a3 !== void 0 ? _a3 : true;
      this._chooseAndInitObserver();
    }
    DevicePixelContentBoxBinding2.prototype.dispose = function() {
      var _a3, _b3;
      if (this._canvasElement === null) {
        throw new Error("Object is disposed");
      }
      (_a3 = this._canvasElementResizeObserver) === null || _a3 === void 0 ? void 0 : _a3.disconnect();
      this._canvasElementResizeObserver = null;
      (_b3 = this._devicePixelRatioObservable) === null || _b3 === void 0 ? void 0 : _b3.dispose();
      this._devicePixelRatioObservable = null;
      this._suggestedBitmapSizeChangedListeners.length = 0;
      this._bitmapSizeChangedListeners.length = 0;
      this._canvasElement = null;
    };
    Object.defineProperty(DevicePixelContentBoxBinding2.prototype, "canvasElement", {
      get: function() {
        if (this._canvasElement === null) {
          throw new Error("Object is disposed");
        }
        return this._canvasElement;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DevicePixelContentBoxBinding2.prototype, "canvasElementClientSize", {
      get: function() {
        return this._canvasElementClientSize;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DevicePixelContentBoxBinding2.prototype, "bitmapSize", {
      get: function() {
        return size$1({
          width: this.canvasElement.width,
          height: this.canvasElement.height
        });
      },
      enumerable: false,
      configurable: true
    });
    DevicePixelContentBoxBinding2.prototype.resizeCanvasElement = function(clientSize) {
      this._canvasElementClientSize = size$1(clientSize);
      this.canvasElement.style.width = "".concat(this._canvasElementClientSize.width, "px");
      this.canvasElement.style.height = "".concat(this._canvasElementClientSize.height, "px");
      this._invalidateBitmapSize();
    };
    DevicePixelContentBoxBinding2.prototype.subscribeBitmapSizeChanged = function(listener) {
      this._bitmapSizeChangedListeners.push(listener);
    };
    DevicePixelContentBoxBinding2.prototype.unsubscribeBitmapSizeChanged = function(listener) {
      this._bitmapSizeChangedListeners = this._bitmapSizeChangedListeners.filter(function(l2) {
        return l2 !== listener;
      });
    };
    Object.defineProperty(DevicePixelContentBoxBinding2.prototype, "suggestedBitmapSize", {
      get: function() {
        return this._suggestedBitmapSize;
      },
      enumerable: false,
      configurable: true
    });
    DevicePixelContentBoxBinding2.prototype.subscribeSuggestedBitmapSizeChanged = function(listener) {
      this._suggestedBitmapSizeChangedListeners.push(listener);
    };
    DevicePixelContentBoxBinding2.prototype.unsubscribeSuggestedBitmapSizeChanged = function(listener) {
      this._suggestedBitmapSizeChangedListeners = this._suggestedBitmapSizeChangedListeners.filter(function(l2) {
        return l2 !== listener;
      });
    };
    DevicePixelContentBoxBinding2.prototype.applySuggestedBitmapSize = function() {
      if (this._suggestedBitmapSize === null) {
        return;
      }
      var oldSuggestedSize = this._suggestedBitmapSize;
      this._suggestedBitmapSize = null;
      this._resizeBitmap(oldSuggestedSize);
      this._emitSuggestedBitmapSizeChanged(oldSuggestedSize, this._suggestedBitmapSize);
    };
    DevicePixelContentBoxBinding2.prototype._resizeBitmap = function(newSize) {
      var oldSize = this.bitmapSize;
      if (equalSizes(oldSize, newSize)) {
        return;
      }
      this.canvasElement.width = newSize.width;
      this.canvasElement.height = newSize.height;
      this._emitBitmapSizeChanged(oldSize, newSize);
    };
    DevicePixelContentBoxBinding2.prototype._emitBitmapSizeChanged = function(oldSize, newSize) {
      var _this = this;
      this._bitmapSizeChangedListeners.forEach(function(listener) {
        return listener.call(_this, oldSize, newSize);
      });
    };
    DevicePixelContentBoxBinding2.prototype._suggestNewBitmapSize = function(newSize) {
      var oldSuggestedSize = this._suggestedBitmapSize;
      var finalNewSize = size$1(this._transformBitmapSize(newSize, this._canvasElementClientSize));
      var newSuggestedSize = equalSizes(this.bitmapSize, finalNewSize) ? null : finalNewSize;
      if (oldSuggestedSize === null && newSuggestedSize === null) {
        return;
      }
      if (oldSuggestedSize !== null && newSuggestedSize !== null && equalSizes(oldSuggestedSize, newSuggestedSize)) {
        return;
      }
      this._suggestedBitmapSize = newSuggestedSize;
      this._emitSuggestedBitmapSizeChanged(oldSuggestedSize, newSuggestedSize);
    };
    DevicePixelContentBoxBinding2.prototype._emitSuggestedBitmapSizeChanged = function(oldSize, newSize) {
      var _this = this;
      this._suggestedBitmapSizeChangedListeners.forEach(function(listener) {
        return listener.call(_this, oldSize, newSize);
      });
    };
    DevicePixelContentBoxBinding2.prototype._chooseAndInitObserver = function() {
      var _this = this;
      if (!this._allowResizeObserver) {
        this._initDevicePixelRatioObservable();
        return;
      }
      isDevicePixelContentBoxSupported().then(function(isSupported) {
        return isSupported ? _this._initResizeObserver() : _this._initDevicePixelRatioObservable();
      });
    };
    DevicePixelContentBoxBinding2.prototype._initDevicePixelRatioObservable = function() {
      var _this = this;
      if (this._canvasElement === null) {
        return;
      }
      var win = canvasElementWindow(this._canvasElement);
      if (win === null) {
        throw new Error("No window is associated with the canvas");
      }
      this._devicePixelRatioObservable = createObservable(win);
      this._devicePixelRatioObservable.subscribe(function() {
        return _this._invalidateBitmapSize();
      });
      this._invalidateBitmapSize();
    };
    DevicePixelContentBoxBinding2.prototype._invalidateBitmapSize = function() {
      var _a3, _b3;
      if (this._canvasElement === null) {
        return;
      }
      var win = canvasElementWindow(this._canvasElement);
      if (win === null) {
        return;
      }
      var ratio = (_b3 = (_a3 = this._devicePixelRatioObservable) === null || _a3 === void 0 ? void 0 : _a3.value) !== null && _b3 !== void 0 ? _b3 : win.devicePixelRatio;
      var canvasRects = this._canvasElement.getClientRects();
      var newSize = (
        // eslint-disable-next-line no-negated-condition
        canvasRects[0] !== void 0 ? predictedBitmapSize(canvasRects[0], ratio) : size$1({
          width: this._canvasElementClientSize.width * ratio,
          height: this._canvasElementClientSize.height * ratio
        })
      );
      this._suggestNewBitmapSize(newSize);
    };
    DevicePixelContentBoxBinding2.prototype._initResizeObserver = function() {
      var _this = this;
      if (this._canvasElement === null) {
        return;
      }
      this._canvasElementResizeObserver = new ResizeObserver(function(entries) {
        var entry = entries.find(function(entry2) {
          return entry2.target === _this._canvasElement;
        });
        if (!entry || !entry.devicePixelContentBoxSize || !entry.devicePixelContentBoxSize[0]) {
          return;
        }
        var entrySize = entry.devicePixelContentBoxSize[0];
        var newSize = size$1({
          width: entrySize.inlineSize,
          height: entrySize.blockSize
        });
        _this._suggestNewBitmapSize(newSize);
      });
      this._canvasElementResizeObserver.observe(this._canvasElement, { box: "device-pixel-content-box" });
    };
    return DevicePixelContentBoxBinding2;
  }()
);
function bindTo(canvasElement, target) {
  {
    return new DevicePixelContentBoxBinding(canvasElement, target.transform, target.options);
  }
}
function canvasElementWindow(canvasElement) {
  return canvasElement.ownerDocument.defaultView;
}
function isDevicePixelContentBoxSupported() {
  return new Promise(function(resolve) {
    var ro = new ResizeObserver(function(entries) {
      resolve(entries.every(function(entry) {
        return "devicePixelContentBoxSize" in entry;
      }));
      ro.disconnect();
    });
    ro.observe(document.body, { box: "device-pixel-content-box" });
  }).catch(function() {
    return false;
  });
}
function predictedBitmapSize(canvasRect, ratio) {
  return size$1({
    width: Math.round(canvasRect.left * ratio + canvasRect.width * ratio) - Math.round(canvasRect.left * ratio),
    height: Math.round(canvasRect.top * ratio + canvasRect.height * ratio) - Math.round(canvasRect.top * ratio)
  });
}
var CanvasRenderingTarget2D = (
  /** @class */
  function() {
    function CanvasRenderingTarget2D2(context, mediaSize, bitmapSize) {
      if (mediaSize.width === 0 || mediaSize.height === 0) {
        throw new TypeError("Rendering target could only be created on a media with positive width and height");
      }
      this._mediaSize = mediaSize;
      if (bitmapSize.width === 0 || bitmapSize.height === 0) {
        throw new TypeError("Rendering target could only be created using a bitmap with positive integer width and height");
      }
      this._bitmapSize = bitmapSize;
      this._context = context;
    }
    CanvasRenderingTarget2D2.prototype.useMediaCoordinateSpace = function(f2) {
      try {
        this._context.save();
        this._context.setTransform(1, 0, 0, 1, 0, 0);
        this._context.scale(this._horizontalPixelRatio, this._verticalPixelRatio);
        return f2({
          context: this._context,
          mediaSize: this._mediaSize
        });
      } finally {
        this._context.restore();
      }
    };
    CanvasRenderingTarget2D2.prototype.useBitmapCoordinateSpace = function(f2) {
      try {
        this._context.save();
        this._context.setTransform(1, 0, 0, 1, 0, 0);
        return f2({
          context: this._context,
          mediaSize: this._mediaSize,
          bitmapSize: this._bitmapSize,
          horizontalPixelRatio: this._horizontalPixelRatio,
          verticalPixelRatio: this._verticalPixelRatio
        });
      } finally {
        this._context.restore();
      }
    };
    Object.defineProperty(CanvasRenderingTarget2D2.prototype, "_horizontalPixelRatio", {
      get: function() {
        return this._bitmapSize.width / this._mediaSize.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CanvasRenderingTarget2D2.prototype, "_verticalPixelRatio", {
      get: function() {
        return this._bitmapSize.height / this._mediaSize.height;
      },
      enumerable: false,
      configurable: true
    });
    return CanvasRenderingTarget2D2;
  }()
);
function tryCreateCanvasRenderingTarget2D(binding, contextOptions) {
  var mediaSize = binding.canvasElementClientSize;
  if (mediaSize.width === 0 || mediaSize.height === 0) {
    return null;
  }
  var bitmapSize = binding.bitmapSize;
  if (bitmapSize.width === 0 || bitmapSize.height === 0) {
    return null;
  }
  var context = binding.canvasElement.getContext("2d", contextOptions);
  if (context === null) {
    return null;
  }
  return new CanvasRenderingTarget2D(context, mediaSize, bitmapSize);
}
/*!
 * @license
 * TradingView Lightweight Charts™ v5.0.8-dev+202509160310
 * Copyright (c) 2025 TradingView, Inc.
 * Licensed under Apache License 2.0 https://www.apache.org/licenses/LICENSE-2.0
 */
const e$1 = { title: "", visible: true, lastValueVisible: true, priceLineVisible: true, priceLineSource: 0, priceLineWidth: 1, priceLineColor: "", priceLineStyle: 2, baseLineVisible: true, baseLineWidth: 1, baseLineColor: "#B2B5BE", baseLineStyle: 0, priceFormat: { type: "price", precision: 2, minMove: 0.01 } };
var r$2, h;
function a$1(t2, i2) {
  const s2 = { 0: [], 1: [t2.lineWidth, t2.lineWidth], 2: [2 * t2.lineWidth, 2 * t2.lineWidth], 3: [6 * t2.lineWidth, 6 * t2.lineWidth], 4: [t2.lineWidth, 4 * t2.lineWidth] }[i2];
  t2.setLineDash(s2);
}
function l$1(t2, i2, s2, n2) {
  t2.beginPath();
  const e2 = t2.lineWidth % 2 ? 0.5 : 0;
  t2.moveTo(s2, i2 + e2), t2.lineTo(n2, i2 + e2), t2.stroke();
}
function o$1(t2, i2) {
  if (!t2) throw new Error("Assertion failed" + (i2 ? ": " + i2 : ""));
}
function _(t2) {
  if (void 0 === t2) throw new Error("Value is undefined");
  return t2;
}
function u(t2) {
  if (null === t2) throw new Error("Value is null");
  return t2;
}
function c(t2) {
  return u(_(t2));
}
!function(t2) {
  t2[t2.Simple = 0] = "Simple", t2[t2.WithSteps = 1] = "WithSteps", t2[t2.Curved = 2] = "Curved";
}(r$2 || (r$2 = {})), function(t2) {
  t2[t2.Solid = 0] = "Solid", t2[t2.Dotted = 1] = "Dotted", t2[t2.Dashed = 2] = "Dashed", t2[t2.LargeDashed = 3] = "LargeDashed", t2[t2.SparseDotted = 4] = "SparseDotted";
}(h || (h = {}));
let d$1 = class d {
  constructor() {
    this.t = [];
  }
  i(t2, i2, s2) {
    const n2 = { h: t2, l: i2, o: true === s2 };
    this.t.push(n2);
  }
  _(t2) {
    const i2 = this.t.findIndex((i3) => t2 === i3.h);
    i2 > -1 && this.t.splice(i2, 1);
  }
  u(t2) {
    this.t = this.t.filter((i2) => i2.l !== t2);
  }
  p(t2, i2, s2) {
    const n2 = [...this.t];
    this.t = this.t.filter((t3) => !t3.o), n2.forEach((n3) => n3.h(t2, i2, s2));
  }
  v() {
    return this.t.length > 0;
  }
  m() {
    this.t = [];
  }
};
function f(t2, ...i2) {
  for (const s2 of i2) for (const i3 in s2) void 0 !== s2[i3] && Object.prototype.hasOwnProperty.call(s2, i3) && !["__proto__", "constructor", "prototype"].includes(i3) && ("object" != typeof s2[i3] || void 0 === t2[i3] || Array.isArray(s2[i3]) ? t2[i3] = s2[i3] : f(t2[i3], s2[i3]));
  return t2;
}
function p(t2) {
  return "number" == typeof t2 && isFinite(t2);
}
function v(t2) {
  return "number" == typeof t2 && t2 % 1 == 0;
}
function m(t2) {
  return "string" == typeof t2;
}
function w(t2) {
  return "boolean" == typeof t2;
}
function M(t2) {
  const i2 = t2;
  if (!i2 || "object" != typeof i2) return i2;
  let s2, n2, e2;
  for (n2 in s2 = Array.isArray(i2) ? [] : {}, i2) i2.hasOwnProperty(n2) && (e2 = i2[n2], s2[n2] = e2 && "object" == typeof e2 ? M(e2) : e2);
  return s2;
}
function g(t2) {
  return null !== t2;
}
function b(t2) {
  return null === t2 ? void 0 : t2;
}
const x = "-apple-system, BlinkMacSystemFont, 'Trebuchet MS', Roboto, Ubuntu, sans-serif";
function S(t2, i2, s2) {
  return void 0 === i2 && (i2 = x), `${s2 = void 0 !== s2 ? `${s2} ` : ""}${t2}px ${i2}`;
}
class C {
  constructor(t2) {
    this.M = { S: 1, C: 5, P: NaN, k: "", T: "", R: "", D: "", I: "", B: 0, V: 0, A: 0, L: 0, O: 0 }, this.N = t2;
  }
  F() {
    const t2 = this.M, i2 = this.W(), s2 = this.H();
    return t2.P === i2 && t2.T === s2 || (t2.P = i2, t2.T = s2, t2.k = S(i2, s2), t2.L = 2.5 / 12 * i2, t2.B = t2.L, t2.V = i2 / 12 * t2.C, t2.A = i2 / 12 * t2.C, t2.O = 0), t2.R = this.U(), t2.D = this.$(), t2.I = this.q(), this.M;
  }
  U() {
    return this.N.F().layout.textColor;
  }
  $() {
    const t2 = this.N.F().rightPriceScale.background;
    return t2 ? "solid" === t2.type ? t2.color : t2.topColor : this.N.Y();
  }
  q() {
    const t2 = this.N.F().rightPriceScale.background;
    return t2 ? "solid" === t2.type ? t2.color : t2.bottomColor : this.N.j();
  }
  W() {
    return this.N.F().layout.fontSize;
  }
  H() {
    return this.N.F().layout.fontFamily;
  }
}
function P(t2) {
  return t2 < 0 ? 0 : t2 > 255 ? 255 : Math.round(t2) || 0;
}
function k(t2) {
  return 0.199 * t2[0] + 0.687 * t2[1] + 0.114 * t2[2];
}
class y {
  constructor(t2, i2) {
    this.K = /* @__PURE__ */ new Map(), this.X = t2, i2 && (this.K = i2);
  }
  G(t2, i2) {
    if ("transparent" === t2) return t2;
    const s2 = this.Z(t2), n2 = s2[3];
    return `rgba(${s2[0]}, ${s2[1]}, ${s2[2]}, ${i2 * n2})`;
  }
  J(t2) {
    const i2 = this.Z(t2);
    return { tt: `rgb(${i2[0]}, ${i2[1]}, ${i2[2]})`, it: k(i2) > 160 ? "black" : "white" };
  }
  st(t2) {
    return k(this.Z(t2));
  }
  nt(t2, i2, s2) {
    const [n2, e2, r2, h2] = this.Z(t2), [a2, l2, o2, _2] = this.Z(i2), u2 = [P(n2 + s2 * (a2 - n2)), P(e2 + s2 * (l2 - e2)), P(r2 + s2 * (o2 - r2)), (c2 = h2 + s2 * (_2 - h2), c2 <= 0 || c2 > 1 ? Math.min(Math.max(c2, 0), 1) : Math.round(1e4 * c2) / 1e4)];
    var c2;
    return `rgba(${u2[0]}, ${u2[1]}, ${u2[2]}, ${u2[3]})`;
  }
  Z(t2) {
    const i2 = this.K.get(t2);
    if (i2) return i2;
    const s2 = function(t3) {
      const i3 = document.createElement("div");
      i3.style.display = "none", document.body.appendChild(i3), i3.style.color = t3;
      const s3 = window.getComputedStyle(i3).color;
      return document.body.removeChild(i3), s3;
    }(t2), n2 = s2.match(/^rgba?\s*\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d*\.?\d+))?\)$/);
    if (!n2) {
      if (this.X.length) for (const i3 of this.X) {
        const s3 = i3(t2);
        if (s3) return this.K.set(t2, s3), s3;
      }
      throw new Error(`Failed to parse color: ${t2}`);
    }
    const e2 = [parseInt(n2[1], 10), parseInt(n2[2], 10), parseInt(n2[3], 10), n2[4] ? parseFloat(n2[4]) : 1];
    return this.K.set(t2, e2), e2;
  }
}
class T {
  constructor() {
    this.et = [];
  }
  rt(t2) {
    this.et = t2;
  }
  ht(t2, i2) {
    var _a3;
    for (const s2 of this.et) {
      const n2 = (_a3 = s2.ht) == null ? void 0 : _a3.call(s2, t2, i2);
      if (n2) return n2;
    }
    return null;
  }
  lt(t2, i2, s2) {
    this.et.forEach((n2) => {
      n2.lt(t2, i2, s2);
    });
  }
}
class R {
  lt(t2, i2, s2) {
    t2.useBitmapCoordinateSpace((t3) => this.ot(t3, i2, s2));
  }
}
class D extends R {
  constructor() {
    super(...arguments), this._t = null;
  }
  ut(t2) {
    this._t = t2;
  }
  ot({ context: t2, horizontalPixelRatio: i2, verticalPixelRatio: s2 }) {
    if (null === this._t || null === this._t.ct) return;
    const n2 = this._t.ct, e2 = this._t, r2 = Math.max(1, Math.floor(i2)) % 2 / 2, h2 = (h3) => {
      t2.beginPath();
      for (let a2 = n2.to - 1; a2 >= n2.from; --a2) {
        const n3 = e2.dt[a2], l2 = Math.round(n3.ft * i2) + r2, o2 = n3.vt * s2, _2 = h3 * s2 + r2;
        t2.moveTo(l2, o2), t2.arc(l2, o2, _2, 0, 2 * Math.PI);
      }
      t2.fill();
    };
    e2.wt > 0 && (t2.fillStyle = e2.Mt, h2(e2.gt + e2.wt)), t2.fillStyle = e2.bt, h2(e2.gt);
  }
}
function I() {
  return { dt: [{ ft: 0, vt: 0, xt: 0, St: 0 }], bt: "", Mt: "", gt: 0, wt: 0, ct: null };
}
const B = { from: 0, to: 1 };
class V {
  constructor(t2, i2, s2) {
    this.Ct = new T(), this.Pt = [], this.kt = [], this.yt = true, this.N = t2, this.Tt = i2, this.Rt = s2, this.Ct.rt(this.Pt);
  }
  Dt(t2) {
    this.It(), this.yt = true;
  }
  Bt() {
    return this.yt && (this.Vt(), this.yt = false), this.Ct;
  }
  It() {
    const t2 = this.Rt.Et();
    t2.length !== this.Pt.length && (this.kt = t2.map(I), this.Pt = this.kt.map((t3) => {
      const i2 = new D();
      return i2.ut(t3), i2;
    }), this.Ct.rt(this.Pt));
  }
  Vt() {
    const t2 = 2 === this.Tt.F().mode || !this.Tt.At(), i2 = this.Rt.zt(), s2 = this.Tt.Lt(), n2 = this.N.Ot();
    this.It(), i2.forEach((i3, e2) => {
      const r2 = this.kt[e2], h2 = i3.Nt(s2), a2 = i3.Ft();
      !t2 && null !== h2 && i3.At() && null !== a2 ? (r2.bt = h2.Wt, r2.gt = h2.gt, r2.wt = h2.Ht, r2.dt[0].St = h2.St, r2.dt[0].vt = i3.$t().Ut(h2.St, a2.qt), r2.Mt = h2.Yt ?? this.N.jt(r2.dt[0].vt / i3.$t().Kt()), r2.dt[0].xt = s2, r2.dt[0].ft = n2.Xt(s2), r2.ct = B) : r2.ct = null;
    });
  }
}
class E extends R {
  constructor(t2) {
    super(), this.Gt = t2;
  }
  ot({ context: t2, bitmapSize: i2, horizontalPixelRatio: s2, verticalPixelRatio: n2 }) {
    if (null === this.Gt) return;
    const e2 = this.Gt.Zt.At, r2 = this.Gt.Jt.At;
    if (!e2 && !r2) return;
    const h2 = Math.round(this.Gt.ft * s2), o2 = Math.round(this.Gt.vt * n2);
    t2.lineCap = "butt", e2 && h2 >= 0 && (t2.lineWidth = Math.floor(this.Gt.Zt.wt * s2), t2.strokeStyle = this.Gt.Zt.R, t2.fillStyle = this.Gt.Zt.R, a$1(t2, this.Gt.Zt.Qt), function(t3, i3, s3, n3) {
      t3.beginPath();
      const e3 = t3.lineWidth % 2 ? 0.5 : 0;
      t3.moveTo(i3 + e3, s3), t3.lineTo(i3 + e3, n3), t3.stroke();
    }(t2, h2, 0, i2.height)), r2 && o2 >= 0 && (t2.lineWidth = Math.floor(this.Gt.Jt.wt * n2), t2.strokeStyle = this.Gt.Jt.R, t2.fillStyle = this.Gt.Jt.R, a$1(t2, this.Gt.Jt.Qt), l$1(t2, o2, 0, i2.width));
  }
}
class A {
  constructor(t2, i2) {
    this.yt = true, this.ti = { Zt: { wt: 1, Qt: 0, R: "", At: false }, Jt: { wt: 1, Qt: 0, R: "", At: false }, ft: 0, vt: 0 }, this.ii = new E(this.ti), this.si = t2, this.Rt = i2;
  }
  Dt() {
    this.yt = true;
  }
  Bt(t2) {
    return this.yt && (this.Vt(), this.yt = false), this.ii;
  }
  Vt() {
    const t2 = this.si.At(), i2 = this.Rt.ni().F().crosshair, s2 = this.ti;
    if (2 === i2.mode) return s2.Jt.At = false, void (s2.Zt.At = false);
    s2.Jt.At = t2 && this.si.ei(this.Rt), s2.Zt.At = t2 && this.si.ri(), s2.Jt.wt = i2.horzLine.width, s2.Jt.Qt = i2.horzLine.style, s2.Jt.R = i2.horzLine.color, s2.Zt.wt = i2.vertLine.width, s2.Zt.Qt = i2.vertLine.style, s2.Zt.R = i2.vertLine.color, s2.ft = this.si.hi(), s2.vt = this.si.ai();
  }
}
function z(t2, i2, s2, n2, e2, r2) {
  t2.fillRect(i2 + r2, s2, n2 - 2 * r2, r2), t2.fillRect(i2 + r2, s2 + e2 - r2, n2 - 2 * r2, r2), t2.fillRect(i2, s2, r2, e2), t2.fillRect(i2 + n2 - r2, s2, r2, e2);
}
function L(t2, i2, s2, n2, e2, r2) {
  t2.save(), t2.globalCompositeOperation = "copy", t2.fillStyle = r2, t2.fillRect(i2, s2, n2, e2), t2.restore();
}
function O(t2, i2, s2, n2, e2, r2) {
  t2.beginPath(), t2.roundRect ? t2.roundRect(i2, s2, n2, e2, r2) : (t2.lineTo(i2 + n2 - r2[1], s2), 0 !== r2[1] && t2.arcTo(i2 + n2, s2, i2 + n2, s2 + r2[1], r2[1]), t2.lineTo(i2 + n2, s2 + e2 - r2[2]), 0 !== r2[2] && t2.arcTo(i2 + n2, s2 + e2, i2 + n2 - r2[2], s2 + e2, r2[2]), t2.lineTo(i2 + r2[3], s2 + e2), 0 !== r2[3] && t2.arcTo(i2, s2 + e2, i2, s2 + e2 - r2[3], r2[3]), t2.lineTo(i2, s2 + r2[0]), 0 !== r2[0] && t2.arcTo(i2, s2, i2 + r2[0], s2, r2[0]));
}
function N(t2, i2, s2, n2, e2, r2, h2 = 0, a2 = [0, 0, 0, 0], l2 = "") {
  if (t2.save(), !h2 || !l2 || l2 === r2) return O(t2, i2, s2, n2, e2, a2), t2.fillStyle = r2, t2.fill(), void t2.restore();
  const o2 = h2 / 2;
  var _2;
  O(t2, i2 + o2, s2 + o2, n2 - h2, e2 - h2, (_2 = -o2, a2.map((t3) => 0 === t3 ? t3 : t3 + _2))), "transparent" !== r2 && (t2.fillStyle = r2, t2.fill()), "transparent" !== l2 && (t2.lineWidth = h2, t2.strokeStyle = l2, t2.closePath(), t2.stroke()), t2.restore();
}
function F(t2, i2, s2, n2, e2, r2, h2) {
  t2.save(), t2.globalCompositeOperation = "copy";
  const a2 = t2.createLinearGradient(0, 0, 0, e2);
  a2.addColorStop(0, r2), a2.addColorStop(1, h2), t2.fillStyle = a2, t2.fillRect(i2, s2, n2, e2), t2.restore();
}
class W {
  constructor(t2, i2) {
    this.ut(t2, i2);
  }
  ut(t2, i2) {
    this.Gt = t2, this.li = i2;
  }
  Kt(t2, i2) {
    return this.Gt.At ? t2.P + t2.L + t2.B : 0;
  }
  lt(t2, i2, s2, n2) {
    if (!this.Gt.At || 0 === this.Gt.oi.length) return;
    const e2 = this.Gt.R, r2 = this.li.tt, h2 = this.Gt._i, a2 = t2.useBitmapCoordinateSpace((t3) => {
      const a3 = t3.context;
      a3.font = i2.k;
      const l2 = this.ui(t3, i2, s2, n2, h2), o2 = l2.ci;
      return l2.di ? N(a3, o2.fi, o2.pi, o2.mi, o2.wi, r2, o2.Mi, [o2.gt, 0, 0, o2.gt], h2 || r2) : N(a3, o2.gi, o2.pi, o2.mi, o2.wi, r2, o2.Mi, [0, o2.gt, o2.gt, 0], h2 || r2), this.Gt.bi && (a3.fillStyle = e2, a3.fillRect(o2.gi, o2.xi, o2.Si - o2.gi, o2.Ci)), this.Gt.Pi && (a3.fillStyle = i2.D, a3.fillStyle = i2.D, a3.fillRect(l2.di ? o2.ki - o2.Mi : 0, o2.pi, o2.Mi, o2.yi - o2.pi)), l2;
    });
    t2.useMediaCoordinateSpace(({ context: t3 }) => {
      const s3 = a2.Ti;
      t3.font = i2.k, t3.textAlign = a2.di ? "right" : "left", t3.textBaseline = "middle", t3.fillStyle = e2, t3.fillText(this.Gt.oi, s3.Ri, (s3.pi + s3.yi) / 2 + s3.Di);
    });
  }
  ui(t2, i2, s2, n2, e2) {
    const { context: r2, bitmapSize: h2, mediaSize: a2, horizontalPixelRatio: l2, verticalPixelRatio: o2 } = t2, _2 = this.Gt.bi || !this.Gt.Ii ? i2.C : 0, u2 = this.Gt.Bi || e2 ? i2.S : 0, c2 = i2.L + this.li.Vi, d3 = i2.B + this.li.Ei, f2 = i2.V, p2 = i2.A, v2 = this.Gt.oi, m2 = i2.P, w2 = s2.yMidCorrection(r2, v2), M2 = Math.ceil(s2.measureText(r2, v2)), g2 = m2 + c2 + d3, b2 = i2.S + f2 + p2 + M2 + _2, x2 = Math.max(1, Math.floor(o2));
    let S2 = Math.round(g2 * o2);
    S2 % 2 != x2 % 2 && (S2 += 1);
    const C2 = u2 > 0 ? Math.max(1, Math.floor(u2 * l2)) : 0, P2 = Math.round(b2 * l2), k2 = Math.round(_2 * l2), y2 = this.li.Ai ?? this.li.zi, T2 = Math.round(y2 * o2) - Math.floor(0.5 * o2), R2 = Math.floor(T2 + x2 / 2 - S2 / 2), D2 = R2 + S2, I2 = "right" === n2, B2 = I2 ? a2.width - u2 : u2, V2 = I2 ? h2.width - C2 : C2;
    let E2, A2, z2;
    return I2 ? (E2 = V2 - P2, A2 = V2 - k2, z2 = B2 - _2 - f2 - u2) : (E2 = V2 + P2, A2 = V2 + k2, z2 = B2 + _2 + f2), { di: I2, ci: { pi: R2, xi: T2, yi: D2, mi: P2, wi: S2, gt: 2 * l2, Mi: C2, fi: E2, gi: V2, Si: A2, Ci: x2, ki: h2.width }, Ti: { pi: R2 / o2, yi: D2 / o2, Ri: z2, Di: w2 } };
  }
}
class H {
  constructor(t2) {
    this.Li = { zi: 0, tt: "#000", Ei: 0, Vi: 0 }, this.Oi = { oi: "", At: false, bi: true, Ii: false, Yt: "", R: "#FFF", Pi: false, Bi: false }, this.Ni = { oi: "", At: false, bi: false, Ii: true, Yt: "", R: "#FFF", Pi: true, Bi: true }, this.yt = true, this.Fi = new (t2 || W)(this.Oi, this.Li), this.Wi = new (t2 || W)(this.Ni, this.Li);
  }
  oi() {
    return this.Hi(), this.Oi.oi;
  }
  zi() {
    return this.Hi(), this.Li.zi;
  }
  Dt() {
    this.yt = true;
  }
  Kt(t2, i2 = false) {
    return Math.max(this.Fi.Kt(t2, i2), this.Wi.Kt(t2, i2));
  }
  Ui() {
    return this.Li.Ai || 0;
  }
  $i(t2) {
    this.Li.Ai = t2;
  }
  qi() {
    return this.Hi(), this.Oi.At || this.Ni.At;
  }
  Yi() {
    return this.Hi(), this.Oi.At;
  }
  Bt(t2) {
    return this.Hi(), this.Oi.bi = this.Oi.bi && t2.F().ticksVisible, this.Ni.bi = this.Ni.bi && t2.F().ticksVisible, this.Fi.ut(this.Oi, this.Li), this.Wi.ut(this.Ni, this.Li), this.Fi;
  }
  ji() {
    return this.Hi(), this.Fi.ut(this.Oi, this.Li), this.Wi.ut(this.Ni, this.Li), this.Wi;
  }
  Hi() {
    this.yt && (this.Oi.bi = true, this.Ni.bi = false, this.Ki(this.Oi, this.Ni, this.Li));
  }
}
class U extends H {
  constructor(t2, i2, s2) {
    super(), this.si = t2, this.Xi = i2, this.Gi = s2;
  }
  Ki(t2, i2, s2) {
    if (t2.At = false, 2 === this.si.F().mode) return;
    const n2 = this.si.F().horzLine;
    if (!n2.labelVisible) return;
    const e2 = this.Xi.Ft();
    if (!this.si.At() || this.Xi.Zi() || null === e2) return;
    const r2 = this.Xi.Ji().J(n2.labelBackgroundColor);
    s2.tt = r2.tt, t2.R = r2.it;
    const h2 = 2 / 12 * this.Xi.P();
    s2.Vi = h2, s2.Ei = h2;
    const a2 = this.Gi(this.Xi);
    s2.zi = a2.zi, t2.oi = this.Xi.Qi(a2.St, e2), t2.At = true;
  }
}
const $ = /[1-9]/g;
class q {
  constructor() {
    this.Gt = null;
  }
  ut(t2) {
    this.Gt = t2;
  }
  lt(t2, i2) {
    if (null === this.Gt || false === this.Gt.At || 0 === this.Gt.oi.length) return;
    const s2 = t2.useMediaCoordinateSpace(({ context: t3 }) => (t3.font = i2.k, Math.round(i2.ts.measureText(t3, u(this.Gt).oi, $))));
    if (s2 <= 0) return;
    const n2 = i2.ss, e2 = s2 + 2 * n2, r2 = e2 / 2, h2 = this.Gt.ns;
    let a2 = this.Gt.zi, l2 = Math.floor(a2 - r2) + 0.5;
    l2 < 0 ? (a2 += Math.abs(0 - l2), l2 = Math.floor(a2 - r2) + 0.5) : l2 + e2 > h2 && (a2 -= Math.abs(h2 - (l2 + e2)), l2 = Math.floor(a2 - r2) + 0.5);
    const o2 = l2 + e2, _2 = Math.ceil(0 + i2.S + i2.C + i2.L + i2.P + i2.B);
    t2.useBitmapCoordinateSpace(({ context: t3, horizontalPixelRatio: s3, verticalPixelRatio: n3 }) => {
      const e3 = u(this.Gt);
      t3.fillStyle = e3.tt;
      const r3 = Math.round(l2 * s3), h3 = Math.round(0 * n3), a3 = Math.round(o2 * s3), c2 = Math.round(_2 * n3), d3 = Math.round(2 * s3);
      if (t3.beginPath(), t3.moveTo(r3, h3), t3.lineTo(r3, c2 - d3), t3.arcTo(r3, c2, r3 + d3, c2, d3), t3.lineTo(a3 - d3, c2), t3.arcTo(a3, c2, a3, c2 - d3, d3), t3.lineTo(a3, h3), t3.fill(), e3.bi) {
        const r4 = Math.round(e3.zi * s3), a4 = h3, l3 = Math.round((a4 + i2.C) * n3);
        t3.fillStyle = e3.R;
        const o3 = Math.max(1, Math.floor(s3)), _3 = Math.floor(0.5 * s3);
        t3.fillRect(r4 - _3, a4, o3, l3 - a4);
      }
    }), t2.useMediaCoordinateSpace(({ context: t3 }) => {
      const s3 = u(this.Gt), e3 = 0 + i2.S + i2.C + i2.L + i2.P / 2;
      t3.font = i2.k, t3.textAlign = "left", t3.textBaseline = "middle", t3.fillStyle = s3.R;
      const r3 = i2.ts.yMidCorrection(t3, "Apr0");
      t3.translate(l2 + n2, e3 + r3), t3.fillText(s3.oi, 0, 0);
    });
  }
}
class Y {
  constructor(t2, i2, s2) {
    this.yt = true, this.ii = new q(), this.ti = { At: false, tt: "#4c525e", R: "white", oi: "", ns: 0, zi: NaN, bi: true }, this.Tt = t2, this.es = i2, this.Gi = s2;
  }
  Dt() {
    this.yt = true;
  }
  Bt() {
    return this.yt && (this.Vt(), this.yt = false), this.ii.ut(this.ti), this.ii;
  }
  Vt() {
    const t2 = this.ti;
    if (t2.At = false, 2 === this.Tt.F().mode) return;
    const i2 = this.Tt.F().vertLine;
    if (!i2.labelVisible) return;
    const s2 = this.es.Ot();
    if (s2.Zi()) return;
    t2.ns = s2.ns();
    const n2 = this.Gi();
    if (null === n2) return;
    t2.zi = n2.zi;
    const e2 = s2.rs(this.Tt.Lt());
    t2.oi = s2.hs(u(e2)), t2.At = true;
    const r2 = this.es.Ji().J(i2.labelBackgroundColor);
    t2.tt = r2.tt, t2.R = r2.it, t2.bi = s2.F().ticksVisible;
  }
}
class j {
  constructor() {
    this.ls = null, this._s = 0;
  }
  us() {
    return this._s;
  }
  cs(t2) {
    this._s = t2;
  }
  $t() {
    return this.ls;
  }
  ds(t2) {
    this.ls = t2;
  }
  fs(t2) {
    return [];
  }
  ps() {
    return [];
  }
  At() {
    return true;
  }
}
var K;
!function(t2) {
  t2[t2.Normal = 0] = "Normal", t2[t2.Magnet = 1] = "Magnet", t2[t2.Hidden = 2] = "Hidden", t2[t2.MagnetOHLC = 3] = "MagnetOHLC", t2[t2.MagnetOHLCWeak = 4] = "MagnetOHLCWeak";
}(K || (K = {}));
class X extends j {
  constructor(t2, i2) {
    super(), this.Rt = null, this.vs = NaN, this.ws = 0, this.Ms = false, this.gs = /* @__PURE__ */ new Map(), this.bs = false, this.xs = /* @__PURE__ */ new WeakMap(), this.Ss = /* @__PURE__ */ new WeakMap(), this.Cs = NaN, this.Ps = NaN, this.ks = NaN, this.ys = NaN, this.es = t2, this.Ts = i2;
    this.Rs = /* @__PURE__ */ ((t3, i3) => (s3) => {
      const n2 = i3(), e2 = t3();
      if (s3 === u(this.Rt).Ds()) return { St: e2, zi: n2 };
      {
        const t4 = u(s3.Ft());
        return { St: s3.Is(n2, t4), zi: n2 };
      }
    })(() => this.vs, () => this.Ps);
    const s2 = /* @__PURE__ */ ((t3, i3) => () => {
      const s3 = this.es.Ot().Bs(t3()), n2 = i3();
      return s3 && Number.isFinite(n2) ? { xt: s3, zi: n2 } : null;
    })(() => this.ws, () => this.hi());
    this.Vs = new Y(this, t2, s2);
  }
  F() {
    return this.Ts;
  }
  Es(t2, i2) {
    this.ks = t2, this.ys = i2;
  }
  As() {
    this.ks = NaN, this.ys = NaN;
  }
  zs() {
    return this.ks;
  }
  Ls() {
    return this.ys;
  }
  Os(t2, i2, s2) {
    this.bs || (this.bs = true), this.Ms = true, this.Ns(t2, i2, s2);
  }
  Fs() {
    return { x: this.Cs, y: this.Ps };
  }
  Ws() {
    return this.Rt;
  }
  Lt() {
    return this.ws;
  }
  hi() {
    return this.Cs;
  }
  ai() {
    return this.Ps;
  }
  At() {
    return this.Ms;
  }
  Hs() {
    this.Ms = false, this.Us(), this.vs = NaN, this.Cs = NaN, this.Ps = NaN, this.Rt = null, this.As(), this.$s();
  }
  qs(t2) {
    let i2 = this.xs.get(t2);
    i2 || (i2 = new A(this, t2), this.xs.set(t2, i2));
    let s2 = this.Ss.get(t2);
    return s2 || (s2 = new V(this.es, this, t2), this.Ss.set(t2, s2)), [i2, s2];
  }
  ei(t2) {
    return t2 === this.Rt && this.Ts.horzLine.visible;
  }
  ri() {
    return this.Ts.vertLine.visible;
  }
  Ys(t2, i2) {
    this.Ms && this.Rt === t2 || this.gs.clear();
    const s2 = [];
    return this.Rt === t2 && s2.push(this.js(this.gs, i2, this.Rs)), s2;
  }
  ps() {
    return this.Ms ? [this.Vs] : [];
  }
  Ks() {
    return this.Rt;
  }
  $s() {
    this.es.Xs().forEach((t2) => {
      var _a3, _b3;
      (_a3 = this.xs.get(t2)) == null ? void 0 : _a3.Dt(), (_b3 = this.Ss.get(t2)) == null ? void 0 : _b3.Dt();
    }), this.gs.forEach((t2) => t2.Dt()), this.Vs.Dt();
  }
  Gs(t2) {
    return t2 && !t2.Ds().Zi() ? t2.Ds() : null;
  }
  Ns(t2, i2, s2) {
    this.Zs(t2, i2, s2) && this.$s();
  }
  Zs(t2, i2, s2) {
    const n2 = this.Cs, e2 = this.Ps, r2 = this.vs, h2 = this.ws, a2 = this.Rt, l2 = this.Gs(s2);
    this.ws = t2, this.Cs = isNaN(t2) ? NaN : this.es.Ot().Xt(t2), this.Rt = s2;
    const o2 = null !== l2 ? l2.Ft() : null;
    return null !== l2 && null !== o2 ? (this.vs = i2, this.Ps = l2.Ut(i2, o2)) : (this.vs = NaN, this.Ps = NaN), n2 !== this.Cs || e2 !== this.Ps || h2 !== this.ws || r2 !== this.vs || a2 !== this.Rt;
  }
  Us() {
    const t2 = this.es.Js().map((t3) => t3.Qs().lastIndex()).filter(g), i2 = 0 === t2.length ? null : Math.max(...t2);
    this.ws = null !== i2 ? i2 : NaN;
  }
  js(t2, i2, s2) {
    let n2 = t2.get(i2);
    return void 0 === n2 && (n2 = new U(this, i2, s2), t2.set(i2, n2)), n2;
  }
}
function G(t2) {
  return "left" === t2 || "right" === t2;
}
class Z {
  constructor(t2) {
    this.tn = /* @__PURE__ */ new Map(), this.sn = [], this.nn = t2;
  }
  en(t2, i2) {
    const s2 = function(t3, i3) {
      return void 0 === t3 ? i3 : { rn: Math.max(t3.rn, i3.rn), hn: t3.hn || i3.hn };
    }(this.tn.get(t2), i2);
    this.tn.set(t2, s2);
  }
  an() {
    return this.nn;
  }
  ln(t2) {
    const i2 = this.tn.get(t2);
    return void 0 === i2 ? { rn: this.nn } : { rn: Math.max(this.nn, i2.rn), hn: i2.hn };
  }
  _n() {
    this.un(), this.sn = [{ cn: 0 }];
  }
  dn(t2) {
    this.un(), this.sn = [{ cn: 1, qt: t2 }];
  }
  fn(t2) {
    this.pn(), this.sn.push({ cn: 5, qt: t2 });
  }
  un() {
    this.pn(), this.sn.push({ cn: 6 });
  }
  vn() {
    this.un(), this.sn = [{ cn: 4 }];
  }
  mn(t2) {
    this.un(), this.sn.push({ cn: 2, qt: t2 });
  }
  wn(t2) {
    this.un(), this.sn.push({ cn: 3, qt: t2 });
  }
  Mn() {
    return this.sn;
  }
  gn(t2) {
    for (const i2 of t2.sn) this.bn(i2);
    this.nn = Math.max(this.nn, t2.nn), t2.tn.forEach((t3, i2) => {
      this.en(i2, t3);
    });
  }
  static xn() {
    return new Z(2);
  }
  static Sn() {
    return new Z(3);
  }
  bn(t2) {
    switch (t2.cn) {
      case 0:
        this._n();
        break;
      case 1:
        this.dn(t2.qt);
        break;
      case 2:
        this.mn(t2.qt);
        break;
      case 3:
        this.wn(t2.qt);
        break;
      case 4:
        this.vn();
        break;
      case 5:
        this.fn(t2.qt);
        break;
      case 6:
        this.pn();
    }
  }
  pn() {
    const t2 = this.sn.findIndex((t3) => 5 === t3.cn);
    -1 !== t2 && this.sn.splice(t2, 1);
  }
}
class J {
  formatTickmarks(t2) {
    return t2.map((t3) => this.format(t3));
  }
}
const Q = ".";
function tt(t2, i2) {
  if (!p(t2)) return "n/a";
  if (!v(i2)) throw new TypeError("invalid length");
  if (i2 < 0 || i2 > 16) throw new TypeError("invalid length");
  if (0 === i2) return t2.toString();
  return ("0000000000000000" + t2.toString()).slice(-i2);
}
class it extends J {
  constructor(t2, i2) {
    if (super(), i2 || (i2 = 1), p(t2) && v(t2) || (t2 = 100), t2 < 0) throw new TypeError("invalid base");
    this.Xi = t2, this.Cn = i2, this.Pn();
  }
  format(t2) {
    const i2 = t2 < 0 ? "−" : "";
    return t2 = Math.abs(t2), i2 + this.kn(t2);
  }
  Pn() {
    if (this._fractionalLength = 0, this.Xi > 0 && this.Cn > 0) {
      let t2 = this.Xi;
      for (; t2 > 1; ) t2 /= 10, this._fractionalLength++;
    }
  }
  kn(t2) {
    const i2 = this.Xi / this.Cn;
    let s2 = Math.floor(t2), n2 = "";
    const e2 = void 0 !== this._fractionalLength ? this._fractionalLength : NaN;
    if (i2 > 1) {
      let r2 = +(Math.round(t2 * i2) - s2 * i2).toFixed(this._fractionalLength);
      r2 >= i2 && (r2 -= i2, s2 += 1), n2 = Q + tt(+r2.toFixed(this._fractionalLength) * this.Cn, e2);
    } else s2 = Math.round(s2 * i2) / i2, e2 > 0 && (n2 = Q + tt(0, e2));
    return s2.toFixed(0) + n2;
  }
}
class st extends it {
  constructor(t2 = 100) {
    super(t2);
  }
  format(t2) {
    return `${super.format(t2)}%`;
  }
}
class nt extends J {
  constructor(t2) {
    super(), this.yn = t2;
  }
  format(t2) {
    let i2 = "";
    return t2 < 0 && (i2 = "-", t2 = -t2), t2 < 995 ? i2 + this.Tn(t2) : t2 < 999995 ? i2 + this.Tn(t2 / 1e3) + "K" : t2 < 999999995 ? (t2 = 1e3 * Math.round(t2 / 1e3), i2 + this.Tn(t2 / 1e6) + "M") : (t2 = 1e6 * Math.round(t2 / 1e6), i2 + this.Tn(t2 / 1e9) + "B");
  }
  Tn(t2) {
    let i2;
    const s2 = Math.pow(10, this.yn);
    return i2 = (t2 = Math.round(t2 * s2) / s2) >= 1e-15 && t2 < 1 ? t2.toFixed(this.yn).replace(/\.?0+$/, "") : String(t2), i2.replace(/(\.[1-9]*)0+$/, (t3, i3) => i3);
  }
}
const et = /[2-9]/g;
class rt {
  constructor(t2 = 50) {
    this.Rn = 0, this.Dn = 1, this.In = 1, this.Bn = {}, this.Vn = /* @__PURE__ */ new Map(), this.En = t2;
  }
  reset() {
    this.Rn = 0, this.Vn.clear(), this.Dn = 1, this.In = 1, this.Bn = {};
  }
  measureText(t2, i2, s2) {
    return this.getMetrics(t2, i2, s2).width;
  }
  yMidCorrection(t2, i2, s2) {
    const n2 = this.getMetrics(t2, i2, s2);
    return ((n2.actualBoundingBoxAscent || 0) - (n2.actualBoundingBoxDescent || 0)) / 2;
  }
  getMetrics(t2, i2, s2) {
    const n2 = s2 || et, e2 = String(i2).replace(n2, "0");
    if (this.Vn.has(e2)) return _(this.Vn.get(e2)).An;
    if (this.Rn === this.En) {
      const t3 = this.Bn[this.In];
      delete this.Bn[this.In], this.Vn.delete(t3), this.In++, this.Rn--;
    }
    t2.save(), t2.textBaseline = "middle";
    const r2 = t2.measureText(e2);
    return t2.restore(), 0 === r2.width && i2.length || (this.Vn.set(e2, { An: r2, zn: this.Dn }), this.Bn[this.Dn] = e2, this.Rn++, this.Dn++), r2;
  }
}
class ht {
  constructor(t2) {
    this.Ln = null, this.M = null, this.On = "right", this.Nn = t2;
  }
  Fn(t2, i2, s2) {
    this.Ln = t2, this.M = i2, this.On = s2;
  }
  lt(t2) {
    null !== this.M && null !== this.Ln && this.Ln.lt(t2, this.M, this.Nn, this.On);
  }
}
class at {
  constructor(t2, i2, s2) {
    this.Wn = t2, this.Nn = new rt(50), this.Hn = i2, this.N = s2, this.W = -1, this.ii = new ht(this.Nn);
  }
  Bt() {
    const t2 = this.N.Un(this.Hn);
    if (null === t2) return null;
    const i2 = t2.$n(this.Hn) ? t2.qn() : this.Hn.$t();
    if (null === i2) return null;
    const s2 = t2.Yn(i2);
    if ("overlay" === s2) return null;
    const n2 = this.N.jn();
    return n2.P !== this.W && (this.W = n2.P, this.Nn.reset()), this.ii.Fn(this.Wn.ji(), n2, s2), this.ii;
  }
}
class lt extends R {
  constructor() {
    super(...arguments), this.Gt = null;
  }
  ut(t2) {
    this.Gt = t2;
  }
  ht(t2, i2) {
    var _a3;
    if (!((_a3 = this.Gt) == null ? void 0 : _a3.At)) return null;
    const { vt: s2, wt: n2, Kn: e2 } = this.Gt;
    return i2 >= s2 - n2 - 7 && i2 <= s2 + n2 + 7 ? { hitTestData: this.Gt, externalId: e2 } : null;
  }
  ot({ context: t2, bitmapSize: i2, horizontalPixelRatio: s2, verticalPixelRatio: n2 }) {
    if (null === this.Gt) return;
    if (false === this.Gt.At) return;
    const e2 = Math.round(this.Gt.vt * n2);
    e2 < 0 || e2 > i2.height || (t2.lineCap = "butt", t2.strokeStyle = this.Gt.R, t2.lineWidth = Math.floor(this.Gt.wt * s2), a$1(t2, this.Gt.Qt), l$1(t2, e2, 0, i2.width));
  }
}
class ot {
  constructor(t2) {
    this.Xn = { vt: 0, R: "rgba(0, 0, 0, 0)", wt: 1, Qt: 0, At: false }, this.Gn = new lt(), this.yt = true, this.Zn = t2, this.Jn = t2.ni(), this.Gn.ut(this.Xn);
  }
  Dt() {
    this.yt = true;
  }
  Bt() {
    return this.Zn.At() ? (this.yt && (this.Qn(), this.yt = false), this.Gn) : null;
  }
}
class _t extends ot {
  constructor(t2) {
    super(t2);
  }
  Qn() {
    this.Xn.At = false;
    const t2 = this.Zn.$t(), i2 = t2.te().te;
    if (2 !== i2 && 3 !== i2) return;
    const s2 = this.Zn.F();
    if (!s2.baseLineVisible || !this.Zn.At()) return;
    const n2 = this.Zn.Ft();
    null !== n2 && (this.Xn.At = true, this.Xn.vt = t2.Ut(n2.qt, n2.qt), this.Xn.R = s2.baseLineColor, this.Xn.wt = s2.baseLineWidth, this.Xn.Qt = s2.baseLineStyle);
  }
}
class ut extends R {
  constructor() {
    super(...arguments), this.Gt = null;
  }
  ut(t2) {
    this.Gt = t2;
  }
  ie() {
    return this.Gt;
  }
  ot({ context: t2, horizontalPixelRatio: i2, verticalPixelRatio: s2 }) {
    const n2 = this.Gt;
    if (null === n2) return;
    const e2 = Math.max(1, Math.floor(i2)), r2 = e2 % 2 / 2, h2 = Math.round(n2.se.x * i2) + r2, a2 = n2.se.y * s2;
    t2.fillStyle = n2.ne, t2.beginPath();
    const l2 = Math.max(2, 1.5 * n2.ee) * i2;
    t2.arc(h2, a2, l2, 0, 2 * Math.PI, false), t2.fill(), t2.fillStyle = n2.re, t2.beginPath(), t2.arc(h2, a2, n2.gt * i2, 0, 2 * Math.PI, false), t2.fill(), t2.lineWidth = e2, t2.strokeStyle = n2.he, t2.beginPath(), t2.arc(h2, a2, n2.gt * i2 + e2 / 2, 0, 2 * Math.PI, false), t2.stroke();
  }
}
const ct = [{ ae: 0, le: 0.25, oe: 4, _e: 10, ue: 0.25, ce: 0, de: 0.4, fe: 0.8 }, { ae: 0.25, le: 0.525, oe: 10, _e: 14, ue: 0, ce: 0, de: 0.8, fe: 0 }, { ae: 0.525, le: 1, oe: 14, _e: 14, ue: 0, ce: 0, de: 0, fe: 0 }];
class dt {
  constructor(t2) {
    this.ii = new ut(), this.yt = true, this.pe = true, this.ve = performance.now(), this.me = this.ve - 1, this.we = t2;
  }
  Me() {
    this.me = this.ve - 1, this.Dt();
  }
  ge() {
    if (this.Dt(), 2 === this.we.F().lastPriceAnimation) {
      const t2 = performance.now(), i2 = this.me - t2;
      if (i2 > 0) return void (i2 < 650 && (this.me += 2600));
      this.ve = t2, this.me = t2 + 2600;
    }
  }
  Dt() {
    this.yt = true;
  }
  be() {
    this.pe = true;
  }
  At() {
    return 0 !== this.we.F().lastPriceAnimation;
  }
  xe() {
    switch (this.we.F().lastPriceAnimation) {
      case 0:
        return false;
      case 1:
        return true;
      case 2:
        return performance.now() <= this.me;
    }
  }
  Bt() {
    return this.yt ? (this.Vt(), this.yt = false, this.pe = false) : this.pe && (this.Se(), this.pe = false), this.ii;
  }
  Vt() {
    this.ii.ut(null);
    const t2 = this.we.ni().Ot(), i2 = t2.Ce(), s2 = this.we.Ft();
    if (null === i2 || null === s2) return;
    const n2 = this.we.Pe(true);
    if (n2.ke || !i2.ye(n2.Te)) return;
    const e2 = { x: t2.Xt(n2.Te), y: this.we.$t().Ut(n2.St, s2.qt) }, r2 = n2.R, h2 = this.we.F().lineWidth, a2 = this.Re(this.De(), r2);
    this.ii.ut({ ne: r2, ee: h2, re: a2.re, he: a2.he, gt: a2.gt, se: e2 });
  }
  Se() {
    const t2 = this.ii.ie();
    if (null !== t2) {
      const i2 = this.Re(this.De(), t2.ne);
      t2.re = i2.re, t2.he = i2.he, t2.gt = i2.gt;
    }
  }
  De() {
    return this.xe() ? performance.now() - this.ve : 2599;
  }
  Ie(t2, i2, s2, n2) {
    const e2 = s2 + (n2 - s2) * i2;
    return this.we.ni().Ji().G(t2, e2);
  }
  Re(t2, i2) {
    const s2 = t2 % 2600 / 2600;
    let n2;
    for (const t3 of ct) if (s2 >= t3.ae && s2 <= t3.le) {
      n2 = t3;
      break;
    }
    o$1(void 0 !== n2, "Last price animation internal logic error");
    const e2 = (s2 - n2.ae) / (n2.le - n2.ae);
    return { re: this.Ie(i2, e2, n2.ue, n2.ce), he: this.Ie(i2, e2, n2.de, n2.fe), gt: (r2 = e2, h2 = n2.oe, a2 = n2._e, h2 + (a2 - h2) * r2) };
    var r2, h2, a2;
  }
}
class ft extends ot {
  constructor(t2) {
    super(t2);
  }
  Qn() {
    const t2 = this.Xn;
    t2.At = false;
    const i2 = this.Zn.F();
    if (!i2.priceLineVisible || !this.Zn.At()) return;
    const s2 = this.Zn.Pe(0 === i2.priceLineSource);
    s2.ke || (t2.At = true, t2.vt = s2.zi, t2.R = this.Zn.Be(s2.R), t2.wt = i2.priceLineWidth, t2.Qt = i2.priceLineStyle);
  }
}
class pt extends H {
  constructor(t2) {
    super(), this.si = t2;
  }
  Ki(t2, i2, s2) {
    t2.At = false, i2.At = false;
    const n2 = this.si;
    if (!n2.At()) return;
    const e2 = n2.F(), r2 = e2.lastValueVisible, h2 = "" !== n2.Ve(), a2 = 0 === e2.seriesLastValueMode, l2 = n2.Pe(false);
    if (l2.ke) return;
    r2 && (t2.oi = this.Ee(l2, r2, a2), t2.At = 0 !== t2.oi.length), (h2 || a2) && (i2.oi = this.Ae(l2, r2, h2, a2), i2.At = i2.oi.length > 0);
    const o2 = n2.Be(l2.R), _2 = this.si.ni().Ji().J(o2);
    s2.tt = _2.tt, s2.zi = l2.zi, i2.Yt = n2.ni().jt(l2.zi / n2.$t().Kt()), t2.Yt = o2, t2.R = _2.it, i2.R = _2.it;
  }
  Ae(t2, i2, s2, n2) {
    let e2 = "";
    const r2 = this.si.Ve();
    return s2 && 0 !== r2.length && (e2 += `${r2} `), i2 && n2 && (e2 += this.si.$t().ze() ? t2.Le : t2.Oe), e2.trim();
  }
  Ee(t2, i2, s2) {
    return i2 ? s2 ? this.si.$t().ze() ? t2.Oe : t2.Le : t2.oi : "";
  }
}
function vt(t2, i2, s2, n2) {
  const e2 = Number.isFinite(i2), r2 = Number.isFinite(s2);
  return e2 && r2 ? t2(i2, s2) : e2 || r2 ? e2 ? i2 : s2 : n2;
}
class mt {
  constructor(t2, i2) {
    this.Ne = t2, this.Fe = i2;
  }
  We(t2) {
    return null !== t2 && (this.Ne === t2.Ne && this.Fe === t2.Fe);
  }
  He() {
    return new mt(this.Ne, this.Fe);
  }
  Ue() {
    return this.Ne;
  }
  $e() {
    return this.Fe;
  }
  qe() {
    return this.Fe - this.Ne;
  }
  Zi() {
    return this.Fe === this.Ne || Number.isNaN(this.Fe) || Number.isNaN(this.Ne);
  }
  gn(t2) {
    return null === t2 ? this : new mt(vt(Math.min, this.Ue(), t2.Ue(), -1 / 0), vt(Math.max, this.$e(), t2.$e(), 1 / 0));
  }
  Ye(t2) {
    if (!p(t2)) return;
    if (0 === this.Fe - this.Ne) return;
    const i2 = 0.5 * (this.Fe + this.Ne);
    let s2 = this.Fe - i2, n2 = this.Ne - i2;
    s2 *= t2, n2 *= t2, this.Fe = i2 + s2, this.Ne = i2 + n2;
  }
  je(t2) {
    p(t2) && (this.Fe += t2, this.Ne += t2);
  }
  Ke() {
    return { minValue: this.Ne, maxValue: this.Fe };
  }
  static Xe(t2) {
    return null === t2 ? null : new mt(t2.minValue, t2.maxValue);
  }
}
class wt {
  constructor(t2, i2) {
    this.Ge = t2, this.Ze = i2 || null;
  }
  Je() {
    return this.Ge;
  }
  Qe() {
    return this.Ze;
  }
  Ke() {
    return { priceRange: null === this.Ge ? null : this.Ge.Ke(), margins: this.Ze || void 0 };
  }
  static Xe(t2) {
    return null === t2 ? null : new wt(mt.Xe(t2.priceRange), t2.margins);
  }
}
class Mt extends ot {
  constructor(t2, i2) {
    super(t2), this.tr = i2;
  }
  Qn() {
    const t2 = this.Xn;
    t2.At = false;
    const i2 = this.tr.F();
    if (!this.Zn.At() || !i2.lineVisible) return;
    const s2 = this.tr.ir();
    null !== s2 && (t2.At = true, t2.vt = s2, t2.R = i2.color, t2.wt = i2.lineWidth, t2.Qt = i2.lineStyle, t2.Kn = this.tr.F().id);
  }
}
class gt extends H {
  constructor(t2, i2) {
    super(), this.we = t2, this.tr = i2;
  }
  Ki(t2, i2, s2) {
    t2.At = false, i2.At = false;
    const n2 = this.tr.F(), e2 = n2.axisLabelVisible, r2 = "" !== n2.title, h2 = this.we;
    if (!e2 || !h2.At()) return;
    const a2 = this.tr.ir();
    if (null === a2) return;
    r2 && (i2.oi = n2.title, i2.At = true), i2.Yt = h2.ni().jt(a2 / h2.$t().Kt()), t2.oi = this.sr(n2.price), t2.At = true;
    const l2 = this.we.ni().Ji().J(n2.axisLabelColor || n2.color);
    s2.tt = l2.tt;
    const o2 = n2.axisLabelTextColor || l2.it;
    t2.R = o2, i2.R = o2, t2._i = n2.axisLabelBorderColor, s2.zi = a2;
  }
  sr(t2) {
    return this.we.nr().format(t2);
  }
}
class bt {
  constructor(t2, i2) {
    this.we = t2, this.Ts = i2, this.er = new Mt(t2, this), this.Wn = new gt(t2, this), this.rr = new at(this.Wn, t2, t2.ni());
  }
  hr(t2) {
    f(this.Ts, t2), this.Dt(), this.we.ni().ar();
  }
  F() {
    return this.Ts;
  }
  lr() {
    return this.er;
  }
  _r() {
    return this.rr;
  }
  ur() {
    return this.Wn;
  }
  Dt() {
    this.er.Dt(), this.Wn.Dt();
  }
  ir() {
    const t2 = this.we, i2 = t2.$t();
    if (t2.ni().Ot().Zi() || i2.Zi()) return null;
    const s2 = t2.Ft();
    return null === s2 ? null : i2.Ut(this.Ts.price, s2.qt);
  }
}
class xt extends j {
  constructor(t2) {
    super(), this.es = t2;
  }
  ni() {
    return this.es;
  }
}
const St = { Bar: (t2, i2, s2, n2) => {
  const e2 = i2.upColor, r2 = i2.downColor, h2 = u(t2(s2, n2)), a2 = c(h2.value[0]) <= c(h2.value[3]);
  return { cr: h2.R ?? (a2 ? e2 : r2) };
}, Candlestick: (t2, i2, s2, n2) => {
  const e2 = i2.upColor, r2 = i2.downColor, h2 = i2.borderUpColor, a2 = i2.borderDownColor, l2 = i2.wickUpColor, o2 = i2.wickDownColor, _2 = u(t2(s2, n2)), d3 = c(_2.value[0]) <= c(_2.value[3]);
  return { cr: _2.R ?? (d3 ? e2 : r2), dr: _2.Yt ?? (d3 ? h2 : a2), pr: _2.vr ?? (d3 ? l2 : o2) };
}, HollowCandlestick: (t2, i2, s2, n2) => {
  const e2 = i2.upColor, r2 = i2.downColor, h2 = i2.borderUpColor, a2 = i2.borderDownColor, l2 = i2.wickUpColor, o2 = i2.wickDownColor, _2 = u(t2(s2, n2)), d3 = t2(s2 - 1), f2 = c(_2.value[0]), p2 = d3 ? c(d3.value[3]) : f2, v2 = c(_2.value[3]), m2 = p2 <= v2, w2 = v2 < f2;
  return { cr: _2.R ?? (m2 ? e2 : r2), dr: _2.Yt ?? (m2 ? h2 : a2), pr: _2.vr ?? (m2 ? l2 : o2), mr: w2 };
}, Custom: (t2, i2, s2, n2) => ({ cr: u(t2(s2, n2)).R ?? i2.color }), Area: (t2, i2, s2, n2) => {
  const e2 = u(t2(s2, n2));
  return { cr: e2.bt ?? i2.lineColor, bt: e2.bt ?? i2.lineColor, wr: e2.wr ?? i2.topColor, Mr: e2.Mr ?? i2.bottomColor };
}, Baseline: (t2, i2, s2, n2) => {
  const e2 = u(t2(s2, n2));
  return { cr: e2.value[3] >= i2.baseValue.price ? i2.topLineColor : i2.bottomLineColor, gr: e2.gr ?? i2.topLineColor, br: e2.br ?? i2.bottomLineColor, Sr: e2.Sr ?? i2.topFillColor1, Cr: e2.Cr ?? i2.topFillColor2, Pr: e2.Pr ?? i2.bottomFillColor1, kr: e2.kr ?? i2.bottomFillColor2 };
}, Line: (t2, i2, s2, n2) => {
  const e2 = u(t2(s2, n2));
  return { cr: e2.R ?? i2.color, bt: e2.R ?? i2.color };
}, Histogram: (t2, i2, s2, n2) => ({ cr: u(t2(s2, n2)).R ?? i2.color }) };
class Ct {
  constructor(t2) {
    this.yr = (t3, i2) => void 0 !== i2 ? i2.qt : this.we.Qs().Tr(t3), this.we = t2, this.Rr = St[t2.Dr()];
  }
  Ir(t2, i2) {
    return this.Rr(this.yr, this.we.F(), t2, i2);
  }
}
function Pt(t2, i2, s2, n2, e2 = 0, r2 = i2.length) {
  let h2 = r2 - e2;
  for (; 0 < h2; ) {
    const r3 = h2 >> 1, a2 = e2 + r3;
    n2(i2[a2], s2) === t2 ? (e2 = a2 + 1, h2 -= r3 + 1) : h2 = r3;
  }
  return e2;
}
const kt = Pt.bind(null, true), yt = Pt.bind(null, false);
var Tt;
!function(t2) {
  t2[t2.NearestLeft = -1] = "NearestLeft", t2[t2.None = 0] = "None", t2[t2.NearestRight = 1] = "NearestRight";
}(Tt || (Tt = {}));
const Rt = 30;
class Dt {
  constructor() {
    this.Br = [], this.Vr = /* @__PURE__ */ new Map(), this.Er = /* @__PURE__ */ new Map(), this.Ar = [];
  }
  zr() {
    return this.size() > 0 ? this.Br[this.Br.length - 1] : null;
  }
  firstIndex() {
    return this.size() > 0 ? this.Lr(0) : null;
  }
  lastIndex() {
    return this.size() > 0 ? this.Lr(this.Br.length - 1) : null;
  }
  size() {
    return this.Br.length;
  }
  Zi() {
    return 0 === this.size();
  }
  ye(t2) {
    return null !== this.Or(t2, 0);
  }
  Tr(t2) {
    return this.Nr(t2);
  }
  Nr(t2, i2 = 0) {
    const s2 = this.Or(t2, i2);
    return null === s2 ? null : { ...this.Fr(s2), index: this.Lr(s2) };
  }
  Wr() {
    return this.Br;
  }
  Hr(t2, i2, s2) {
    if (this.Zi()) return null;
    let n2 = null;
    for (const e2 of s2) {
      n2 = It(n2, this.Ur(t2, i2, e2));
    }
    return n2;
  }
  ut(t2) {
    this.Er.clear(), this.Vr.clear(), this.Br = t2, this.Ar = t2.map((t3) => t3.index);
  }
  $r() {
    return this.Ar;
  }
  fullRangeIterator() {
    return this.qr(0, this.size());
  }
  rangeIterator(t2, i2) {
    const s2 = this.Yr(t2), n2 = this.jr(i2);
    return this.qr(s2, n2);
  }
  Lr(t2) {
    return this.Br[t2].index;
  }
  Fr(t2) {
    return this.Br[t2];
  }
  Or(t2, i2) {
    const s2 = this.Kr(t2);
    if (null === s2 && 0 !== i2) switch (i2) {
      case -1:
        return this.Xr(t2);
      case 1:
        return this.Gr(t2);
      default:
        throw new TypeError("Unknown search mode");
    }
    return s2;
  }
  Xr(t2) {
    let i2 = this.Yr(t2);
    return i2 > 0 && (i2 -= 1), i2 !== this.Br.length && this.Lr(i2) < t2 ? i2 : null;
  }
  Gr(t2) {
    const i2 = this.jr(t2);
    return i2 !== this.Br.length && t2 < this.Lr(i2) ? i2 : null;
  }
  Kr(t2) {
    const i2 = this.Yr(t2);
    return i2 === this.Br.length || t2 < this.Br[i2].index ? null : i2;
  }
  Yr(t2) {
    return kt(this.Br, t2, (t3, i2) => t3.index < i2);
  }
  jr(t2) {
    return yt(this.Br, t2, (t3, i2) => t3.index > i2);
  }
  Zr(t2, i2, s2) {
    let n2 = null;
    for (let e2 = t2; e2 < i2; e2++) {
      const t3 = this.Br[e2].value[s2];
      Number.isNaN(t3) || (null === n2 ? n2 = { Jr: t3, Qr: t3 } : (t3 < n2.Jr && (n2.Jr = t3), t3 > n2.Qr && (n2.Qr = t3)));
    }
    return n2;
  }
  Ur(t2, i2, s2) {
    if (this.Zi()) return null;
    let n2 = null;
    const e2 = u(this.firstIndex()), r2 = u(this.lastIndex()), h2 = Math.max(t2, e2), a2 = Math.min(i2, r2), l2 = Math.ceil(h2 / Rt) * Rt, o2 = Math.max(l2, Math.floor(a2 / Rt) * Rt);
    {
      const t3 = this.Yr(h2), e3 = this.jr(Math.min(a2, l2, i2));
      n2 = It(n2, this.Zr(t3, e3, s2));
    }
    let _2 = this.Vr.get(s2);
    void 0 === _2 && (_2 = /* @__PURE__ */ new Map(), this.Vr.set(s2, _2));
    for (let t3 = Math.max(l2 + 1, h2); t3 < o2; t3 += Rt) {
      const i3 = Math.floor(t3 / Rt);
      let e3 = _2.get(i3);
      if (void 0 === e3) {
        const t4 = this.Yr(i3 * Rt), n3 = this.jr((i3 + 1) * Rt - 1);
        e3 = this.Zr(t4, n3, s2), _2.set(i3, e3);
      }
      n2 = It(n2, e3);
    }
    {
      const t3 = this.Yr(o2), i3 = this.jr(a2);
      n2 = It(n2, this.Zr(t3, i3, s2));
    }
    return n2;
  }
  qr(t2, i2) {
    let s2 = t2 - 1;
    return { [Symbol.iterator]() {
      return this;
    }, next: () => (s2 += 1, s2 >= i2 ? { done: true, value: void 0 } : { done: false, value: this.Br[s2] }) };
  }
}
function It(t2, i2) {
  if (null === t2) return i2;
  if (null === i2) return t2;
  return { Jr: Math.min(t2.Jr, i2.Jr), Qr: Math.max(t2.Qr, i2.Qr) };
}
class Bt {
  constructor(t2) {
    this.th = t2;
  }
  lt(t2, i2, s2) {
    this.th.draw(t2);
  }
  ih(t2, i2, s2) {
    var _a3, _b3;
    (_b3 = (_a3 = this.th).drawBackground) == null ? void 0 : _b3.call(_a3, t2);
  }
}
class Vt {
  constructor(t2) {
    this.Vn = null, this.sh = t2;
  }
  Bt() {
    var _a3;
    const t2 = this.sh.renderer();
    if (null === t2) return null;
    if (((_a3 = this.Vn) == null ? void 0 : _a3.nh) === t2) return this.Vn.eh;
    const i2 = new Bt(t2);
    return this.Vn = { nh: t2, eh: i2 }, i2;
  }
  rh() {
    var _a3, _b3;
    return ((_b3 = (_a3 = this.sh).zOrder) == null ? void 0 : _b3.call(_a3)) ?? "normal";
  }
}
class Et {
  constructor(t2) {
    this.hh = null, this.ah = t2;
  }
  oh() {
    return this.ah;
  }
  $s() {
    var _a3, _b3;
    (_b3 = (_a3 = this.ah).updateAllViews) == null ? void 0 : _b3.call(_a3);
  }
  qs() {
    var _a3, _b3, _c2;
    const t2 = ((_b3 = (_a3 = this.ah).paneViews) == null ? void 0 : _b3.call(_a3)) ?? [];
    if (((_c2 = this.hh) == null ? void 0 : _c2.nh) === t2) return this.hh.eh;
    const i2 = t2.map((t3) => new Vt(t3));
    return this.hh = { nh: t2, eh: i2 }, i2;
  }
  ht(t2, i2) {
    var _a3, _b3;
    return ((_b3 = (_a3 = this.ah).hitTest) == null ? void 0 : _b3.call(_a3, t2, i2)) ?? null;
  }
}
let At = class extends Et {
  fs() {
    return [];
  }
};
class zt {
  constructor(t2) {
    this.th = t2;
  }
  lt(t2, i2, s2) {
    this.th.draw(t2);
  }
  ih(t2, i2, s2) {
    var _a3, _b3;
    (_b3 = (_a3 = this.th).drawBackground) == null ? void 0 : _b3.call(_a3, t2);
  }
}
class Lt {
  constructor(t2) {
    this.Vn = null, this.sh = t2;
  }
  Bt() {
    var _a3;
    const t2 = this.sh.renderer();
    if (null === t2) return null;
    if (((_a3 = this.Vn) == null ? void 0 : _a3.nh) === t2) return this.Vn.eh;
    const i2 = new zt(t2);
    return this.Vn = { nh: t2, eh: i2 }, i2;
  }
  rh() {
    var _a3, _b3;
    return ((_b3 = (_a3 = this.sh).zOrder) == null ? void 0 : _b3.call(_a3)) ?? "normal";
  }
}
function Ot(t2) {
  var _a3, _b3, _c2, _d2;
  return { oi: t2.text(), zi: t2.coordinate(), Ai: (_a3 = t2.fixedCoordinate) == null ? void 0 : _a3.call(t2), R: t2.textColor(), tt: t2.backColor(), _h: (_b3 = t2.borderColor) == null ? void 0 : _b3.call(t2), At: ((_c2 = t2.visible) == null ? void 0 : _c2.call(t2)) ?? true, bi: ((_d2 = t2.tickVisible) == null ? void 0 : _d2.call(t2)) ?? true };
}
class Nt {
  constructor(t2, i2) {
    this.ii = new q(), this.uh = t2, this.dh = i2;
  }
  Bt() {
    return this.ii.ut({ ns: this.dh.ns(), ...Ot(this.uh) }), this.ii;
  }
}
class Ft extends H {
  constructor(t2, i2) {
    super(), this.uh = t2, this.Xi = i2;
  }
  Ki(t2, i2, s2) {
    const n2 = Ot(this.uh);
    s2.tt = n2.tt, t2.R = n2.R, t2._i = n2._h;
    const e2 = 2 / 12 * this.Xi.P();
    s2.Vi = e2, s2.Ei = e2, s2.zi = n2.zi, s2.Ai = n2.Ai, t2.oi = n2.oi, t2.At = n2.At, t2.bi = n2.bi;
  }
}
class Wt extends Et {
  constructor(t2, i2) {
    super(t2), this.fh = null, this.ph = null, this.mh = null, this.wh = null, this.we = i2;
  }
  ps() {
    var _a3, _b3, _c2;
    const t2 = ((_b3 = (_a3 = this.ah).timeAxisViews) == null ? void 0 : _b3.call(_a3)) ?? [];
    if (((_c2 = this.fh) == null ? void 0 : _c2.nh) === t2) return this.fh.eh;
    const i2 = this.we.ni().Ot(), s2 = t2.map((t3) => new Nt(t3, i2));
    return this.fh = { nh: t2, eh: s2 }, s2;
  }
  Ys() {
    var _a3, _b3, _c2;
    const t2 = ((_b3 = (_a3 = this.ah).priceAxisViews) == null ? void 0 : _b3.call(_a3)) ?? [];
    if (((_c2 = this.ph) == null ? void 0 : _c2.nh) === t2) return this.ph.eh;
    const i2 = this.we.$t(), s2 = t2.map((t3) => new Ft(t3, i2));
    return this.ph = { nh: t2, eh: s2 }, s2;
  }
  Mh() {
    var _a3, _b3, _c2;
    const t2 = ((_b3 = (_a3 = this.ah).priceAxisPaneViews) == null ? void 0 : _b3.call(_a3)) ?? [];
    if (((_c2 = this.mh) == null ? void 0 : _c2.nh) === t2) return this.mh.eh;
    const i2 = t2.map((t3) => new Lt(t3));
    return this.mh = { nh: t2, eh: i2 }, i2;
  }
  gh() {
    var _a3, _b3, _c2;
    const t2 = ((_b3 = (_a3 = this.ah).timeAxisPaneViews) == null ? void 0 : _b3.call(_a3)) ?? [];
    if (((_c2 = this.wh) == null ? void 0 : _c2.nh) === t2) return this.wh.eh;
    const i2 = t2.map((t3) => new Lt(t3));
    return this.wh = { nh: t2, eh: i2 }, i2;
  }
  bh(t2, i2) {
    var _a3, _b3;
    return ((_b3 = (_a3 = this.ah).autoscaleInfo) == null ? void 0 : _b3.call(_a3, t2, i2)) ?? null;
  }
}
function Ht(t2, i2, s2, n2) {
  t2.forEach((t3) => {
    i2(t3).forEach((t4) => {
      t4.rh() === s2 && n2.push(t4);
    });
  });
}
function Ut(t2) {
  return t2.qs();
}
function $t(t2) {
  return t2.Mh();
}
function qt(t2) {
  return t2.gh();
}
const Yt = ["Area", "Line", "Baseline"];
class jt extends xt {
  constructor(t2, i2, s2, n2, e2) {
    super(t2), this.Gt = new Dt(), this.er = new ft(this), this.xh = [], this.Sh = new _t(this), this.Ch = null, this.Ph = null, this.kh = null, this.yh = [], this.Ts = s2, this.Th = i2;
    const r2 = new pt(this);
    this.gs = [r2], this.rr = new at(r2, this, t2), Yt.includes(this.Th) && (this.Ch = new dt(this)), this.Rh(), this.sh = n2(this, this.ni(), e2);
  }
  m() {
    null !== this.kh && clearTimeout(this.kh);
  }
  Be(t2) {
    return this.Ts.priceLineColor || t2;
  }
  Pe(t2) {
    const i2 = { ke: true }, s2 = this.$t();
    if (this.ni().Ot().Zi() || s2.Zi() || this.Gt.Zi()) return i2;
    const n2 = this.ni().Ot().Ce(), e2 = this.Ft();
    if (null === n2 || null === e2) return i2;
    let r2, h2;
    if (t2) {
      const t3 = this.Gt.zr();
      if (null === t3) return i2;
      r2 = t3, h2 = t3.index;
    } else {
      const t3 = this.Gt.Nr(n2.ki(), -1);
      if (null === t3) return i2;
      if (r2 = this.Gt.Tr(t3.index), null === r2) return i2;
      h2 = t3.index;
    }
    const a2 = r2.value[3], l2 = this.Dh().Ir(h2, { qt: r2 }), o2 = s2.Ut(a2, e2.qt);
    return { ke: false, St: a2, oi: s2.Qi(a2, e2.qt), Le: s2.Ih(a2), Oe: s2.Bh(a2, e2.qt), R: l2.cr, zi: o2, Te: h2 };
  }
  Dh() {
    return null !== this.Ph || (this.Ph = new Ct(this)), this.Ph;
  }
  F() {
    return this.Ts;
  }
  hr(t2) {
    const i2 = t2.priceScaleId;
    void 0 !== i2 && i2 !== this.Ts.priceScaleId && this.ni().Vh(this, i2), f(this.Ts, t2), void 0 !== t2.priceFormat && (this.Rh(), this.ni().Eh()), this.ni().Ah(this), this.ni().zh(), this.sh.Dt("options");
  }
  ut(t2, i2) {
    this.Gt.ut(t2), this.sh.Dt("data"), null !== this.Ch && (i2 && i2.Lh ? this.Ch.ge() : 0 === t2.length && this.Ch.Me());
    const s2 = this.ni().Un(this);
    this.ni().Oh(s2), this.ni().Ah(this), this.ni().zh(), this.ni().ar();
  }
  Nh(t2) {
    const i2 = new bt(this, t2);
    return this.xh.push(i2), this.ni().Ah(this), i2;
  }
  Fh(t2) {
    const i2 = this.xh.indexOf(t2);
    -1 !== i2 && this.xh.splice(i2, 1), this.ni().Ah(this);
  }
  Wh() {
    return this.xh;
  }
  Dr() {
    return this.Th;
  }
  Ft() {
    const t2 = this.Hh();
    return null === t2 ? null : { qt: t2.value[3], Uh: t2.time };
  }
  Hh() {
    const t2 = this.ni().Ot().Ce();
    if (null === t2) return null;
    const i2 = t2.$h();
    return this.Gt.Nr(i2, 1);
  }
  Qs() {
    return this.Gt;
  }
  qh(t2) {
    const i2 = this.Gt.Tr(t2);
    return null === i2 ? null : "Bar" === this.Th || "Candlestick" === this.Th || "Custom" === this.Th ? { Yh: i2.value[0], jh: i2.value[1], Kh: i2.value[2], Xh: i2.value[3] } : i2.value[3];
  }
  Gh(t2) {
    const i2 = [];
    Ht(this.yh, Ut, "top", i2);
    const s2 = this.Ch;
    return null !== s2 && s2.At() ? (null === this.kh && s2.xe() && (this.kh = setTimeout(() => {
      this.kh = null, this.ni().Zh();
    }, 0)), s2.be(), i2.unshift(s2), i2) : i2;
  }
  qs() {
    const t2 = [];
    this.Jh() || t2.push(this.Sh), t2.push(this.sh, this.er);
    const i2 = this.xh.map((t3) => t3.lr());
    return t2.push(...i2), Ht(this.yh, Ut, "normal", t2), t2;
  }
  Qh() {
    return this.ta(Ut, "bottom");
  }
  ia() {
    return this.ta(Ut, "under");
  }
  sa(t2) {
    return this.ta($t, t2);
  }
  na(t2) {
    return this.ta(qt, t2);
  }
  ea(t2, i2) {
    return this.yh.map((s2) => s2.ht(t2, i2)).filter((t3) => null !== t3);
  }
  fs() {
    return [this.rr, ...this.xh.map((t2) => t2._r())];
  }
  Ys(t2, i2) {
    if (i2 !== this.ls && !this.Jh()) return [];
    const s2 = [...this.gs];
    for (const t3 of this.xh) s2.push(t3.ur());
    return this.yh.forEach((t3) => {
      s2.push(...t3.Ys());
    }), s2;
  }
  ps() {
    const t2 = [];
    return this.yh.forEach((i2) => {
      t2.push(...i2.ps());
    }), t2;
  }
  bh(t2, i2) {
    if (void 0 !== this.Ts.autoscaleInfoProvider) {
      const s2 = this.Ts.autoscaleInfoProvider(() => {
        const s3 = this.ra(t2, i2);
        return null === s3 ? null : s3.Ke();
      });
      return wt.Xe(s2);
    }
    return this.ra(t2, i2);
  }
  nh() {
    const t2 = this.Ts.priceFormat;
    return t2.base ?? 1 / t2.minMove;
  }
  nr() {
    return this.ha;
  }
  $s() {
    var _a3;
    this.sh.Dt();
    for (const t2 of this.gs) t2.Dt();
    for (const t2 of this.xh) t2.Dt();
    this.er.Dt(), this.Sh.Dt(), (_a3 = this.Ch) == null ? void 0 : _a3.Dt(), this.yh.forEach((t2) => t2.$s());
  }
  $t() {
    return u(super.$t());
  }
  Nt(t2) {
    if (!(("Line" === this.Th || "Area" === this.Th || "Baseline" === this.Th) && this.Ts.crosshairMarkerVisible)) return null;
    const i2 = this.Gt.Tr(t2);
    if (null === i2) return null;
    return { St: i2.value[3], gt: this.aa(), Yt: this.la(), Ht: this.oa(), Wt: this._a(t2) };
  }
  Ve() {
    return this.Ts.title;
  }
  At() {
    return this.Ts.visible;
  }
  ua(t2) {
    this.yh.push(new Wt(t2, this));
  }
  ca(t2) {
    this.yh = this.yh.filter((i2) => i2.oh() !== t2);
  }
  da() {
    return this.yh.slice().map((t2) => t2.oh());
  }
  fa() {
    if ("Custom" === this.Th) return (t2) => this.sh.pa(t2);
  }
  va() {
    if ("Custom" === this.Th) return (t2) => this.sh.ma(t2);
  }
  wa() {
    return this.Gt.$r();
  }
  Jh() {
    return !G(this.$t().Ma());
  }
  ra(t2, i2) {
    if (!v(t2) || !v(i2) || this.Gt.Zi()) return null;
    const s2 = "Line" === this.Th || "Area" === this.Th || "Baseline" === this.Th || "Histogram" === this.Th ? [3] : [2, 1], n2 = this.Gt.Hr(t2, i2, s2);
    let e2 = null !== n2 ? new mt(n2.Jr, n2.Qr) : null, r2 = null;
    if ("Histogram" === this.Dr()) {
      const t3 = this.Ts.base, i3 = new mt(t3, t3);
      e2 = null !== e2 ? e2.gn(i3) : i3;
    }
    return this.yh.forEach((s3) => {
      const n3 = s3.bh(t2, i2);
      if (n3 == null ? void 0 : n3.priceRange) {
        const t3 = new mt(n3.priceRange.minValue, n3.priceRange.maxValue);
        e2 = null !== e2 ? e2.gn(t3) : t3;
      }
      (n3 == null ? void 0 : n3.margins) && (r2 = n3.margins);
    }), new wt(e2, r2);
  }
  aa() {
    switch (this.Th) {
      case "Line":
      case "Area":
      case "Baseline":
        return this.Ts.crosshairMarkerRadius;
    }
    return 0;
  }
  la() {
    switch (this.Th) {
      case "Line":
      case "Area":
      case "Baseline": {
        const t2 = this.Ts.crosshairMarkerBorderColor;
        if (0 !== t2.length) return t2;
      }
    }
    return null;
  }
  oa() {
    switch (this.Th) {
      case "Line":
      case "Area":
      case "Baseline":
        return this.Ts.crosshairMarkerBorderWidth;
    }
    return 0;
  }
  _a(t2) {
    switch (this.Th) {
      case "Line":
      case "Area":
      case "Baseline": {
        const t3 = this.Ts.crosshairMarkerBackgroundColor;
        if (0 !== t3.length) return t3;
      }
    }
    return this.Dh().Ir(t2).cr;
  }
  Rh() {
    switch (this.Ts.priceFormat.type) {
      case "custom": {
        const t2 = this.Ts.priceFormat.formatter;
        this.ha = { format: t2, formatTickmarks: this.Ts.priceFormat.tickmarksFormatter ?? ((i2) => i2.map(t2)) };
        break;
      }
      case "volume":
        this.ha = new nt(this.Ts.priceFormat.precision);
        break;
      case "percent":
        this.ha = new st(this.Ts.priceFormat.precision);
        break;
      default: {
        const t2 = Math.pow(10, this.Ts.priceFormat.precision);
        this.ha = new it(t2, this.Ts.priceFormat.minMove * t2);
      }
    }
    null !== this.ls && this.ls.ga();
  }
  ta(t2, i2) {
    const s2 = [];
    return Ht(this.yh, t2, i2, s2), s2;
  }
}
const Kt = [3], Xt = [0, 1, 2, 3];
class Gt {
  constructor(t2) {
    this.Ts = t2;
  }
  ba(t2, i2, s2) {
    let n2 = t2;
    if (0 === this.Ts.mode) return n2;
    const e2 = s2.Ds(), r2 = e2.Ft();
    if (null === r2) return n2;
    const h2 = e2.Ut(t2, r2), a2 = s2.xa().filter((t3) => t3 instanceof jt).reduce((t3, n3) => {
      if (s2.$n(n3) || !n3.At()) return t3;
      const e3 = n3.$t(), r3 = n3.Qs();
      if (e3.Zi() || !r3.ye(i2)) return t3;
      const h3 = r3.Tr(i2);
      if (null === h3) return t3;
      const a3 = c(n3.Ft()), l3 = 1 === this.Ts.mode ? Kt : Xt;
      return t3.concat(l3.map((t4) => e3.Ut(h3.value[t4], a3.qt)));
    }, []);
    if (0 === a2.length) return n2;
    a2.sort((t3, i3) => Math.abs(t3 - h2) - Math.abs(i3 - h2));
    const l2 = a2[0], o2 = 1 === this.Ts.mode || 3 === this.Ts.mode, _2 = 4 === this.Ts.mode && Math.abs(l2 - h2) < 50;
    return n2 = o2 || _2 ? e2.Is(l2, r2) : t2, n2;
  }
}
function Zt(t2, i2, s2) {
  return Math.min(Math.max(t2, i2), s2);
}
function Jt(t2, i2, s2) {
  return i2 - t2 <= s2;
}
class ti extends R {
  constructor() {
    super(...arguments), this.Gt = null;
  }
  ut(t2) {
    this.Gt = t2;
  }
  ot({ context: t2, bitmapSize: i2, horizontalPixelRatio: s2, verticalPixelRatio: n2 }) {
    if (null === this.Gt) return;
    const e2 = Math.max(1, Math.floor(s2));
    t2.lineWidth = e2, function(t3, i3) {
      t3.save(), t3.lineWidth % 2 && t3.translate(0.5, 0.5), i3(), t3.restore();
    }(t2, () => {
      const r2 = u(this.Gt);
      if (r2.Sa) {
        t2.strokeStyle = r2.Ca, a$1(t2, r2.Pa), t2.beginPath();
        for (const n3 of r2.ka) {
          const r3 = Math.round(n3.ya * s2);
          t2.moveTo(r3, -e2), t2.lineTo(r3, i2.height + e2);
        }
        t2.stroke();
      }
      if (r2.Ta) {
        t2.strokeStyle = r2.Ra, a$1(t2, r2.Da), t2.beginPath();
        for (const s3 of r2.Ia) {
          const r3 = Math.round(s3.ya * n2);
          t2.moveTo(-e2, r3), t2.lineTo(i2.width + e2, r3);
        }
        t2.stroke();
      }
    });
  }
}
class ii {
  constructor(t2) {
    this.ii = new ti(), this.yt = true, this.Rt = t2;
  }
  Dt() {
    this.yt = true;
  }
  Bt() {
    if (this.yt) {
      const t2 = this.Rt.ni().F().grid, i2 = { Ta: t2.horzLines.visible, Sa: t2.vertLines.visible, Ra: t2.horzLines.color, Ca: t2.vertLines.color, Da: t2.horzLines.style, Pa: t2.vertLines.style, Ia: this.Rt.Ds().Ba(), ka: (this.Rt.ni().Ot().Ba() || []).map((t3) => ({ ya: t3.coord })) };
      this.ii.ut(i2), this.yt = false;
    }
    return this.ii;
  }
}
class si {
  constructor(t2) {
    this.sh = new ii(t2);
  }
  lr() {
    return this.sh;
  }
}
const ni = { Va: 4, Ea: 1e-4 };
function ei(t2, i2) {
  const s2 = 100 * (t2 - i2) / i2;
  return i2 < 0 ? -s2 : s2;
}
function ri(t2, i2) {
  const s2 = ei(t2.Ue(), i2), n2 = ei(t2.$e(), i2);
  return new mt(s2, n2);
}
function hi(t2, i2) {
  const s2 = 100 * (t2 - i2) / i2 + 100;
  return i2 < 0 ? -s2 : s2;
}
function ai(t2, i2) {
  const s2 = hi(t2.Ue(), i2), n2 = hi(t2.$e(), i2);
  return new mt(s2, n2);
}
function li(t2, i2) {
  const s2 = Math.abs(t2);
  if (s2 < 1e-15) return 0;
  const n2 = Math.log10(s2 + i2.Ea) + i2.Va;
  return t2 < 0 ? -n2 : n2;
}
function oi(t2, i2) {
  const s2 = Math.abs(t2);
  if (s2 < 1e-15) return 0;
  const n2 = Math.pow(10, s2 - i2.Va) - i2.Ea;
  return t2 < 0 ? -n2 : n2;
}
function _i(t2, i2) {
  if (null === t2) return null;
  const s2 = li(t2.Ue(), i2), n2 = li(t2.$e(), i2);
  return new mt(s2, n2);
}
function ui(t2, i2) {
  if (null === t2) return null;
  const s2 = oi(t2.Ue(), i2), n2 = oi(t2.$e(), i2);
  return new mt(s2, n2);
}
function ci(t2) {
  if (null === t2) return ni;
  const i2 = Math.abs(t2.$e() - t2.Ue());
  if (i2 >= 1 || i2 < 1e-15) return ni;
  const s2 = Math.ceil(Math.abs(Math.log10(i2))), n2 = ni.Va + s2;
  return { Va: n2, Ea: 1 / Math.pow(10, n2) };
}
class di {
  constructor(t2, i2) {
    if (this.Aa = t2, this.za = i2, function(t3) {
      if (t3 < 0) return false;
      if (t3 > 1e18) return true;
      for (let i3 = t3; i3 > 1; i3 /= 10) if (i3 % 10 != 0) return false;
      return true;
    }(this.Aa)) this.La = [2, 2.5, 2];
    else {
      this.La = [];
      for (let t3 = this.Aa; 1 !== t3; ) {
        if (t3 % 2 == 0) this.La.push(2), t3 /= 2;
        else {
          if (t3 % 5 != 0) throw new Error("unexpected base");
          this.La.push(2, 2.5), t3 /= 5;
        }
        if (this.La.length > 100) throw new Error("something wrong with base");
      }
    }
  }
  Oa(t2, i2, s2) {
    const n2 = 0 === this.Aa ? 0 : 1 / this.Aa;
    let e2 = Math.pow(10, Math.max(0, Math.ceil(Math.log10(t2 - i2)))), r2 = 0, h2 = this.za[0];
    for (; ; ) {
      const t3 = Jt(e2, n2, 1e-14) && e2 > n2 + 1e-14, i3 = Jt(e2, s2 * h2, 1e-14), a3 = Jt(e2, 1, 1e-14);
      if (!(t3 && i3 && a3)) break;
      e2 /= h2, h2 = this.za[++r2 % this.za.length];
    }
    if (e2 <= n2 + 1e-14 && (e2 = n2), e2 = Math.max(1, e2), this.La.length > 0 && (a2 = e2, l2 = 1, o2 = 1e-14, Math.abs(a2 - l2) < o2)) for (r2 = 0, h2 = this.La[0]; Jt(e2, s2 * h2, 1e-14) && e2 > n2 + 1e-14; ) e2 /= h2, h2 = this.La[++r2 % this.La.length];
    var a2, l2, o2;
    return e2;
  }
}
class fi {
  constructor(t2, i2, s2, n2) {
    this.Na = [], this.Xi = t2, this.Aa = i2, this.Fa = s2, this.Wa = n2;
  }
  Oa(t2, i2) {
    if (t2 < i2) throw new Error("high < low");
    const s2 = this.Xi.Kt(), n2 = (t2 - i2) * this.Ha() / s2, e2 = new di(this.Aa, [2, 2.5, 2]), r2 = new di(this.Aa, [2, 2, 2.5]), h2 = new di(this.Aa, [2.5, 2, 2]), a2 = [];
    return a2.push(e2.Oa(t2, i2, n2), r2.Oa(t2, i2, n2), h2.Oa(t2, i2, n2)), function(t3) {
      if (t3.length < 1) throw Error("array is empty");
      let i3 = t3[0];
      for (let s3 = 1; s3 < t3.length; ++s3) t3[s3] < i3 && (i3 = t3[s3]);
      return i3;
    }(a2);
  }
  Ua() {
    const t2 = this.Xi, i2 = t2.Ft();
    if (null === i2) return void (this.Na = []);
    const s2 = t2.Kt(), n2 = this.Fa(s2 - 1, i2), e2 = this.Fa(0, i2), r2 = this.Xi.F().entireTextOnly ? this.$a() / 2 : 0, h2 = r2, a2 = s2 - 1 - r2, l2 = Math.max(n2, e2), o2 = Math.min(n2, e2);
    if (l2 === o2) return void (this.Na = []);
    const _2 = this.Oa(l2, o2);
    if (this.qa(i2, _2, l2, o2, h2, a2), t2.Ya() && this.ja(_2, o2, l2)) {
      const t3 = this.Xi.Ka();
      this.Xa(i2, _2, h2, a2, t3, 2 * t3);
    }
    const u2 = this.Na.map((t3) => t3.Ga), c2 = this.Xi.Za(u2);
    for (let t3 = 0; t3 < this.Na.length; t3++) this.Na[t3].Ja = c2[t3];
  }
  Ba() {
    return this.Na;
  }
  $a() {
    return this.Xi.P();
  }
  Ha() {
    return Math.ceil(2.5 * this.$a());
  }
  qa(t2, i2, s2, n2, e2, r2) {
    const h2 = this.Na, a2 = this.Xi;
    let l2 = s2 % i2;
    l2 += l2 < 0 ? i2 : 0;
    const o2 = s2 >= n2 ? 1 : -1;
    let _2 = null, u2 = 0;
    for (let c2 = s2 - l2; c2 > n2; c2 -= i2) {
      const s3 = this.Wa(c2, t2, true);
      null !== _2 && Math.abs(s3 - _2) < this.Ha() || (s3 < e2 || s3 > r2 || (u2 < h2.length ? (h2[u2].ya = s3, h2[u2].Ja = a2.Qa(c2), h2[u2].Ga = c2) : h2.push({ ya: s3, Ja: a2.Qa(c2), Ga: c2 }), u2++, _2 = s3, a2.tl() && (i2 = this.Oa(c2 * o2, n2))));
    }
    h2.length = u2;
  }
  Xa(t2, i2, s2, n2, e2, r2) {
    const h2 = this.Na, a2 = this.il(t2, s2, e2, r2), l2 = this.il(t2, n2, -r2, -e2), o2 = this.Wa(0, t2, true) - this.Wa(i2, t2, true);
    h2.length > 0 && h2[0].ya - a2.ya < o2 / 2 && h2.shift(), h2.length > 0 && l2.ya - h2[h2.length - 1].ya < o2 / 2 && h2.pop(), h2.unshift(a2), h2.push(l2);
  }
  il(t2, i2, s2, n2) {
    const e2 = (s2 + n2) / 2, r2 = this.Fa(i2 + s2, t2), h2 = this.Fa(i2 + n2, t2), a2 = Math.min(r2, h2), l2 = Math.max(r2, h2), o2 = Math.max(0.1, this.Oa(l2, a2)), _2 = this.Fa(i2 + e2, t2), u2 = _2 - _2 % o2, c2 = this.Wa(u2, t2, true);
    return { Ja: this.Xi.Qa(u2), ya: c2, Ga: u2 };
  }
  ja(t2, i2, s2) {
    let n2 = c(this.Xi.Je());
    return this.Xi.tl() && (n2 = ui(n2, this.Xi.sl())), n2.Ue() - i2 < t2 && s2 - n2.$e() < t2;
  }
}
function pi(t2) {
  return t2.slice().sort((t3, i2) => u(t3.us()) - u(i2.us()));
}
var vi;
!function(t2) {
  t2[t2.Normal = 0] = "Normal", t2[t2.Logarithmic = 1] = "Logarithmic", t2[t2.Percentage = 2] = "Percentage", t2[t2.IndexedTo100 = 3] = "IndexedTo100";
}(vi || (vi = {}));
const mi = new st(), wi = new it(100, 1);
class Mi {
  constructor(t2, i2, s2, n2, e2) {
    this.nl = 0, this.el = null, this.Ge = null, this.rl = null, this.hl = { al: false, ll: null }, this.ol = false, this._l = 0, this.ul = 0, this.cl = new d$1(), this.dl = new d$1(), this.fl = [], this.pl = null, this.vl = null, this.ml = null, this.wl = null, this.Ml = null, this.ha = wi, this.gl = ci(null), this.bl = t2, this.Ts = i2, this.xl = s2, this.Sl = n2, this.Cl = e2, this.Pl = new fi(this, 100, this.kl.bind(this), this.yl.bind(this));
  }
  Ma() {
    return this.bl;
  }
  F() {
    return this.Ts;
  }
  hr(t2) {
    if (f(this.Ts, t2), this.ga(), void 0 !== t2.mode && this.Tl({ te: t2.mode }), void 0 !== t2.scaleMargins) {
      const i2 = _(t2.scaleMargins.top), s2 = _(t2.scaleMargins.bottom);
      if (i2 < 0 || i2 > 1) throw new Error(`Invalid top margin - expect value between 0 and 1, given=${i2}`);
      if (s2 < 0 || s2 > 1) throw new Error(`Invalid bottom margin - expect value between 0 and 1, given=${s2}`);
      if (i2 + s2 > 1) throw new Error(`Invalid margins - sum of margins must be less than 1, given=${i2 + s2}`);
      this.Rl(), this.ml = null;
    }
  }
  Dl() {
    return this.Ts.autoScale;
  }
  Il() {
    return this.ol;
  }
  tl() {
    return 1 === this.Ts.mode;
  }
  ze() {
    return 2 === this.Ts.mode;
  }
  Bl() {
    return 3 === this.Ts.mode;
  }
  sl() {
    return this.gl;
  }
  te() {
    return { hn: this.Ts.autoScale, Vl: this.Ts.invertScale, te: this.Ts.mode };
  }
  Tl(t2) {
    const i2 = this.te();
    let s2 = null;
    void 0 !== t2.hn && (this.Ts.autoScale = t2.hn), void 0 !== t2.te && (this.Ts.mode = t2.te, 2 !== t2.te && 3 !== t2.te || (this.Ts.autoScale = true), this.hl.al = false), 1 === i2.te && t2.te !== i2.te && (!function(t3, i3) {
      if (null === t3) return false;
      const s3 = oi(t3.Ue(), i3), n3 = oi(t3.$e(), i3);
      return isFinite(s3) && isFinite(n3);
    }(this.Ge, this.gl) ? this.Ts.autoScale = true : (s2 = ui(this.Ge, this.gl), null !== s2 && this.El(s2))), 1 === t2.te && t2.te !== i2.te && (s2 = _i(this.Ge, this.gl), null !== s2 && this.El(s2));
    const n2 = i2.te !== this.Ts.mode;
    n2 && (2 === i2.te || this.ze()) && this.ga(), n2 && (3 === i2.te || this.Bl()) && this.ga(), void 0 !== t2.Vl && i2.Vl !== t2.Vl && (this.Ts.invertScale = t2.Vl, this.Al()), this.dl.p(i2, this.te());
  }
  zl() {
    return this.dl;
  }
  P() {
    return this.xl.fontSize;
  }
  Kt() {
    return this.nl;
  }
  Ll(t2) {
    this.nl !== t2 && (this.nl = t2, this.Rl(), this.ml = null);
  }
  Ol() {
    if (this.el) return this.el;
    const t2 = this.Kt() - this.Nl() - this.Fl();
    return this.el = t2, t2;
  }
  Je() {
    return this.Wl(), this.Ge;
  }
  El(t2, i2) {
    const s2 = this.Ge;
    (i2 || null === s2 && null !== t2 || null !== s2 && !s2.We(t2)) && (this.ml = null, this.Ge = t2);
  }
  Hl(t2) {
    this.El(t2), this.Ul(null !== t2);
  }
  Zi() {
    return this.Wl(), 0 === this.nl || !this.Ge || this.Ge.Zi();
  }
  $l(t2) {
    return this.Vl() ? t2 : this.Kt() - 1 - t2;
  }
  Ut(t2, i2) {
    return this.ze() ? t2 = ei(t2, i2) : this.Bl() && (t2 = hi(t2, i2)), this.yl(t2, i2);
  }
  ql(t2, i2, s2) {
    this.Wl();
    const n2 = this.Fl(), e2 = u(this.Je()), r2 = e2.Ue(), h2 = e2.$e(), a2 = this.Ol() - 1, l2 = this.Vl(), o2 = a2 / (h2 - r2), _2 = void 0 === s2 ? 0 : s2.from, c2 = void 0 === s2 ? t2.length : s2.to, d3 = this.Yl();
    for (let s3 = _2; s3 < c2; s3++) {
      const e3 = t2[s3], h3 = e3.St;
      if (isNaN(h3)) continue;
      let a3 = h3;
      null !== d3 && (a3 = d3(e3.St, i2));
      const _3 = n2 + o2 * (a3 - r2), u2 = l2 ? _3 : this.nl - 1 - _3;
      e3.vt = u2;
    }
  }
  jl(t2, i2, s2) {
    this.Wl();
    const n2 = this.Fl(), e2 = u(this.Je()), r2 = e2.Ue(), h2 = e2.$e(), a2 = this.Ol() - 1, l2 = this.Vl(), o2 = a2 / (h2 - r2), _2 = void 0 === s2 ? 0 : s2.from, c2 = void 0 === s2 ? t2.length : s2.to, d3 = this.Yl();
    for (let s3 = _2; s3 < c2; s3++) {
      const e3 = t2[s3];
      let h3 = e3.Yh, a3 = e3.jh, _3 = e3.Kh, u2 = e3.Xh;
      null !== d3 && (h3 = d3(e3.Yh, i2), a3 = d3(e3.jh, i2), _3 = d3(e3.Kh, i2), u2 = d3(e3.Xh, i2));
      let c3 = n2 + o2 * (h3 - r2), f2 = l2 ? c3 : this.nl - 1 - c3;
      e3.Kl = f2, c3 = n2 + o2 * (a3 - r2), f2 = l2 ? c3 : this.nl - 1 - c3, e3.Xl = f2, c3 = n2 + o2 * (_3 - r2), f2 = l2 ? c3 : this.nl - 1 - c3, e3.Gl = f2, c3 = n2 + o2 * (u2 - r2), f2 = l2 ? c3 : this.nl - 1 - c3, e3.Zl = f2;
    }
  }
  Is(t2, i2) {
    const s2 = this.kl(t2, i2);
    return this.Jl(s2, i2);
  }
  Jl(t2, i2) {
    let s2 = t2;
    return this.ze() ? s2 = function(t3, i3) {
      return i3 < 0 && (t3 = -t3), t3 / 100 * i3 + i3;
    }(s2, i2) : this.Bl() && (s2 = function(t3, i3) {
      return t3 -= 100, i3 < 0 && (t3 = -t3), t3 / 100 * i3 + i3;
    }(s2, i2)), s2;
  }
  xa() {
    return this.fl;
  }
  Et() {
    return this.vl || (this.vl = pi(this.fl)), this.vl;
  }
  Ql(t2) {
    -1 === this.fl.indexOf(t2) && (this.fl.push(t2), this.ga(), this.io());
  }
  so(t2) {
    const i2 = this.fl.indexOf(t2);
    if (-1 === i2) throw new Error("source is not attached to scale");
    this.fl.splice(i2, 1), 0 === this.fl.length && (this.Tl({ hn: true }), this.El(null)), this.ga(), this.io();
  }
  Ft() {
    let t2 = null;
    for (const i2 of this.fl) {
      const s2 = i2.Ft();
      null !== s2 && ((null === t2 || s2.Uh < t2.Uh) && (t2 = s2));
    }
    return null === t2 ? null : t2.qt;
  }
  Vl() {
    return this.Ts.invertScale;
  }
  Ba() {
    const t2 = null === this.Ft();
    if (null !== this.ml && (t2 || this.ml.no === t2)) return this.ml.Ba;
    this.Pl.Ua();
    const i2 = this.Pl.Ba();
    return this.ml = { Ba: i2, no: t2 }, this.cl.p(), i2;
  }
  eo() {
    return this.cl;
  }
  ro(t2) {
    this.ze() || this.Bl() || null === this.wl && null === this.rl && (this.Zi() || (this.wl = this.nl - t2, this.rl = u(this.Je()).He()));
  }
  ho(t2) {
    if (this.ze() || this.Bl()) return;
    if (null === this.wl) return;
    this.Tl({ hn: false }), (t2 = this.nl - t2) < 0 && (t2 = 0);
    let i2 = (this.wl + 0.2 * (this.nl - 1)) / (t2 + 0.2 * (this.nl - 1));
    const s2 = u(this.rl).He();
    i2 = Math.max(i2, 0.1), s2.Ye(i2), this.El(s2);
  }
  ao() {
    this.ze() || this.Bl() || (this.wl = null, this.rl = null);
  }
  lo(t2) {
    this.Dl() || null === this.Ml && null === this.rl && (this.Zi() || (this.Ml = t2, this.rl = u(this.Je()).He()));
  }
  oo(t2) {
    if (this.Dl()) return;
    if (null === this.Ml) return;
    const i2 = u(this.Je()).qe() / (this.Ol() - 1);
    let s2 = t2 - this.Ml;
    this.Vl() && (s2 *= -1);
    const n2 = s2 * i2, e2 = u(this.rl).He();
    e2.je(n2), this.El(e2, true), this.ml = null;
  }
  _o() {
    this.Dl() || null !== this.Ml && (this.Ml = null, this.rl = null);
  }
  nr() {
    return this.ha || this.ga(), this.ha;
  }
  Qi(t2, i2) {
    switch (this.Ts.mode) {
      case 2:
        return this.uo(ei(t2, i2));
      case 3:
        return this.nr().format(hi(t2, i2));
      default:
        return this.sr(t2);
    }
  }
  Qa(t2) {
    switch (this.Ts.mode) {
      case 2:
        return this.uo(t2);
      case 3:
        return this.nr().format(t2);
      default:
        return this.sr(t2);
    }
  }
  Za(t2) {
    switch (this.Ts.mode) {
      case 2:
        return this.co(t2);
      case 3:
        return this.nr().formatTickmarks(t2);
      default:
        return this.do(t2);
    }
  }
  Ih(t2) {
    return this.sr(t2, u(this.pl).nr());
  }
  Bh(t2, i2) {
    return t2 = ei(t2, i2), this.uo(t2, mi);
  }
  fo() {
    return this.fl;
  }
  po(t2) {
    this.hl = { ll: t2, al: false };
  }
  $s() {
    this.fl.forEach((t2) => t2.$s());
  }
  Ya() {
    return this.Ts.ensureEdgeTickMarksVisible && this.Dl();
  }
  Ka() {
    return this.P() / 2;
  }
  ga() {
    this.ml = null;
    let t2 = 1 / 0;
    this.pl = null;
    for (const i3 of this.fl) i3.us() < t2 && (t2 = i3.us(), this.pl = i3);
    let i2 = 100;
    null !== this.pl && (i2 = Math.round(this.pl.nh())), this.ha = wi, this.ze() ? (this.ha = mi, i2 = 100) : this.Bl() ? (this.ha = new it(100, 1), i2 = 100) : null !== this.pl && (this.ha = this.pl.nr()), this.Pl = new fi(this, i2, this.kl.bind(this), this.yl.bind(this)), this.Pl.Ua();
  }
  io() {
    this.vl = null;
  }
  Ji() {
    return this.Cl;
  }
  Ul(t2) {
    this.ol = t2;
  }
  Nl() {
    return this.Vl() ? this.Ts.scaleMargins.bottom * this.Kt() + this.ul : this.Ts.scaleMargins.top * this.Kt() + this._l;
  }
  Fl() {
    return this.Vl() ? this.Ts.scaleMargins.top * this.Kt() + this._l : this.Ts.scaleMargins.bottom * this.Kt() + this.ul;
  }
  Wl() {
    this.hl.al || (this.hl.al = true, this.vo());
  }
  Rl() {
    this.el = null;
  }
  yl(t2, i2) {
    if (this.Wl(), this.Zi()) return 0;
    t2 = this.tl() && t2 ? li(t2, this.gl) : t2;
    const s2 = u(this.Je()), n2 = this.Fl() + (this.Ol() - 1) * (t2 - s2.Ue()) / s2.qe();
    return this.$l(n2);
  }
  kl(t2, i2) {
    if (this.Wl(), this.Zi()) return 0;
    const s2 = this.$l(t2), n2 = u(this.Je()), e2 = n2.Ue() + n2.qe() * ((s2 - this.Fl()) / (this.Ol() - 1));
    return this.tl() ? oi(e2, this.gl) : e2;
  }
  Al() {
    this.ml = null, this.Pl.Ua();
  }
  vo() {
    if (this.Il() && !this.Dl()) return;
    const t2 = this.hl.ll;
    if (null === t2) return;
    let i2 = null;
    const s2 = this.fo();
    let n2 = 0, e2 = 0;
    for (const r3 of s2) {
      if (!r3.At()) continue;
      const s3 = r3.Ft();
      if (null === s3) continue;
      const h3 = r3.bh(t2.$h(), t2.ki());
      let a2 = h3 && h3.Je();
      if (null !== a2) {
        switch (this.Ts.mode) {
          case 1:
            a2 = _i(a2, this.gl);
            break;
          case 2:
            a2 = ri(a2, s3.qt);
            break;
          case 3:
            a2 = ai(a2, s3.qt);
        }
        if (i2 = null === i2 ? a2 : i2.gn(u(a2)), null !== h3) {
          const t3 = h3.Qe();
          null !== t3 && (n2 = Math.max(n2, t3.above), e2 = Math.max(e2, t3.below));
        }
      }
    }
    if (this.Ya() && (n2 = Math.max(n2, this.Ka()), e2 = Math.max(e2, this.Ka())), n2 === this._l && e2 === this.ul || (this._l = n2, this.ul = e2, this.ml = null, this.Rl()), null !== i2) {
      if (i2.Ue() === i2.$e()) {
        const t3 = this.pl, s3 = 5 * (null === t3 || this.ze() || this.Bl() ? 1 : 1 / t3.nh());
        this.tl() && (i2 = ui(i2, this.gl)), i2 = new mt(i2.Ue() - s3, i2.$e() + s3), this.tl() && (i2 = _i(i2, this.gl));
      }
      if (this.tl()) {
        const t3 = ui(i2, this.gl), s3 = ci(t3);
        if (r2 = s3, h2 = this.gl, r2.Va !== h2.Va || r2.Ea !== h2.Ea) {
          const n3 = null !== this.rl ? ui(this.rl, this.gl) : null;
          this.gl = s3, i2 = _i(t3, s3), null !== n3 && (this.rl = _i(n3, s3));
        }
      }
      this.El(i2);
    } else null === this.Ge && (this.El(new mt(-0.5, 0.5)), this.gl = ci(null));
    var r2, h2;
  }
  Yl() {
    return this.ze() ? ei : this.Bl() ? hi : this.tl() ? (t2) => li(t2, this.gl) : null;
  }
  mo(t2, i2, s2) {
    return void 0 === i2 ? (void 0 === s2 && (s2 = this.nr()), s2.format(t2)) : i2(t2);
  }
  wo(t2, i2, s2) {
    return void 0 === i2 ? (void 0 === s2 && (s2 = this.nr()), s2.formatTickmarks(t2)) : i2(t2);
  }
  sr(t2, i2) {
    return this.mo(t2, this.Sl.priceFormatter, i2);
  }
  do(t2, i2) {
    const s2 = this.Sl.priceFormatter;
    return this.wo(t2, this.Sl.tickmarksPriceFormatter ?? (s2 ? (t3) => t3.map(s2) : void 0), i2);
  }
  uo(t2, i2) {
    return this.mo(t2, this.Sl.percentageFormatter, i2);
  }
  co(t2, i2) {
    const s2 = this.Sl.percentageFormatter;
    return this.wo(t2, this.Sl.tickmarksPercentageFormatter ?? (s2 ? (t3) => t3.map(s2) : void 0), i2);
  }
}
function gi(t2) {
  return t2 instanceof jt;
}
class bi {
  constructor(t2, i2) {
    this.fl = [], this.Mo = /* @__PURE__ */ new Map(), this.nl = 0, this.bo = 0, this.xo = 1, this.vl = null, this.So = false, this.Co = new d$1(), this.yh = [], this.dh = t2, this.es = i2, this.Po = new si(this);
    const s2 = i2.F();
    this.ko = this.yo("left", s2.leftPriceScale), this.To = this.yo("right", s2.rightPriceScale), this.ko.zl().i(this.Ro.bind(this, this.ko), this), this.To.zl().i(this.Ro.bind(this, this.To), this), this.Do(s2);
  }
  Do(t2) {
    if (t2.leftPriceScale && this.ko.hr(t2.leftPriceScale), t2.rightPriceScale && this.To.hr(t2.rightPriceScale), t2.localization && (this.ko.ga(), this.To.ga()), t2.overlayPriceScales) {
      const i2 = Array.from(this.Mo.values());
      for (const s2 of i2) {
        const i3 = u(s2[0].$t());
        i3.hr(t2.overlayPriceScales), t2.localization && i3.ga();
      }
    }
  }
  Io(t2) {
    switch (t2) {
      case "left":
        return this.ko;
      case "right":
        return this.To;
    }
    return this.Mo.has(t2) ? _(this.Mo.get(t2))[0].$t() : null;
  }
  m() {
    this.ni().Bo().u(this), this.ko.zl().u(this), this.To.zl().u(this), this.fl.forEach((t2) => {
      t2.m && t2.m();
    }), this.yh = this.yh.filter((t2) => {
      const i2 = t2.oh();
      return i2.detached && i2.detached(), false;
    }), this.Co.p();
  }
  Vo() {
    return this.xo;
  }
  Eo(t2) {
    this.xo = t2;
  }
  ni() {
    return this.es;
  }
  ns() {
    return this.bo;
  }
  Kt() {
    return this.nl;
  }
  Ao(t2) {
    this.bo = t2, this.zo();
  }
  Ll(t2) {
    this.nl = t2, this.ko.Ll(t2), this.To.Ll(t2), this.fl.forEach((i2) => {
      if (this.$n(i2)) {
        const s2 = i2.$t();
        null !== s2 && s2.Ll(t2);
      }
    }), this.zo();
  }
  Lo(t2) {
    this.So = t2;
  }
  Oo() {
    return this.So;
  }
  No() {
    return this.fl.filter(gi);
  }
  xa() {
    return this.fl;
  }
  $n(t2) {
    const i2 = t2.$t();
    return null === i2 || this.ko !== i2 && this.To !== i2;
  }
  Ql(t2, i2, s2) {
    this.Fo(t2, i2, s2 ? t2.us() : this.fl.length);
  }
  so(t2, i2) {
    const s2 = this.fl.indexOf(t2);
    o$1(-1 !== s2, "removeDataSource: invalid data source"), this.fl.splice(s2, 1), i2 || this.fl.forEach((t3, i3) => t3.cs(i3));
    const n2 = u(t2.$t()).Ma();
    if (this.Mo.has(n2)) {
      const i3 = _(this.Mo.get(n2)), s3 = i3.indexOf(t2);
      -1 !== s3 && (i3.splice(s3, 1), 0 === i3.length && this.Mo.delete(n2));
    }
    const e2 = t2.$t();
    e2 && e2.xa().indexOf(t2) >= 0 && (e2.so(t2), this.Wo(e2)), this.vl = null;
  }
  Yn(t2) {
    return t2 === this.ko ? "left" : t2 === this.To ? "right" : "overlay";
  }
  Ho() {
    return this.ko;
  }
  Uo() {
    return this.To;
  }
  $o(t2, i2) {
    t2.ro(i2);
  }
  qo(t2, i2) {
    t2.ho(i2), this.zo();
  }
  Yo(t2) {
    t2.ao();
  }
  jo(t2, i2) {
    t2.lo(i2);
  }
  Ko(t2, i2) {
    t2.oo(i2), this.zo();
  }
  Xo(t2) {
    t2._o();
  }
  zo() {
    this.fl.forEach((t2) => {
      t2.$s();
    });
  }
  Ds() {
    let t2 = null;
    return this.es.F().rightPriceScale.visible && 0 !== this.To.xa().length ? t2 = this.To : this.es.F().leftPriceScale.visible && 0 !== this.ko.xa().length ? t2 = this.ko : 0 !== this.fl.length && (t2 = this.fl[0].$t()), null === t2 && (t2 = this.To), t2;
  }
  qn() {
    let t2 = null;
    return this.es.F().rightPriceScale.visible ? t2 = this.To : this.es.F().leftPriceScale.visible && (t2 = this.ko), t2;
  }
  Wo(t2) {
    null !== t2 && t2.Dl() && this.Go(t2);
  }
  Zo(t2) {
    const i2 = this.dh.Ce();
    t2.Tl({ hn: true }), null !== i2 && t2.po(i2), this.zo();
  }
  Jo() {
    this.Go(this.ko), this.Go(this.To);
  }
  Qo() {
    this.Wo(this.ko), this.Wo(this.To), this.fl.forEach((t2) => {
      this.$n(t2) && this.Wo(t2.$t());
    }), this.zo(), this.es.ar();
  }
  Et() {
    return null === this.vl && (this.vl = pi(this.fl)), this.vl;
  }
  t_(t2, i2) {
    i2 = Zt(i2, 0, this.fl.length - 1);
    const s2 = this.fl.indexOf(t2);
    o$1(-1 !== s2, "setSeriesOrder: invalid data source"), this.fl.splice(s2, 1), this.fl.splice(i2, 0, t2), this.fl.forEach((t3, i3) => t3.cs(i3)), this.vl = null;
    for (const t3 of [this.ko, this.To]) t3.io(), t3.ga();
    this.es.ar();
  }
  zt() {
    return this.Et().filter(gi);
  }
  i_() {
    return this.Co;
  }
  s_() {
    return this.Po;
  }
  ua(t2) {
    this.yh.push(new At(t2));
  }
  ca(t2) {
    this.yh = this.yh.filter((i2) => i2.oh() !== t2), t2.detached && t2.detached(), this.es.ar();
  }
  da() {
    return this.yh;
  }
  ea(t2, i2) {
    return this.yh.map((s2) => s2.ht(t2, i2)).filter((t3) => null !== t3);
  }
  Go(t2) {
    const i2 = t2.fo();
    if (i2 && i2.length > 0 && !this.dh.Zi()) {
      const i3 = this.dh.Ce();
      null !== i3 && t2.po(i3);
    }
    t2.$s();
  }
  Fo(t2, i2, s2) {
    let n2 = this.Io(i2);
    if (null === n2 && (n2 = this.yo(i2, this.es.F().overlayPriceScales)), this.fl.splice(s2, 0, t2), !G(i2)) {
      const s3 = this.Mo.get(i2) || [];
      s3.push(t2), this.Mo.set(i2, s3);
    }
    t2.cs(s2), n2.Ql(t2), t2.ds(n2), this.Wo(n2), this.vl = null;
  }
  Ro(t2, i2, s2) {
    i2.te !== s2.te && this.Go(t2);
  }
  yo(t2, i2) {
    const s2 = { visible: true, autoScale: true, ...M(i2) }, n2 = new Mi(t2, s2, this.es.F().layout, this.es.F().localization, this.es.Ji());
    return n2.Ll(this.Kt()), n2;
  }
}
function xi(t2) {
  return { n_: t2.n_, e_: { externalId: t2.r_.externalId }, h_: t2.r_.cursorStyle };
}
function Si(t2, i2, s2, n2) {
  for (const e2 of t2) {
    const t3 = e2.Bt(n2);
    if (null !== t3 && t3.ht) {
      const n3 = t3.ht(i2, s2);
      if (null !== n3) return { a_: e2, e_: n3 };
    }
  }
  return null;
}
function Ci(t2) {
  return void 0 !== t2.qs;
}
function Pi(t2, i2, s2) {
  const n2 = [t2, ...t2.Et()], e2 = i2 < 1e9 ? function(t3, i3, s3) {
    var _a3;
    let n3, e3;
    for (const a2 of t3) {
      const t4 = ((_a3 = a2.ea) == null ? void 0 : _a3.call(a2, i3, s3)) ?? [];
      for (const i4 of t4) r2 = i4.zOrder, h2 = n3 == null ? void 0 : n3.zOrder, (!h2 || "top" === r2 && "top" !== h2 || "normal" === r2 && "bottom" === h2) && (n3 = i4, e3 = a2);
    }
    var r2, h2;
    return n3 && e3 ? { r_: n3, n_: e3 } : null;
  }(n2, i2, s2) : null;
  if ("top" === (e2 == null ? void 0 : e2.r_.zOrder)) return xi(e2);
  for (const r2 of n2) {
    if (e2 && e2.n_ === r2 && "bottom" !== e2.r_.zOrder && !e2.r_.isBackground) return xi(e2);
    if (Ci(r2)) {
      const n3 = Si(r2.qs(t2), i2, s2, t2);
      if (null !== n3) return { n_: r2, a_: n3.a_, e_: n3.e_ };
    }
    if (e2 && e2.n_ === r2 && "bottom" !== e2.r_.zOrder && e2.r_.isBackground) return xi(e2);
  }
  return (e2 == null ? void 0 : e2.r_) ? xi(e2) : null;
}
class ki {
  constructor(t2, i2, s2 = 50) {
    this.Rn = 0, this.Dn = 1, this.In = 1, this.Vn = /* @__PURE__ */ new Map(), this.Bn = /* @__PURE__ */ new Map(), this.l_ = t2, this.o_ = i2, this.En = s2;
  }
  __(t2) {
    const i2 = t2.time, s2 = this.o_.cacheKey(i2), n2 = this.Vn.get(s2);
    if (void 0 !== n2) return n2.u_;
    if (this.Rn === this.En) {
      const t3 = this.Bn.get(this.In);
      this.Bn.delete(this.In), this.Vn.delete(_(t3)), this.In++, this.Rn--;
    }
    const e2 = this.l_(t2);
    return this.Vn.set(s2, { u_: e2, zn: this.Dn }), this.Bn.set(this.Dn, s2), this.Rn++, this.Dn++, e2;
  }
}
class yi {
  constructor(t2, i2) {
    o$1(t2 <= i2, "right should be >= left"), this.c_ = t2, this.d_ = i2;
  }
  $h() {
    return this.c_;
  }
  ki() {
    return this.d_;
  }
  f_() {
    return this.d_ - this.c_ + 1;
  }
  ye(t2) {
    return this.c_ <= t2 && t2 <= this.d_;
  }
  We(t2) {
    return this.c_ === t2.$h() && this.d_ === t2.ki();
  }
}
function Ti(t2, i2) {
  return null === t2 || null === i2 ? t2 === i2 : t2.We(i2);
}
class Ri {
  constructor() {
    this.p_ = /* @__PURE__ */ new Map(), this.Vn = null, this.v_ = false;
  }
  m_(t2) {
    this.v_ = t2, this.Vn = null;
  }
  w_(t2, i2) {
    this.M_(i2), this.Vn = null;
    for (let s2 = i2; s2 < t2.length; ++s2) {
      const i3 = t2[s2];
      let n2 = this.p_.get(i3.timeWeight);
      void 0 === n2 && (n2 = [], this.p_.set(i3.timeWeight, n2)), n2.push({ index: s2, time: i3.time, weight: i3.timeWeight, originalTime: i3.originalTime });
    }
  }
  g_(t2, i2, s2, n2, e2) {
    const r2 = Math.ceil(i2 / t2);
    return null !== this.Vn && this.Vn.b_ === r2 && e2 === this.Vn.x_ && s2 === this.Vn.S_ || (this.Vn = { x_: e2, S_: s2, Ba: this.C_(r2, s2, n2), b_: r2 }), this.Vn.Ba;
  }
  M_(t2) {
    if (0 === t2) return void this.p_.clear();
    const i2 = [];
    this.p_.forEach((s2, n2) => {
      t2 <= s2[0].index ? i2.push(n2) : s2.splice(kt(s2, t2, (i3) => i3.index < t2), 1 / 0);
    });
    for (const t3 of i2) this.p_.delete(t3);
  }
  C_(t2, i2, s2) {
    let n2 = [];
    const e2 = (t3) => !i2 || s2.has(t3.index);
    for (const i3 of Array.from(this.p_.keys()).sort((t3, i4) => i4 - t3)) {
      if (!this.p_.get(i3)) continue;
      const s3 = n2;
      n2 = [];
      const r2 = s3.length;
      let h2 = 0;
      const a2 = _(this.p_.get(i3)), l2 = a2.length;
      let o2 = 1 / 0, u2 = -1 / 0;
      for (let i4 = 0; i4 < l2; i4++) {
        const l3 = a2[i4], _2 = l3.index;
        for (; h2 < r2; ) {
          const t3 = s3[h2], i5 = t3.index;
          if (!(i5 < _2 && e2(t3))) {
            o2 = i5;
            break;
          }
          h2++, n2.push(t3), u2 = i5, o2 = 1 / 0;
        }
        if (o2 - _2 >= t2 && _2 - u2 >= t2 && e2(l3)) n2.push(l3), u2 = _2;
        else if (this.v_) return s3;
      }
      for (; h2 < r2; h2++) e2(s3[h2]) && n2.push(s3[h2]);
    }
    return n2;
  }
}
class Di {
  constructor(t2) {
    this.P_ = t2;
  }
  k_() {
    return null === this.P_ ? null : new yi(Math.floor(this.P_.$h()), Math.ceil(this.P_.ki()));
  }
  y_() {
    return this.P_;
  }
  static T_() {
    return new Di(null);
  }
}
function Ii(t2, i2) {
  return t2.weight > i2.weight ? t2 : i2;
}
class Bi {
  constructor(t2, i2, s2, n2) {
    this.bo = 0, this.R_ = null, this.D_ = [], this.Ml = null, this.wl = null, this.I_ = new Ri(), this.B_ = /* @__PURE__ */ new Map(), this.V_ = Di.T_(), this.E_ = true, this.A_ = new d$1(), this.z_ = new d$1(), this.L_ = new d$1(), this.O_ = null, this.N_ = null, this.F_ = /* @__PURE__ */ new Map(), this.W_ = -1, this.H_ = [], this.Ts = i2, this.Sl = s2, this.U_ = i2.rightOffset, this.q_ = i2.barSpacing, this.es = t2, this.o_ = n2, this.Y_(), this.I_.m_(i2.uniformDistribution), this.j_();
  }
  F() {
    return this.Ts;
  }
  K_(t2) {
    f(this.Sl, t2), this.X_(), this.Y_();
  }
  hr(t2, i2) {
    f(this.Ts, t2), this.Ts.fixLeftEdge && this.G_(), this.Ts.fixRightEdge && this.Z_(), void 0 !== t2.barSpacing && this.es.mn(t2.barSpacing), void 0 !== t2.rightOffset && this.es.wn(t2.rightOffset), void 0 === t2.minBarSpacing && void 0 === t2.maxBarSpacing || this.es.mn(t2.barSpacing ?? this.q_), void 0 !== t2.ignoreWhitespaceIndices && t2.ignoreWhitespaceIndices !== this.Ts.ignoreWhitespaceIndices && this.j_(), this.X_(), this.Y_(), this.L_.p();
  }
  J_(t2) {
    var _a3;
    return ((_a3 = this.D_[t2]) == null ? void 0 : _a3.time) ?? null;
  }
  Bs(t2) {
    var _a3, _b3;
    const i2 = this.D_.length - 1;
    if (t2 > i2) {
      const s2 = t2 - i2, n2 = this.D_[i2].originalTime;
      return ((_a3 = this.F().extendedScale) == null ? void 0 : _a3.getExtendedTime(n2, s2)) ?? null;
    }
    return ((_b3 = this.D_[t2]) == null ? void 0 : _b3.time) ?? null;
  }
  Q_(t2) {
    return this.D_[t2] ?? null;
  }
  rs(t2) {
    var _a3;
    const i2 = this.D_.length - 1;
    if (t2 > i2) {
      const s2 = t2 - i2, n2 = this.D_[i2].originalTime, e2 = (_a3 = this.F().extendedScale) == null ? void 0 : _a3.getExtendedTime(n2, s2);
      return { timeWeight: 0, time: e2, originalTime: e2 };
    }
    return this.D_[t2] ?? null;
  }
  tu(t2, i2) {
    if (this.D_.length < 1) return null;
    if (this.o_.key(t2) > this.o_.key(this.D_[this.D_.length - 1].time)) return i2 ? this.D_.length - 1 : null;
    const s2 = kt(this.D_, this.o_.key(t2), (t3, i3) => this.o_.key(t3.time) < i3);
    return this.o_.key(t2) < this.o_.key(this.D_[s2].time) ? i2 ? s2 : null : s2;
  }
  Zi() {
    return 0 === this.bo || 0 === this.D_.length || null === this.R_;
  }
  iu() {
    return this.D_.length > 0;
  }
  Ce() {
    return this.su(), this.V_.k_();
  }
  nu() {
    return this.su(), this.V_.y_();
  }
  eu() {
    const t2 = this.Ce();
    if (null === t2) return null;
    const i2 = { from: t2.$h(), to: t2.ki() };
    return this.ru(i2);
  }
  ru(t2) {
    const i2 = Math.round(t2.from), s2 = Math.round(t2.to), n2 = u(this.hu()), e2 = u(this.au());
    return { from: u(this.Q_(Math.max(n2, i2))), to: u(this.Q_(Math.min(e2, s2))) };
  }
  lu(t2) {
    return { from: u(this.tu(t2.from, true)), to: u(this.tu(t2.to, true)) };
  }
  ns() {
    return this.bo;
  }
  Ao(t2) {
    if (!isFinite(t2) || t2 <= 0) return;
    if (this.bo === t2) return;
    const i2 = this.nu(), s2 = this.bo;
    if (this.bo = t2, this.E_ = true, this.Ts.lockVisibleTimeRangeOnResize && 0 !== s2) {
      const i3 = this.q_ * t2 / s2;
      this.q_ = i3;
    }
    if (this.Ts.fixLeftEdge && null !== i2 && i2.$h() <= 0) {
      const i3 = s2 - t2;
      this.U_ -= Math.round(i3 / this.q_) + 1, this.E_ = true;
    }
    this.ou(), this._u();
  }
  Xt(t2) {
    if (this.Zi() || !v(t2)) return 0;
    const i2 = this.uu() + this.U_ - t2;
    return this.bo - (i2 + 0.5) * this.q_ - 1;
  }
  cu(t2, i2) {
    const s2 = this.uu(), n2 = void 0 === i2 ? 0 : i2.from, e2 = void 0 === i2 ? t2.length : i2.to;
    for (let i3 = n2; i3 < e2; i3++) {
      const n3 = t2[i3].xt, e3 = s2 + this.U_ - n3, r2 = this.bo - (e3 + 0.5) * this.q_ - 1;
      t2[i3].ft = r2;
    }
  }
  du(t2, i2) {
    const s2 = Math.ceil(this.fu(t2));
    return i2 && this.Ts.ignoreWhitespaceIndices && !this.pu(s2) ? this.vu(s2) : s2;
  }
  wn(t2) {
    this.E_ = true, this.U_ = t2, this._u(), this.es.mu(), this.es.ar();
  }
  wu() {
    return this.q_;
  }
  mn(t2) {
    this.Mu(t2), this._u(), this.es.mu(), this.es.ar();
  }
  gu() {
    return this.U_;
  }
  Ba() {
    if (this.Zi()) return null;
    if (null !== this.N_) return this.N_;
    const t2 = this.q_, i2 = 5 * (this.es.F().layout.fontSize + 4) / 8 * (this.Ts.tickMarkMaxCharacterLength || 8), s2 = Math.round(i2 / t2), n2 = u(this.Ce()), e2 = Math.max(n2.$h(), n2.$h() - s2), r2 = Math.max(n2.ki(), n2.ki() - s2), h2 = this.I_.g_(t2, i2, this.Ts.ignoreWhitespaceIndices, this.F_, this.W_), a2 = this.hu() + s2, l2 = this.au() - s2, o2 = this.bu(), _2 = this.Ts.fixLeftEdge || o2, c2 = this.Ts.fixRightEdge || o2;
    let d3 = 0;
    for (const t3 of h2) {
      if (!(e2 <= t3.index && t3.index <= r2)) continue;
      let s3;
      d3 < this.H_.length ? (s3 = this.H_[d3], s3.coord = this.Xt(t3.index), s3.label = this.xu(t3), s3.weight = t3.weight) : (s3 = { needAlignCoordinate: false, coord: this.Xt(t3.index), label: this.xu(t3), weight: t3.weight }, this.H_.push(s3)), this.q_ > i2 / 2 && !o2 ? s3.needAlignCoordinate = false : s3.needAlignCoordinate = _2 && t3.index <= a2 || c2 && t3.index >= l2, d3++;
    }
    return this.H_.length = d3, this.N_ = this.H_, this.H_;
  }
  Su() {
    this.E_ = true, this.mn(this.Ts.barSpacing), this.wn(this.Ts.rightOffset);
  }
  Cu(t2) {
    this.E_ = true, this.R_ = t2, this._u(), this.G_();
  }
  Pu(t2, i2) {
    const s2 = this.fu(t2), n2 = this.wu(), e2 = n2 + i2 * (n2 / 10);
    this.mn(e2), this.Ts.rightBarStaysOnScroll || this.wn(this.gu() + (s2 - this.fu(t2)));
  }
  ro(t2) {
    this.Ml && this._o(), null === this.wl && null === this.O_ && (this.Zi() || (this.wl = t2, this.ku()));
  }
  ho(t2) {
    if (null === this.O_) return;
    const i2 = Zt(this.bo - t2, 0, this.bo), s2 = Zt(this.bo - u(this.wl), 0, this.bo);
    0 !== i2 && 0 !== s2 && this.mn(this.O_.wu * i2 / s2);
  }
  ao() {
    null !== this.wl && (this.wl = null, this.yu());
  }
  lo(t2) {
    null === this.Ml && null === this.O_ && (this.Zi() || (this.Ml = t2, this.ku()));
  }
  oo(t2) {
    if (null === this.Ml) return;
    const i2 = (this.Ml - t2) / this.wu();
    this.U_ = u(this.O_).gu + i2, this.E_ = true, this._u();
  }
  _o() {
    null !== this.Ml && (this.Ml = null, this.yu());
  }
  Tu(t2 = 400) {
    this.Ru(this.Ts.rightOffset, t2);
  }
  Ru(t2, i2 = 400) {
    if (!isFinite(t2)) throw new RangeError("offset is required and must be finite number");
    if (!isFinite(i2) || i2 <= 0) throw new RangeError("animationDuration (optional) must be finite positive number");
    const s2 = this.U_;
    this.es.fn(new Vi(s2, t2, i2));
  }
  Dt(t2, i2) {
    this.E_ = true, this.D_ = t2, this.I_.w_(t2, i2), this._u();
  }
  Du() {
    return this.A_;
  }
  Iu() {
    return this.z_;
  }
  Bu() {
    return this.L_;
  }
  uu() {
    return this.R_ || 0;
  }
  Vu(t2) {
    const i2 = t2.f_();
    this.Mu(this.bo / i2), this.U_ = t2.ki() - this.uu(), this._u(), this.E_ = true, this.es.mu(), this.es.ar();
  }
  Eu() {
    const t2 = this.hu(), i2 = this.au();
    null !== t2 && null !== i2 && this.Vu(new yi(t2, i2 + this.Ts.rightOffset));
  }
  Au(t2) {
    const i2 = new yi(t2.from, t2.to);
    this.Vu(i2);
  }
  hs(t2) {
    return void 0 !== this.Sl.timeFormatter ? this.Sl.timeFormatter(t2.originalTime) : this.o_.formatHorzItem(t2.time);
  }
  j_() {
    if (!this.Ts.ignoreWhitespaceIndices) return;
    this.F_.clear();
    const t2 = this.es.Js();
    for (const i2 of t2) for (const t3 of i2.wa()) this.F_.set(t3, true);
    this.W_++;
  }
  zu() {
    return this.hu();
  }
  Lu() {
    return this.au();
  }
  Ou() {
    return this.D_;
  }
  bu() {
    const t2 = this.es.F().handleScroll, i2 = this.es.F().handleScale;
    return !(t2.horzTouchDrag || t2.mouseWheel || t2.pressedMouseMove || t2.vertTouchDrag || i2.axisDoubleClickReset.time || i2.axisPressedMouseMove.time || i2.mouseWheel || i2.pinch);
  }
  hu() {
    return 0 === this.D_.length ? null : 0;
  }
  au() {
    return 0 === this.D_.length ? null : this.D_.length - 1;
  }
  Nu(t2) {
    return (this.bo - 1 - t2) / this.q_;
  }
  fu(t2) {
    const i2 = this.Nu(t2), s2 = this.uu() + this.U_ - i2;
    return Math.round(1e6 * s2) / 1e6;
  }
  Mu(t2) {
    const i2 = this.q_;
    this.q_ = t2, this.ou(), i2 !== this.q_ && (this.E_ = true, this.Fu());
  }
  su() {
    if (!this.E_) return;
    if (this.E_ = false, this.Zi()) return void this.Wu(Di.T_());
    const t2 = this.uu(), i2 = this.bo / this.q_, s2 = this.U_ + t2, n2 = new yi(s2 - i2 + 1, s2);
    this.Wu(new Di(n2));
  }
  ou() {
    const t2 = Zt(this.q_, this.Hu(), this.Uu());
    this.q_ !== t2 && (this.q_ = t2, this.E_ = true);
  }
  Uu() {
    return this.Ts.maxBarSpacing > 0 ? this.Ts.maxBarSpacing : 0.5 * this.bo;
  }
  Hu() {
    return this.Ts.fixLeftEdge && this.Ts.fixRightEdge && 0 !== this.D_.length ? this.bo / this.D_.length : this.Ts.minBarSpacing;
  }
  _u() {
    const t2 = this.$u();
    null !== t2 && this.U_ < t2 && (this.U_ = t2, this.E_ = true);
    const i2 = this.qu();
    this.U_ > i2 && (this.U_ = i2, this.E_ = true);
  }
  $u() {
    const t2 = this.hu(), i2 = this.R_;
    if (null === t2 || null === i2) return null;
    return t2 - i2 - 1 + (this.Ts.fixLeftEdge ? this.bo / this.q_ : Math.min(2, this.D_.length));
  }
  qu() {
    return this.Ts.fixRightEdge ? 0 : this.bo / this.q_ - Math.min(2, this.D_.length);
  }
  ku() {
    this.O_ = { wu: this.wu(), gu: this.gu() };
  }
  yu() {
    this.O_ = null;
  }
  xu(t2) {
    let i2 = this.B_.get(t2.weight);
    return void 0 === i2 && (i2 = new ki((t3) => this.Yu(t3), this.o_), this.B_.set(t2.weight, i2)), i2.__(t2);
  }
  Yu(t2) {
    return this.o_.formatTickmark(t2, this.Sl);
  }
  Wu(t2) {
    const i2 = this.V_;
    this.V_ = t2, Ti(i2.k_(), this.V_.k_()) || this.A_.p(), Ti(i2.y_(), this.V_.y_()) || this.z_.p(), this.Fu();
  }
  Fu() {
    this.N_ = null;
  }
  X_() {
    this.Fu(), this.B_.clear();
  }
  Y_() {
    this.o_.updateFormatter(this.Sl);
  }
  G_() {
    if (!this.Ts.fixLeftEdge) return;
    const t2 = this.hu();
    if (null === t2) return;
    const i2 = this.Ce();
    if (null === i2) return;
    const s2 = i2.$h() - t2;
    if (s2 < 0) {
      const t3 = this.U_ - s2 - 1;
      this.wn(t3);
    }
    this.ou();
  }
  Z_() {
    this._u(), this.ou();
  }
  pu(t2) {
    return !this.Ts.ignoreWhitespaceIndices || (this.F_.get(t2) || false);
  }
  vu(t2) {
    const i2 = function* (t3) {
      const i3 = Math.round(t3), s3 = i3 < t3;
      let n2 = 1;
      for (; ; ) s3 ? (yield i3 + n2, yield i3 - n2) : (yield i3 - n2, yield i3 + n2), n2++;
    }(t2), s2 = this.au();
    for (; s2; ) {
      const t3 = i2.next().value;
      if (this.F_.get(t3)) return t3;
      if (t3 < 0 || t3 > s2) break;
    }
    return t2;
  }
}
class Vi {
  constructor(t2, i2, s2) {
    this.ju = performance.now(), this.Ku = t2, this.Xu = i2, this.Gu = s2;
  }
  Fs(t2) {
    const i2 = this.Zu(t2), s2 = Ei(i2);
    return n2 = this.Ku, e2 = this.Xu, n2 * (1 - (r2 = s2)) + e2 * r2;
    var n2, e2, r2;
  }
  Ju(t2) {
    return (t2 - this.ju) / this.Gu >= 1;
  }
  Zu(t2) {
    const i2 = t2 - this.ju;
    return i2 >= this.Gu ? 1 : i2 / this.Gu;
  }
}
const Ei = (t2) => t2 < 0.5 ? 16 * t2 * t2 * t2 * t2 * t2 : 1 + 16 * --t2 * t2 * t2 * t2 * t2;
var Ai, zi, Li, Oi, Ni;
!function(t2) {
  t2[t2.OnTouchEnd = 0] = "OnTouchEnd", t2[t2.OnNextTap = 1] = "OnNextTap";
}(Ai || (Ai = {}));
class Fi {
  constructor(t2, i2, s2) {
    this.Qu = [], this.tc = [], this.bo = 0, this.sc = null, this.nc = null, this.ec = new d$1(), this.rc = new d$1(), this.hc = null, this.ac = t2, this.Ts = i2, this.o_ = s2, this.Cl = new y(this.Ts.layout.colorParsers), this.lc = new C(this), this.dh = new Bi(this, i2.timeScale, this.Ts.localization, s2), this.Tt = new X(this, i2.crosshair), this.oc = new Gt(i2.crosshair), i2.addDefaultPane && (this._c(0), this.Qu[0].Eo(2)), this.uc = this.cc(0), this.dc = this.cc(1);
  }
  Eh() {
    this.fc(Z.Sn());
  }
  ar() {
    this.fc(Z.xn());
  }
  Zh() {
    this.fc(new Z(1));
  }
  Ah(t2) {
    const i2 = this.vc(t2);
    this.fc(i2);
  }
  mc() {
    return this.sc;
  }
  wc(t2) {
    var _a3, _b3, _c2, _d2;
    if (((_a3 = this.sc) == null ? void 0 : _a3.n_) === (t2 == null ? void 0 : t2.n_) && ((_c2 = (_b3 = this.sc) == null ? void 0 : _b3.e_) == null ? void 0 : _c2.externalId) === ((_d2 = t2 == null ? void 0 : t2.e_) == null ? void 0 : _d2.externalId)) return;
    const i2 = this.sc;
    this.sc = t2, null !== i2 && this.Ah(i2.n_), null !== t2 && t2.n_ !== (i2 == null ? void 0 : i2.n_) && this.Ah(t2.n_);
  }
  Mc() {
    return this.nc;
  }
  gc(t2) {
    this.nc = t2;
  }
  F() {
    return this.Ts;
  }
  hr(t2) {
    f(this.Ts, t2), this.Qu.forEach((i2) => i2.Do(t2)), void 0 !== t2.timeScale && this.dh.hr(t2.timeScale), void 0 !== t2.localization && this.dh.K_(t2.localization), (t2.leftPriceScale || t2.rightPriceScale) && this.ec.p(), this.uc = this.cc(0), this.dc = this.cc(1), this.Eh();
  }
  bc(t2, i2, s2 = 0) {
    const n2 = this.Qu[s2];
    if (void 0 === n2) return;
    if ("left" === t2) return f(this.Ts, { leftPriceScale: i2 }), n2.Do({ leftPriceScale: i2 }), this.ec.p(), void this.Eh();
    if ("right" === t2) return f(this.Ts, { rightPriceScale: i2 }), n2.Do({ rightPriceScale: i2 }), this.ec.p(), void this.Eh();
    const e2 = this.xc(t2, s2);
    null !== e2 && (e2.$t.hr(i2), this.ec.p());
  }
  xc(t2, i2) {
    const s2 = this.Qu[i2];
    if (void 0 === s2) return null;
    const n2 = s2.Io(t2);
    return null !== n2 ? { Ks: s2, $t: n2 } : null;
  }
  Ot() {
    return this.dh;
  }
  Xs() {
    return this.Qu;
  }
  Sc() {
    return this.Tt;
  }
  Cc() {
    return this.rc;
  }
  Pc(t2, i2) {
    t2.Ll(i2), this.mu();
  }
  Ao(t2) {
    this.bo = t2, this.dh.Ao(this.bo), this.Qu.forEach((i2) => i2.Ao(t2)), this.mu();
  }
  kc(t2) {
    1 !== this.Qu.length && (o$1(t2 >= 0 && t2 < this.Qu.length, "Invalid pane index"), this.Qu.splice(t2, 1), this.Eh());
  }
  yc(t2, i2) {
    if (this.Qu.length < 2) return;
    o$1(t2 >= 0 && t2 < this.Qu.length, "Invalid pane index");
    const s2 = this.Qu[t2], n2 = this.Qu.reduce((t3, i3) => t3 + i3.Vo(), 0), e2 = this.Qu.reduce((t3, i3) => t3 + i3.Kt(), 0), r2 = e2 - 30 * (this.Qu.length - 1);
    i2 = Math.min(r2, Math.max(30, i2));
    const h2 = n2 / e2, a2 = s2.Kt();
    s2.Eo(i2 * h2);
    let l2 = i2 - a2, _2 = this.Qu.length - 1;
    for (const t3 of this.Qu) if (t3 !== s2) {
      const i3 = Math.min(r2, Math.max(30, t3.Kt() - l2 / _2));
      l2 -= t3.Kt() - i3, _2 -= 1;
      const s3 = i3 * h2;
      t3.Eo(s3);
    }
    this.Eh();
  }
  Tc(t2, i2) {
    o$1(t2 >= 0 && t2 < this.Qu.length && i2 >= 0 && i2 < this.Qu.length, "Invalid pane index");
    const s2 = this.Qu[t2], n2 = this.Qu[i2];
    this.Qu[t2] = n2, this.Qu[i2] = s2, this.Eh();
  }
  Rc(t2, i2) {
    if (o$1(t2 >= 0 && t2 < this.Qu.length && i2 >= 0 && i2 < this.Qu.length, "Invalid pane index"), t2 === i2) return;
    const [s2] = this.Qu.splice(t2, 1);
    this.Qu.splice(i2, 0, s2), this.Eh();
  }
  $o(t2, i2, s2) {
    t2.$o(i2, s2);
  }
  qo(t2, i2, s2) {
    t2.qo(i2, s2), this.zh(), this.fc(this.Dc(t2, 2));
  }
  Yo(t2, i2) {
    t2.Yo(i2), this.fc(this.Dc(t2, 2));
  }
  jo(t2, i2, s2) {
    i2.Dl() || t2.jo(i2, s2);
  }
  Ko(t2, i2, s2) {
    i2.Dl() || (t2.Ko(i2, s2), this.zh(), this.fc(this.Dc(t2, 2)));
  }
  Xo(t2, i2) {
    i2.Dl() || (t2.Xo(i2), this.fc(this.Dc(t2, 2)));
  }
  Zo(t2, i2) {
    t2.Zo(i2), this.fc(this.Dc(t2, 2));
  }
  Ic(t2) {
    this.dh.ro(t2);
  }
  Bc(t2, i2) {
    const s2 = this.Ot();
    if (s2.Zi() || 0 === i2) return;
    const n2 = s2.ns();
    t2 = Math.max(1, Math.min(t2, n2)), s2.Pu(t2, i2), this.mu();
  }
  Vc(t2) {
    this.Ec(0), this.Ac(t2), this.zc();
  }
  Lc(t2) {
    this.dh.ho(t2), this.mu();
  }
  Oc() {
    this.dh.ao(), this.ar();
  }
  Ec(t2) {
    this.dh.lo(t2);
  }
  Ac(t2) {
    this.dh.oo(t2), this.mu();
  }
  zc() {
    this.dh._o(), this.ar();
  }
  Js() {
    return this.tc;
  }
  Nc(t2, i2, s2, n2, e2) {
    this.Tt.Es(t2, i2);
    let r2 = NaN, h2 = this.dh.du(t2, true);
    const a2 = this.dh.Ce();
    null !== a2 && (h2 = Math.min(Math.max(a2.$h(), h2), a2.ki()));
    const l2 = n2.Ds(), o2 = l2.Ft();
    if (null !== o2 && (r2 = l2.Is(i2, o2)), r2 = this.oc.ba(r2, h2, n2), this.Tt.Os(h2, r2, n2), this.Zh(), !e2) {
      const e3 = Pi(n2, t2, i2);
      this.wc(e3 && { n_: e3.n_, e_: e3.e_, h_: e3.h_ || null }), this.rc.p(this.Tt.Lt(), { x: t2, y: i2 }, s2);
    }
  }
  Fc() {
    const t2 = this.Tt.Fs(), i2 = this.Tt.Ws(), s2 = i2 ? this.Wc(i2) : void 0;
    return { x: t2.x, y: t2.y, paneIndex: s2 };
  }
  Hc(t2, i2, s2) {
    const n2 = s2.Ds(), e2 = n2.Ft(), r2 = n2.Ut(t2, u(e2)), h2 = this.dh.tu(i2, true), a2 = this.dh.Xt(u(h2));
    this.Nc(a2, r2, null, s2, true);
  }
  Uc(t2) {
    this.Sc().Hs(), this.Zh(), t2 || this.rc.p(null, null, null);
  }
  zh() {
    const t2 = this.Tt.Ks();
    if (null !== t2) {
      const i2 = this.Tt.zs(), s2 = this.Tt.Ls();
      this.Nc(i2, s2, null, t2);
    }
    this.Tt.$s();
  }
  $c(t2, i2, s2) {
    const n2 = this.dh.J_(0);
    void 0 !== i2 && void 0 !== s2 && this.dh.Dt(i2, s2);
    const e2 = this.dh.J_(0), r2 = this.dh.uu(), h2 = this.dh.Ce();
    if (null !== h2 && null !== n2 && null !== e2) {
      const i3 = h2.ye(r2), a2 = this.o_.key(n2) > this.o_.key(e2), l2 = null !== t2 && t2 > r2 && !a2, o2 = this.dh.F().allowShiftVisibleRangeOnWhitespaceReplacement, _2 = i3 && (!(void 0 === s2) || o2) && this.dh.F().shiftVisibleRangeOnNewBar;
      if (l2 && !_2) {
        const i4 = t2 - r2;
        this.dh.wn(this.dh.gu() - i4);
      }
    }
    this.dh.Cu(t2);
  }
  Oh(t2) {
    null !== t2 && t2.Qo();
  }
  Un(t2) {
    if (function(t3) {
      return t3 instanceof bi;
    }(t2)) return t2;
    const i2 = this.Qu.find((i3) => i3.Et().includes(t2));
    return void 0 === i2 ? null : i2;
  }
  mu() {
    this.Qu.forEach((t2) => t2.Qo()), this.zh();
  }
  m() {
    this.Qu.forEach((t2) => t2.m()), this.Qu.length = 0, this.Ts.localization.priceFormatter = void 0, this.Ts.localization.percentageFormatter = void 0, this.Ts.localization.timeFormatter = void 0;
  }
  qc() {
    return this.lc;
  }
  jn() {
    return this.lc.F();
  }
  Bo() {
    return this.ec;
  }
  Yc(t2, i2) {
    const s2 = this._c(i2);
    this.jc(t2, s2), this.tc.push(t2), 1 === this.tc.length ? this.Eh() : this.ar();
  }
  Kc(t2) {
    const i2 = this.Un(t2), s2 = this.tc.indexOf(t2);
    o$1(-1 !== s2, "Series not found");
    const n2 = u(i2);
    this.tc.splice(s2, 1), n2.so(t2), t2.m && t2.m(), this.dh.j_(), this.Xc(n2);
  }
  Vh(t2, i2) {
    const s2 = u(this.Un(t2));
    s2.so(t2, true), s2.Ql(t2, i2, true);
  }
  Eu() {
    const t2 = Z.xn();
    t2._n(), this.fc(t2);
  }
  Gc(t2) {
    const i2 = Z.xn();
    i2.dn(t2), this.fc(i2);
  }
  vn() {
    const t2 = Z.xn();
    t2.vn(), this.fc(t2);
  }
  mn(t2) {
    const i2 = Z.xn();
    i2.mn(t2), this.fc(i2);
  }
  wn(t2) {
    const i2 = Z.xn();
    i2.wn(t2), this.fc(i2);
  }
  fn(t2) {
    const i2 = Z.xn();
    i2.fn(t2), this.fc(i2);
  }
  un() {
    const t2 = Z.xn();
    t2.un(), this.fc(t2);
  }
  Zc() {
    return this.Ts.rightPriceScale.visible ? "right" : "left";
  }
  Jc(t2, i2) {
    o$1(i2 >= 0, "Index should be greater or equal to 0");
    if (i2 === this.Qc(t2)) return;
    const s2 = u(this.Un(t2));
    s2.so(t2);
    const n2 = this._c(i2);
    this.jc(t2, n2), 0 === s2.xa().length && this.Xc(s2), this.Eh();
  }
  j() {
    return this.dc;
  }
  Y() {
    return this.uc;
  }
  jt(t2) {
    const i2 = this.dc, s2 = this.uc;
    if (i2 === s2) return i2;
    if (t2 = Math.max(0, Math.min(100, Math.round(100 * t2))), null === this.hc || this.hc.wr !== s2 || this.hc.Mr !== i2) this.hc = { wr: s2, Mr: i2, td: /* @__PURE__ */ new Map() };
    else {
      const i3 = this.hc.td.get(t2);
      if (void 0 !== i3) return i3;
    }
    const n2 = this.Cl.nt(s2, i2, t2 / 100);
    return this.hc.td.set(t2, n2), n2;
  }
  Wc(t2) {
    return this.Qu.indexOf(t2);
  }
  Ji() {
    return this.Cl;
  }
  sd() {
    return this.nd();
  }
  nd(t2) {
    const i2 = new bi(this.dh, this);
    this.Qu.push(i2);
    const s2 = t2 ?? this.Qu.length - 1, n2 = Z.Sn();
    return n2.en(s2, { rn: 0, hn: true }), this.fc(n2), i2;
  }
  _c(t2) {
    return o$1(t2 >= 0, "Index should be greater or equal to 0"), (t2 = Math.min(this.Qu.length, t2)) < this.Qu.length ? this.Qu[t2] : this.nd(t2);
  }
  Qc(t2) {
    return this.Qu.findIndex((i2) => i2.No().includes(t2));
  }
  Dc(t2, i2) {
    const s2 = new Z(i2);
    if (null !== t2) {
      const n2 = this.Qu.indexOf(t2);
      s2.en(n2, { rn: i2 });
    }
    return s2;
  }
  vc(t2, i2) {
    return void 0 === i2 && (i2 = 2), this.Dc(this.Un(t2), i2);
  }
  fc(t2) {
    this.ac && this.ac(t2), this.Qu.forEach((t3) => t3.s_().lr().Dt());
  }
  jc(t2, i2) {
    const s2 = t2.F().priceScaleId, n2 = void 0 !== s2 ? s2 : this.Zc();
    i2.Ql(t2, n2), G(n2) || t2.hr(t2.F());
  }
  cc(t2) {
    const i2 = this.Ts.layout;
    return "gradient" === i2.background.type ? 0 === t2 ? i2.background.topColor : i2.background.bottomColor : i2.background.color;
  }
  Xc(t2) {
    !t2.Oo() && 0 === t2.xa().length && this.Qu.length > 1 && this.Qu.splice(this.Wc(t2), 1);
  }
}
function Wi(t2) {
  return !p(t2) && !m(t2);
}
function Hi(t2) {
  return p(t2);
}
!function(t2) {
  t2[t2.Disabled = 0] = "Disabled", t2[t2.Continuous = 1] = "Continuous", t2[t2.OnDataUpdate = 2] = "OnDataUpdate";
}(zi || (zi = {})), function(t2) {
  t2[t2.LastBar = 0] = "LastBar", t2[t2.LastVisible = 1] = "LastVisible";
}(Li || (Li = {})), function(t2) {
  t2.Solid = "solid", t2.VerticalGradient = "gradient";
}(Oi || (Oi = {})), function(t2) {
  t2[t2.Year = 0] = "Year", t2[t2.Month = 1] = "Month", t2[t2.DayOfMonth = 2] = "DayOfMonth", t2[t2.Time = 3] = "Time", t2[t2.TimeWithSeconds = 4] = "TimeWithSeconds";
}(Ni || (Ni = {}));
const Ui = (t2) => t2.getUTCFullYear();
function $i(t2, i2, s2) {
  return i2.replace(/yyyy/g, ((t3) => tt(Ui(t3), 4))(t2)).replace(/yy/g, ((t3) => tt(Ui(t3) % 100, 2))(t2)).replace(/MMMM/g, ((t3, i3) => new Date(t3.getUTCFullYear(), t3.getUTCMonth(), 1).toLocaleString(i3, { month: "long" }))(t2, s2)).replace(/MMM/g, ((t3, i3) => new Date(t3.getUTCFullYear(), t3.getUTCMonth(), 1).toLocaleString(i3, { month: "short" }))(t2, s2)).replace(/MM/g, ((t3) => tt(((t4) => t4.getUTCMonth() + 1)(t3), 2))(t2)).replace(/dd/g, ((t3) => tt(((t4) => t4.getUTCDate())(t3), 2))(t2));
}
class qi {
  constructor(t2 = "yyyy-MM-dd", i2 = "default") {
    this.ed = t2, this.rd = i2;
  }
  __(t2) {
    return $i(t2, this.ed, this.rd);
  }
}
class Yi {
  constructor(t2) {
    this.hd = t2 || "%h:%m:%s";
  }
  __(t2) {
    return this.hd.replace("%h", tt(t2.getUTCHours(), 2)).replace("%m", tt(t2.getUTCMinutes(), 2)).replace("%s", tt(t2.getUTCSeconds(), 2));
  }
}
const ji = { ad: "yyyy-MM-dd", ld: "%h:%m:%s", od: " ", _d: "default" };
class Ki {
  constructor(t2 = {}) {
    const i2 = { ...ji, ...t2 };
    this.ud = new qi(i2.ad, i2._d), this.dd = new Yi(i2.ld), this.fd = i2.od;
  }
  __(t2) {
    return `${this.ud.__(t2)}${this.fd}${this.dd.__(t2)}`;
  }
}
function Xi(t2) {
  return 60 * t2 * 60 * 1e3;
}
function Gi(t2) {
  return 60 * t2 * 1e3;
}
const Zi = [{ pd: (Ji = 1, 1e3 * Ji), vd: 10 }, { pd: Gi(1), vd: 20 }, { pd: Gi(5), vd: 21 }, { pd: Gi(30), vd: 22 }, { pd: Xi(1), vd: 30 }, { pd: Xi(3), vd: 31 }, { pd: Xi(6), vd: 32 }, { pd: Xi(12), vd: 33 }];
var Ji;
function Qi(t2, i2) {
  if (t2.getUTCFullYear() !== i2.getUTCFullYear()) return 70;
  if (t2.getUTCMonth() !== i2.getUTCMonth()) return 60;
  if (t2.getUTCDate() !== i2.getUTCDate()) return 50;
  for (let s2 = Zi.length - 1; s2 >= 0; --s2) if (Math.floor(i2.getTime() / Zi[s2].pd) !== Math.floor(t2.getTime() / Zi[s2].pd)) return Zi[s2].vd;
  return 0;
}
function ts(t2) {
  let i2 = t2;
  if (m(t2) && (i2 = ss(t2)), !Wi(i2)) throw new Error("time must be of type BusinessDay");
  const s2 = new Date(Date.UTC(i2.year, i2.month - 1, i2.day, 0, 0, 0, 0));
  return { md: Math.round(s2.getTime() / 1e3), wd: i2 };
}
function is$1(t2) {
  if (!Hi(t2)) throw new Error("time must be of type isUTCTimestamp");
  return { md: t2 };
}
function ss(t2) {
  const i2 = new Date(t2);
  if (isNaN(i2.getTime())) throw new Error(`Invalid date string=${t2}, expected format=yyyy-mm-dd`);
  return { day: i2.getUTCDate(), month: i2.getUTCMonth() + 1, year: i2.getUTCFullYear() };
}
function ns(t2) {
  m(t2.time) && (t2.time = ss(t2.time));
}
class es {
  options() {
    return this.Ts;
  }
  setOptions(t2) {
    this.Ts = t2, this.updateFormatter(t2.localization);
  }
  preprocessData(t2) {
    Array.isArray(t2) ? function(t3) {
      t3.forEach(ns);
    }(t2) : ns(t2);
  }
  createConverterToInternalObj(t2) {
    return u(function(t3) {
      return 0 === t3.length ? null : Wi(t3[0].time) || m(t3[0].time) ? ts : is$1;
    }(t2));
  }
  key(t2) {
    return "object" == typeof t2 && "md" in t2 ? t2.md : this.key(this.convertHorzItemToInternal(t2));
  }
  cacheKey(t2) {
    const i2 = t2;
    return void 0 === i2.wd ? new Date(1e3 * i2.md).getTime() : new Date(Date.UTC(i2.wd.year, i2.wd.month - 1, i2.wd.day)).getTime();
  }
  convertHorzItemToInternal(t2) {
    return Hi(i2 = t2) ? is$1(i2) : Wi(i2) ? ts(i2) : ts(ss(i2));
    var i2;
  }
  updateFormatter(t2) {
    if (!this.Ts) return;
    const i2 = t2.dateFormat;
    this.Ts.timeScale.timeVisible ? this.Md = new Ki({ ad: i2, ld: this.Ts.timeScale.secondsVisible ? "%h:%m:%s" : "%h:%m", od: "   ", _d: t2.locale }) : this.Md = new qi(i2, t2.locale);
  }
  formatHorzItem(t2) {
    const i2 = t2;
    return this.Md.__(new Date(1e3 * i2.md));
  }
  formatTickmark(t2, i2) {
    const s2 = function(t3, i3, s3) {
      switch (t3) {
        case 0:
        case 10:
          return i3 ? s3 ? 4 : 3 : 2;
        case 20:
        case 21:
        case 22:
        case 30:
        case 31:
        case 32:
        case 33:
          return i3 ? 3 : 2;
        case 50:
          return 2;
        case 60:
          return 1;
        case 70:
          return 0;
      }
    }(t2.weight, this.Ts.timeScale.timeVisible, this.Ts.timeScale.secondsVisible), n2 = this.Ts.timeScale;
    if (void 0 !== n2.tickMarkFormatter) {
      const e2 = n2.tickMarkFormatter(t2.originalTime, s2, i2.locale);
      if (null !== e2) return e2;
    }
    return function(t3, i3, s3) {
      const n3 = {};
      switch (i3) {
        case 0:
          n3.year = "numeric";
          break;
        case 1:
          n3.month = "short";
          break;
        case 2:
          n3.day = "numeric";
          break;
        case 3:
          n3.hour12 = false, n3.hour = "2-digit", n3.minute = "2-digit";
          break;
        case 4:
          n3.hour12 = false, n3.hour = "2-digit", n3.minute = "2-digit", n3.second = "2-digit";
      }
      const e2 = void 0 === t3.wd ? new Date(1e3 * t3.md) : new Date(Date.UTC(t3.wd.year, t3.wd.month - 1, t3.wd.day));
      return new Date(e2.getUTCFullYear(), e2.getUTCMonth(), e2.getUTCDate(), e2.getUTCHours(), e2.getUTCMinutes(), e2.getUTCSeconds(), e2.getUTCMilliseconds()).toLocaleString(s3, n3);
    }(t2.time, s2, i2.locale);
  }
  maxTickMarkWeight(t2) {
    let i2 = t2.reduce(Ii, t2[0]).weight;
    return i2 > 30 && i2 < 50 && (i2 = 30), i2;
  }
  fillWeightsForPoints(t2, i2) {
    !function(t3, i3 = 0) {
      if (0 === t3.length) return;
      let s2 = 0 === i3 ? null : t3[i3 - 1].time.md, n2 = null !== s2 ? new Date(1e3 * s2) : null, e2 = 0;
      for (let r2 = i3; r2 < t3.length; ++r2) {
        const i4 = t3[r2], h2 = new Date(1e3 * i4.time.md);
        null !== n2 && (i4.timeWeight = Qi(h2, n2)), e2 += i4.time.md - (s2 || i4.time.md), s2 = i4.time.md, n2 = h2;
      }
      if (0 === i3 && t3.length > 1) {
        const i4 = Math.ceil(e2 / (t3.length - 1)), s3 = new Date(1e3 * (t3[0].time.md - i4));
        t3[0].timeWeight = Qi(new Date(1e3 * t3[0].time.md), s3);
      }
    }(t2, i2);
  }
  static gd(t2) {
    return f({ localization: { dateFormat: "dd MMM 'yy" } }, t2 ?? {});
  }
}
const rs = "undefined" != typeof window;
function hs() {
  return !!rs && window.navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
}
function as() {
  return !!rs && /iPhone|iPad|iPod/.test(window.navigator.platform);
}
function ls(t2) {
  return t2 + t2 % 2;
}
function os(t2) {
  rs && void 0 !== window.chrome && t2.addEventListener("mousedown", (t3) => {
    if (1 === t3.button) return t3.preventDefault(), false;
  });
}
class _s {
  constructor(t2, i2, s2) {
    this.bd = 0, this.xd = null, this.Sd = { ft: Number.NEGATIVE_INFINITY, vt: Number.POSITIVE_INFINITY }, this.Cd = 0, this.Pd = null, this.kd = { ft: Number.NEGATIVE_INFINITY, vt: Number.POSITIVE_INFINITY }, this.yd = null, this.Td = false, this.Rd = null, this.Dd = null, this.Id = false, this.Bd = false, this.Vd = false, this.Ed = null, this.Ad = null, this.zd = null, this.Ld = null, this.Od = null, this.Nd = null, this.Fd = null, this.Wd = 0, this.Hd = false, this.Ud = false, this.$d = false, this.qd = 0, this.Yd = null, this.jd = !as(), this.Kd = (t3) => {
      this.Xd(t3);
    }, this.Gd = (t3) => {
      if (this.Zd(t3)) {
        const i3 = this.Jd(t3);
        if (++this.Cd, this.Pd && this.Cd > 1) {
          const { Qd: s3 } = this.tf(ds(t3), this.kd);
          s3 < 30 && !this.Vd && this.if(i3, this.nf.sf), this.ef();
        }
      } else {
        const i3 = this.Jd(t3);
        if (++this.bd, this.xd && this.bd > 1) {
          const { Qd: s3 } = this.tf(ds(t3), this.Sd);
          s3 < 5 && !this.Bd && this.rf(i3, this.nf.hf), this.af();
        }
      }
    }, this.lf = t2, this.nf = i2, this.Ts = s2, this._f();
  }
  m() {
    null !== this.Ed && (this.Ed(), this.Ed = null), null !== this.Ad && (this.Ad(), this.Ad = null), null !== this.Ld && (this.Ld(), this.Ld = null), null !== this.Od && (this.Od(), this.Od = null), null !== this.Nd && (this.Nd(), this.Nd = null), null !== this.zd && (this.zd(), this.zd = null), this.uf(), this.af();
  }
  cf(t2) {
    this.Ld && this.Ld();
    const i2 = this.df.bind(this);
    if (this.Ld = () => {
      this.lf.removeEventListener("mousemove", i2);
    }, this.lf.addEventListener("mousemove", i2), this.Zd(t2)) return;
    const s2 = this.Jd(t2);
    this.rf(s2, this.nf.ff), this.jd = true;
  }
  af() {
    null !== this.xd && clearTimeout(this.xd), this.bd = 0, this.xd = null, this.Sd = { ft: Number.NEGATIVE_INFINITY, vt: Number.POSITIVE_INFINITY };
  }
  ef() {
    null !== this.Pd && clearTimeout(this.Pd), this.Cd = 0, this.Pd = null, this.kd = { ft: Number.NEGATIVE_INFINITY, vt: Number.POSITIVE_INFINITY };
  }
  df(t2) {
    if (this.$d || null !== this.Dd) return;
    if (this.Zd(t2)) return;
    const i2 = this.Jd(t2);
    this.rf(i2, this.nf.pf), this.jd = true;
  }
  vf(t2) {
    const i2 = ps(t2.changedTouches, u(this.Yd));
    if (null === i2) return;
    if (this.qd = fs(t2), null !== this.Fd) return;
    if (this.Ud) return;
    this.Hd = true;
    const s2 = this.tf(ds(i2), u(this.Dd)), { mf: n2, wf: e2, Qd: r2 } = s2;
    if (this.Id || !(r2 < 5)) {
      if (!this.Id) {
        const t3 = 0.5 * n2, i3 = e2 >= t3 && !this.Ts.Mf(), s3 = t3 > e2 && !this.Ts.gf();
        i3 || s3 || (this.Ud = true), this.Id = true, this.Vd = true, this.uf(), this.ef();
      }
      if (!this.Ud) {
        const s3 = this.Jd(t2, i2);
        this.if(s3, this.nf.bf), cs(t2);
      }
    }
  }
  xf(t2) {
    if (0 !== t2.button) return;
    const i2 = this.tf(ds(t2), u(this.Rd)), { Qd: s2 } = i2;
    if (s2 >= 5 && (this.Bd = true, this.af()), this.Bd) {
      const i3 = this.Jd(t2);
      this.rf(i3, this.nf.Sf);
    }
  }
  tf(t2, i2) {
    const s2 = Math.abs(i2.ft - t2.ft), n2 = Math.abs(i2.vt - t2.vt);
    return { mf: s2, wf: n2, Qd: s2 + n2 };
  }
  Cf(t2) {
    let i2 = ps(t2.changedTouches, u(this.Yd));
    if (null === i2 && 0 === t2.touches.length && (i2 = t2.changedTouches[0]), null === i2) return;
    this.Yd = null, this.qd = fs(t2), this.uf(), this.Dd = null, this.Nd && (this.Nd(), this.Nd = null);
    const s2 = this.Jd(t2, i2);
    if (this.if(s2, this.nf.Pf), ++this.Cd, this.Pd && this.Cd > 1) {
      const { Qd: t3 } = this.tf(ds(i2), this.kd);
      t3 < 30 && !this.Vd && this.if(s2, this.nf.sf), this.ef();
    } else this.Vd || (this.if(s2, this.nf.kf), this.nf.kf && cs(t2));
    0 === this.Cd && cs(t2), 0 === t2.touches.length && this.Td && (this.Td = false, cs(t2));
  }
  Xd(t2) {
    if (0 !== t2.button) return;
    const i2 = this.Jd(t2);
    if (this.Rd = null, this.$d = false, this.Od && (this.Od(), this.Od = null), hs()) {
      this.lf.ownerDocument.documentElement.removeEventListener("mouseleave", this.Kd);
    }
    if (!this.Zd(t2)) if (this.rf(i2, this.nf.yf), ++this.bd, this.xd && this.bd > 1) {
      const { Qd: s2 } = this.tf(ds(t2), this.Sd);
      s2 < 5 && !this.Bd && this.rf(i2, this.nf.hf), this.af();
    } else this.Bd || this.rf(i2, this.nf.Tf);
  }
  uf() {
    null !== this.yd && (clearTimeout(this.yd), this.yd = null);
  }
  Rf(t2) {
    if (null !== this.Yd) return;
    const i2 = t2.changedTouches[0];
    this.Yd = i2.identifier, this.qd = fs(t2);
    const s2 = this.lf.ownerDocument.documentElement;
    this.Vd = false, this.Id = false, this.Ud = false, this.Dd = ds(i2), this.Nd && (this.Nd(), this.Nd = null);
    {
      const i3 = this.vf.bind(this), n3 = this.Cf.bind(this);
      this.Nd = () => {
        s2.removeEventListener("touchmove", i3), s2.removeEventListener("touchend", n3);
      }, s2.addEventListener("touchmove", i3, { passive: false }), s2.addEventListener("touchend", n3, { passive: false }), this.uf(), this.yd = setTimeout(this.Df.bind(this, t2), 240);
    }
    const n2 = this.Jd(t2, i2);
    this.if(n2, this.nf.If), this.Pd || (this.Cd = 0, this.Pd = setTimeout(this.ef.bind(this), 500), this.kd = ds(i2));
  }
  Bf(t2) {
    if (0 !== t2.button) return;
    const i2 = this.lf.ownerDocument.documentElement;
    hs() && i2.addEventListener("mouseleave", this.Kd), this.Bd = false, this.Rd = ds(t2), this.Od && (this.Od(), this.Od = null);
    {
      const t3 = this.xf.bind(this), s3 = this.Xd.bind(this);
      this.Od = () => {
        i2.removeEventListener("mousemove", t3), i2.removeEventListener("mouseup", s3);
      }, i2.addEventListener("mousemove", t3), i2.addEventListener("mouseup", s3);
    }
    if (this.$d = true, this.Zd(t2)) return;
    const s2 = this.Jd(t2);
    this.rf(s2, this.nf.Vf), this.xd || (this.bd = 0, this.xd = setTimeout(this.af.bind(this), 500), this.Sd = ds(t2));
  }
  _f() {
    this.lf.addEventListener("mouseenter", this.cf.bind(this)), this.lf.addEventListener("touchcancel", this.uf.bind(this));
    {
      const t2 = this.lf.ownerDocument, i2 = (t3) => {
        this.nf.Ef && (t3.composed && this.lf.contains(t3.composedPath()[0]) || t3.target && this.lf.contains(t3.target) || this.nf.Ef());
      };
      this.Ad = () => {
        t2.removeEventListener("touchstart", i2);
      }, this.Ed = () => {
        t2.removeEventListener("mousedown", i2);
      }, t2.addEventListener("mousedown", i2), t2.addEventListener("touchstart", i2, { passive: true });
    }
    as() && (this.zd = () => {
      this.lf.removeEventListener("dblclick", this.Gd);
    }, this.lf.addEventListener("dblclick", this.Gd)), this.lf.addEventListener("mouseleave", this.Af.bind(this)), this.lf.addEventListener("touchstart", this.Rf.bind(this), { passive: true }), os(this.lf), this.lf.addEventListener("mousedown", this.Bf.bind(this)), this.zf(), this.lf.addEventListener("touchmove", () => {
    }, { passive: false });
  }
  zf() {
    void 0 === this.nf.Lf && void 0 === this.nf.Of && void 0 === this.nf.Nf || (this.lf.addEventListener("touchstart", (t2) => this.Ff(t2.touches), { passive: true }), this.lf.addEventListener("touchmove", (t2) => {
      if (2 === t2.touches.length && null !== this.Fd && void 0 !== this.nf.Of) {
        const i2 = us(t2.touches[0], t2.touches[1]) / this.Wd;
        this.nf.Of(this.Fd, i2), cs(t2);
      }
    }, { passive: false }), this.lf.addEventListener("touchend", (t2) => {
      this.Ff(t2.touches);
    }));
  }
  Ff(t2) {
    1 === t2.length && (this.Hd = false), 2 !== t2.length || this.Hd || this.Td ? this.Wf() : this.Hf(t2);
  }
  Hf(t2) {
    const i2 = this.lf.getBoundingClientRect() || { left: 0, top: 0 };
    this.Fd = { ft: (t2[0].clientX - i2.left + (t2[1].clientX - i2.left)) / 2, vt: (t2[0].clientY - i2.top + (t2[1].clientY - i2.top)) / 2 }, this.Wd = us(t2[0], t2[1]), void 0 !== this.nf.Lf && this.nf.Lf(), this.uf();
  }
  Wf() {
    null !== this.Fd && (this.Fd = null, void 0 !== this.nf.Nf && this.nf.Nf());
  }
  Af(t2) {
    var _a3, _b3;
    if (this.Ld && this.Ld(), this.Zd(t2)) return;
    if (!this.jd) return;
    if ((_b3 = (_a3 = this.Ts).Uf) == null ? void 0 : _b3.call(_a3)) return;
    const i2 = this.Jd(t2);
    this.rf(i2, this.nf.$f), this.jd = !as();
  }
  Df(t2) {
    const i2 = ps(t2.touches, u(this.Yd));
    if (null === i2) return;
    const s2 = this.Jd(t2, i2);
    this.if(s2, this.nf.qf), this.Vd = true, this.Td = true;
  }
  Zd(t2) {
    return t2.sourceCapabilities && void 0 !== t2.sourceCapabilities.firesTouchEvents ? t2.sourceCapabilities.firesTouchEvents : fs(t2) < this.qd + 500;
  }
  if(t2, i2) {
    i2 && i2.call(this.nf, t2);
  }
  rf(t2, i2) {
    i2 && i2.call(this.nf, t2);
  }
  Jd(t2, i2) {
    const s2 = i2 || t2, n2 = this.lf.getBoundingClientRect() || { left: 0, top: 0 };
    return { clientX: s2.clientX, clientY: s2.clientY, pageX: s2.pageX, pageY: s2.pageY, screenX: s2.screenX, screenY: s2.screenY, localX: s2.clientX - n2.left, localY: s2.clientY - n2.top, ctrlKey: t2.ctrlKey, altKey: t2.altKey, shiftKey: t2.shiftKey, metaKey: t2.metaKey, Yf: !t2.type.startsWith("mouse") && "contextmenu" !== t2.type && "click" !== t2.type, jf: t2.type, Kf: s2.target, a_: t2.view, Xf: () => {
      "touchstart" !== t2.type && cs(t2);
    } };
  }
}
function us(t2, i2) {
  const s2 = t2.clientX - i2.clientX, n2 = t2.clientY - i2.clientY;
  return Math.sqrt(s2 * s2 + n2 * n2);
}
function cs(t2) {
  t2.cancelable && t2.preventDefault();
}
function ds(t2) {
  return { ft: t2.pageX, vt: t2.pageY };
}
function fs(t2) {
  return t2.timeStamp || performance.now();
}
function ps(t2, i2) {
  for (let s2 = 0; s2 < t2.length; ++s2) if (t2[s2].identifier === i2) return t2[s2];
  return null;
}
class vs {
  constructor(t2, i2, s2) {
    this.Gf = null, this.Zf = null, this.Jf = true, this.Qf = null, this.tp = t2, this.ip = t2.sp()[i2], this.np = t2.sp()[s2], this.ep = document.createElement("tr"), this.ep.style.height = "1px", this.rp = document.createElement("td"), this.rp.style.position = "relative", this.rp.style.padding = "0", this.rp.style.margin = "0", this.rp.setAttribute("colspan", "3"), this.hp(), this.ep.appendChild(this.rp), this.Jf = this.tp.F().layout.panes.enableResize, this.Jf ? this.ap() : (this.Gf = null, this.Zf = null);
  }
  m() {
    null !== this.Zf && this.Zf.m();
  }
  lp() {
    return this.ep;
  }
  op() {
    return size$1({ width: this.ip.op().width, height: 1 });
  }
  _p() {
    return size$1({ width: this.ip._p().width, height: 1 * window.devicePixelRatio });
  }
  up(t2, i2, s2) {
    const n2 = this._p();
    t2.fillStyle = this.tp.F().layout.panes.separatorColor, t2.fillRect(i2, s2, n2.width, n2.height);
  }
  Dt() {
    this.hp(), this.tp.F().layout.panes.enableResize !== this.Jf && (this.Jf = this.tp.F().layout.panes.enableResize, this.Jf ? this.ap() : (null !== this.Gf && (this.rp.removeChild(this.Gf.cp), this.rp.removeChild(this.Gf.dp), this.Gf = null), null !== this.Zf && (this.Zf.m(), this.Zf = null)));
  }
  ap() {
    const t2 = document.createElement("div"), i2 = t2.style;
    i2.position = "fixed", i2.display = "none", i2.zIndex = "49", i2.top = "0", i2.left = "0", i2.width = "100%", i2.height = "100%", i2.cursor = "row-resize", this.rp.appendChild(t2);
    const s2 = document.createElement("div"), n2 = s2.style;
    n2.position = "absolute", n2.zIndex = "50", n2.top = "-4px", n2.height = "9px", n2.width = "100%", n2.backgroundColor = "", n2.cursor = "row-resize", this.rp.appendChild(s2);
    const e2 = { ff: this.fp.bind(this), $f: this.pp.bind(this), Vf: this.vp.bind(this), If: this.vp.bind(this), Sf: this.mp.bind(this), bf: this.mp.bind(this), yf: this.wp.bind(this), Pf: this.wp.bind(this) };
    this.Zf = new _s(s2, e2, { Mf: () => false, gf: () => true }), this.Gf = { dp: s2, cp: t2 };
  }
  hp() {
    this.rp.style.background = this.tp.F().layout.panes.separatorColor;
  }
  fp(t2) {
    null !== this.Gf && (this.Gf.dp.style.backgroundColor = this.tp.F().layout.panes.separatorHoverColor);
  }
  pp(t2) {
    null !== this.Gf && null === this.Qf && (this.Gf.dp.style.backgroundColor = "");
  }
  vp(t2) {
    if (null === this.Gf) return;
    const i2 = this.ip.Mp().Vo() + this.np.Mp().Vo(), s2 = i2 / (this.ip.op().height + this.np.op().height), n2 = 30 * s2;
    i2 <= 2 * n2 || (this.Qf = { gp: t2.pageY, bp: this.ip.Mp().Vo(), xp: i2 - n2, Sp: i2, Cp: s2, Pp: n2 }, this.Gf.cp.style.display = "block");
  }
  mp(t2) {
    const i2 = this.Qf;
    if (null === i2) return;
    const s2 = (t2.pageY - i2.gp) * i2.Cp, n2 = Zt(i2.bp + s2, i2.Pp, i2.xp);
    this.ip.Mp().Eo(n2), this.np.Mp().Eo(i2.Sp - n2), this.tp.ni().Eh();
  }
  wp(t2) {
    null !== this.Qf && null !== this.Gf && (this.Qf = null, this.Gf.cp.style.display = "none");
  }
}
function ms(t2, i2) {
  return t2.kp - i2.kp;
}
function ws(t2, i2, s2) {
  const n2 = (t2.kp - i2.kp) / (t2.xt - i2.xt);
  return Math.sign(n2) * Math.min(Math.abs(n2), s2);
}
class Ms {
  constructor(t2, i2, s2, n2) {
    this.yp = null, this.Tp = null, this.Rp = null, this.Dp = null, this.Ip = null, this.Bp = 0, this.Vp = 0, this.Ep = t2, this.Ap = i2, this.zp = s2, this.Cn = n2;
  }
  Lp(t2, i2) {
    if (null !== this.yp) {
      if (this.yp.xt === i2) return void (this.yp.kp = t2);
      if (Math.abs(this.yp.kp - t2) < this.Cn) return;
    }
    this.Dp = this.Rp, this.Rp = this.Tp, this.Tp = this.yp, this.yp = { xt: i2, kp: t2 };
  }
  ae(t2, i2) {
    if (null === this.yp || null === this.Tp) return;
    if (i2 - this.yp.xt > 50) return;
    let s2 = 0;
    const n2 = ws(this.yp, this.Tp, this.Ap), e2 = ms(this.yp, this.Tp), r2 = [n2], h2 = [e2];
    if (s2 += e2, null !== this.Rp) {
      const t3 = ws(this.Tp, this.Rp, this.Ap);
      if (Math.sign(t3) === Math.sign(n2)) {
        const i3 = ms(this.Tp, this.Rp);
        if (r2.push(t3), h2.push(i3), s2 += i3, null !== this.Dp) {
          const t4 = ws(this.Rp, this.Dp, this.Ap);
          if (Math.sign(t4) === Math.sign(n2)) {
            const i4 = ms(this.Rp, this.Dp);
            r2.push(t4), h2.push(i4), s2 += i4;
          }
        }
      }
    }
    let a2 = 0;
    for (let t3 = 0; t3 < r2.length; ++t3) a2 += h2[t3] / s2 * r2[t3];
    Math.abs(a2) < this.Ep || (this.Ip = { kp: t2, xt: i2 }, this.Vp = a2, this.Bp = function(t3, i3) {
      const s3 = Math.log(i3);
      return Math.log(1 * s3 / -t3) / s3;
    }(Math.abs(a2), this.zp));
  }
  Fs(t2) {
    const i2 = u(this.Ip), s2 = t2 - i2.xt;
    return i2.kp + this.Vp * (Math.pow(this.zp, s2) - 1) / Math.log(this.zp);
  }
  Ju(t2) {
    return null === this.Ip || this.Op(t2) === this.Bp;
  }
  Op(t2) {
    const i2 = t2 - u(this.Ip).xt;
    return Math.min(i2, this.Bp);
  }
}
function gs(t2, s2) {
  const n2 = u(t2.ownerDocument).createElement("canvas");
  t2.appendChild(n2);
  const e2 = bindTo(n2, { options: { allowResizeObserver: true }, transform: (t3, i2) => ({ width: Math.max(t3.width, i2.width), height: Math.max(t3.height, i2.height) }) });
  return e2.resizeCanvasElement(s2), e2;
}
function bs(t2) {
  var _a3;
  t2.width = 1, t2.height = 1, (_a3 = t2.getContext("2d")) == null ? void 0 : _a3.clearRect(0, 0, 1, 1);
}
function xs(t2, i2, s2, n2) {
  t2.ih && t2.ih(i2, s2, n2);
}
function Ss(t2, i2, s2, n2) {
  t2.lt(i2, s2, n2);
}
function Cs(t2, i2, s2, n2) {
  const e2 = t2(s2, n2);
  for (const t3 of e2) {
    const s3 = t3.Bt(n2);
    null !== s3 && i2(s3);
  }
}
function Ps(t2, i2) {
  return (s2) => {
    var _a3, _b3;
    if (!function(t3) {
      return void 0 !== t3.$t;
    }(s2)) return [];
    return (((_a3 = s2.$t()) == null ? void 0 : _a3.Ma()) ?? "") !== i2 ? [] : ((_b3 = s2.sa) == null ? void 0 : _b3.call(s2, t2)) ?? [];
  };
}
function ks(t2, i2, s2, n2) {
  if (!t2.length) return;
  let e2 = 0;
  const r2 = t2[0].Kt(n2, true);
  let h2 = 1 === i2 ? s2 / 2 - (t2[0].Ui() - r2 / 2) : t2[0].Ui() - r2 / 2 - s2 / 2;
  h2 = Math.max(0, h2);
  for (let r3 = 1; r3 < t2.length; r3++) {
    const a2 = t2[r3], l2 = t2[r3 - 1], o2 = l2.Kt(n2, false), _2 = a2.Ui(), u2 = l2.Ui();
    if (1 === i2 ? _2 > u2 - o2 : _2 < u2 + o2) {
      const n3 = u2 - o2 * i2;
      a2.$i(n3);
      const r4 = n3 - i2 * o2 / 2;
      if ((1 === i2 ? r4 < 0 : r4 > s2) && h2 > 0) {
        const n4 = 1 === i2 ? -1 - r4 : r4 - s2, a3 = Math.min(n4, h2);
        for (let s3 = e2; s3 < t2.length; s3++) t2[s3].$i(t2[s3].Ui() + i2 * a3);
        h2 -= a3;
      }
    } else e2 = r3, h2 = 1 === i2 ? u2 - o2 - _2 : _2 - (u2 + o2);
  }
}
class ys {
  constructor(i2, s2, n2, e2) {
    this.Xi = null, this.Np = null, this.Fp = false, this.Wp = new rt(200), this.Hp = null, this.Up = 0, this.$p = false, this.qp = () => {
      this.$p || this.Rt.Yp().ni().ar();
    }, this.jp = () => {
      this.$p || this.Rt.Yp().ni().ar();
    }, this.Rt = i2, this.Ts = s2, this.xl = s2.layout, this.lc = n2, this.Kp = "left" === e2, this.Xp = Ps("normal", e2), this.Gp = Ps("top", e2), this.Zp = Ps("bottom", e2), this.rp = document.createElement("div"), this.rp.style.height = "100%", this.rp.style.overflow = "hidden", this.rp.style.width = "25px", this.rp.style.left = "0", this.rp.style.position = "relative", this.Jp = gs(this.rp, size$1({ width: 16, height: 16 })), this.Jp.subscribeSuggestedBitmapSizeChanged(this.qp);
    const r2 = this.Jp.canvasElement;
    r2.style.position = "absolute", r2.style.zIndex = "1", r2.style.left = "0", r2.style.top = "0", this.Qp = gs(this.rp, size$1({ width: 16, height: 16 })), this.Qp.subscribeSuggestedBitmapSizeChanged(this.jp);
    const h2 = this.Qp.canvasElement;
    h2.style.position = "absolute", h2.style.zIndex = "2", h2.style.left = "0", h2.style.top = "0";
    const a2 = { Vf: this.vp.bind(this), If: this.vp.bind(this), Sf: this.mp.bind(this), bf: this.mp.bind(this), Ef: this.tv.bind(this), yf: this.wp.bind(this), Pf: this.wp.bind(this), hf: this.iv.bind(this), sf: this.iv.bind(this), ff: this.sv.bind(this), $f: this.pp.bind(this) };
    this.Zf = new _s(this.Qp.canvasElement, a2, { Mf: () => !this.Ts.handleScroll.vertTouchDrag, gf: () => true });
  }
  m() {
    this.Zf.m(), this.Qp.unsubscribeSuggestedBitmapSizeChanged(this.jp), bs(this.Qp.canvasElement), this.Qp.dispose(), this.Jp.unsubscribeSuggestedBitmapSizeChanged(this.qp), bs(this.Jp.canvasElement), this.Jp.dispose(), null !== this.Xi && this.Xi.eo().u(this), this.Xi = null;
  }
  lp() {
    return this.rp;
  }
  P() {
    return this.xl.fontSize;
  }
  nv() {
    const t2 = this.lc.F();
    return this.Hp !== t2.k && (this.Wp.reset(), this.Hp = t2.k), t2;
  }
  ev() {
    if (null === this.Xi) return 0;
    let t2 = 0;
    const i2 = this.nv(), s2 = u(this.Jp.canvasElement.getContext("2d", { colorSpace: this.Rt.Yp().F().layout.colorSpace }));
    s2.save();
    const n2 = this.Xi.Ba();
    s2.font = this.rv(), n2.length > 0 && (t2 = Math.max(this.Wp.measureText(s2, n2[0].Ja), this.Wp.measureText(s2, n2[n2.length - 1].Ja)));
    const e2 = this.hv();
    for (let i3 = e2.length; i3--; ) {
      const n3 = this.Wp.measureText(s2, e2[i3].oi());
      n3 > t2 && (t2 = n3);
    }
    const r2 = this.Xi.Ft();
    if (null !== r2 && null !== this.Np && (2 !== (h2 = this.Ts.crosshair).mode && h2.horzLine.visible && h2.horzLine.labelVisible)) {
      const i3 = this.Xi.Is(1, r2), n3 = this.Xi.Is(this.Np.height - 2, r2);
      t2 = Math.max(t2, this.Wp.measureText(s2, this.Xi.Qi(Math.floor(Math.min(i3, n3)) + 0.11111111111111, r2)), this.Wp.measureText(s2, this.Xi.Qi(Math.ceil(Math.max(i3, n3)) - 0.11111111111111, r2)));
    }
    var h2;
    s2.restore();
    const a2 = t2 || 34;
    return ls(Math.ceil(i2.S + i2.C + i2.V + i2.A + 5 + a2));
  }
  av(t2) {
    null !== this.Np && equalSizes(this.Np, t2) || (this.Np = t2, this.$p = true, this.Jp.resizeCanvasElement(t2), this.Qp.resizeCanvasElement(t2), this.$p = false, this.rp.style.width = `${t2.width}px`, this.rp.style.height = `${t2.height}px`);
  }
  lv() {
    return u(this.Np).width;
  }
  ds(t2) {
    this.Xi !== t2 && (null !== this.Xi && this.Xi.eo().u(this), this.Xi = t2, t2.eo().i(this.cl.bind(this), this));
  }
  $t() {
    return this.Xi;
  }
  ov() {
    const t2 = this.Rt.Mp();
    this.Rt.Yp().ni().Zo(t2, u(this.$t()));
  }
  _v(t2) {
    if (null === this.Np) return;
    const i2 = { colorSpace: this.Rt.Yp().F().layout.colorSpace };
    if (1 !== t2) {
      this.uv(), this.Jp.applySuggestedBitmapSize();
      const t3 = tryCreateCanvasRenderingTarget2D(this.Jp, i2);
      null !== t3 && (t3.useBitmapCoordinateSpace((t4) => {
        this.cv(t4), this.dv(t4);
      }), this.Rt.fv(t3, this.Zp), this.pv(t3), this.Rt.fv(t3, this.Xp), this.vv(t3));
    }
    this.Qp.applySuggestedBitmapSize();
    const s2 = tryCreateCanvasRenderingTarget2D(this.Qp, i2);
    null !== s2 && (s2.useBitmapCoordinateSpace(({ context: t3, bitmapSize: i3 }) => {
      t3.clearRect(0, 0, i3.width, i3.height);
    }), this.mv(s2), this.Rt.fv(s2, this.Gp));
  }
  _p() {
    return this.Jp.bitmapSize;
  }
  up(t2, i2, s2) {
    const n2 = this._p();
    n2.width > 0 && n2.height > 0 && t2.drawImage(this.Jp.canvasElement, i2, s2);
  }
  Dt() {
    var _a3;
    (_a3 = this.Xi) == null ? void 0 : _a3.Ba();
  }
  vp(t2) {
    if (null === this.Xi || this.Xi.Zi() || !this.Ts.handleScale.axisPressedMouseMove.price) return;
    const i2 = this.Rt.Yp().ni(), s2 = this.Rt.Mp();
    this.Fp = true, i2.$o(s2, this.Xi, t2.localY);
  }
  mp(t2) {
    if (null === this.Xi || !this.Ts.handleScale.axisPressedMouseMove.price) return;
    const i2 = this.Rt.Yp().ni(), s2 = this.Rt.Mp(), n2 = this.Xi;
    i2.qo(s2, n2, t2.localY);
  }
  tv() {
    if (null === this.Xi || !this.Ts.handleScale.axisPressedMouseMove.price) return;
    const t2 = this.Rt.Yp().ni(), i2 = this.Rt.Mp(), s2 = this.Xi;
    this.Fp && (this.Fp = false, t2.Yo(i2, s2));
  }
  wp(t2) {
    if (null === this.Xi || !this.Ts.handleScale.axisPressedMouseMove.price) return;
    const i2 = this.Rt.Yp().ni(), s2 = this.Rt.Mp();
    this.Fp = false, i2.Yo(s2, this.Xi);
  }
  iv(t2) {
    this.Ts.handleScale.axisDoubleClickReset.price && this.ov();
  }
  sv(t2) {
    if (null === this.Xi) return;
    !this.Rt.Yp().ni().F().handleScale.axisPressedMouseMove.price || this.Xi.ze() || this.Xi.Bl() || this.wv(1);
  }
  pp(t2) {
    this.wv(0);
  }
  hv() {
    const t2 = [], i2 = null === this.Xi ? void 0 : this.Xi;
    return ((s2) => {
      for (let n2 = 0; n2 < s2.length; ++n2) {
        const e2 = s2[n2].Ys(this.Rt.Mp(), i2);
        for (let i3 = 0; i3 < e2.length; i3++) t2.push(e2[i3]);
      }
    })(this.Rt.Mp().Et()), t2;
  }
  cv({ context: t2, bitmapSize: i2 }) {
    const { width: s2, height: n2 } = i2, e2 = this.nv().D, r2 = this.nv().I;
    e2 === r2 ? L(t2, 0, 0, s2, n2, e2) : F(t2, 0, 0, s2, n2, e2, r2);
  }
  dv({ context: t2, bitmapSize: i2, horizontalPixelRatio: s2 }) {
    if (null === this.Np || null === this.Xi || !this.Xi.F().borderVisible) return;
    t2.fillStyle = this.Xi.F().borderColor;
    const n2 = Math.max(1, Math.floor(this.nv().S * s2));
    let e2;
    e2 = this.Kp ? i2.width - n2 : 0, t2.fillRect(e2, 0, n2, i2.height);
  }
  pv(t2) {
    if (null === this.Np || null === this.Xi) return;
    const i2 = this.Xi.Ba(), s2 = this.Xi.F(), n2 = this.nv(), e2 = this.Kp ? this.Np.width - n2.C : 0;
    s2.borderVisible && s2.ticksVisible && t2.useBitmapCoordinateSpace(({ context: t3, horizontalPixelRatio: r2, verticalPixelRatio: h2 }) => {
      t3.fillStyle = s2.borderColor;
      const a2 = Math.max(1, Math.floor(h2)), l2 = Math.floor(0.5 * h2), o2 = Math.round(n2.C * r2);
      t3.beginPath();
      for (const s3 of i2) t3.rect(Math.floor(e2 * r2), Math.round(s3.ya * h2) - l2, o2, a2);
      t3.fill();
    }), t2.useMediaCoordinateSpace(({ context: t3 }) => {
      t3.font = this.rv(), t3.fillStyle = s2.textColor ?? this.xl.textColor, t3.textAlign = this.Kp ? "right" : "left", t3.textBaseline = "middle";
      const r2 = this.Kp ? Math.round(e2 - n2.V) : Math.round(e2 + n2.C + n2.V), h2 = i2.map((i3) => this.Wp.yMidCorrection(t3, i3.Ja));
      for (let s3 = i2.length; s3--; ) {
        const n3 = i2[s3];
        t3.fillText(n3.Ja, r2, n3.ya + h2[s3]);
      }
    });
  }
  uv() {
    if (null === this.Np || null === this.Xi) return;
    let t2 = this.Np.height / 2;
    const i2 = [], s2 = this.Xi.Et().slice(), n2 = this.Rt.Mp(), e2 = this.nv();
    this.Xi === n2.qn() && this.Rt.Mp().Et().forEach((t3) => {
      n2.$n(t3) && s2.push(t3);
    });
    const r2 = this.Xi.xa()[0], h2 = this.Xi;
    s2.forEach((s3) => {
      const e3 = s3.Ys(n2, h2);
      e3.forEach((t3) => {
        t3.$i(null), t3.qi() && i2.push(t3);
      }), r2 === s3 && e3.length > 0 && (t2 = e3[0].zi());
    }), i2.forEach((t3) => t3.$i(t3.zi()));
    this.Xi.F().alignLabels && this.Mv(i2, e2, t2);
  }
  Mv(t2, i2, s2) {
    if (null === this.Np) return;
    const n2 = t2.filter((t3) => t3.zi() <= s2), e2 = t2.filter((t3) => t3.zi() > s2);
    n2.sort((t3, i3) => i3.zi() - t3.zi()), n2.length && e2.length && e2.push(n2[0]), e2.sort((t3, i3) => t3.zi() - i3.zi());
    for (const s3 of t2) {
      const t3 = Math.floor(s3.Kt(i2) / 2), n3 = s3.zi();
      n3 > -t3 && n3 < t3 && s3.$i(t3), n3 > this.Np.height - t3 && n3 < this.Np.height + t3 && s3.$i(this.Np.height - t3);
    }
    ks(n2, 1, this.Np.height, i2), ks(e2, -1, this.Np.height, i2);
  }
  vv(t2) {
    if (null === this.Np) return;
    const i2 = this.hv(), s2 = this.nv(), n2 = this.Kp ? "right" : "left";
    i2.forEach((i3) => {
      if (i3.Yi()) {
        i3.Bt(u(this.Xi)).lt(t2, s2, this.Wp, n2);
      }
    });
  }
  mv(t2) {
    if (null === this.Np || null === this.Xi) return;
    const i2 = this.Rt.Yp().ni(), s2 = [], n2 = this.Rt.Mp(), e2 = i2.Sc().Ys(n2, this.Xi);
    e2.length && s2.push(e2);
    const r2 = this.nv(), h2 = this.Kp ? "right" : "left";
    s2.forEach((i3) => {
      i3.forEach((i4) => {
        i4.Bt(u(this.Xi)).lt(t2, r2, this.Wp, h2);
      });
    });
  }
  wv(t2) {
    this.rp.style.cursor = 1 === t2 ? "ns-resize" : "default";
  }
  cl() {
    const t2 = this.ev();
    this.Up < t2 && this.Rt.Yp().ni().Eh(), this.Up = t2;
  }
  rv() {
    return S(this.xl.fontSize, this.xl.fontFamily);
  }
}
function Ts(t2, i2) {
  var _a3;
  return ((_a3 = t2.Qh) == null ? void 0 : _a3.call(t2, i2)) ?? [];
}
function Rs(t2, i2) {
  var _a3;
  return ((_a3 = t2.ia) == null ? void 0 : _a3.call(t2, i2)) ?? [];
}
function Ds(t2, i2) {
  var _a3;
  return ((_a3 = t2.qs) == null ? void 0 : _a3.call(t2, i2)) ?? [];
}
function Is(t2, i2) {
  var _a3;
  return ((_a3 = t2.fs) == null ? void 0 : _a3.call(t2, i2)) ?? [];
}
function Bs(t2, i2) {
  var _a3;
  return ((_a3 = t2.Gh) == null ? void 0 : _a3.call(t2, i2)) ?? [];
}
class Vs {
  constructor(i2, s2) {
    this.Np = size$1({ width: 0, height: 0 }), this.gv = null, this.bv = null, this.xv = null, this.Sv = false, this.Cv = new d$1(), this.Pv = new d$1(), this.kv = 0, this.yv = false, this.Tv = null, this.Rv = false, this.Dv = null, this.Iv = null, this.$p = false, this.qp = () => {
      this.$p || null === this.Bv || this.es().ar();
    }, this.jp = () => {
      this.$p || null === this.Bv || this.es().ar();
    }, this.Vv = i2, this.Bv = s2, this.Bv.i_().i(this.Ev.bind(this), this, true), this.Av = document.createElement("td"), this.Av.style.padding = "0", this.Av.style.position = "relative";
    const n2 = document.createElement("div");
    n2.style.width = "100%", n2.style.height = "100%", n2.style.position = "relative", n2.style.overflow = "hidden", this.zv = document.createElement("td"), this.zv.style.padding = "0", this.Lv = document.createElement("td"), this.Lv.style.padding = "0", this.Av.appendChild(n2), this.Jp = gs(n2, size$1({ width: 16, height: 16 })), this.Jp.subscribeSuggestedBitmapSizeChanged(this.qp);
    const e2 = this.Jp.canvasElement;
    e2.style.position = "absolute", e2.style.zIndex = "1", e2.style.left = "0", e2.style.top = "0", this.Qp = gs(n2, size$1({ width: 16, height: 16 })), this.Qp.subscribeSuggestedBitmapSizeChanged(this.jp);
    const r2 = this.Qp.canvasElement;
    r2.style.position = "absolute", r2.style.zIndex = "2", r2.style.left = "0", r2.style.top = "0", this.ep = document.createElement("tr"), this.ep.appendChild(this.zv), this.ep.appendChild(this.Av), this.ep.appendChild(this.Lv), this.Ov(), this.Zf = new _s(this.Qp.canvasElement, this, { Mf: () => null === this.Tv && !this.Vv.F().handleScroll.vertTouchDrag, gf: () => null === this.Tv && !this.Vv.F().handleScroll.horzTouchDrag, Uf: this.Vv.F().preventLeave });
  }
  m() {
    null !== this.gv && this.gv.m(), null !== this.bv && this.bv.m(), this.Qp.unsubscribeSuggestedBitmapSizeChanged(this.jp), bs(this.Qp.canvasElement), this.Qp.dispose(), this.Jp.unsubscribeSuggestedBitmapSizeChanged(this.qp), bs(this.Jp.canvasElement), this.Jp.dispose(), null !== this.Bv && (this.Bv.i_().u(this), this.Bv.m()), this.Zf.m();
  }
  Mp() {
    return u(this.Bv);
  }
  Nv(t2) {
    null !== this.Bv && this.Bv.i_().u(this), this.Bv = t2, null !== this.Bv && this.Bv.i_().i(Vs.prototype.Ev.bind(this), this, true), this.Ov();
  }
  Yp() {
    return this.Vv;
  }
  lp() {
    return this.ep;
  }
  Ov() {
    if (null !== this.Bv && (this.Fv(), 0 !== this.es().Js().length)) {
      if (null !== this.gv) {
        const t2 = this.Bv.Ho();
        this.gv.ds(u(t2));
      }
      if (null !== this.bv) {
        const t2 = this.Bv.Uo();
        this.bv.ds(u(t2));
      }
    }
  }
  Wv() {
    null !== this.gv && this.gv.Dt(), null !== this.bv && this.bv.Dt();
  }
  Vo() {
    return null !== this.Bv ? this.Bv.Vo() : 0;
  }
  Eo(t2) {
    this.Bv && this.Bv.Eo(t2);
  }
  ff(t2) {
    if (!this.Bv) return;
    this.Hv();
    const i2 = t2.localX, s2 = t2.localY;
    this.Uv(i2, s2, t2);
  }
  Vf(t2) {
    this.Hv(), this.$v(), this.Uv(t2.localX, t2.localY, t2);
  }
  pf(t2) {
    if (!this.Bv) return;
    this.Hv();
    const i2 = t2.localX, s2 = t2.localY;
    this.Uv(i2, s2, t2);
  }
  Tf(t2) {
    null !== this.Bv && (this.Hv(), this.qv(t2));
  }
  hf(t2) {
    null !== this.Bv && this.Yv(this.Pv, t2);
  }
  sf(t2) {
    this.hf(t2);
  }
  Sf(t2) {
    this.Hv(), this.jv(t2), this.Uv(t2.localX, t2.localY, t2);
  }
  yf(t2) {
    null !== this.Bv && (this.Hv(), this.yv = false, this.Kv(t2));
  }
  kf(t2) {
    null !== this.Bv && this.qv(t2);
  }
  qf(t2) {
    if (this.yv = true, null === this.Tv) {
      const i2 = { x: t2.localX, y: t2.localY };
      this.Xv(i2, i2, t2);
    }
  }
  $f(t2) {
    null !== this.Bv && (this.Hv(), this.Bv.ni().wc(null), this.Gv());
  }
  Zv() {
    return this.Cv;
  }
  Jv() {
    return this.Pv;
  }
  Lf() {
    this.kv = 1, this.es().un();
  }
  Of(t2, i2) {
    if (!this.Vv.F().handleScale.pinch) return;
    const s2 = 5 * (i2 - this.kv);
    this.kv = i2, this.es().Bc(t2.ft, s2);
  }
  If(t2) {
    this.yv = false, this.Rv = null !== this.Tv, this.$v();
    const i2 = this.es().Sc();
    null !== this.Tv && i2.At() && (this.Dv = { x: i2.hi(), y: i2.ai() }, this.Tv = { x: t2.localX, y: t2.localY });
  }
  bf(t2) {
    if (null === this.Bv) return;
    const i2 = t2.localX, s2 = t2.localY;
    if (null === this.Tv) this.jv(t2);
    else {
      this.Rv = false;
      const n2 = u(this.Dv), e2 = n2.x + (i2 - this.Tv.x), r2 = n2.y + (s2 - this.Tv.y);
      this.Uv(e2, r2, t2);
    }
  }
  Pf(t2) {
    0 === this.Yp().F().trackingMode.exitMode && (this.Rv = true), this.Qv(), this.Kv(t2);
  }
  ht(t2, i2) {
    const s2 = this.Bv;
    return null === s2 ? null : Pi(s2, t2, i2);
  }
  tm(i2, s2) {
    u("left" === s2 ? this.gv : this.bv).av(size$1({ width: i2, height: this.Np.height }));
  }
  op() {
    return this.Np;
  }
  av(t2) {
    equalSizes(this.Np, t2) || (this.Np = t2, this.$p = true, this.Jp.resizeCanvasElement(t2), this.Qp.resizeCanvasElement(t2), this.$p = false, this.Av.style.width = t2.width + "px", this.Av.style.height = t2.height + "px");
  }
  im() {
    const t2 = u(this.Bv);
    t2.Wo(t2.Ho()), t2.Wo(t2.Uo());
    for (const i2 of t2.xa()) if (t2.$n(i2)) {
      const s2 = i2.$t();
      null !== s2 && t2.Wo(s2), i2.$s();
    }
    for (const i2 of t2.da()) i2.$s();
  }
  _p() {
    return this.Jp.bitmapSize;
  }
  up(t2, i2, s2) {
    const n2 = this._p();
    n2.width > 0 && n2.height > 0 && t2.drawImage(this.Jp.canvasElement, i2, s2);
  }
  _v(t2) {
    if (0 === t2) return;
    if (null === this.Bv) return;
    t2 > 1 && this.im(), null !== this.gv && this.gv._v(t2), null !== this.bv && this.bv._v(t2);
    const i2 = { colorSpace: this.Vv.F().layout.colorSpace };
    if (1 !== t2) {
      this.Jp.applySuggestedBitmapSize();
      const t3 = tryCreateCanvasRenderingTarget2D(this.Jp, i2);
      null !== t3 && (t3.useBitmapCoordinateSpace((t4) => {
        this.cv(t4);
      }), this.Bv && (this.sm(t3, Ts), this.nm(t3), this.sm(t3, Rs), this.sm(t3, Ds), this.sm(t3, Is)));
    }
    this.Qp.applySuggestedBitmapSize();
    const s2 = tryCreateCanvasRenderingTarget2D(this.Qp, i2);
    null !== s2 && (s2.useBitmapCoordinateSpace(({ context: t3, bitmapSize: i3 }) => {
      t3.clearRect(0, 0, i3.width, i3.height);
    }), this.rm(s2), this.sm(s2, Bs), this.sm(s2, Is));
  }
  hm() {
    return this.gv;
  }
  am() {
    return this.bv;
  }
  fv(t2, i2) {
    this.sm(t2, i2);
  }
  Ev() {
    null !== this.Bv && this.Bv.i_().u(this), this.Bv = null;
  }
  qv(t2) {
    this.Yv(this.Cv, t2);
  }
  Yv(t2, i2) {
    const s2 = i2.localX, n2 = i2.localY;
    t2.v() && t2.p(this.es().Ot().du(s2), { x: s2, y: n2 }, i2);
  }
  cv({ context: t2, bitmapSize: i2 }) {
    const { width: s2, height: n2 } = i2, e2 = this.es(), r2 = e2.Y(), h2 = e2.j();
    r2 === h2 ? L(t2, 0, 0, s2, n2, h2) : F(t2, 0, 0, s2, n2, r2, h2);
  }
  nm(t2) {
    const i2 = u(this.Bv), s2 = i2.s_().lr().Bt(i2);
    null !== s2 && s2.lt(t2, false);
  }
  rm(t2) {
    this.lm(t2, Ds, Ss, this.es().Sc());
  }
  sm(t2, i2) {
    const s2 = u(this.Bv), n2 = s2.Et(), e2 = s2.da();
    for (const s3 of e2) this.lm(t2, i2, xs, s3);
    for (const s3 of n2) this.lm(t2, i2, xs, s3);
    for (const s3 of e2) this.lm(t2, i2, Ss, s3);
    for (const s3 of n2) this.lm(t2, i2, Ss, s3);
  }
  lm(t2, i2, s2, n2) {
    const e2 = u(this.Bv), r2 = e2.ni().mc(), h2 = null !== r2 && r2.n_ === n2, a2 = null !== r2 && h2 && void 0 !== r2.e_ ? r2.e_.hitTestData : void 0;
    Cs(i2, (i3) => s2(i3, t2, h2, a2), n2, e2);
  }
  Fv() {
    if (null === this.Bv) return;
    const t2 = this.Vv, i2 = this.Bv.Ho().F().visible, s2 = this.Bv.Uo().F().visible;
    i2 || null === this.gv || (this.zv.removeChild(this.gv.lp()), this.gv.m(), this.gv = null), s2 || null === this.bv || (this.Lv.removeChild(this.bv.lp()), this.bv.m(), this.bv = null);
    const n2 = t2.ni().qc();
    i2 && null === this.gv && (this.gv = new ys(this, t2.F(), n2, "left"), this.zv.appendChild(this.gv.lp())), s2 && null === this.bv && (this.bv = new ys(this, t2.F(), n2, "right"), this.Lv.appendChild(this.bv.lp()));
  }
  om(t2) {
    return t2.Yf && this.yv || null !== this.Tv;
  }
  _m(t2) {
    return Math.max(0, Math.min(t2, this.Np.width - 1));
  }
  um(t2) {
    return Math.max(0, Math.min(t2, this.Np.height - 1));
  }
  Uv(t2, i2, s2) {
    this.es().Nc(this._m(t2), this.um(i2), s2, u(this.Bv));
  }
  Gv() {
    this.es().Uc();
  }
  Qv() {
    this.Rv && (this.Tv = null, this.Gv());
  }
  Xv(t2, i2, s2) {
    this.Tv = t2, this.Rv = false, this.Uv(i2.x, i2.y, s2);
    const n2 = this.es().Sc();
    this.Dv = { x: n2.hi(), y: n2.ai() };
  }
  es() {
    return this.Vv.ni();
  }
  Kv(t2) {
    if (!this.Sv) return;
    const i2 = this.es(), s2 = this.Mp();
    if (i2.Xo(s2, s2.Ds()), this.xv = null, this.Sv = false, i2.zc(), null !== this.Iv) {
      const t3 = performance.now(), s3 = i2.Ot();
      this.Iv.ae(s3.gu(), t3), this.Iv.Ju(t3) || i2.fn(this.Iv);
    }
  }
  Hv() {
    this.Tv = null;
  }
  $v() {
    if (!this.Bv) return;
    this.es().un();
    !this.Bv.Ds().Zi() && this.es().Ot().Zi();
  }
  jv(t2) {
    if (null === this.Bv) return;
    const i2 = this.es(), s2 = i2.Ot();
    if (s2.Zi()) return;
    const n2 = this.Vv.F(), e2 = n2.handleScroll, r2 = n2.kineticScroll;
    if ((!e2.pressedMouseMove || t2.Yf) && (!e2.horzTouchDrag && !e2.vertTouchDrag || !t2.Yf)) return;
    const h2 = this.Bv.Ds(), a2 = performance.now();
    if (null !== this.xv || this.om(t2) || (this.xv = { x: t2.clientX, y: t2.clientY, md: a2, dm: t2.localX, fm: t2.localY }), null !== this.xv && !this.Sv && (this.xv.x !== t2.clientX || this.xv.y !== t2.clientY)) {
      if (t2.Yf && r2.touch || !t2.Yf && r2.mouse) {
        const t3 = s2.wu();
        this.Iv = new Ms(0.2 / t3, 7 / t3, 0.997, 15 / t3), this.Iv.Lp(s2.gu(), this.xv.md);
      } else this.Iv = null;
      h2.Zi() || i2.jo(this.Bv, h2, t2.localY), i2.Ec(t2.localX), this.Sv = true;
    }
    this.Sv && (h2.Zi() || i2.Ko(this.Bv, h2, t2.localY), i2.Ac(t2.localX), null !== this.Iv && this.Iv.Lp(s2.gu(), a2));
  }
}
class Es {
  constructor(i2, s2, n2, e2, r2) {
    this.yt = true, this.Np = size$1({ width: 0, height: 0 }), this.qp = () => this._v(3), this.Kp = "left" === i2, this.lc = n2.qc, this.Ts = s2, this.pm = e2, this.vm = r2, this.rp = document.createElement("div"), this.rp.style.width = "25px", this.rp.style.height = "100%", this.rp.style.overflow = "hidden", this.Jp = gs(this.rp, size$1({ width: 16, height: 16 })), this.Jp.subscribeSuggestedBitmapSizeChanged(this.qp);
  }
  m() {
    this.Jp.unsubscribeSuggestedBitmapSizeChanged(this.qp), bs(this.Jp.canvasElement), this.Jp.dispose();
  }
  lp() {
    return this.rp;
  }
  op() {
    return this.Np;
  }
  av(t2) {
    equalSizes(this.Np, t2) || (this.Np = t2, this.Jp.resizeCanvasElement(t2), this.rp.style.width = `${t2.width}px`, this.rp.style.height = `${t2.height}px`, this.yt = true);
  }
  _v(t2) {
    if (t2 < 3 && !this.yt) return;
    if (0 === this.Np.width || 0 === this.Np.height) return;
    this.yt = false, this.Jp.applySuggestedBitmapSize();
    const i2 = tryCreateCanvasRenderingTarget2D(this.Jp, { colorSpace: this.Ts.layout.colorSpace });
    null !== i2 && i2.useBitmapCoordinateSpace((t3) => {
      this.cv(t3), this.dv(t3);
    });
  }
  _p() {
    return this.Jp.bitmapSize;
  }
  up(t2, i2, s2) {
    const n2 = this._p();
    n2.width > 0 && n2.height > 0 && t2.drawImage(this.Jp.canvasElement, i2, s2);
  }
  dv({ context: t2, bitmapSize: i2, horizontalPixelRatio: s2, verticalPixelRatio: n2 }) {
    if (!this.pm()) return;
    t2.fillStyle = this.Ts.timeScale.borderColor;
    const e2 = Math.floor(this.lc.F().S * s2), r2 = Math.floor(this.lc.F().S * n2), h2 = this.Kp ? i2.width - e2 : 0;
    t2.fillRect(h2, 0, e2, r2);
  }
  cv({ context: t2, bitmapSize: i2 }) {
    L(t2, 0, 0, i2.width, i2.height, this.vm());
  }
}
function As(t2) {
  return (i2) => {
    var _a3;
    return ((_a3 = i2.na) == null ? void 0 : _a3.call(i2, t2)) ?? [];
  };
}
const zs = As("normal"), Ls = As("top"), Os = As("bottom");
class Ns {
  constructor(i2, s2) {
    this.wm = null, this.Mm = null, this.M = null, this.gm = false, this.Np = size$1({ width: 0, height: 0 }), this.bm = new d$1(), this.Wp = new rt(5), this.$p = false, this.qp = () => {
      this.$p || this.Vv.ni().ar();
    }, this.jp = () => {
      this.$p || this.Vv.ni().ar();
    }, this.Vv = i2, this.o_ = s2, this.Ts = i2.F().layout, this.xm = document.createElement("tr"), this.Sm = document.createElement("td"), this.Sm.style.padding = "0", this.Cm = document.createElement("td"), this.Cm.style.padding = "0", this.rp = document.createElement("td"), this.rp.style.height = "25px", this.rp.style.padding = "0", this.Pm = document.createElement("div"), this.Pm.style.width = "100%", this.Pm.style.height = "100%", this.Pm.style.position = "relative", this.Pm.style.overflow = "hidden", this.rp.appendChild(this.Pm), this.Jp = gs(this.Pm, size$1({ width: 16, height: 16 })), this.Jp.subscribeSuggestedBitmapSizeChanged(this.qp);
    const n2 = this.Jp.canvasElement;
    n2.style.position = "absolute", n2.style.zIndex = "1", n2.style.left = "0", n2.style.top = "0", this.Qp = gs(this.Pm, size$1({ width: 16, height: 16 })), this.Qp.subscribeSuggestedBitmapSizeChanged(this.jp);
    const e2 = this.Qp.canvasElement;
    e2.style.position = "absolute", e2.style.zIndex = "2", e2.style.left = "0", e2.style.top = "0", this.xm.appendChild(this.Sm), this.xm.appendChild(this.rp), this.xm.appendChild(this.Cm), this.km(), this.Vv.ni().Bo().i(this.km.bind(this), this), this.Zf = new _s(this.Qp.canvasElement, this, { Mf: () => true, gf: () => !this.Vv.F().handleScroll.horzTouchDrag });
  }
  m() {
    this.Zf.m(), null !== this.wm && this.wm.m(), null !== this.Mm && this.Mm.m(), this.Qp.unsubscribeSuggestedBitmapSizeChanged(this.jp), bs(this.Qp.canvasElement), this.Qp.dispose(), this.Jp.unsubscribeSuggestedBitmapSizeChanged(this.qp), bs(this.Jp.canvasElement), this.Jp.dispose();
  }
  lp() {
    return this.xm;
  }
  ym() {
    return this.wm;
  }
  Tm() {
    return this.Mm;
  }
  Vf(t2) {
    if (this.gm) return;
    this.gm = true;
    const i2 = this.Vv.ni();
    !i2.Ot().Zi() && this.Vv.F().handleScale.axisPressedMouseMove.time && i2.Ic(t2.localX);
  }
  If(t2) {
    this.Vf(t2);
  }
  Ef() {
    const t2 = this.Vv.ni();
    !t2.Ot().Zi() && this.gm && (this.gm = false, this.Vv.F().handleScale.axisPressedMouseMove.time && t2.Oc());
  }
  Sf(t2) {
    const i2 = this.Vv.ni();
    !i2.Ot().Zi() && this.Vv.F().handleScale.axisPressedMouseMove.time && i2.Lc(t2.localX);
  }
  bf(t2) {
    this.Sf(t2);
  }
  yf() {
    this.gm = false;
    const t2 = this.Vv.ni();
    t2.Ot().Zi() && !this.Vv.F().handleScale.axisPressedMouseMove.time || t2.Oc();
  }
  Pf() {
    this.yf();
  }
  hf() {
    this.Vv.F().handleScale.axisDoubleClickReset.time && this.Vv.ni().vn();
  }
  sf() {
    this.hf();
  }
  ff() {
    this.Vv.ni().F().handleScale.axisPressedMouseMove.time && this.wv(1);
  }
  $f() {
    this.wv(0);
  }
  op() {
    return this.Np;
  }
  Rm() {
    return this.bm;
  }
  Dm(i2, n2, e2) {
    equalSizes(this.Np, i2) || (this.Np = i2, this.$p = true, this.Jp.resizeCanvasElement(i2), this.Qp.resizeCanvasElement(i2), this.$p = false, this.rp.style.width = `${i2.width}px`, this.rp.style.height = `${i2.height}px`, this.bm.p(i2)), null !== this.wm && this.wm.av(size$1({ width: n2, height: i2.height })), null !== this.Mm && this.Mm.av(size$1({ width: e2, height: i2.height }));
  }
  Im() {
    const t2 = this.Bm();
    return Math.ceil(t2.S + t2.C + t2.P + t2.L + t2.B + t2.Vm);
  }
  Dt() {
    this.Vv.ni().Ot().Ba();
  }
  _p() {
    return this.Jp.bitmapSize;
  }
  up(t2, i2, s2) {
    const n2 = this._p();
    n2.width > 0 && n2.height > 0 && t2.drawImage(this.Jp.canvasElement, i2, s2);
  }
  _v(t2) {
    if (0 === t2) return;
    const i2 = { colorSpace: this.Ts.colorSpace };
    if (1 !== t2) {
      this.Jp.applySuggestedBitmapSize();
      const s3 = tryCreateCanvasRenderingTarget2D(this.Jp, i2);
      null !== s3 && (s3.useBitmapCoordinateSpace((t3) => {
        this.cv(t3), this.dv(t3), this.Em(s3, Os);
      }), this.pv(s3), this.Em(s3, zs)), null !== this.wm && this.wm._v(t2), null !== this.Mm && this.Mm._v(t2);
    }
    this.Qp.applySuggestedBitmapSize();
    const s2 = tryCreateCanvasRenderingTarget2D(this.Qp, i2);
    null !== s2 && (s2.useBitmapCoordinateSpace(({ context: t3, bitmapSize: i3 }) => {
      t3.clearRect(0, 0, i3.width, i3.height);
    }), this.Am([...this.Vv.ni().Js(), this.Vv.ni().Sc()], s2), this.Em(s2, Ls));
  }
  Em(t2, i2) {
    const s2 = this.Vv.ni().Js();
    for (const n2 of s2) Cs(i2, (i3) => xs(i3, t2, false, void 0), n2, void 0);
    for (const n2 of s2) Cs(i2, (i3) => Ss(i3, t2, false, void 0), n2, void 0);
  }
  cv({ context: t2, bitmapSize: i2 }) {
    L(t2, 0, 0, i2.width, i2.height, this.Vv.ni().j());
  }
  dv({ context: t2, bitmapSize: i2, verticalPixelRatio: s2 }) {
    if (this.Vv.F().timeScale.borderVisible) {
      t2.fillStyle = this.zm();
      const n2 = Math.max(1, Math.floor(this.Bm().S * s2));
      t2.fillRect(0, 0, i2.width, n2);
    }
  }
  pv(t2) {
    const i2 = this.Vv.ni().Ot(), s2 = i2.Ba();
    if (!s2 || 0 === s2.length) return;
    const n2 = this.o_.maxTickMarkWeight(s2), e2 = this.Bm(), r2 = i2.F();
    r2.borderVisible && r2.ticksVisible && t2.useBitmapCoordinateSpace(({ context: t3, horizontalPixelRatio: i3, verticalPixelRatio: n3 }) => {
      t3.strokeStyle = this.zm(), t3.fillStyle = this.zm();
      const r3 = Math.max(1, Math.floor(i3)), h2 = Math.floor(0.5 * i3);
      t3.beginPath();
      const a2 = Math.round(e2.C * n3);
      for (let n4 = s2.length; n4--; ) {
        const e3 = Math.round(s2[n4].coord * i3);
        t3.rect(e3 - h2, 0, r3, a2);
      }
      t3.fill();
    }), t2.useMediaCoordinateSpace(({ context: t3 }) => {
      const i3 = e2.S + e2.C + e2.L + e2.P / 2;
      t3.textAlign = "center", t3.textBaseline = "middle", t3.fillStyle = this.U(), t3.font = this.rv();
      for (const e3 of s2) if (e3.weight < n2) {
        const s3 = e3.needAlignCoordinate ? this.Lm(t3, e3.coord, e3.label) : e3.coord;
        t3.fillText(e3.label, s3, i3);
      }
      this.Vv.F().timeScale.allowBoldLabels && (t3.font = this.Om());
      for (const e3 of s2) if (e3.weight >= n2) {
        const s3 = e3.needAlignCoordinate ? this.Lm(t3, e3.coord, e3.label) : e3.coord;
        t3.fillText(e3.label, s3, i3);
      }
    });
  }
  Lm(t2, i2, s2) {
    const n2 = this.Wp.measureText(t2, s2), e2 = n2 / 2, r2 = Math.floor(i2 - e2) + 0.5;
    return r2 < 0 ? i2 += Math.abs(0 - r2) : r2 + n2 > this.Np.width && (i2 -= Math.abs(this.Np.width - (r2 + n2))), i2;
  }
  Am(t2, i2) {
    const s2 = this.Bm();
    for (const n2 of t2) for (const t3 of n2.ps()) t3.Bt().lt(i2, s2);
  }
  zm() {
    return this.Vv.F().timeScale.borderColor;
  }
  U() {
    return this.Ts.textColor;
  }
  W() {
    return this.Ts.fontSize;
  }
  rv() {
    return S(this.W(), this.Ts.fontFamily);
  }
  Om() {
    return S(this.W(), this.Ts.fontFamily, "bold");
  }
  Bm() {
    null === this.M && (this.M = { S: 1, O: NaN, L: NaN, B: NaN, ss: NaN, C: 5, P: NaN, k: "", ts: new rt(), Vm: 0 });
    const t2 = this.M, i2 = this.rv();
    if (t2.k !== i2) {
      const s2 = this.W();
      t2.P = s2, t2.k = i2, t2.L = 3 * s2 / 12, t2.B = 3 * s2 / 12, t2.ss = 9 * s2 / 12, t2.O = 0, t2.Vm = 4 * s2 / 12, t2.ts.reset();
    }
    return this.M;
  }
  wv(t2) {
    this.rp.style.cursor = 1 === t2 ? "ew-resize" : "default";
  }
  km() {
    const t2 = this.Vv.ni(), i2 = t2.F();
    i2.leftPriceScale.visible || null === this.wm || (this.Sm.removeChild(this.wm.lp()), this.wm.m(), this.wm = null), i2.rightPriceScale.visible || null === this.Mm || (this.Cm.removeChild(this.Mm.lp()), this.Mm.m(), this.Mm = null);
    const s2 = { qc: this.Vv.ni().qc() }, n2 = () => i2.leftPriceScale.borderVisible && t2.Ot().F().borderVisible, e2 = () => t2.j();
    i2.leftPriceScale.visible && null === this.wm && (this.wm = new Es("left", i2, s2, n2, e2), this.Sm.appendChild(this.wm.lp())), i2.rightPriceScale.visible && null === this.Mm && (this.Mm = new Es("right", i2, s2, n2, e2), this.Cm.appendChild(this.Mm.lp()));
  }
}
const Fs = !!rs && !!navigator.userAgentData && navigator.userAgentData.brands.some((t2) => t2.brand.includes("Chromium")) && !!rs && (((_a2 = navigator == null ? void 0 : navigator.userAgentData) == null ? void 0 : _a2.platform) ? "Windows" === navigator.userAgentData.platform : navigator.userAgent.toLowerCase().indexOf("win") >= 0);
class Ws {
  constructor(t2, i2, s2) {
    var n2;
    this.Nm = [], this.Fm = [], this.Wm = 0, this.nl = 0, this.bo = 0, this.Hm = 0, this.Um = 0, this.$m = null, this.qm = false, this.Cv = new d$1(), this.Pv = new d$1(), this.rc = new d$1(), this.Ym = null, this.jm = null, this.Km = t2, this.Ts = i2, this.o_ = s2, this.xm = document.createElement("div"), this.xm.classList.add("tv-lightweight-charts"), this.xm.style.overflow = "hidden", this.xm.style.direction = "ltr", this.xm.style.width = "100%", this.xm.style.height = "100%", (n2 = this.xm).style.userSelect = "none", n2.style.webkitUserSelect = "none", n2.style.msUserSelect = "none", n2.style.MozUserSelect = "none", n2.style.webkitTapHighlightColor = "transparent", this.Xm = document.createElement("table"), this.Xm.setAttribute("cellspacing", "0"), this.xm.appendChild(this.Xm), this.Gm = this.Zm.bind(this), Hs(this.Ts) && this.Jm(true), this.es = new Fi(this.ac.bind(this), this.Ts, s2), this.ni().Cc().i(this.Qm.bind(this), this), this.tw = new Ns(this, this.o_), this.Xm.appendChild(this.tw.lp());
    const e2 = i2.autoSize && this.iw();
    let r2 = this.Ts.width, h2 = this.Ts.height;
    if (e2 || 0 === r2 || 0 === h2) {
      const i3 = t2.getBoundingClientRect();
      r2 = r2 || i3.width, h2 = h2 || i3.height;
    }
    this.sw(r2, h2), this.nw(), t2.appendChild(this.xm), this.ew(), this.es.Ot().Bu().i(this.es.Eh.bind(this.es), this), this.es.Bo().i(this.es.Eh.bind(this.es), this);
  }
  ni() {
    return this.es;
  }
  F() {
    return this.Ts;
  }
  sp() {
    return this.Nm;
  }
  rw() {
    return this.tw;
  }
  m() {
    this.Jm(false), 0 !== this.Wm && window.cancelAnimationFrame(this.Wm), this.es.Cc().u(this), this.es.Ot().Bu().u(this), this.es.Bo().u(this), this.es.m();
    for (const t2 of this.Nm) this.Xm.removeChild(t2.lp()), t2.Zv().u(this), t2.Jv().u(this), t2.m();
    this.Nm = [];
    for (const t2 of this.Fm) this.hw(t2);
    this.Fm = [], u(this.tw).m(), null !== this.xm.parentElement && this.xm.parentElement.removeChild(this.xm), this.rc.m(), this.Cv.m(), this.Pv.m(), this.aw();
  }
  sw(i2, s2, n2 = false) {
    if (this.nl === s2 && this.bo === i2) return;
    const e2 = function(i3) {
      const s3 = Math.floor(i3.width), n3 = Math.floor(i3.height);
      return size$1({ width: s3 - s3 % 2, height: n3 - n3 % 2 });
    }(size$1({ width: i2, height: s2 }));
    this.nl = e2.height, this.bo = e2.width;
    const r2 = this.nl + "px", h2 = this.bo + "px";
    u(this.xm).style.height = r2, u(this.xm).style.width = h2, this.Xm.style.height = r2, this.Xm.style.width = h2, n2 ? this.lw(Z.Sn(), performance.now()) : this.es.Eh();
  }
  _v(t2) {
    void 0 === t2 && (t2 = Z.Sn());
    for (let i2 = 0; i2 < this.Nm.length; i2++) this.Nm[i2]._v(t2.ln(i2).rn);
    this.Ts.timeScale.visible && this.tw._v(t2.an());
  }
  hr(t2) {
    var _a3;
    const i2 = Hs(this.Ts);
    this.es.hr(t2);
    const s2 = Hs(this.Ts);
    s2 !== i2 && this.Jm(s2), ((_a3 = t2.layout) == null ? void 0 : _a3.panes) && this.ow(), this.ew(), this._w(t2);
  }
  Zv() {
    return this.Cv;
  }
  Jv() {
    return this.Pv;
  }
  Cc() {
    return this.rc;
  }
  uw() {
    null !== this.$m && (this.lw(this.$m, performance.now()), this.$m = null);
    const t2 = this.cw(null), i2 = document.createElement("canvas");
    i2.width = t2.width, i2.height = t2.height;
    const s2 = u(i2.getContext("2d"));
    return this.cw(s2), i2;
  }
  dw(t2) {
    if ("left" === t2 && !this.fw()) return 0;
    if ("right" === t2 && !this.pw()) return 0;
    if (0 === this.Nm.length) return 0;
    return u("left" === t2 ? this.Nm[0].hm() : this.Nm[0].am()).lv();
  }
  mw() {
    return this.Ts.autoSize && null !== this.Ym;
  }
  dp() {
    return this.xm;
  }
  ww(t2) {
    this.jm = t2, this.jm ? this.dp().style.setProperty("cursor", t2) : this.dp().style.removeProperty("cursor");
  }
  Mw() {
    return this.jm;
  }
  gw(t2) {
    return _(this.Nm[t2]).op();
  }
  ow() {
    this.Fm.forEach((t2) => {
      t2.Dt();
    });
  }
  _w(t2) {
    (void 0 !== t2.autoSize || !this.Ym || void 0 === t2.width && void 0 === t2.height) && (t2.autoSize && !this.Ym && this.iw(), false === t2.autoSize && null !== this.Ym && this.aw(), t2.autoSize || void 0 === t2.width && void 0 === t2.height || this.sw(t2.width || this.bo, t2.height || this.nl));
  }
  cw(i2) {
    let s2 = 0, n2 = 0;
    const e2 = this.Nm[0], r2 = (t2, s3) => {
      let n3 = 0;
      for (let e3 = 0; e3 < this.Nm.length; e3++) {
        const r3 = this.Nm[e3], h3 = u("left" === t2 ? r3.hm() : r3.am()), a2 = h3._p();
        if (null !== i2 && h3.up(i2, s3, n3), n3 += a2.height, e3 < this.Nm.length - 1) {
          const t3 = this.Fm[e3], r4 = t3._p();
          null !== i2 && t3.up(i2, s3, n3), n3 += r4.height;
        }
      }
    };
    if (this.fw()) {
      r2("left", 0);
      s2 += u(e2.hm())._p().width;
    }
    for (let t2 = 0; t2 < this.Nm.length; t2++) {
      const e3 = this.Nm[t2], r3 = e3._p();
      if (null !== i2 && e3.up(i2, s2, n2), n2 += r3.height, t2 < this.Nm.length - 1) {
        const e4 = this.Fm[t2], r4 = e4._p();
        null !== i2 && e4.up(i2, s2, n2), n2 += r4.height;
      }
    }
    if (s2 += e2._p().width, this.pw()) {
      r2("right", s2);
      s2 += u(e2.am())._p().width;
    }
    const h2 = (t2, s3, n3) => {
      u("left" === t2 ? this.tw.ym() : this.tw.Tm()).up(u(i2), s3, n3);
    };
    if (this.Ts.timeScale.visible) {
      const t2 = this.tw._p();
      if (null !== i2) {
        let s3 = 0;
        this.fw() && (h2("left", s3, n2), s3 = u(e2.hm())._p().width), this.tw.up(i2, s3, n2), s3 += t2.width, this.pw() && h2("right", s3, n2);
      }
      n2 += t2.height;
    }
    return size$1({ width: s2, height: n2 });
  }
  bw() {
    let i2 = 0, s2 = 0, n2 = 0;
    for (const t2 of this.Nm) this.fw() && (s2 = Math.max(s2, u(t2.hm()).ev(), this.Ts.leftPriceScale.minimumWidth)), this.pw() && (n2 = Math.max(n2, u(t2.am()).ev(), this.Ts.rightPriceScale.minimumWidth)), i2 += t2.Vo();
    s2 = ls(s2), n2 = ls(n2);
    const e2 = this.bo, r2 = this.nl, h2 = Math.max(e2 - s2 - n2, 0), a2 = 1 * this.Fm.length, l2 = this.Ts.timeScale.visible;
    let o2 = l2 ? Math.max(this.tw.Im(), this.Ts.timeScale.minimumHeight) : 0;
    var _2;
    o2 = (_2 = o2) + _2 % 2;
    const c2 = a2 + o2, d3 = r2 < c2 ? 0 : r2 - c2, f2 = d3 / i2;
    let p2 = 0;
    const v2 = window.devicePixelRatio || 1;
    for (let i3 = 0; i3 < this.Nm.length; ++i3) {
      const e3 = this.Nm[i3];
      e3.Nv(this.es.Xs()[i3]);
      let r3 = 0, a3 = 0;
      a3 = i3 === this.Nm.length - 1 ? Math.ceil((d3 - p2) * v2) / v2 : Math.round(e3.Vo() * f2 * v2) / v2, r3 = Math.max(a3, 2), p2 += r3, e3.av(size$1({ width: h2, height: r3 })), this.fw() && e3.tm(s2, "left"), this.pw() && e3.tm(n2, "right"), e3.Mp() && this.es.Pc(e3.Mp(), r3);
    }
    this.tw.Dm(size$1({ width: l2 ? h2 : 0, height: o2 }), l2 ? s2 : 0, l2 ? n2 : 0), this.es.Ao(h2), this.Hm !== s2 && (this.Hm = s2), this.Um !== n2 && (this.Um = n2);
  }
  Jm(t2) {
    t2 ? this.xm.addEventListener("wheel", this.Gm, { passive: false }) : this.xm.removeEventListener("wheel", this.Gm);
  }
  xw(t2) {
    switch (t2.deltaMode) {
      case t2.DOM_DELTA_PAGE:
        return 120;
      case t2.DOM_DELTA_LINE:
        return 32;
    }
    return Fs ? 1 / window.devicePixelRatio : 1;
  }
  Zm(t2) {
    if (!(0 !== t2.deltaX && this.Ts.handleScroll.mouseWheel || 0 !== t2.deltaY && this.Ts.handleScale.mouseWheel)) return;
    const i2 = this.xw(t2), s2 = i2 * t2.deltaX / 100, n2 = -i2 * t2.deltaY / 100;
    if (t2.cancelable && t2.preventDefault(), 0 !== n2 && this.Ts.handleScale.mouseWheel) {
      const i3 = Math.sign(n2) * Math.min(1, Math.abs(n2)), s3 = t2.clientX - this.xm.getBoundingClientRect().left;
      this.ni().Bc(s3, i3);
    }
    0 !== s2 && this.Ts.handleScroll.mouseWheel && this.ni().Vc(-80 * s2);
  }
  lw(t2, i2) {
    var _a3;
    const s2 = t2.an();
    3 === s2 && this.Sw(), 3 !== s2 && 2 !== s2 || (this.Cw(t2), this.Pw(t2, i2), this.tw.Dt(), this.Nm.forEach((t3) => {
      t3.Wv();
    }), 3 === ((_a3 = this.$m) == null ? void 0 : _a3.an()) && (this.$m.gn(t2), this.Sw(), this.Cw(this.$m), this.Pw(this.$m, i2), t2 = this.$m, this.$m = null)), this._v(t2);
  }
  Pw(t2, i2) {
    for (const s2 of t2.Mn()) this.bn(s2, i2);
  }
  Cw(t2) {
    const i2 = this.es.Xs();
    for (let s2 = 0; s2 < i2.length; s2++) t2.ln(s2).hn && i2[s2].Jo();
  }
  bn(t2, i2) {
    const s2 = this.es.Ot();
    switch (t2.cn) {
      case 0:
        s2.Eu();
        break;
      case 1:
        s2.Au(t2.qt);
        break;
      case 2:
        s2.mn(t2.qt);
        break;
      case 3:
        s2.wn(t2.qt);
        break;
      case 4:
        s2.Su();
        break;
      case 5:
        t2.qt.Ju(i2) || s2.wn(t2.qt.Fs(i2));
    }
  }
  ac(t2) {
    null !== this.$m ? this.$m.gn(t2) : this.$m = t2, this.qm || (this.qm = true, this.Wm = window.requestAnimationFrame((t3) => {
      if (this.qm = false, this.Wm = 0, null !== this.$m) {
        const i2 = this.$m;
        this.$m = null, this.lw(i2, t3);
        for (const s2 of i2.Mn()) if (5 === s2.cn && !s2.qt.Ju(t3)) {
          this.ni().fn(s2.qt);
          break;
        }
      }
    }));
  }
  Sw() {
    this.nw();
  }
  hw(t2) {
    this.Xm.removeChild(t2.lp()), t2.m();
  }
  nw() {
    const t2 = this.es.Xs(), i2 = t2.length, s2 = this.Nm.length;
    for (let t3 = i2; t3 < s2; t3++) {
      const t4 = _(this.Nm.pop());
      this.Xm.removeChild(t4.lp()), t4.Zv().u(this), t4.Jv().u(this), t4.m();
      const i3 = this.Fm.pop();
      void 0 !== i3 && this.hw(i3);
    }
    for (let n2 = s2; n2 < i2; n2++) {
      const i3 = new Vs(this, t2[n2]);
      if (i3.Zv().i(this.kw.bind(this, i3), this), i3.Jv().i(this.yw.bind(this, i3), this), this.Nm.push(i3), n2 > 0) {
        const t3 = new vs(this, n2 - 1, n2);
        this.Fm.push(t3), this.Xm.insertBefore(t3.lp(), this.tw.lp());
      }
      this.Xm.insertBefore(i3.lp(), this.tw.lp());
    }
    for (let s3 = 0; s3 < i2; s3++) {
      const i3 = t2[s3], n2 = this.Nm[s3];
      n2.Mp() !== i3 ? n2.Nv(i3) : n2.Ov();
    }
    this.ew(), this.bw();
  }
  Tw(t2, i2, s2, n2) {
    var _a3;
    const e2 = /* @__PURE__ */ new Map();
    if (null !== t2) {
      this.es.Js().forEach((i3) => {
        const s3 = i3.Qs().Nr(t2);
        null !== s3 && e2.set(i3, s3);
      });
    }
    let r2;
    if (null !== t2) {
      const i3 = (_a3 = this.es.Ot().Q_(t2)) == null ? void 0 : _a3.originalTime;
      void 0 !== i3 && (r2 = i3);
    }
    const h2 = this.ni().mc(), a2 = null !== h2 && h2.n_ instanceof jt ? h2.n_ : void 0, l2 = null !== h2 && void 0 !== h2.e_ ? h2.e_.externalId : void 0, o2 = this.Rw(n2);
    return { Dw: r2, Te: t2 ?? void 0, Iw: i2 ?? void 0, Bw: -1 !== o2 ? o2 : void 0, Vw: a2, Ew: e2, Aw: l2, zw: s2 ?? void 0 };
  }
  Rw(t2) {
    let i2 = -1;
    if (t2) i2 = this.Nm.indexOf(t2);
    else {
      const t3 = this.ni().Sc().Ks();
      null !== t3 && (i2 = this.ni().Xs().indexOf(t3));
    }
    return i2;
  }
  kw(t2, i2, s2, n2) {
    this.Cv.p(() => this.Tw(i2, s2, n2, t2));
  }
  yw(t2, i2, s2, n2) {
    this.Pv.p(() => this.Tw(i2, s2, n2, t2));
  }
  Qm(t2, i2, s2) {
    var _a3;
    this.ww(((_a3 = this.ni().mc()) == null ? void 0 : _a3.h_) ?? null), this.rc.p(() => this.Tw(t2, i2, s2));
  }
  ew() {
    const t2 = this.Ts.timeScale.visible ? "" : "none";
    this.tw.lp().style.display = t2;
  }
  fw() {
    return this.Nm[0].Mp().Ho().F().visible;
  }
  pw() {
    return this.Nm[0].Mp().Uo().F().visible;
  }
  iw() {
    return "ResizeObserver" in window && (this.Ym = new ResizeObserver((t2) => {
      const i2 = t2[t2.length - 1];
      i2 && this.sw(i2.contentRect.width, i2.contentRect.height);
    }), this.Ym.observe(this.Km, { box: "border-box" }), true);
  }
  aw() {
    null !== this.Ym && this.Ym.disconnect(), this.Ym = null;
  }
}
function Hs(t2) {
  return Boolean(t2.handleScroll.mouseWheel || t2.handleScale.mouseWheel);
}
function Us(t2) {
  return void 0 === t2.open && void 0 === t2.value;
}
function $s(t2) {
  return function(t3) {
    return void 0 !== t3.open;
  }(t2) || function(t3) {
    return void 0 !== t3.value;
  }(t2);
}
function qs(t2, i2, s2, n2) {
  const e2 = s2.value, r2 = { index: i2, time: t2, value: [e2, e2, e2, e2], originalTime: n2 };
  return void 0 !== s2.color && (r2.R = s2.color), r2;
}
function Ys(t2, i2, s2, n2) {
  const e2 = s2.value, r2 = { index: i2, time: t2, value: [e2, e2, e2, e2], originalTime: n2 };
  return void 0 !== s2.lineColor && (r2.bt = s2.lineColor), void 0 !== s2.topColor && (r2.wr = s2.topColor), void 0 !== s2.bottomColor && (r2.Mr = s2.bottomColor), r2;
}
function js(t2, i2, s2, n2) {
  const e2 = s2.value, r2 = { index: i2, time: t2, value: [e2, e2, e2, e2], originalTime: n2 };
  return void 0 !== s2.topLineColor && (r2.gr = s2.topLineColor), void 0 !== s2.bottomLineColor && (r2.br = s2.bottomLineColor), void 0 !== s2.topFillColor1 && (r2.Sr = s2.topFillColor1), void 0 !== s2.topFillColor2 && (r2.Cr = s2.topFillColor2), void 0 !== s2.bottomFillColor1 && (r2.Pr = s2.bottomFillColor1), void 0 !== s2.bottomFillColor2 && (r2.kr = s2.bottomFillColor2), r2;
}
function Ks(t2, i2, s2, n2) {
  const e2 = { index: i2, time: t2, value: [s2.open, s2.high, s2.low, s2.close], originalTime: n2 };
  return void 0 !== s2.color && (e2.R = s2.color), e2;
}
function Xs(t2, i2, s2, n2) {
  const e2 = { index: i2, time: t2, value: [s2.open, s2.high, s2.low, s2.close], originalTime: n2 };
  return void 0 !== s2.color && (e2.R = s2.color), void 0 !== s2.borderColor && (e2.Yt = s2.borderColor), void 0 !== s2.wickColor && (e2.vr = s2.wickColor), e2;
}
function Gs(t2, i2, s2, n2) {
  const e2 = { index: i2, time: t2, value: [s2.open, s2.high, s2.low, s2.close], originalTime: n2 };
  return void 0 !== s2.color && (e2.R = s2.color), void 0 !== s2.borderColor && (e2.Yt = s2.borderColor), void 0 !== s2.wickColor && (e2.vr = s2.wickColor), e2;
}
function Zs(t2, i2, s2, n2, e2) {
  const r2 = _(e2)(s2), h2 = Math.max(...r2), a2 = Math.min(...r2), l2 = r2[r2.length - 1], o2 = [l2, h2, a2, l2], { time: u2, ...c2 } = s2;
  return { index: i2, time: t2, value: o2, originalTime: n2, ie: c2, R: c2.color };
}
function Js(t2) {
  return void 0 !== t2.value;
}
function Qs(t2, i2) {
  return void 0 !== i2.customValues && (t2.customValues = i2.customValues), t2;
}
function tn(t2) {
  return (i2, s2, n2, e2, r2, h2) => function(t3, i3) {
    return i3 ? i3(t3) : Us(t3);
  }(n2, h2) ? Qs({ xt: i2, Te: s2, Dw: e2 }, n2) : Qs(t2(i2, s2, n2, e2, r2), n2);
}
function sn(t2) {
  return { Candlestick: tn(Xs), HollowCandlestick: tn(Gs), Bar: tn(Ks), Area: tn(Ys), Baseline: tn(js), Histogram: tn(qs), Line: tn(qs), Custom: tn(Zs) }[t2];
}
function nn(t2) {
  return { Te: 0, Lw: /* @__PURE__ */ new Map(), Uh: t2 };
}
function en$1(t2, i2) {
  if (void 0 !== t2 && 0 !== t2.length) return { Ow: i2.key(t2[0].time), Nw: i2.key(t2[t2.length - 1].time) };
}
function rn(t2) {
  let i2;
  return t2.forEach((t3) => {
    void 0 === i2 && (i2 = t3.originalTime);
  }), _(i2);
}
class hn {
  constructor(t2) {
    this.Fw = /* @__PURE__ */ new Map(), this.Ww = /* @__PURE__ */ new Map(), this.Hw = /* @__PURE__ */ new Map(), this.Uw = [], this.o_ = t2;
  }
  m() {
    this.Fw.clear(), this.Ww.clear(), this.Hw.clear(), this.Uw = [];
  }
  $w(t2, i2) {
    let s2 = 0 !== this.Fw.size, n2 = false;
    const e2 = this.Ww.get(t2);
    if (void 0 !== e2) if (1 === this.Ww.size) s2 = false, n2 = true, this.Fw.clear();
    else for (const i3 of this.Uw) i3.pointData.Lw.delete(t2) && (n2 = true);
    let r2 = [];
    if (0 !== i2.length) {
      const s3 = i2.map((t3) => t3.time), e3 = this.o_.createConverterToInternalObj(i2), h3 = sn(t2.Dr()), a2 = t2.fa(), l2 = t2.va();
      r2 = i2.map((i3, r3) => {
        const o2 = e3(i3.time), _2 = this.o_.key(o2);
        let u2 = this.Fw.get(_2);
        void 0 === u2 && (u2 = nn(o2), this.Fw.set(_2, u2), n2 = true);
        const c2 = h3(o2, u2.Te, i3, s3[r3], a2, l2);
        return u2.Lw.set(t2, c2), c2;
      });
    }
    s2 && this.qw(), this.Yw(t2, r2);
    let h2 = -1;
    if (n2) {
      const t3 = [];
      this.Fw.forEach((i3) => {
        t3.push({ timeWeight: 0, time: i3.Uh, pointData: i3, originalTime: rn(i3.Lw) });
      }), t3.sort((t4, i3) => this.o_.key(t4.time) - this.o_.key(i3.time)), h2 = this.jw(t3);
    }
    return this.Kw(t2, h2, function(t3, i3, s3) {
      const n3 = en$1(t3, s3), e3 = en$1(i3, s3);
      if (void 0 !== n3 && void 0 !== e3) return { Xw: false, Lh: n3.Nw >= e3.Nw && n3.Ow >= e3.Ow };
    }(this.Ww.get(t2), e2, this.o_));
  }
  Kc(t2) {
    return this.$w(t2, []);
  }
  Gw(t2, i2, s2) {
    const n2 = i2;
    !function(t3) {
      void 0 === t3.Dw && (t3.Dw = t3.time);
    }(n2), this.o_.preprocessData(i2);
    const e2 = this.o_.createConverterToInternalObj([i2])(i2.time), r2 = this.Hw.get(t2);
    if (!s2 && void 0 !== r2 && this.o_.key(e2) < this.o_.key(r2)) throw new Error(`Cannot update oldest data, last time=${r2}, new time=${e2}`);
    let h2 = this.Fw.get(this.o_.key(e2));
    if (s2 && void 0 === h2) throw new Error("Cannot update non-existing data point when historicalUpdate is true");
    const a2 = void 0 === h2;
    void 0 === h2 && (h2 = nn(e2), this.Fw.set(this.o_.key(e2), h2));
    const l2 = sn(t2.Dr()), o2 = t2.fa(), _2 = t2.va(), u2 = l2(e2, h2.Te, i2, n2.Dw, o2, _2);
    h2.Lw.set(t2, u2), s2 ? this.Zw(t2, u2, h2.Te) : this.Jw(t2, u2);
    const c2 = { Lh: Js(u2), Xw: s2 };
    if (!a2) return this.Kw(t2, -1, c2);
    const d3 = { timeWeight: 0, time: h2.Uh, pointData: h2, originalTime: rn(h2.Lw) }, f2 = kt(this.Uw, this.o_.key(d3.time), (t3, i3) => this.o_.key(t3.time) < i3);
    this.Uw.splice(f2, 0, d3);
    for (let t3 = f2; t3 < this.Uw.length; ++t3) an(this.Uw[t3].pointData, t3);
    return this.o_.fillWeightsForPoints(this.Uw, f2), this.Kw(t2, f2, c2);
  }
  Jw(t2, i2) {
    let s2 = this.Ww.get(t2);
    void 0 === s2 && (s2 = [], this.Ww.set(t2, s2));
    const n2 = 0 !== s2.length ? s2[s2.length - 1] : null;
    null === n2 || this.o_.key(i2.time) > this.o_.key(n2.time) ? Js(i2) && s2.push(i2) : Js(i2) ? s2[s2.length - 1] = i2 : s2.splice(-1, 1), this.Hw.set(t2, i2.time);
  }
  Zw(t2, i2, s2) {
    const n2 = this.Ww.get(t2);
    if (void 0 === n2) return;
    const e2 = kt(n2, s2, (t3, i3) => t3.index < i3);
    Js(i2) ? n2[e2] = i2 : n2.splice(e2, 1);
  }
  Yw(t2, i2) {
    0 !== i2.length ? (this.Ww.set(t2, i2.filter(Js)), this.Hw.set(t2, i2[i2.length - 1].time)) : (this.Ww.delete(t2), this.Hw.delete(t2));
  }
  qw() {
    for (const t2 of this.Uw) 0 === t2.pointData.Lw.size && this.Fw.delete(this.o_.key(t2.time));
  }
  jw(t2) {
    let i2 = -1;
    for (let s2 = 0; s2 < this.Uw.length && s2 < t2.length; ++s2) {
      const n2 = this.Uw[s2], e2 = t2[s2];
      if (this.o_.key(n2.time) !== this.o_.key(e2.time)) {
        i2 = s2;
        break;
      }
      e2.timeWeight = n2.timeWeight, an(e2.pointData, s2);
    }
    if (-1 === i2 && this.Uw.length !== t2.length && (i2 = Math.min(this.Uw.length, t2.length)), -1 === i2) return -1;
    for (let s2 = i2; s2 < t2.length; ++s2) an(t2[s2].pointData, s2);
    return this.o_.fillWeightsForPoints(t2, i2), this.Uw = t2, i2;
  }
  Qw() {
    if (0 === this.Ww.size) return null;
    let t2 = 0;
    return this.Ww.forEach((i2) => {
      0 !== i2.length && (t2 = Math.max(t2, i2[i2.length - 1].index));
    }), t2;
  }
  Kw(t2, i2, s2) {
    const n2 = { No: /* @__PURE__ */ new Map(), Ot: { uu: this.Qw() } };
    if (-1 !== i2) this.Ww.forEach((i3, e2) => {
      n2.No.set(e2, { ie: i3, tM: e2 === t2 ? s2 : void 0 });
    }), this.Ww.has(t2) || n2.No.set(t2, { ie: [], tM: s2 }), n2.Ot.Ou = this.Uw, n2.Ot.iM = i2;
    else {
      const i3 = this.Ww.get(t2);
      n2.No.set(t2, { ie: i3 || [], tM: s2 });
    }
    return n2;
  }
}
function an(t2, i2) {
  t2.Te = i2, t2.Lw.forEach((t3) => {
    t3.index = i2;
  });
}
class ln {
  constructor(t2) {
    this.sM = null, this.nM = null, this.eM = null, this.rM = t2;
  }
  hM() {
    const t2 = this.rM.nu();
    if (null === t2) return [];
    const i2 = Math.round(t2.$h()), s2 = Math.round(t2.ki()), n2 = this.rM.uu();
    if (null === this.nM || null === this.eM || this.sM !== n2) {
      const t3 = this.rM.wu();
      this.eM = Math.floor(120 / t3), this.nM = s2 % this.eM, this.sM = n2;
    }
    const e2 = c(this.nM), r2 = [];
    let h2 = Math.floor((i2 - e2) / this.eM);
    const a2 = Math.floor((s2 - e2) / this.eM);
    for (; h2 <= a2; h2++) r2.push(e2 + h2 * this.eM);
    return r2;
  }
  aM() {
    this.nM = null, this.sM = null, this.eM = null;
  }
}
function on$1(t2, i2) {
  return t2.xt < i2;
}
function _n(t2, i2) {
  return i2 < t2.xt;
}
function un(t2, i2, s2) {
  const n2 = i2.$h(), e2 = i2.ki(), r2 = kt(t2, n2, on$1), h2 = yt(t2, e2, _n);
  if (!s2) return { from: r2, to: h2 };
  let a2 = r2, l2 = h2;
  return r2 > 0 && r2 < t2.length && t2[r2].xt >= n2 && (a2 = r2 - 1), h2 > 0 && h2 < t2.length && t2[h2 - 1].xt <= e2 && (l2 = h2 + 1), { from: a2, to: l2 };
}
class cn {
  constructor(t2, i2, s2) {
    this.lM = true, this.oM = true, this._M = true, this.uM = [], this.cM = null, this.Zn = t2, this.Jn = i2, this.dM = s2, this.fM = new ln(this.Jn.Ot());
  }
  Dt(t2) {
    this.lM = true, "data" === t2 && (this.oM = true), "options" === t2 && (this._M = true);
  }
  Bt() {
    return this.Zn.At() ? (this.pM(), null === this.cM ? null : this.vM) : null;
  }
  mM() {
    this.uM = this.uM.map((t2) => ({ ...t2, ...this.Zn.Dh().Ir(t2.xt) }));
  }
  wM() {
    this.cM = null;
  }
  MM() {
    const t2 = this.Jn.Un(this.Zn);
    if (!t2) return null;
    const i2 = t2.Kt(), s2 = { Ou: [], gM: [], At: true }, n2 = this.Zn.Ft();
    if (null === n2) return null;
    for (const t3 of this.fM.hM()) {
      const e2 = Math.round(t3), r2 = this.Zn.Qs().Nr(e2);
      if (!r2) continue;
      const h2 = r2.value, a2 = h2.reduce((t4, i3) => t4 + i3) / h2.length, l2 = this.Jn.Ot().Xt(e2), o2 = this.Zn.$t().Ut(a2, n2.qt);
      s2.Ou.push({ x: l2, y: o2 });
      const _2 = o2 / i2, u2 = this.Jn.jt(_2);
      s2.gM.push(u2);
    }
    return s2;
  }
  pM() {
    this.oM && (this.fM.aM(), this.bM(), this.oM = false), this._M && (this.mM(), this._M = false), this.lM && (this.xM(), this.lM = false);
  }
  xM() {
    const t2 = this.Zn.$t(), i2 = this.Jn.Ot();
    if (this.wM(), i2.Zi() || t2.Zi()) return;
    const s2 = i2.Ce();
    if (null === s2) return;
    if (0 === this.Zn.Qs().size()) return;
    const n2 = this.Zn.Ft();
    null !== n2 && (this.cM = un(this.uM, s2, this.dM), this.SM(t2, i2, n2.qt), this.CM());
  }
}
class dn {
  constructor(t2, i2) {
    this.PM = t2, this.Xi = i2;
  }
  lt(t2, i2, s2) {
    this.PM.draw(t2, this.Xi, i2, s2);
  }
  ht(t2, i2) {
    return this.PM.hitTest ? this.PM.hitTest(t2, i2) : null;
  }
}
class fn extends cn {
  constructor(t2, i2, s2) {
    super(t2, i2, false), this.sh = s2, this.vM = new dn(this.sh.renderer(), (i3) => {
      const s3 = t2.Ft();
      return null === s3 ? null : t2.$t().Ut(i3, s3.qt);
    });
  }
  pa(t2) {
    return this.sh.priceValueBuilder(t2);
  }
  ma(t2) {
    return this.sh.isWhitespace(t2);
  }
  bM() {
    const t2 = this.Zn.Dh();
    this.uM = this.Zn.Qs().Wr().map((i2) => ({ xt: i2.index, ft: NaN, ...t2.Ir(i2.index), kM: i2.ie }));
  }
  SM(t2, i2) {
    i2.cu(this.uM, b(this.cM));
  }
  CM() {
    this.sh.update({ bars: this.uM.map(pn), barSpacing: this.Jn.Ot().wu(), visibleRange: this.cM }, this.Zn.F());
  }
}
function pn(t2) {
  return { x: t2.ft, time: t2.xt, originalData: t2.kM, barColor: t2.cr };
}
const vn = { color: "#2196f3" }, mn = (t2, i2, s2) => {
  const n2 = c(s2);
  return new fn(t2, i2, n2);
};
function wn(t2) {
  const i2 = { value: t2.value[3], time: t2.originalTime };
  return void 0 !== t2.customValues && (i2.customValues = t2.customValues), i2;
}
function Mn(t2) {
  const i2 = wn(t2);
  return void 0 !== t2.R && (i2.color = t2.R), i2;
}
function gn(t2) {
  const i2 = wn(t2);
  return void 0 !== t2.bt && (i2.lineColor = t2.bt), void 0 !== t2.wr && (i2.topColor = t2.wr), void 0 !== t2.Mr && (i2.bottomColor = t2.Mr), i2;
}
function bn(t2) {
  const i2 = wn(t2);
  return void 0 !== t2.gr && (i2.topLineColor = t2.gr), void 0 !== t2.br && (i2.bottomLineColor = t2.br), void 0 !== t2.Sr && (i2.topFillColor1 = t2.Sr), void 0 !== t2.Cr && (i2.topFillColor2 = t2.Cr), void 0 !== t2.Pr && (i2.bottomFillColor1 = t2.Pr), void 0 !== t2.kr && (i2.bottomFillColor2 = t2.kr), i2;
}
function xn(t2) {
  const i2 = { open: t2.value[0], high: t2.value[1], low: t2.value[2], close: t2.value[3], time: t2.originalTime };
  return void 0 !== t2.customValues && (i2.customValues = t2.customValues), i2;
}
function Sn(t2) {
  const i2 = xn(t2);
  return void 0 !== t2.R && (i2.color = t2.R), i2;
}
function Cn(t2) {
  const i2 = xn(t2), { R: s2, Yt: n2, vr: e2 } = t2;
  return void 0 !== s2 && (i2.color = s2), void 0 !== n2 && (i2.borderColor = n2), void 0 !== e2 && (i2.wickColor = e2), i2;
}
function Pn(t2) {
  const i2 = xn(t2), { R: s2, Yt: n2, vr: e2 } = t2;
  return void 0 !== s2 && (i2.color = s2), void 0 !== n2 && (i2.borderColor = n2), void 0 !== e2 && (i2.wickColor = e2), i2;
}
function kn(t2) {
  return { Area: gn, Line: Mn, Baseline: bn, Histogram: Mn, Bar: Sn, Candlestick: Cn, HollowCandlestick: Pn, Custom: yn }[t2];
}
function yn(t2) {
  const i2 = t2.originalTime;
  return { ...t2.ie, time: i2 };
}
const Tn = { vertLine: { color: "#9598A1", width: 1, style: 3, visible: true, labelVisible: true, labelBackgroundColor: "#131722" }, horzLine: { color: "#9598A1", width: 1, style: 3, visible: true, labelVisible: true, labelBackgroundColor: "#131722" }, mode: 1 }, Rn = { vertLines: { color: "#D6DCDE", style: 0, visible: true }, horzLines: { color: "#D6DCDE", style: 0, visible: true } }, Dn = { background: { type: "solid", color: "#FFFFFF" }, textColor: "#191919", fontSize: 12, fontFamily: x, panes: { enableResize: true, separatorColor: "#E0E3EB", separatorHoverColor: "rgba(178, 181, 189, 0.2)" }, attributionLogo: true, colorSpace: "srgb", colorParsers: [] }, In = { autoScale: true, mode: 0, invertScale: false, alignLabels: true, borderVisible: true, borderColor: "#2B2B43", entireTextOnly: false, visible: false, ticksVisible: false, scaleMargins: { bottom: 0.1, top: 0.2 }, minimumWidth: 0, ensureEdgeTickMarksVisible: false }, Bn = { rightOffset: 0, barSpacing: 6, minBarSpacing: 0.5, maxBarSpacing: 0, fixLeftEdge: false, fixRightEdge: false, lockVisibleTimeRangeOnResize: false, rightBarStaysOnScroll: false, borderVisible: true, borderColor: "#2B2B43", visible: true, timeVisible: false, secondsVisible: true, shiftVisibleRangeOnNewBar: true, allowShiftVisibleRangeOnWhitespaceReplacement: false, ticksVisible: false, uniformDistribution: false, minimumHeight: 0, allowBoldLabels: true, ignoreWhitespaceIndices: false };
function Vn() {
  return { addDefaultPane: true, width: 0, height: 0, autoSize: false, layout: Dn, crosshair: Tn, grid: Rn, overlayPriceScales: { ...In }, leftPriceScale: { ...In, visible: false }, rightPriceScale: { ...In, visible: true }, timeScale: Bn, localization: { locale: rs ? navigator.language : "", dateFormat: "dd MMM 'yy" }, handleScroll: { mouseWheel: true, pressedMouseMove: true, horzTouchDrag: true, vertTouchDrag: true }, handleScale: { axisPressedMouseMove: { time: true, price: true }, axisDoubleClickReset: { time: true, price: true }, mouseWheel: true, pinch: true }, kineticScroll: { mouse: false, touch: true }, trackingMode: { exitMode: 1 } };
}
class En {
  constructor(t2, i2, s2) {
    this.tp = t2, this.yM = i2, this.TM = s2 ?? 0;
  }
  applyOptions(t2) {
    this.tp.ni().bc(this.yM, t2, this.TM);
  }
  options() {
    return this.Xi().F();
  }
  width() {
    return G(this.yM) ? this.tp.dw(this.yM) : 0;
  }
  setVisibleRange(t2) {
    this.setAutoScale(false), this.Xi().Hl(new mt(t2.from, t2.to));
  }
  getVisibleRange() {
    const t2 = this.Xi().Je();
    return null === t2 ? null : { from: t2.Ue(), to: t2.$e() };
  }
  setAutoScale(t2) {
    this.applyOptions({ autoScale: t2 });
  }
  Xi() {
    return u(this.tp.ni().xc(this.yM, this.TM)).$t;
  }
}
class An {
  constructor(t2, i2, s2, n2) {
    this.tp = t2, this.Rt = s2, this.RM = i2, this.DM = n2;
  }
  getHeight() {
    return this.Rt.Kt();
  }
  setHeight(t2) {
    const i2 = this.tp.ni(), s2 = i2.Wc(this.Rt);
    i2.yc(s2, t2);
  }
  getStretchFactor() {
    return this.Rt.Vo();
  }
  setStretchFactor(t2) {
    this.Rt.Eo(t2), this.tp.ni().Eh();
  }
  paneIndex() {
    return this.tp.ni().Wc(this.Rt);
  }
  moveTo(t2) {
    const i2 = this.paneIndex();
    i2 !== t2 && (o$1(t2 >= 0 && t2 < this.tp.sp().length, "Invalid pane index"), this.tp.ni().Rc(i2, t2));
  }
  getSeries() {
    return this.Rt.No().map((t2) => this.RM(t2)) ?? [];
  }
  getHTMLElement() {
    const t2 = this.tp.sp();
    return t2 && 0 !== t2.length && t2[this.paneIndex()] ? t2[this.paneIndex()].lp() : null;
  }
  attachPrimitive(t2) {
    this.Rt.ua(t2), t2.attached && t2.attached({ chart: this.DM, requestUpdate: () => this.Rt.ni().Eh() });
  }
  detachPrimitive(t2) {
    this.Rt.ca(t2);
  }
  priceScale(t2) {
    if (null === this.Rt.Io(t2)) throw new Error(`Cannot find price scale with id: ${t2}`);
    return new En(this.tp, t2, this.paneIndex());
  }
  setPreserveEmptyPane(t2) {
    this.Rt.Lo(t2);
  }
  preserveEmptyPane() {
    return this.Rt.Oo();
  }
  addCustomSeries(t2, i2 = {}, s2 = 0) {
    return this.DM.addCustomSeries(t2, i2, s2);
  }
  addSeries(t2, i2 = {}) {
    return this.DM.addSeries(t2, i2, this.paneIndex());
  }
}
const zn = { color: "#FF0000", price: 0, lineStyle: 2, lineWidth: 1, lineVisible: true, axisLabelVisible: true, title: "", axisLabelColor: "", axisLabelTextColor: "", axisLabelBorderColor: "" };
class Ln {
  constructor(t2) {
    this.tr = t2;
  }
  applyOptions(t2) {
    this.tr.hr(t2);
  }
  options() {
    return this.tr.F();
  }
  IM() {
    return this.tr;
  }
}
class On {
  constructor(t2, i2, s2, n2, e2, r2) {
    this.BM = new d$1(), this.Zn = t2, this.VM = i2, this.EM = s2, this.o_ = e2, this.DM = n2, this.AM = r2;
  }
  m() {
    this.BM.m();
  }
  priceFormatter() {
    return this.Zn.nr();
  }
  priceToCoordinate(t2) {
    const i2 = this.Zn.Ft();
    return null === i2 ? null : this.Zn.$t().Ut(t2, i2.qt);
  }
  coordinateToPrice(t2) {
    const i2 = this.Zn.Ft();
    return null === i2 ? null : this.Zn.$t().Is(t2, i2.qt);
  }
  barsInLogicalRange(t2) {
    if (null === t2) return null;
    const i2 = new Di(new yi(t2.from, t2.to)).k_(), s2 = this.Zn.Qs();
    if (s2.Zi()) return null;
    const n2 = s2.Nr(i2.$h(), 1), e2 = s2.Nr(i2.ki(), -1), r2 = u(s2.firstIndex()), h2 = u(s2.lastIndex());
    if (null !== n2 && null !== e2 && n2.index > e2.index) return { barsBefore: t2.from - r2, barsAfter: h2 - t2.to };
    const a2 = { barsBefore: null === n2 || n2.index === r2 ? t2.from - r2 : n2.index - r2, barsAfter: null === e2 || e2.index === h2 ? h2 - t2.to : h2 - e2.index };
    return null !== n2 && null !== e2 && (a2.from = n2.originalTime, a2.to = e2.originalTime), a2;
  }
  setData(t2) {
    this.o_, this.Zn.Dr(), this.VM.zM(this.Zn, t2), this.LM("full");
  }
  update(t2, i2 = false) {
    this.Zn.Dr(), this.VM.OM(this.Zn, t2, i2), this.LM("update");
  }
  dataByIndex(t2, i2) {
    const s2 = this.Zn.Qs().Nr(t2, i2);
    if (null === s2) return null;
    return kn(this.seriesType())(s2);
  }
  barsProvider() {
    return { firstIndex: () => this.Zn.Qs().firstIndex(), lastIndex: () => this.Zn.Qs().lastIndex() };
  }
  plots() {
    return this.Zn.Qs();
  }
  data() {
    const t2 = kn(this.seriesType());
    return this.Zn.Qs().Wr().map((i2) => t2(i2));
  }
  subscribeDataChanged(t2) {
    this.BM.i(t2);
  }
  unsubscribeDataChanged(t2) {
    this.BM._(t2);
  }
  applyOptions(t2) {
    this.Zn.hr(t2);
  }
  options() {
    return M(this.Zn.F());
  }
  priceScale() {
    return this.EM.priceScale(this.Zn.$t().Ma(), this.getPane().paneIndex());
  }
  createPriceLine(t2) {
    const i2 = f(M(zn), t2), s2 = this.Zn.Nh(i2);
    return new Ln(s2);
  }
  removePriceLine(t2) {
    this.Zn.Fh(t2.IM());
  }
  priceLines() {
    return this.Zn.Wh().map((t2) => new Ln(t2));
  }
  seriesType() {
    return this.Zn.Dr();
  }
  attachPrimitive(t2) {
    this.Zn.ua(t2), t2.attached && t2.attached({ chart: this.DM, series: this, requestUpdate: () => this.Zn.ni().Eh(), horzScaleBehavior: this.o_ });
  }
  detachPrimitive(t2) {
    this.Zn.ca(t2), t2.detached && t2.detached(), this.Zn.ni().Eh();
  }
  primitives() {
    return this.Zn.da();
  }
  getPane() {
    const t2 = this.Zn, i2 = u(this.Zn.ni().Un(t2));
    return this.AM(i2);
  }
  moveToPane(t2) {
    this.Zn.ni().Jc(this.Zn, t2);
  }
  seriesOrder() {
    const t2 = this.Zn.ni().Un(this.Zn);
    return null === t2 ? -1 : t2.No().indexOf(this.Zn);
  }
  setSeriesOrder(t2) {
    const i2 = this.Zn.ni().Un(this.Zn);
    null !== i2 && i2.t_(this.Zn, t2);
  }
  updateAllViews() {
    this.Zn.$s();
  }
  requestUpdate() {
    return this.Zn.ni().Eh();
  }
  LM(t2) {
    this.BM.v() && this.BM.p(t2);
  }
}
class Nn {
  constructor(t2, i2, s2) {
    this.NM = new d$1(), this.z_ = new d$1(), this.bm = new d$1(), this.es = t2, this.dh = t2.Ot(), this.tw = i2, this.dh.Du().i(this.FM.bind(this)), this.dh.Iu().i(this.WM.bind(this)), this.tw.Rm().i(this.HM.bind(this)), this.o_ = s2;
  }
  m() {
    this.dh.Du().u(this), this.dh.Iu().u(this), this.tw.Rm().u(this), this.NM.m(), this.z_.m(), this.bm.m();
  }
  scrollPosition() {
    return this.dh.gu();
  }
  scrollToPosition(t2, i2) {
    i2 ? this.dh.Ru(t2, 1e3) : this.es.wn(t2);
  }
  scrollToRealTime(t2) {
    this.dh.Tu(t2);
  }
  getVisibleRange() {
    const t2 = this.dh.eu();
    return null === t2 ? null : { from: t2.from.originalTime, to: t2.to.originalTime };
  }
  setVisibleRange(t2) {
    const i2 = { from: this.o_.convertHorzItemToInternal(t2.from), to: this.o_.convertHorzItemToInternal(t2.to) }, s2 = this.dh.lu(i2);
    this.es.Gc(s2);
  }
  getVisibleLogicalRange() {
    const t2 = this.dh.nu();
    return null === t2 ? null : { from: t2.$h(), to: t2.ki() };
  }
  setVisibleLogicalRange(t2) {
    o$1(t2.from <= t2.to, "The from index cannot be after the to index."), this.es.Gc(t2);
  }
  resetTimeScale() {
    this.es.vn();
  }
  fitContent() {
    this.es.Eu();
  }
  logicalToCoordinate(t2) {
    const i2 = this.es.Ot();
    return i2.Zi() ? null : i2.Xt(t2);
  }
  coordinateToLogical(t2) {
    return this.dh.Zi() ? null : this.dh.du(t2);
  }
  timeToIndex(t2, i2) {
    const s2 = this.o_.convertHorzItemToInternal(t2);
    return this.dh.tu(s2, i2);
  }
  timeToIndexEx(t2) {
    var _a3, _b3;
    const i2 = this.o_.convertHorzItemToInternal(t2), s2 = this.dh.Ou();
    if (s2.length < 1) return null;
    if (this.o_.key(i2) > this.o_.key(s2[s2.length - 1].time)) {
      const i3 = this.dh.Ou()[s2.length - 1], n3 = (_a3 = this.dh.F().extendedScale) == null ? void 0 : _a3.getAdvanceUnit(i3.originalTime, t2);
      return void 0 === n3 ? null : s2.length - 1 + n3;
    }
    const n2 = kt(s2, this.o_.key(i2), (t3, i3) => this.o_.key(t3.time) < i3);
    if (this.o_.key(i2) < this.o_.key(s2[n2].time)) {
      const i3 = this.dh.Ou()[n2], s3 = (_b3 = this.dh.F().extendedScale) == null ? void 0 : _b3.getAdvanceUnit(t2, i3.originalTime);
      return void 0 === s3 ? null : n2 - s3;
    }
    return n2;
  }
  timeToCoordinate(t2) {
    const i2 = this.timeToIndex(t2, false);
    return null === i2 ? null : this.dh.Xt(i2);
  }
  timeToCoordinateEx(t2) {
    var _a3, _b3;
    const i2 = this.o_.convertHorzItemToInternal(t2), s2 = this.dh.zu(), n2 = this.dh.Lu();
    if (null === s2 || null === n2) return null;
    const e2 = this.dh.Ou()[n2];
    if (this.o_.key(i2) > this.o_.key(e2.time)) {
      const i3 = (_a3 = this.dh.F().extendedScale) == null ? void 0 : _a3.getAdvanceUnit(e2.originalTime, t2);
      return void 0 === i3 ? null : this.dh.Xt(n2 + i3);
    }
    const r2 = kt(this.dh.Ou(), this.o_.key(t2), (t3, i3) => this.o_.key(t3.time) < i3);
    if (this.o_.key(t2) < this.o_.key(this.dh.Ou()[r2].time)) {
      const i3 = this.dh.Ou()[r2], s3 = (_b3 = this.dh.F().extendedScale) == null ? void 0 : _b3.getAdvanceUnit(i3.originalTime, t2);
      return void 0 === s3 ? null : this.dh.Xt(r2 + s3);
    }
    return this.dh.Xt(r2);
  }
  coordinateToTime(t2) {
    const i2 = this.es.Ot(), s2 = i2.du(t2), n2 = i2.Q_(s2);
    return null === n2 ? null : n2.originalTime;
  }
  coordinateToTimeEx(t2) {
    var _a3, _b3;
    const i2 = this.es.Ot(), s2 = i2.du(t2), n2 = i2.zu(), e2 = i2.Lu();
    if (null === n2 || null === e2) return null;
    if (s2 > e2) {
      const t3 = i2.Q_(e2);
      if (null === t3) return null;
      const n3 = t3.originalTime;
      return ((_a3 = i2.F().extendedScale) == null ? void 0 : _a3.getExtendedTime(n3, s2 - e2)) ?? null;
    }
    if (s2 < n2) {
      const t3 = i2.Q_(n2);
      if (null === t3) return null;
      const r2 = t3.originalTime;
      return ((_b3 = i2.F().extendedScale) == null ? void 0 : _b3.getExtendedTime(r2, s2 - e2)) ?? null;
    }
    {
      const t3 = i2.Q_(s2);
      return null === t3 ? null : t3.originalTime;
    }
  }
  width() {
    return this.tw.op().width;
  }
  height() {
    return this.tw.op().height;
  }
  subscribeVisibleTimeRangeChange(t2) {
    this.NM.i(t2);
  }
  unsubscribeVisibleTimeRangeChange(t2) {
    this.NM._(t2);
  }
  subscribeVisibleLogicalRangeChange(t2) {
    this.z_.i(t2);
  }
  unsubscribeVisibleLogicalRangeChange(t2) {
    this.z_._(t2);
  }
  subscribeSizeChange(t2) {
    this.bm.i(t2);
  }
  unsubscribeSizeChange(t2) {
    this.bm._(t2);
  }
  applyOptions(t2) {
    this.dh.hr(t2);
  }
  options() {
    return { ...M(this.dh.F()), barSpacing: this.dh.wu() };
  }
  barSpacing() {
    return this.dh.wu();
  }
  baseIndex() {
    return this.dh.uu();
  }
  rightOffset() {
    return this.dh.gu();
  }
  FM() {
    this.NM.v() && this.NM.p(this.getVisibleRange());
  }
  WM() {
    this.z_.v() && this.z_.p(this.getVisibleLogicalRange());
  }
  HM(t2) {
    this.bm.p(t2.width, t2.height);
  }
}
function Fn(t2) {
  if (void 0 === t2 || "custom" === t2.type) return;
  const i2 = t2;
  void 0 !== i2.minMove && void 0 === i2.precision && (i2.precision = function(t3) {
    if (t3 >= 1) return 0;
    let i3 = 0;
    for (; i3 < 8; i3++) {
      const s2 = Math.round(t3);
      if (Math.abs(s2 - t3) < 1e-8) return i3;
      t3 *= 10;
    }
    return i3;
  }(i2.minMove));
}
function Wn(t2) {
  return function(t3) {
    if (w(t3.handleScale)) {
      const i3 = t3.handleScale;
      t3.handleScale = { axisDoubleClickReset: { time: i3, price: i3 }, axisPressedMouseMove: { time: i3, price: i3 }, mouseWheel: i3, pinch: i3 };
    } else if (void 0 !== t3.handleScale) {
      const { axisPressedMouseMove: i3, axisDoubleClickReset: s2 } = t3.handleScale;
      w(i3) && (t3.handleScale.axisPressedMouseMove = { time: i3, price: i3 }), w(s2) && (t3.handleScale.axisDoubleClickReset = { time: s2, price: s2 });
    }
    const i2 = t3.handleScroll;
    w(i2) && (t3.handleScroll = { horzTouchDrag: i2, vertTouchDrag: i2, mouseWheel: i2, pressedMouseMove: i2 });
  }(t2), t2;
}
class Hn {
  constructor(t2, i2, s2) {
    this.UM = /* @__PURE__ */ new Map(), this.$M = /* @__PURE__ */ new Map(), this.qM = new d$1(), this.YM = new d$1(), this.jM = new d$1(), this.Qu = /* @__PURE__ */ new WeakMap(), this.KM = new hn(i2);
    const n2 = void 0 === s2 ? M(Vn()) : f(M(Vn()), Wn(s2));
    this.XM = i2, this.tp = new Ws(t2, n2, i2), this.tp.Zv().i((t3) => {
      this.qM.v() && this.qM.p(this.GM(t3()));
    }, this), this.tp.Jv().i((t3) => {
      this.YM.v() && this.YM.p(this.GM(t3()));
    }, this), this.tp.Cc().i((t3) => {
      this.jM.v() && this.jM.p(this.GM(t3()));
    }, this);
    const e2 = this.tp.ni();
    this.ZM = new Nn(e2, this.tp.rw(), this.XM);
  }
  remove() {
    this.tp.Zv().u(this), this.tp.Jv().u(this), this.tp.Cc().u(this), this.ZM.m(), this.tp.m(), this.UM.clear(), this.$M.clear(), this.qM.m(), this.YM.m(), this.jM.m(), this.KM.m();
  }
  resize(t2, i2, s2) {
    this.autoSizeActive() || this.tp.sw(t2, i2, s2);
  }
  addCustomSeries(t2, i2 = {}, s2 = 0) {
    const n2 = ((t3) => ({ type: "Custom", isBuiltIn: false, defaultOptions: { ...vn, ...t3.defaultOptions() }, JM: mn, QM: t3 }))(c(t2));
    return this.tg(n2, i2, s2);
  }
  addSeries(t2, i2 = {}, s2 = 0) {
    return this.tg(t2, i2, s2);
  }
  removeSeries(t2) {
    const i2 = _(this.UM.get(t2)), s2 = this.KM.Kc(i2);
    this.tp.ni().Kc(i2), this.ig(s2), this.UM.delete(t2), this.$M.delete(i2);
  }
  zM(t2, i2) {
    this.ig(this.KM.$w(t2, i2));
  }
  OM(t2, i2, s2) {
    this.ig(this.KM.Gw(t2, i2, s2));
  }
  subscribeClick(t2) {
    this.qM.i(t2);
  }
  unsubscribeClick(t2) {
    this.qM._(t2);
  }
  subscribeCrosshairMove(t2) {
    this.jM.i(t2);
  }
  unsubscribeCrosshairMove(t2) {
    this.jM._(t2);
  }
  subscribeDblClick(t2) {
    this.YM.i(t2);
  }
  unsubscribeDblClick(t2) {
    this.YM._(t2);
  }
  priceScale(t2, i2 = 0) {
    return new En(this.tp, t2, i2);
  }
  timeScale() {
    return this.ZM;
  }
  applyOptions(t2) {
    this.tp.hr(Wn(t2));
  }
  options() {
    return this.tp.F();
  }
  takeScreenshot() {
    return this.tp.uw();
  }
  addPane(t2 = false) {
    const i2 = this.tp.ni().sd();
    return i2.Lo(t2), this.sg(i2);
  }
  removePane(t2) {
    this.tp.ni().kc(t2);
  }
  swapPanes(t2, i2) {
    this.tp.ni().Tc(t2, i2);
  }
  autoSizeActive() {
    return this.tp.mw();
  }
  chartElement() {
    return this.tp.dp();
  }
  panes() {
    return this.tp.ni().Xs().map((t2) => this.sg(t2));
  }
  paneSize(t2 = 0) {
    const i2 = this.tp.gw(t2);
    return { height: i2.height, width: i2.width };
  }
  setCrosshairPosition(t2, i2, s2) {
    const n2 = this.UM.get(s2);
    if (void 0 === n2) return;
    const e2 = this.tp.ni().Un(n2);
    null !== e2 && this.tp.ni().Hc(t2, i2, e2);
  }
  getCrosshairPosition() {
    return this.tp.ni().Fc();
  }
  clearCrosshairPosition() {
    this.tp.ni().Uc(true);
  }
  horzBehaviour() {
    return this.XM;
  }
  selectedSource() {
    const t2 = this.tp.ni().Mc();
    if (!t2) return null;
    return _(this.$M.get(t2)) ?? null;
  }
  setSelectedSource(t2) {
    if (!t2) return void this.tp.ni().gc(null);
    const i2 = _(this.UM.get(t2));
    this.tp.ni().gc(i2);
  }
  tg(t2, i2 = {}, s2 = 0) {
    o$1(void 0 !== t2.JM), Fn(i2.priceFormat), "Candlestick" === t2.type && function(t3) {
      void 0 !== t3.borderColor && (t3.borderUpColor = t3.borderColor, t3.borderDownColor = t3.borderColor), void 0 !== t3.wickColor && (t3.wickUpColor = t3.wickColor, t3.wickDownColor = t3.wickColor);
    }(i2);
    const n2 = f(M(e$1), M(t2.defaultOptions), i2), r2 = t2.JM, h2 = new jt(this.tp.ni(), t2.type, n2, r2, t2.QM);
    this.tp.ni().Yc(h2, s2);
    const a2 = new On(h2, this, this, this, this.XM, (t3) => this.sg(t3));
    return this.UM.set(a2, h2), this.$M.set(h2, a2), a2;
  }
  ig(t2) {
    const i2 = this.tp.ni();
    i2.$c(t2.Ot.uu, t2.Ot.Ou, t2.Ot.iM), t2.No.forEach((t3, i3) => i3.ut(t3.ie, t3.tM)), i2.Ot().j_(), i2.mu();
  }
  ng(t2) {
    return _(this.$M.get(t2));
  }
  GM(t2) {
    const i2 = /* @__PURE__ */ new Map();
    t2.Ew.forEach((t3, s3) => {
      const n2 = s3.Dr(), e2 = kn(n2)(t3);
      if ("Custom" !== n2) o$1($s(e2));
      else {
        const t4 = s3.va();
        o$1(!t4 || false === t4(e2));
      }
      i2.set(this.ng(s3), e2);
    });
    const s2 = void 0 !== t2.Vw && this.$M.has(t2.Vw) ? this.ng(t2.Vw) : void 0;
    return { time: t2.Dw, logical: t2.Te, point: t2.Iw, paneIndex: t2.Bw, hoveredSeries: s2, hoveredObjectId: t2.Aw, seriesData: i2, sourceEvent: t2.zw };
  }
  sg(t2) {
    let i2 = this.Qu.get(t2);
    return i2 || (i2 = new An(this.tp, (t3) => this.ng(t3), t2, this), this.Qu.set(t2, i2)), i2;
  }
}
function Un(t2) {
  if (m(t2)) {
    const i2 = document.getElementById(t2);
    return o$1(null !== i2, `Cannot find element in DOM with id=${t2}`), i2;
  }
  return t2;
}
function $n(t2, i2, s2) {
  const n2 = Un(t2), e2 = new Hn(n2, i2, s2);
  return i2.setOptions(e2.options()), e2;
}
function qn(t2, i2) {
  return $n(t2, new es(), es.gd(i2));
}
class jn extends cn {
  constructor(t2, i2) {
    super(t2, i2, true);
  }
  SM(t2, i2, s2) {
    i2.cu(this.uM, b(this.cM)), t2.ql(this.uM, s2, b(this.cM));
  }
  eg(t2, i2) {
    return { xt: t2, St: i2, ft: NaN, vt: NaN };
  }
  bM() {
    const t2 = this.Zn.Dh();
    this.uM = this.Zn.Qs().Wr().map((i2) => {
      const s2 = i2.value[3];
      return this.rg(i2.index, s2, t2);
    });
  }
}
function Kn(t2, i2, s2) {
  const n2 = Gn(i2, t2), e2 = Gn(s2, t2), r2 = n2.ft * n2.ft + n2.vt * n2.vt, h2 = n2.ft * e2.ft + n2.vt * e2.vt, a2 = r2 > 0 ? h2 / r2 : 0, l2 = Math.max(0, Math.min(1, a2));
  return function(t3) {
    return Math.sqrt(t3.ft * t3.ft + t3.vt * t3.vt);
  }(Gn(Xn(t2.ft + n2.ft * l2, t2.vt + n2.vt * l2), s2));
}
function Xn(t2, i2) {
  return { ft: t2, vt: i2 };
}
function Gn(t2, i2) {
  return { ft: t2.ft - i2.ft, vt: t2.vt - i2.vt };
}
function Zn(t2, i2, s2, n2, e2, r2, h2) {
  if (0 === i2.length || n2.from >= i2.length || n2.to <= 0) return;
  const { context: a2, horizontalPixelRatio: l2, verticalPixelRatio: o2 } = t2, _2 = i2[n2.from];
  let u2 = r2(t2, _2), c2 = _2;
  if (n2.to - n2.from < 2) {
    const i3 = e2 / 2;
    a2.beginPath();
    const s3 = { ft: _2.ft - i3, vt: _2.vt }, n3 = { ft: _2.ft + i3, vt: _2.vt };
    a2.moveTo(s3.ft * l2, s3.vt * o2), a2.lineTo(n3.ft * l2, n3.vt * o2), h2(t2, u2, s3, n3);
  } else {
    const e3 = (i3, s3) => {
      h2(t2, u2, c2, s3), a2.beginPath(), u2 = i3, c2 = s3;
    };
    let d3 = c2;
    a2.beginPath(), a2.moveTo(_2.ft * l2, _2.vt * o2);
    for (let h3 = n2.from + 1; h3 < n2.to; ++h3) {
      d3 = i2[h3];
      const n3 = r2(t2, d3);
      switch (s2) {
        case 0:
          a2.lineTo(d3.ft * l2, d3.vt * o2);
          break;
        case 1:
          a2.lineTo(d3.ft * l2, i2[h3 - 1].vt * o2), n3 !== u2 && (e3(n3, d3), a2.lineTo(d3.ft * l2, i2[h3 - 1].vt * o2)), a2.lineTo(d3.ft * l2, d3.vt * o2);
          break;
        case 2: {
          const [t3, s3] = ie(i2, h3 - 1, h3);
          a2.bezierCurveTo(t3.ft * l2, t3.vt * o2, s3.ft * l2, s3.vt * o2, d3.ft * l2, d3.vt * o2);
          break;
        }
      }
      1 !== s2 && n3 !== u2 && (e3(n3, d3), a2.moveTo(d3.ft * l2, d3.vt * o2));
    }
    (c2 !== d3 || c2 === d3 && 1 === s2) && h2(t2, u2, c2, d3);
  }
}
const Jn = 6;
function Qn(t2, i2) {
  return { ft: t2.ft - i2.ft, vt: t2.vt - i2.vt };
}
function te(t2, i2) {
  return { ft: t2.ft / i2, vt: t2.vt / i2 };
}
function ie(t2, i2, s2) {
  const n2 = Math.max(0, i2 - 1), e2 = Math.min(t2.length - 1, s2 + 1);
  var r2, h2;
  return [(r2 = t2[i2], h2 = te(Qn(t2[s2], t2[n2]), Jn), { ft: r2.ft + h2.ft, vt: r2.vt + h2.vt }), Qn(t2[s2], te(Qn(t2[e2], t2[i2]), Jn))];
}
function se(t2, i2) {
  const s2 = t2.context;
  s2.strokeStyle = i2, s2.stroke();
}
class ne extends R {
  constructor() {
    super(...arguments), this._t = null;
  }
  ut(t2) {
    this._t = t2;
  }
  ht(t2, i2) {
    var _a3, _b3;
    if (null === this._t) return null;
    const s2 = 2 + this._t.wt / 2, n2 = this._t.dt.length - 1;
    let e2 = Zt(((_a3 = this._t.ct) == null ? void 0 : _a3.from) ?? 0, 0, n2), r2 = Zt((((_b3 = this._t.ct) == null ? void 0 : _b3.to) ?? this._t.dt.length) - 1, 0, n2);
    for (; r2 - e2 > 2; ) {
      const i3 = Math.round((e2 + r2) / 2);
      this._t.dt[i3].ft <= t2 ? e2 = i3 : r2 = i3;
    }
    e2 = Math.max(1, e2 - 1), r2 = Math.min(this._t.dt.length - 1, r2 + 1);
    for (let n3 = e2; n3 <= r2; ++n3) {
      const e3 = this._t.dt[n3 - 1], r3 = this._t.dt[n3], h2 = e3.ft, a2 = r3.ft;
      if (Kn(Xn(h2, e3.vt), Xn(a2, r3.vt), Xn(t2, i2)) <= s2) return { hitTestData: null, externalId: "series" };
    }
    return null;
  }
  ot(t2) {
    if (null === this._t) return;
    const { dt: i2, ct: s2, hg: n2, ag: e2, wt: r2, Qt: h2, lg: l2 } = this._t;
    if (null === s2) return;
    const o2 = t2.context;
    o2.lineCap = "butt", o2.lineWidth = r2 * t2.verticalPixelRatio, a$1(o2, h2), o2.lineJoin = "round";
    const _2 = this.og.bind(this);
    void 0 !== e2 && Zn(t2, i2, e2, s2, n2, _2, se), l2 && function(t3, i3, s3, n3, e3) {
      if (n3.to - n3.from <= 0) return;
      const { horizontalPixelRatio: r3, verticalPixelRatio: h3, context: a2 } = t3;
      let l3 = null;
      const o3 = Math.max(1, Math.floor(r3)) % 2 / 2, _3 = s3 * h3 + o3;
      for (let s4 = n3.to - 1; s4 >= n3.from; --s4) {
        const n4 = i3[s4];
        if (n4) {
          const i4 = e3(t3, n4);
          i4 !== l3 && (a2.beginPath(), null !== l3 && a2.fill(), a2.fillStyle = i4, l3 = i4);
          const s5 = Math.round(n4.ft * r3) + o3, u2 = n4.vt * h3;
          a2.moveTo(s5, u2), a2.arc(s5, u2, _3, 0, 2 * Math.PI);
        }
      }
      a2.fill();
    }(t2, i2, l2, s2, _2);
  }
}
class ee extends ne {
  og(t2, i2) {
    return i2.bt;
  }
}
class re extends R {
  constructor() {
    super(...arguments), this.Gt = null;
  }
  ut(t2) {
    this.Gt = t2;
  }
  ot(t2) {
    if (!this.Gt || !this.Gt.At) return;
    const { context: i2, horizontalPixelRatio: s2 } = t2;
    i2.strokeStyle = this.Gt.R ?? "#2A62FF", i2.lineCap = "butt";
    const n2 = Math.max(1, Math.floor(s2));
    i2.lineWidth = n2;
    const e2 = this.Gt._g ?? 0;
    for (let s3 = 0; s3 < this.Gt.Ou.length; ++s3) {
      const r2 = this.Gt.Ou[s3];
      Number.isFinite(r2.x) && Number.isFinite(r2.y) && (i2.fillStyle = this.Gt.gM[s3], this.ug(t2, { ft: r2.x, vt: r2.y }, e2, n2));
    }
  }
  ug(t2, i2, s2, n2) {
    const { context: e2, horizontalPixelRatio: r2, verticalPixelRatio: h2 } = t2;
    let a2 = Math.round(3.5 * r2 * 2);
    a2 % 2 != n2 % 2 && (a2 += 1);
    let l2 = Math.round(a2 + 2 * (0.5 * n2 + 0.75 * r2));
    l2 % 2 != n2 % 2 && (l2 += 1);
    const o2 = Math.round(i2.ft * r2), _2 = Math.round((i2.vt + s2) * h2), u2 = n2 % 2 / 2;
    e2.beginPath(), e2.arc(o2 + u2, _2 + u2, l2 / 2, 0, 2 * Math.PI, true), e2.closePath(), e2.fill(), e2.beginPath(), e2.arc(o2 + u2, _2 + u2, a2 / 2, 0, 2 * Math.PI, true), e2.closePath(), e2.stroke();
  }
}
class he extends jn {
  constructor(t2, i2) {
    super(t2, i2), this.vM = new T(), this.Gn = new ee(), this.cg = new re(), this.vM.rt([this.Gn, this.cg]);
  }
  rg(t2, i2, s2) {
    return { ...this.eg(t2, i2), ...s2.Ir(t2) };
  }
  CM() {
    const t2 = this.Zn.F(), i2 = { dt: this.uM, Qt: t2.lineStyle, ag: t2.lineVisible ? t2.lineType : void 0, wt: t2.lineWidth, lg: t2.pointMarkersVisible ? t2.pointMarkersRadius || t2.lineWidth / 2 + 2 : void 0, ct: this.cM, hg: this.Jn.Ot().wu() };
    this.Gn.ut(i2), this.Jn.Mc() === this.Zn ? this.cg.ut(this.MM()) : this.cg.ut(null);
  }
}
const ae = { type: "Line", isBuiltIn: true, defaultOptions: { color: "#2196f3", lineStyle: 0, lineWidth: 3, lineType: 0, lineVisible: true, crosshairMarkerVisible: true, crosshairMarkerRadius: 4, crosshairMarkerBorderColor: "", crosshairMarkerBorderWidth: 2, crosshairMarkerBackgroundColor: "", lastPriceAnimation: 0, pointMarkersVisible: false }, JM: (t2, i2) => new he(t2, i2) };
function me(t2, i2, s2, n2, e2) {
  const { context: r2, horizontalPixelRatio: h2, verticalPixelRatio: a2 } = i2;
  r2.lineTo(e2.ft * h2, t2 * a2), r2.lineTo(n2.ft * h2, t2 * a2), r2.closePath(), r2.fillStyle = s2, r2.fill();
}
class we extends R {
  constructor() {
    super(...arguments), this._t = null;
  }
  ut(t2) {
    this._t = t2;
  }
  ot(t2) {
    if (null === this._t) return;
    const { dt: i2, ct: s2, hg: n2, wt: e2, Qt: r2, ag: h2 } = this._t, l2 = this._t.Mg ?? (this._t.gg ? 0 : t2.mediaSize.height);
    if (null === s2) return;
    const o2 = t2.context;
    o2.lineCap = "butt", o2.lineJoin = "round", o2.lineWidth = e2, a$1(o2, r2), o2.lineWidth = 1, Zn(t2, i2, h2, s2, n2, this.bg.bind(this), me.bind(null, l2));
  }
}
class Me {
  xg(t2, i2) {
    const s2 = this.Sg, { Cg: n2, Pg: e2, kg: r2, yg: h2, Mg: a2, Tg: l2, Rg: o2 } = i2;
    if (void 0 === this.Dg || void 0 === s2 || s2.Cg !== n2 || s2.Pg !== e2 || s2.kg !== r2 || s2.yg !== h2 || s2.Mg !== a2 || s2.Tg !== l2 || s2.Rg !== o2) {
      const { verticalPixelRatio: s3 } = t2, _2 = a2 || l2 > 0 ? s3 : 1, u2 = l2 * _2, c2 = o2 === t2.bitmapSize.height ? o2 : o2 * _2, d3 = (a2 ?? 0) * _2, f2 = t2.context.createLinearGradient(0, u2, 0, c2);
      if (f2.addColorStop(0, n2), null != a2) {
        const t3 = Zt((d3 - u2) / (c2 - u2), 0, 1);
        f2.addColorStop(t3, e2), f2.addColorStop(t3, r2);
      }
      f2.addColorStop(1, h2), this.Dg = f2, this.Sg = i2;
    }
    return this.Dg;
  }
}
class Ce extends we {
  constructor() {
    super(...arguments), this.Ig = new Me();
  }
  bg(t2, i2) {
    var _a3;
    return this.Ig.xg(t2, { Cg: i2.wr, Pg: "", kg: "", yg: i2.Mr, Tg: ((_a3 = this._t) == null ? void 0 : _a3.Tg) ?? 0, Rg: t2.bitmapSize.height });
  }
}
class Pe extends jn {
  constructor(t2, i2) {
    super(t2, i2), this.vM = new T(), this.Ag = new Ce(), this.zg = new ee(), this.Lg = new re(), this.vM.rt([this.Ag, this.zg, this.Lg]);
  }
  rg(t2, i2, s2) {
    return { ...this.eg(t2, i2), ...s2.Ir(t2) };
  }
  CM() {
    const t2 = this.Zn.F();
    if (null === this.cM || 0 === this.uM.length) return;
    let i2;
    if (t2.relativeGradient) {
      i2 = this.uM[this.cM.from].vt;
      for (let t3 = this.cM.from; t3 < this.cM.to; t3++) {
        const s2 = this.uM[t3];
        s2.vt < i2 && (i2 = s2.vt);
      }
    }
    this.Ag.ut({ ag: t2.lineType, dt: this.uM, Qt: t2.lineStyle, wt: t2.lineWidth, Mg: null, Tg: i2, gg: t2.invertFilledArea, ct: this.cM, hg: this.Jn.Ot().wu() }), this.zg.ut({ ag: t2.lineVisible ? t2.lineType : void 0, dt: this.uM, Qt: t2.lineStyle, wt: t2.lineWidth, ct: this.cM, hg: this.Jn.Ot().wu(), lg: t2.pointMarkersVisible ? t2.pointMarkersRadius || t2.lineWidth / 2 + 2 : void 0 }), this.Jn.Mc() === this.Zn ? this.Lg.ut(this.MM()) : this.Lg.ut(null);
  }
}
const ke = { type: "Area", isBuiltIn: true, defaultOptions: { topColor: "rgba( 46, 220, 135, 0.4)", bottomColor: "rgba( 40, 221, 100, 0)", invertFilledArea: false, relativeGradient: false, lineColor: "#33D778", lineStyle: 0, lineWidth: 3, lineType: 0, lineVisible: true, crosshairMarkerVisible: true, crosshairMarkerRadius: 4, crosshairMarkerBorderColor: "", crosshairMarkerBorderWidth: 2, crosshairMarkerBackgroundColor: "", lastPriceAnimation: 0, pointMarkersVisible: false }, JM: (t2, i2) => new Pe(t2, i2) };
function ye(t2, i2) {
  return i2 = i2 ?? window.devicePixelRatio ?? 1, Math.floor(0.3 * t2 * i2);
}
function Te(t2, i2) {
  i2 = i2 ?? window.devicePixelRatio ?? 1;
  if (t2 >= 2.5 && t2 <= 4) return Math.floor(3 * i2);
  const s2 = 1 - 0.2 * Math.atan(Math.max(4, t2) - 4) / (0.5 * Math.PI), n2 = Math.floor(t2 * s2 * i2), e2 = Math.floor(t2 * i2), r2 = Math.min(n2, e2);
  return Math.max(Math.floor(i2), r2);
}
class Re extends R {
  constructor() {
    super(...arguments), this.Gt = null, this.Og = 0, this.Ng = 0;
  }
  ut(t2) {
    this.Gt = t2;
  }
  ht(t2, i2) {
    if (null === this.Gt || 0 === this.Gt.Qs.length || null === this.Gt.ct) return null;
    return De(t2, i2, this.Gt.Qs, this.Og, 2, this.Gt.ct) ? { hitTestData: null, externalId: "series" } : null;
  }
  ot({ context: t2, horizontalPixelRatio: i2, verticalPixelRatio: s2 }) {
    if (null === this.Gt || 0 === this.Gt.Qs.length || null === this.Gt.ct) return;
    if (this.Og = this.Fg(i2), this.Og >= 2) {
      Math.max(1, Math.floor(i2)) % 2 != this.Og % 2 && this.Og--;
    }
    this.Ng = this.Gt.Wg ? Math.min(this.Og, Math.floor(i2)) : this.Og;
    let n2 = null;
    const e2 = this.Ng <= this.Og && this.Gt.wu >= Math.floor(1.5 * i2);
    for (let r2 = this.Gt.ct.from; r2 < this.Gt.ct.to; ++r2) {
      const h2 = this.Gt.Qs[r2];
      n2 !== h2.cr && (t2.fillStyle = h2.cr, n2 = h2.cr);
      const a2 = Math.floor(0.5 * this.Ng), l2 = Math.round(h2.ft * i2), o2 = l2 - a2, _2 = this.Ng, u2 = o2 + _2 - 1, c2 = Math.min(h2.Xl, h2.Gl), d3 = Math.max(h2.Xl, h2.Gl), f2 = Math.round(c2 * s2) - a2, p2 = Math.round(d3 * s2) + a2, v2 = Math.max(p2 - f2, this.Ng);
      t2.fillRect(o2, f2, _2, v2);
      const m2 = Math.ceil(1.5 * this.Og);
      if (e2) {
        if (this.Gt.Hg) {
          const i4 = l2 - m2;
          let n4 = Math.max(f2, Math.round(h2.Kl * s2) - a2), e4 = n4 + _2 - 1;
          e4 > f2 + v2 - 1 && (e4 = f2 + v2 - 1, n4 = e4 - _2 + 1), t2.fillRect(i4, n4, o2 - i4, e4 - n4 + 1);
        }
        const i3 = l2 + m2;
        let n3 = Math.max(f2, Math.round(h2.Zl * s2) - a2), e3 = n3 + _2 - 1;
        e3 > f2 + v2 - 1 && (e3 = f2 + v2 - 1, n3 = e3 - _2 + 1), t2.fillRect(u2 + 1, n3, i3 - u2, e3 - n3 + 1);
      }
    }
  }
  Fg(t2) {
    const i2 = Math.floor(t2);
    return Math.max(i2, Math.floor(ye(u(this.Gt).wu, t2)));
  }
}
function De(t2, i2, s2, n2, e2 = 2, r2 = null) {
  if (!s2.length) return false;
  const h2 = Zt((r2 == null ? void 0 : r2.from) ?? 0, 0, s2.length - 1), a2 = Zt((r2 == null ? void 0 : r2.to) ?? s2.length - 1, 0, s2.length - 1), l2 = s2[h2], o2 = s2[a2], _2 = n2 / 2;
  if (isFinite(l2.ft) && t2 < l2.ft - _2 - e2 || isFinite(o2.ft) && t2 > o2.ft + _2 + e2) return false;
  let u2 = h2, c2 = a2, d3 = -1;
  for (; u2 <= c2; ) {
    const i3 = Math.floor((u2 + c2) / 2), n3 = s2[i3];
    if (t2 >= n3.ft - _2 && t2 <= n3.ft + _2) {
      d3 = i3;
      break;
    }
    t2 > n3.ft + _2 ? u2 = i3 + 1 : c2 = i3 - 1;
  }
  if (-1 === d3) return false;
  if (Ie(s2[d3], i2, e2)) return true;
  let f2 = d3;
  for (; f2 >= 1 && t2 - s2[f2 - 1].ft + _2 < e2; ) f2--;
  let p2 = d3;
  for (; p2 <= s2.length - 2 && s2[p2 + 1].ft - _2 - t2 < e2; ) p2++;
  for (let t3 = f2; t3 <= p2; t3++) if (t3 !== d3 && Ie(s2[t3], i2, e2)) return true;
  return false;
}
function Ie(t2, i2, s2) {
  const n2 = Math.min(t2.Xl, t2.Gl), e2 = Math.max(t2.Xl, t2.Gl);
  return n2 - s2 <= i2 && i2 <= e2 + s2;
}
class Be extends cn {
  constructor(t2, i2) {
    super(t2, i2, false);
  }
  SM(t2, i2, s2) {
    i2.cu(this.uM, b(this.cM)), t2.jl(this.uM, s2, b(this.cM));
  }
  Ug(t2, i2, s2) {
    return { xt: t2, Yh: i2.value[0], jh: i2.value[1], Kh: i2.value[2], Xh: i2.value[3], ft: NaN, Kl: NaN, Xl: NaN, Gl: NaN, Zl: NaN };
  }
  bM() {
    const t2 = this.Zn.Dh();
    this.uM = this.Zn.Qs().Wr().map((i2) => this.rg(i2.index, i2, t2));
  }
}
class Ve extends Be {
  constructor(t2, i2) {
    super(t2, i2), this.vM = new T(), this.$g = new Re(), this.cg = new re(), this.vM.rt([this.$g, this.cg]);
  }
  rg(t2, i2, s2) {
    return { ...this.Ug(t2, i2, s2), ...s2.Ir(t2) };
  }
  CM() {
    const t2 = this.Zn.F();
    this.$g.ut({ Qs: this.uM, wu: this.Jn.Ot().wu(), Hg: t2.openVisible, Wg: t2.thinBars, ct: this.cM }), this.Jn.Mc() === this.Zn ? this.cg.ut(this.MM()) : this.cg.ut(null);
  }
}
const Ee = { type: "Bar", isBuiltIn: true, defaultOptions: { upColor: "#26a69a", downColor: "#ef5350", openVisible: true, thinBars: true }, JM: (t2, i2) => new Ve(t2, i2) };
class Ae extends R {
  constructor() {
    super(...arguments), this.Gt = null, this.Og = 0;
  }
  ut(t2) {
    this.Gt = t2;
  }
  ht(t2, i2) {
    if (null === this.Gt || 0 === this.Gt.Qs.length || null === this.Gt.ct) return null;
    return De(t2, i2, this.Gt.Qs, this.Gt.wu, 2, this.Gt.ct) ? { hitTestData: null, externalId: "series" } : null;
  }
  ot(t2) {
    if (null === this.Gt || 0 === this.Gt.Qs.length || null === this.Gt.ct) return;
    const { horizontalPixelRatio: i2 } = t2;
    if (this.Og = Te(this.Gt.wu, i2), this.Og >= 2) {
      Math.floor(i2) % 2 != this.Og % 2 && this.Og--;
    }
    const s2 = this.Gt.Qs;
    this.Gt.qg && this.Yg(t2, s2, this.Gt.ct), this.Gt.Pi && this.dv(t2, s2, this.Gt.ct);
    const n2 = this.jg(i2);
    (!this.Gt.Pi || this.Og > 2 * n2) && this.Kg(t2, s2, this.Gt.ct);
  }
  Yg(t2, i2, s2) {
    if (null === this.Gt) return;
    const { context: n2, horizontalPixelRatio: e2, verticalPixelRatio: r2 } = t2;
    let h2 = "", a2 = Math.min(Math.floor(e2), Math.floor(this.Gt.wu * e2));
    a2 = Math.max(Math.floor(e2), Math.min(a2, this.Og));
    const l2 = Math.floor(0.5 * a2);
    let o2 = null;
    for (let t3 = s2.from; t3 < s2.to; t3++) {
      const s3 = i2[t3];
      s3.pr !== h2 && (n2.fillStyle = s3.pr, h2 = s3.pr);
      const _2 = Math.round(Math.min(s3.Kl, s3.Zl) * r2), u2 = Math.round(Math.max(s3.Kl, s3.Zl) * r2), c2 = Math.round(s3.Xl * r2), d3 = Math.round(s3.Gl * r2);
      let f2 = Math.round(e2 * s3.ft) - l2;
      const p2 = f2 + a2 - 1;
      null !== o2 && (f2 = Math.max(o2 + 1, f2), f2 = Math.min(f2, p2));
      const v2 = p2 - f2 + 1;
      n2.fillRect(f2, c2, v2, _2 - c2), n2.fillRect(f2, u2 + 1, v2, d3 - u2), o2 = p2;
    }
  }
  jg(t2) {
    let i2 = Math.floor(1 * t2);
    this.Og <= 2 * i2 && (i2 = Math.floor(0.5 * (this.Og - 1)));
    const s2 = Math.max(Math.floor(t2), i2);
    return this.Og <= 2 * s2 ? Math.max(Math.floor(t2), Math.floor(1 * t2)) : s2;
  }
  dv(t2, i2, s2) {
    if (null === this.Gt) return;
    const { context: n2, horizontalPixelRatio: e2, verticalPixelRatio: r2 } = t2;
    let h2 = "";
    const a2 = this.jg(e2);
    let l2 = null;
    for (let t3 = s2.from; t3 < s2.to; t3++) {
      const s3 = i2[t3];
      s3.dr !== h2 && (n2.fillStyle = s3.dr, h2 = s3.dr);
      let o2 = Math.round(s3.ft * e2) - Math.floor(0.5 * this.Og);
      const _2 = o2 + this.Og - 1, u2 = Math.round(Math.min(s3.Kl, s3.Zl) * r2), c2 = Math.round(Math.max(s3.Kl, s3.Zl) * r2);
      if (null !== l2 && (o2 = Math.max(l2 + 1, o2), o2 = Math.min(o2, _2)), this.Gt.wu * e2 > 2 * a2) z(n2, o2, u2, _2 - o2 + 1, c2 - u2 + 1, a2);
      else {
        const t4 = _2 - o2 + 1;
        n2.fillRect(o2, u2, t4, c2 - u2 + 1);
      }
      l2 = _2;
    }
  }
  Kg(t2, i2, s2) {
    if (null === this.Gt) return;
    const { context: n2, horizontalPixelRatio: e2, verticalPixelRatio: r2 } = t2;
    let h2 = "";
    const a2 = this.jg(e2);
    for (let t3 = s2.from; t3 < s2.to; t3++) {
      const s3 = i2[t3];
      let l2 = Math.round(Math.min(s3.Kl, s3.Zl) * r2), o2 = Math.round(Math.max(s3.Kl, s3.Zl) * r2), _2 = Math.round(s3.ft * e2) - Math.floor(0.5 * this.Og), u2 = _2 + this.Og - 1;
      if (s3.cr !== h2) {
        const t4 = s3.cr;
        n2.fillStyle = t4, h2 = t4;
      }
      this.Gt.Pi && (_2 += a2, l2 += a2, u2 -= a2, o2 -= a2), l2 > o2 || n2.fillRect(_2, l2, u2 - _2 + 1, o2 - l2 + 1);
    }
  }
}
class ze extends Be {
  constructor(t2, i2) {
    super(t2, i2), this.vM = new T(), this.Xg = new Ae(), this.cg = new re(), this.vM.rt([this.Xg, this.cg]);
  }
  rg(t2, i2, s2) {
    return { ...this.Ug(t2, i2, s2), ...s2.Ir(t2) };
  }
  CM() {
    const t2 = this.Zn.F();
    this.Xg.ut({ Qs: this.uM, wu: this.Jn.Ot().wu(), qg: t2.wickVisible, Pi: t2.borderVisible, ct: this.cM }), this.Jn.Mc() === this.Zn ? this.cg.ut(this.MM()) : this.cg.ut(null);
  }
}
const Le = { type: "Candlestick", isBuiltIn: true, defaultOptions: { upColor: "#26a69a", downColor: "#ef5350", wickVisible: true, borderVisible: true, borderColor: "#378658", borderUpColor: "#26a69a", borderDownColor: "#ef5350", wickColor: "#737375", wickUpColor: "#26a69a", wickDownColor: "#ef5350" }, JM: (t2, i2) => new ze(t2, i2) };
class Oe extends R {
  constructor() {
    super(...arguments), this.Gt = null, this.Og = 0;
  }
  ut(t2) {
    this.Gt = t2;
  }
  ht(t2, i2) {
    if (null === this.Gt || 0 === this.Gt.Qs.length || null === this.Gt.ct) return null;
    return De(t2, i2, this.Gt.Qs, this.Gt.wu, 2, this.Gt.ct) ? { hitTestData: null, externalId: "series" } : null;
  }
  ot(t2) {
    if (null === this.Gt || 0 === this.Gt.Qs.length || null === this.Gt.ct) return;
    const { horizontalPixelRatio: i2 } = t2;
    if (this.Og = Te(this.Gt.wu, i2), this.Og >= 2) {
      Math.floor(i2) % 2 != this.Og % 2 && this.Og--;
    }
    const s2 = this.Gt.Qs;
    this.Gt.qg && this.Yg(t2, s2, this.Gt.ct), this.Gt.Pi && this.dv(t2, s2, this.Gt.ct);
    const n2 = this.jg(i2);
    (!this.Gt.Pi || this.Og > 2 * n2) && this.Kg(t2, s2, this.Gt.ct);
  }
  Yg(t2, i2, s2) {
    if (null === this.Gt) return;
    const { context: n2, horizontalPixelRatio: e2, verticalPixelRatio: r2 } = t2;
    let h2 = "", a2 = Math.min(Math.floor(e2), Math.floor(this.Gt.wu * e2));
    a2 = Math.max(Math.floor(e2), Math.min(a2, this.Og));
    const l2 = Math.floor(0.5 * a2);
    let o2 = null;
    for (let t3 = s2.from; t3 < s2.to; t3++) {
      const s3 = i2[t3];
      s3.pr !== h2 && (n2.fillStyle = s3.pr, h2 = s3.pr);
      const _2 = Math.round(Math.min(s3.Kl, s3.Zl) * r2), u2 = Math.round(Math.max(s3.Kl, s3.Zl) * r2), c2 = Math.round(s3.Xl * r2), d3 = Math.round(s3.Gl * r2);
      let f2 = Math.round(e2 * s3.ft) - l2;
      const p2 = f2 + a2 - 1;
      null !== o2 && (f2 = Math.max(o2 + 1, f2), f2 = Math.min(f2, p2));
      const v2 = p2 - f2 + 1;
      n2.fillRect(f2, c2, v2, _2 - c2), n2.fillRect(f2, u2 + 1, v2, d3 - u2), o2 = p2;
    }
  }
  jg(t2) {
    let i2 = Math.floor(1 * t2);
    this.Og <= 2 * i2 && (i2 = Math.floor(0.5 * (this.Og - 1)));
    const s2 = Math.max(Math.floor(t2), i2);
    return this.Og <= 2 * s2 ? Math.max(Math.floor(t2), Math.floor(1 * t2)) : s2;
  }
  dv(t2, i2, s2) {
    if (null === this.Gt) return;
    const { context: n2, horizontalPixelRatio: e2, verticalPixelRatio: r2 } = t2;
    let h2 = "";
    const a2 = this.jg(e2);
    let l2 = null;
    for (let t3 = s2.from; t3 < s2.to; t3++) {
      const s3 = i2[t3];
      s3.dr !== h2 && (n2.fillStyle = s3.dr, h2 = s3.dr);
      let o2 = Math.round(s3.ft * e2) - Math.floor(0.5 * this.Og);
      const _2 = o2 + this.Og - 1, u2 = Math.round(Math.min(s3.Kl, s3.Zl) * r2), c2 = Math.round(Math.max(s3.Kl, s3.Zl) * r2);
      if (null !== l2 && (o2 = Math.max(l2 + 1, o2), o2 = Math.min(o2, _2)), this.Gt.wu * e2 > 2 * a2) z(n2, o2, u2, _2 - o2 + 1, c2 - u2 + 1, a2);
      else {
        const t4 = _2 - o2 + 1;
        n2.fillRect(o2, u2, t4, c2 - u2 + 1);
      }
      l2 = _2;
    }
  }
  Kg(t2, i2, s2) {
    if (null === this.Gt) return;
    const { context: n2, horizontalPixelRatio: e2, verticalPixelRatio: r2 } = t2;
    let h2 = "";
    const a2 = this.jg(e2);
    for (let t3 = s2.from; t3 < s2.to; t3++) {
      const s3 = i2[t3];
      let l2 = Math.round(Math.min(s3.Kl, s3.Zl) * r2), o2 = Math.round(Math.max(s3.Kl, s3.Zl) * r2), _2 = Math.round(s3.ft * e2) - Math.floor(0.5 * this.Og), u2 = _2 + this.Og - 1;
      if (s3.cr !== h2) {
        const t4 = s3.cr;
        n2.fillStyle = t4, h2 = t4;
      }
      s3.mr && (this.Gt.Pi && (_2 += a2, l2 += a2, u2 -= a2, o2 -= a2), l2 > o2 || n2.fillRect(_2, l2, u2 - _2 + 1, o2 - l2 + 1));
    }
  }
}
class Ne extends Be {
  constructor(t2, i2) {
    super(t2, i2), this.vM = new T(), this.Gg = new Oe(), this.cg = new re(), this.vM.rt([this.Gg, this.cg]);
  }
  rg(t2, i2, s2) {
    return { ...this.Ug(t2, i2, s2), ...s2.Ir(t2) };
  }
  CM() {
    const t2 = this.Zn.F();
    this.Gg.ut({ Qs: this.uM, wu: this.Jn.Ot().wu(), qg: t2.wickVisible, Pi: t2.borderVisible, ct: this.cM }), this.Jn.Mc() === this.Zn ? this.cg.ut(this.MM()) : this.cg.ut(null);
  }
}
const Fe = { type: "HollowCandlestick", isBuiltIn: true, defaultOptions: { upColor: "#26a69a", downColor: "#ef5350", wickVisible: true, borderVisible: true, borderColor: "#378658", borderUpColor: "#26a69a", borderDownColor: "#ef5350", wickColor: "#737375", wickUpColor: "#26a69a", wickDownColor: "#ef5350" }, JM: (t2, i2) => new Ne(t2, i2) };
const zr = { ...e$1, color: "#2196f3" };
var _util;
((_util2) => {
  _util2.serviceIds = /* @__PURE__ */ new Map();
  _util2.DI_TARGET = "$di$target";
  _util2.DI_DEPENDENCIES = "$di$dependencies";
  function getServiceDependencies(ctor) {
    return ctor[_util2.DI_DEPENDENCIES] || [];
  }
  _util2.getServiceDependencies = getServiceDependencies;
})(_util || (_util = {}));
const IInstantiationService = createDecorator$1("instantiationService");
function storeServiceDependency(id2, target, index2) {
  if (target[_util.DI_TARGET] === target) {
    target[_util.DI_DEPENDENCIES].push({ id: id2, index: index2 });
  } else {
    target[_util.DI_DEPENDENCIES] = [{ id: id2, index: index2 }];
    target[_util.DI_TARGET] = target;
  }
}
function createDecorator$1(serviceId) {
  if (_util.serviceIds.has(serviceId)) {
    return _util.serviceIds.get(serviceId);
  }
  const id2 = function(target, key2, index2) {
    if (arguments.length !== 3) {
      throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
    }
    storeServiceDependency(id2, target, index2);
  };
  id2.toString = () => serviceId;
  _util.serviceIds.set(serviceId, id2);
  return id2;
}
const IChartService = createDecorator$1("chartService");
const IChartGuiService = createDecorator$1("chartGuiService");
const IChartManagementService = createDecorator$1("chartManagementService");
const HideDrawingsBit = 1 << 0;
const HideIndicatorsBit = 1 << 1;
const HidePositionsAndOrdersBit = 1 << 2;
let Node$2 = (_b = class {
  constructor(element2) {
    __publicField(this, "element");
    __publicField(this, "next");
    __publicField(this, "prev");
    this.element = element2;
    this.next = _b.Undefined;
    this.prev = _b.Undefined;
  }
}, __publicField(_b, "Undefined", new _b(void 0)), _b);
class LinkedList {
  constructor() {
    __publicField(this, "_first", Node$2.Undefined);
    __publicField(this, "_last", Node$2.Undefined);
    __publicField(this, "_size", 0);
  }
  get size() {
    return this._size;
  }
  isEmpty() {
    return this._first === Node$2.Undefined;
  }
  clear() {
    let node = this._first;
    while (node !== Node$2.Undefined) {
      const next = node.next;
      node.prev = Node$2.Undefined;
      node.next = Node$2.Undefined;
      node = next;
    }
    this._first = Node$2.Undefined;
    this._last = Node$2.Undefined;
    this._size = 0;
  }
  unshift(element2) {
    return this._insert(element2, false);
  }
  push(element2) {
    return this._insert(element2, true);
  }
  _insert(element2, atTheEnd) {
    const newNode = new Node$2(element2);
    if (this._first === Node$2.Undefined) {
      this._first = newNode;
      this._last = newNode;
    } else if (atTheEnd) {
      const oldLast = this._last;
      this._last = newNode;
      newNode.prev = oldLast;
      oldLast.next = newNode;
    } else {
      const oldFirst = this._first;
      this._first = newNode;
      newNode.next = oldFirst;
      oldFirst.prev = newNode;
    }
    this._size += 1;
    let didRemove = false;
    return () => {
      if (!didRemove) {
        didRemove = true;
        this._remove(newNode);
      }
    };
  }
  shift() {
    if (this._first === Node$2.Undefined) {
      return void 0;
    } else {
      const res = this._first.element;
      this._remove(this._first);
      return res;
    }
  }
  pop() {
    if (this._last === Node$2.Undefined) {
      return void 0;
    } else {
      const res = this._last.element;
      this._remove(this._last);
      return res;
    }
  }
  _remove(node) {
    if (node.prev !== Node$2.Undefined && node.next !== Node$2.Undefined) {
      const anchor = node.prev;
      anchor.next = node.next;
      node.next.prev = anchor;
    } else if (node.prev === Node$2.Undefined && node.next === Node$2.Undefined) {
      this._first = Node$2.Undefined;
      this._last = Node$2.Undefined;
    } else if (node.next === Node$2.Undefined) {
      this._last = this._last.prev;
      this._last.next = Node$2.Undefined;
    } else if (node.prev === Node$2.Undefined) {
      this._first = this._first.next;
      this._first.prev = Node$2.Undefined;
    }
    this._size -= 1;
  }
  *[Symbol.iterator]() {
    let node = this._first;
    while (node !== Node$2.Undefined) {
      yield node.element;
      node = node.next;
    }
  }
}
const ICommandService = createDecorator$1("commandService");
const ICommandRegistry = createDecorator$1("commandRegistry");
class CommandRegistry {
  constructor() {
    __publicField(this, "_serviceBrand");
    __publicField(this, "_commands", /* @__PURE__ */ new Map());
  }
  registerCommand(command) {
    const { id: id2 } = command;
    let commands = this._commands.get(id2);
    if (!commands) {
      commands = new LinkedList();
      this._commands.set(id2, commands);
    }
    const removeFn = commands.unshift(command);
    const ret = toDisposable(() => {
      removeFn();
      const command2 = this._commands.get(id2);
      if (command2 == null ? void 0 : command2.isEmpty()) {
        this._commands.delete(id2);
      }
    });
    return ret;
  }
  getCommand(id2) {
    const list = this._commands.get(id2);
    if (!list || list.isEmpty()) {
      return void 0;
    }
    return Iterable.first(list);
  }
  dispose() {
    this._commands.clear();
  }
}
var __getOwnPropDesc$m = Object.getOwnPropertyDescriptor;
var __decorateClass$m = (decorators, target, key2, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$m(target, key2) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$k = (index2, decorator) => (target, key2) => decorator(target, key2, index2);
const IKeybindingsRegistry = createDecorator$1("keybindingsRegistry");
var KeybindingWeight = /* @__PURE__ */ ((KeybindingWeight2) => {
  KeybindingWeight2[KeybindingWeight2["ChartCore"] = 0] = "ChartCore";
  KeybindingWeight2[KeybindingWeight2["ChartContrib"] = 100] = "ChartContrib";
  KeybindingWeight2[KeybindingWeight2["WorkbenchContrib"] = 200] = "WorkbenchContrib";
  KeybindingWeight2[KeybindingWeight2["BuiltinExtension"] = 300] = "BuiltinExtension";
  KeybindingWeight2[KeybindingWeight2["ExternalExtension"] = 400] = "ExternalExtension";
  return KeybindingWeight2;
})(KeybindingWeight || {});
class KeybindingItem {
  constructor(keybinding, command, commandArgs, weight1 = 0, weight2 = 0, when = void 0) {
    this.keybinding = keybinding;
    this.command = command;
    this.commandArgs = commandArgs;
    this.weight1 = weight1;
    this.weight2 = weight2;
    this.when = when;
  }
}
let KeybindingsRegistry = class {
  constructor(commandRegistry) {
    __publicField(this, "_serviceBrand");
    __publicField(this, "_coreKeybindings");
    __publicField(this, "_cachedMergedKeybindings");
    this.commandRegistry = commandRegistry;
    this._coreKeybindings = new LinkedList();
    this._cachedMergedKeybindings = null;
  }
  /**
   * Take current platform into account and reduce to primary & secondary.
   */
  static bindToCurrentPlatform(kb) {
    if (OS === OperatingSystem.Windows) {
      if (kb && kb.win) {
        return kb.win;
      }
    } else if (OS === OperatingSystem.Macintosh) {
      if (kb && kb.mac) {
        return kb.mac;
      }
    } else {
      if (kb && kb.linux) {
        return kb.linux;
      }
    }
    return kb;
  }
  registerKeybindingRule(rule) {
    const actualKb = KeybindingsRegistry.bindToCurrentPlatform(rule);
    const result = new DisposableStore();
    if (actualKb && actualKb.primary) {
      const kk = decodeKeybinding(actualKb.primary, OS);
      if (kk) {
        result.add(
          this._registerDefaultKeybinding(kk, rule.id, rule.args, rule.weight, 0, rule.when)
        );
      }
    }
    if (actualKb && Array.isArray(actualKb.secondary)) {
      for (let i2 = 0, len = actualKb.secondary.length; i2 < len; i2++) {
        const k2 = actualKb.secondary[i2];
        const kk = decodeKeybinding(k2, OS);
        if (kk) {
          result.add(
            this._registerDefaultKeybinding(kk, rule.id, rule.args, rule.weight, -i2 - 1, rule.when)
          );
        }
      }
    }
    return result;
  }
  registerCommandAndKeybindingRule(desc) {
    return combinedDisposable(
      this.registerKeybindingRule(desc),
      this.commandRegistry.registerCommand(desc)
    );
  }
  _registerDefaultKeybinding(keybinding, command, commandArgs, weight1 = 0, weight2 = 0, when = void 0) {
    const remove = this._coreKeybindings.push(
      new KeybindingItem(keybinding, command, commandArgs, weight1, weight2, when)
    );
    this._cachedMergedKeybindings = null;
    return toDisposable(() => {
      remove();
      this._cachedMergedKeybindings = null;
    });
  }
  getDefaultKeybindings() {
    if (!this._cachedMergedKeybindings) {
      this._cachedMergedKeybindings = Array.from(this._coreKeybindings);
      this._cachedMergedKeybindings.sort(sorter);
    }
    return this._cachedMergedKeybindings.slice(0);
  }
  dispose() {
    this._coreKeybindings.clear();
  }
};
KeybindingsRegistry = __decorateClass$m([
  __decorateParam$k(0, ICommandRegistry)
], KeybindingsRegistry);
function sorter(a2, b2) {
  if (a2.weight1 !== b2.weight1) {
    return a2.weight1 - b2.weight1;
  }
  if (a2.command && b2.command) {
    if (a2.command < b2.command) {
      return -1;
    }
    if (a2.command > b2.command) {
      return 1;
    }
  }
  return a2.weight2 - b2.weight2;
}
var __getOwnPropDesc$l = Object.getOwnPropertyDescriptor;
var __decorateClass$l = (decorators, target, key2, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$l(target, key2) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$j = (index2, decorator) => (target, key2) => decorator(target, key2, index2);
const kbLog = KeyCode.KeyL | KeyMod.Alt;
const kbPercent = KeyCode.KeyP | KeyMod.Alt;
let PriceScaleKeybindingContrib = class extends Disposable {
  constructor(chartManagementService, keybindingsRegistry) {
    super();
    this._register(
      keybindingsRegistry.registerCommandAndKeybindingRule({
        id: "priceScale.log",
        primary: kbLog,
        weight: KeybindingWeight.ChartCore,
        handler: () => {
          var _a3;
          const chart = (_a3 = chartManagementService.activeChart()) == null ? void 0 : _a3.chartApi;
          if (!chart) return;
          chart.applyOptions({
            rightPriceScale: {
              mode: chart.options().rightPriceScale.mode === vi.Logarithmic ? vi.Normal : vi.Logarithmic
            }
          });
        }
      })
    );
    this._register(
      keybindingsRegistry.registerCommandAndKeybindingRule({
        id: "priceScale.percent",
        primary: kbPercent,
        weight: KeybindingWeight.ChartCore,
        handler: () => {
          const chart = chartManagementService.activeChart().chartApi;
          if (!chart) return;
          chart.applyOptions({
            rightPriceScale: {
              mode: chart.options().rightPriceScale.mode === vi.Percentage ? vi.Normal : vi.Percentage
            }
          });
        }
      })
    );
  }
};
PriceScaleKeybindingContrib = __decorateClass$l([
  __decorateParam$j(0, IChartManagementService),
  __decorateParam$j(1, IKeybindingsRegistry)
], PriceScaleKeybindingContrib);
var __getOwnPropDesc$k = Object.getOwnPropertyDescriptor;
var __decorateClass$k = (decorators, target, key2, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$k(target, key2) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$i = (index2, decorator) => (target, key2) => decorator(target, key2, index2);
let StudyKeybindingContrib = class extends Disposable {
  constructor(chartManagementService, keybindingsRegistry) {
    super();
    this._register(
      keybindingsRegistry.registerCommandAndKeybindingRule({
        id: "study.remove",
        primary: KeyCode.Delete,
        secondary: [KeyCode.Backspace],
        weight: KeybindingWeight.ChartCore,
        when: () => {
          var _a3;
          const activeChart = chartManagementService.activeChart();
          const currentActive = activeChart.getModel().currentActive;
          if (!currentActive) return false;
          if (!((_a3 = currentActive.isSeries) == null ? void 0 : _a3.call(currentActive))) return false;
          return currentActive !== activeChart.mainSeriesApi;
        },
        handler: () => {
          const activeChart = chartManagementService.activeChart();
          const currentActive = ensure(activeChart.getModel().currentActive);
          activeChart.removeEntity(currentActive.id);
        }
      })
    );
  }
};
StudyKeybindingContrib = __decorateClass$k([
  __decorateParam$i(0, IChartManagementService),
  __decorateParam$i(1, IKeybindingsRegistry)
], StudyKeybindingContrib);
var __getOwnPropDesc$j = Object.getOwnPropertyDescriptor;
var __decorateClass$j = (decorators, target, key2, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$j(target, key2) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$h = (index2, decorator) => (target, key2) => decorator(target, key2, index2);
const kbMoveLeft = KeyCode.LeftArrow;
const kbMoveRight = KeyCode.RightArrow;
let TimeScaleKeybindingContrib = class extends Disposable {
  constructor(chartManagementService, keybindingsRegistry) {
    super();
    this._register(
      keybindingsRegistry.registerCommandAndKeybindingRule({
        id: "timeScale.moveLeft",
        primary: kbMoveLeft,
        weight: KeybindingWeight.ChartCore,
        handler: () => {
          var _a3;
          const chart = (_a3 = chartManagementService.activeChart()) == null ? void 0 : _a3.chartApi;
          if (!chart) return;
          const range = chart.timeScale().getVisibleLogicalRange();
          if (!range) return;
          chart.timeScale().setVisibleLogicalRange({ from: range.from + 1, to: range.to + 1 });
        }
      })
    );
    this._register(
      keybindingsRegistry.registerCommandAndKeybindingRule({
        id: "timeScale.moveRight",
        primary: kbMoveRight,
        weight: KeybindingWeight.ChartCore,
        handler: () => {
          var _a3;
          const chart = (_a3 = chartManagementService.activeChart()) == null ? void 0 : _a3.chartApi;
          if (!chart) return;
          const range = chart.timeScale().getVisibleLogicalRange();
          if (!range) return;
          chart.timeScale().setVisibleLogicalRange({ from: range.from - 1, to: range.to - 1 });
        }
      })
    );
  }
};
TimeScaleKeybindingContrib = __decorateClass$j([
  __decorateParam$h(0, IChartManagementService),
  __decorateParam$h(1, IKeybindingsRegistry)
], TimeScaleKeybindingContrib);
const IUndoRedoService = createDecorator$1("undoRedoService");
var UndoRedoElementType = /* @__PURE__ */ ((UndoRedoElementType2) => {
  UndoRedoElementType2[UndoRedoElementType2["Resource"] = 0] = "Resource";
  UndoRedoElementType2[UndoRedoElementType2["Workspace"] = 1] = "Workspace";
  return UndoRedoElementType2;
})(UndoRedoElementType || {});
var __getOwnPropDesc$i = Object.getOwnPropertyDescriptor;
var __decorateClass$i = (decorators, target, key2, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$i(target, key2) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$g = (index2, decorator) => (target, key2) => decorator(target, key2, index2);
let UndoRedoKeybindingContrib = class extends Disposable {
  constructor(undoRedoService, chartManagementService, keybindingsRegistry) {
    super();
    this._register(
      keybindingsRegistry.registerCommandAndKeybindingRule({
        id: "core.undo",
        primary: KeyCode.KeyZ | KeyMod.CtrlCmd,
        weight: KeybindingWeight.ChartCore,
        handler: () => {
          const chart = chartManagementService.activeChart();
          if (undoRedoService.canUndo(chart.id)) {
            undoRedoService.undo(chart.id);
          }
        }
      })
    );
    this._register(
      keybindingsRegistry.registerCommandAndKeybindingRule({
        id: "core.redo",
        primary: KeyCode.KeyZ | KeyMod.CtrlCmd | KeyMod.Shift,
        weight: KeybindingWeight.ChartCore,
        handler: () => {
          const chart = chartManagementService.activeChart();
          if (undoRedoService.canRedo(chart.id)) {
            undoRedoService.redo(chart.id);
          }
        }
      })
    );
  }
};
UndoRedoKeybindingContrib = __decorateClass$i([
  __decorateParam$g(0, IUndoRedoService),
  __decorateParam$g(1, IChartManagementService),
  __decorateParam$g(2, IKeybindingsRegistry)
], UndoRedoKeybindingContrib);
const DrawingContribId = "drawing";
const ExitDrawingCommand = "drawing.cancel";
const IChartContributionRegistry = createDecorator$1(
  "chartContributionRegistry"
);
var ChartContributionInstantiation = /* @__PURE__ */ ((ChartContributionInstantiation2) => {
  ChartContributionInstantiation2[ChartContributionInstantiation2["Eager"] = 0] = "Eager";
  ChartContributionInstantiation2[ChartContributionInstantiation2["AfterFirstRender"] = 1] = "AfterFirstRender";
  ChartContributionInstantiation2[ChartContributionInstantiation2["Eventually"] = 2] = "Eventually";
  ChartContributionInstantiation2[ChartContributionInstantiation2["Lazy"] = 3] = "Lazy";
  return ChartContributionInstantiation2;
})(ChartContributionInstantiation || {});
class ChartContributionRegistry {
  constructor() {
    __publicField(this, "_serviceBrand");
    __publicField(this, "contributions", []);
  }
  register(id2, ctor, instantiation) {
    this.contributions.push({
      id: id2,
      ctor,
      instantiation
    });
  }
  getContributions() {
    return this.contributions;
  }
  dispose() {
    this.contributions.length = 0;
  }
}
function isObject$1(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$s = freeGlobal || freeSelf || Function("return this")();
var now = function() {
  return root$s.Date.now();
};
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index2 = string.length;
  while (index2-- && reWhitespace.test(string.charAt(index2))) {
  }
  return index2;
}
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var Symbol$1 = root$s.Symbol;
var objectProto$h = Object.prototype;
var hasOwnProperty$e = objectProto$h.hasOwnProperty;
var nativeObjectToString$1 = objectProto$h.toString;
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$e.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$g = Object.prototype;
var nativeObjectToString = objectProto$g.toString;
function objectToString(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var symbolTag$3 = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$3;
}
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$1(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$1(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var FUNC_ERROR_TEXT$2 = "Expected a function";
var nativeMax$1 = Math.max, nativeMin = Math.min;
function debounce$1(func, wait2, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  wait2 = toNumber(wait2) || 0;
  if (isObject$1(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax$1(toNumber(options.maxWait) || 0, wait2) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait2);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait2 - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait2 || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now());
  }
  function debounced() {
    var time = now(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait2);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait2);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
function createDecorator(mapFn) {
  return (_target, key2, descriptor) => {
    let fnKey = null;
    let fn2 = null;
    if (typeof descriptor.value === "function") {
      fnKey = "value";
      fn2 = descriptor.value;
    } else if (typeof descriptor.get === "function") {
      fnKey = "get";
      fn2 = descriptor.get;
    }
    if (!fn2 || typeof key2 === "symbol") {
      throw new Error("not supported");
    }
    descriptor[fnKey] = mapFn(fn2, key2);
  };
}
function debounce(wait2, options) {
  return createDecorator((fn2) => {
    const debounced = debounce$1(fn2, wait2, options);
    return function(...args) {
      debounced.apply(this, args);
    };
  });
}
function memoize$1(_target, key2, descriptor) {
  let fnKey = null;
  let fn2 = null;
  if (typeof descriptor.value === "function") {
    fnKey = "value";
    fn2 = descriptor.value;
    if (fn2.length !== 0) {
      console.warn("Memoize should only be used in functions with zero parameters");
    }
  } else if (typeof descriptor.get === "function") {
    fnKey = "get";
    fn2 = descriptor.get;
  }
  if (!fn2) {
    throw new Error("not supported");
  }
  const memoizeKey = `$memoize$${key2}`;
  descriptor[fnKey] = function(...args) {
    if (!Object.prototype.hasOwnProperty.call(this, memoizeKey)) {
      Object.defineProperty(this, memoizeKey, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: fn2.apply(this, args)
      });
    }
    return this[memoizeKey];
  };
}
const NoneEvent = () => Disposable.None;
function once(event2) {
  return (listener, thisArgs = null, disposables) => {
    let didFire = false;
    let result = void 0;
    result = event2(
      (e2) => {
        if (didFire) {
          return;
        } else if (result) {
          result.dispose();
        } else {
          didFire = true;
        }
        return listener.call(thisArgs, e2);
      },
      null,
      disposables
    );
    if (didFire) {
      result.dispose();
    }
    return result;
  };
}
let id = 0;
class UniqueContainer {
  constructor(value) {
    __publicField(this, "stack");
    __publicField(this, "id", id++);
    this.value = value;
  }
}
class Stacktrace {
  constructor(value) {
    this.value = value;
  }
  static create() {
    const err = new Error();
    return new Stacktrace(err.stack ?? "");
  }
  print() {
    console.warn(this.value.split("\n").slice(2).join("\n"));
  }
}
class EventDeliveryQueuePrivate {
  constructor() {
    /**
     * Index in current's listener list.
     */
    __publicField(this, "i", -1);
    /**
     * The last index in the listener's list to deliver.
     */
    __publicField(this, "end", 0);
    /**
     * Emitter currently being dispatched on. Emitter._listeners is always an array.
     */
    __publicField(this, "current");
    /**
     * Currently emitting value. Defined whenever `current` is.
     */
    __publicField(this, "value");
  }
  enqueue(emitter, value, end) {
    this.i = 0;
    this.end = end;
    this.current = emitter;
    this.value = value;
  }
  reset() {
    this.i = this.end;
    this.current = void 0;
    this.value = void 0;
  }
}
const compactionThreshold = 2;
class Emitter {
  constructor(options) {
    __publicField(this, "_options");
    __publicField(this, "_leakageMon");
    __publicField(this, "_perfMon");
    __publicField(this, "_disposed");
    __publicField(this, "_event");
    /**
     * A listener, or list of listeners. A single listener is the most common
     * for event emitters (#185789), so we optimize that special case to avoid
     * wrapping it in an array (just like Node.js itself.)
     *
     * A list of listeners never 'downgrades' back to a plain function if
     * listeners are removed, for two reasons:
     *
     *  1. That's complicated (especially with the deliveryQueue)
     *  2. A listener with >1 listener is likely to have >1 listener again at
     *     some point, and swapping between arrays and functions may[citation needed]
     *     introduce unnecessary work and garbage.
     *
     * The array listeners can be 'sparse', to avoid reallocating the array
     * whenever any listener is added or removed. If more than `1 / compactionThreshold`
     * of the array is empty, only then is it resized.
     */
    __publicField(this, "_listeners");
    /**
     * Always to be defined if _listeners is an array. It's no longer a true
     * queue, but holds the dispatching 'state'. If `fire()` is called on an
     * emitter, any work left in the _deliveryQueue is finished first.
     */
    __publicField(this, "_deliveryQueue");
    __publicField(this, "_size", 0);
    var _a3;
    this._options = options;
    this._deliveryQueue = (_a3 = this._options) == null ? void 0 : _a3.deliveryQueue;
  }
  dispose() {
    var _a3, _b3, _c2, _d2;
    if (!this._disposed) {
      this._disposed = true;
      if (((_a3 = this._deliveryQueue) == null ? void 0 : _a3.current) === this) {
        this._deliveryQueue.reset();
      }
      if (this._listeners) {
        this._listeners = void 0;
        this._size = 0;
      }
      (_c2 = (_b3 = this._options) == null ? void 0 : _b3.onDidRemoveLastListener) == null ? void 0 : _c2.call(_b3);
      (_d2 = this._leakageMon) == null ? void 0 : _d2.dispose();
    }
  }
  /**
   * For the public to allow to subscribe
   * to events from this Emitter
   */
  get event() {
    this._event ?? (this._event = (callback, thisArgs, disposables) => {
      var _a3, _b3, _c2, _d2, _e, _f, _g;
      if (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {
        const message2 = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;
        console.warn(message2);
        const tuple = this._leakageMon.getMostFrequentStack() ?? ["UNKNOWN stack", -1];
        const error = new ListenerRefusalError(
          `${message2}. HINT: Stack shows most frequent listener (${tuple[1]}-times)`,
          tuple[0]
        );
        const errorHandler2 = ((_a3 = this._options) == null ? void 0 : _a3.onListenerError) || onUnexpectedError;
        errorHandler2(error);
        return Disposable.None;
      }
      if (this._disposed) {
        return Disposable.None;
      }
      if (thisArgs) {
        callback = callback.bind(thisArgs);
      }
      const contained = new UniqueContainer(callback);
      let removeMonitor;
      if (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {
        contained.stack = Stacktrace.create();
        removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);
      }
      if (!this._listeners) {
        (_c2 = (_b3 = this._options) == null ? void 0 : _b3.onWillAddFirstListener) == null ? void 0 : _c2.call(_b3, this);
        this._listeners = contained;
        (_e = (_d2 = this._options) == null ? void 0 : _d2.onDidAddFirstListener) == null ? void 0 : _e.call(_d2, this);
      } else if (this._listeners instanceof UniqueContainer) {
        this._deliveryQueue ?? (this._deliveryQueue = new EventDeliveryQueuePrivate());
        this._listeners = [this._listeners, contained];
      } else {
        this._listeners.push(contained);
      }
      (_g = (_f = this._options) == null ? void 0 : _f.onDidAddListener) == null ? void 0 : _g.call(_f, this);
      this._size++;
      const result = toDisposable(() => {
        removeMonitor == null ? void 0 : removeMonitor();
        this._removeListener(contained);
      });
      if (disposables instanceof DisposableStore) {
        disposables.add(result);
      } else if (Array.isArray(disposables)) {
        disposables.push(result);
      }
      return result;
    });
    return this._event;
  }
  _removeListener(listener) {
    var _a3, _b3, _c2, _d2;
    (_b3 = (_a3 = this._options) == null ? void 0 : _a3.onWillRemoveListener) == null ? void 0 : _b3.call(_a3, this);
    if (!this._listeners) {
      return;
    }
    if (this._size === 1) {
      this._listeners = void 0;
      (_d2 = (_c2 = this._options) == null ? void 0 : _c2.onDidRemoveLastListener) == null ? void 0 : _d2.call(_c2, this);
      this._size = 0;
      return;
    }
    const listeners = this._listeners;
    const index2 = listeners.indexOf(listener);
    if (index2 === -1) {
      throw new Error("Attempted to dispose unknown listener");
    }
    this._size--;
    listeners[index2] = void 0;
    const adjustDeliveryQueue = this._deliveryQueue.current === this;
    if (this._size * compactionThreshold <= listeners.length) {
      let n2 = 0;
      for (let i2 = 0; i2 < listeners.length; i2++) {
        if (listeners[i2]) {
          listeners[n2++] = listeners[i2];
        } else if (adjustDeliveryQueue && n2 < this._deliveryQueue.end) {
          this._deliveryQueue.end--;
          if (n2 < this._deliveryQueue.i) {
            this._deliveryQueue.i--;
          }
        }
      }
      listeners.length = n2;
    }
  }
  _deliver(listener, value) {
    var _a3;
    if (!listener) {
      return;
    }
    const errorHandler2 = ((_a3 = this._options) == null ? void 0 : _a3.onListenerError) || onUnexpectedError;
    if (!errorHandler2) {
      listener.value(value);
      return;
    }
    try {
      listener.value(value);
    } catch (e2) {
      errorHandler2(e2);
    }
  }
  /** Delivers items in the queue. Assumes the queue is ready to go. */
  _deliverQueue(dq) {
    const listeners = dq.current._listeners;
    while (dq.i < dq.end) {
      this._deliver(listeners[dq.i++], dq.value);
    }
    dq.reset();
  }
  /**
   * To be kept private to fire an event to
   * subscribers
   */
  fire(event2) {
    var _a3, _b3, _c2, _d2;
    if ((_a3 = this._deliveryQueue) == null ? void 0 : _a3.current) {
      this._deliverQueue(this._deliveryQueue);
      (_b3 = this._perfMon) == null ? void 0 : _b3.stop();
    }
    (_c2 = this._perfMon) == null ? void 0 : _c2.start(this._size);
    if (!this._listeners) ;
    else if (this._listeners instanceof UniqueContainer) {
      this._deliver(this._listeners, event2);
    } else {
      const dq = this._deliveryQueue;
      dq.enqueue(this, event2, this._listeners.length);
      this._deliverQueue(dq);
    }
    (_d2 = this._perfMon) == null ? void 0 : _d2.stop();
  }
  hasListeners() {
    return this._size > 0;
  }
}
const createEventDeliveryQueue = () => new EventDeliveryQueuePrivate();
class ListenerRefusalError extends Error {
  constructor(message2, stack) {
    super(message2);
    this.name = "ListenerRefusalError";
    this.stack = stack;
  }
}
function arrayMap(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var isArray = Array.isArray;
var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray(value)) {
    return arrayMap(value, baseToString) + "";
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -Infinity ? "-0" : result;
}
var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292;
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -Infinity) {
    var sign2 = value < 0 ? -1 : 1;
    return sign2 * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
function toInteger(value) {
  var result = toFinite(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
function identity$1(value) {
  return value;
}
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$1(value) {
  if (!isObject$1(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root$s["__core-js_shared__"];
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$f = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$d = objectProto$f.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$d).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject$1(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function getValue(object, key2) {
  return object == null ? void 0 : object[key2];
}
function getNative(object, key2) {
  var value = getValue(object, key2);
  return baseIsNative(value) ? value : void 0;
}
var WeakMap$1 = getNative(root$s, "WeakMap");
var objectCreate = Object.create;
var baseCreate = /* @__PURE__ */ function() {
  function object() {
  }
  return function(proto) {
    if (!isObject$1(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
function copyArray(source2, array) {
  var index2 = -1, length = source2.length;
  array || (array = Array(length));
  while (++index2 < length) {
    array[index2] = source2[index2];
  }
  return array;
}
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
function constant(value) {
  return function() {
    return value;
  };
}
var defineProperty = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
var baseSetToString = !defineProperty ? identity$1 : function(func, string) {
  return defineProperty(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var setToString = shortOut(baseSetToString);
function arrayEach(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (iteratee(array[index2], index2, array) === false) {
      break;
    }
  }
  return array;
}
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
function baseAssignValue(object, key2, value) {
  if (key2 == "__proto__" && defineProperty) {
    defineProperty(object, key2, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key2] = value;
  }
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var objectProto$e = Object.prototype;
var hasOwnProperty$c = objectProto$e.hasOwnProperty;
function assignValue(object, key2, value) {
  var objValue = object[key2];
  if (!(hasOwnProperty$c.call(object, key2) && eq(objValue, value)) || value === void 0 && !(key2 in object)) {
    baseAssignValue(object, key2, value);
  }
}
function copyObject(source2, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key2 = props[index2];
    var newValue = void 0;
    if (newValue === void 0) {
      newValue = source2[key2];
    }
    if (isNew) {
      baseAssignValue(object, key2, newValue);
    } else {
      assignValue(object, key2, newValue);
    }
  }
  return object;
}
var nativeMax = Math.max;
function overRest(func, start2, transform) {
  start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax(args.length - start2, 0), array = Array(length);
    while (++index2 < length) {
      array[index2] = args[start2 + index2];
    }
    index2 = -1;
    var otherArgs = Array(start2 + 1);
    while (++index2 < start2) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start2] = transform(array);
    return apply(func, this, otherArgs);
  };
}
function baseRest(func, start2) {
  return setToString(overRest(func, start2, identity$1), func + "");
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction$1(value);
}
function isIterateeCall(value, index2, object) {
  if (!isObject$1(object)) {
    return false;
  }
  var type = typeof index2;
  if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
    return eq(object[index2], value);
  }
  return false;
}
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index2 < length) {
      var source2 = sources[index2];
      if (source2) {
        assigner(object, source2, index2, customizer);
      }
    }
    return object;
  });
}
var objectProto$d = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$d;
  return value === proto;
}
function baseTimes(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var argsTag$3 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$3;
}
var objectProto$c = Object.prototype;
var hasOwnProperty$b = objectProto$c.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$c.propertyIsEnumerable;
var isArguments = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$b.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
function stubFalse() {
  return false;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$1 = moduleExports$2 ? root$s.Buffer : void 0;
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
var isBuffer$1 = nativeIsBuffer || stubFalse;
var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$6 = "[object Map]", numberTag$3 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$6 = "[object Set]", stringTag$4 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$6] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$6] = typedArrayTags[stringTag$4] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var freeProcess = moduleExports$1 && freeGlobal.process;
var nodeUtil = function() {
  try {
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e2) {
  }
}();
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var objectProto$b = Object.prototype;
var hasOwnProperty$a = objectProto$b.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key2 in value) {
    if ((inherited || hasOwnProperty$a.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
    isIndex(key2, length)))) {
      result.push(key2);
    }
  }
  return result;
}
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var nativeKeys = overArg(Object.keys, Object);
var objectProto$a = Object.prototype;
var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key2 in Object(object)) {
    if (hasOwnProperty$9.call(object, key2) && key2 != "constructor") {
      result.push(key2);
    }
  }
  return result;
}
function keys$1(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key2 in Object(object)) {
      result.push(key2);
    }
  }
  return result;
}
var objectProto$9 = Object.prototype;
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject$1(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object), result = [];
  for (var key2 in object) {
    if (!(key2 == "constructor" && (isProto || !hasOwnProperty$8.call(object, key2)))) {
      result.push(key2);
    }
  }
  return result;
}
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var nativeCreate = getNative(Object, "create");
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}
function hashDelete(key2) {
  var result = this.has(key2) && delete this.__data__[key2];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$8 = Object.prototype;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
function hashGet(key2) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key2];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$7.call(data, key2) ? data[key2] : void 0;
}
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
function hashHas(key2) {
  var data = this.__data__;
  return nativeCreate ? data[key2] !== void 0 : hasOwnProperty$6.call(data, key2);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key2, value) {
  var data = this.__data__;
  this.size += this.has(key2) ? 0 : 1;
  data[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
function Hash(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function assocIndexOf(array, key2) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key2)) {
      return length;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key2) {
  var data = this.__data__, index2 = assocIndexOf(data, key2);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key2) {
  var data = this.__data__, index2 = assocIndexOf(data, key2);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas(key2) {
  return assocIndexOf(this.__data__, key2) > -1;
}
function listCacheSet(key2, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key2);
  if (index2 < 0) {
    ++this.size;
    data.push([key2, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root$s, "Map");
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$1 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map, key2) {
  var data = map.__data__;
  return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key2) {
  var result = getMapData(this, key2)["delete"](key2);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key2) {
  return getMapData(this, key2).get(key2);
}
function mapCacheHas(key2) {
  return getMapData(this, key2).has(key2);
}
function mapCacheSet(key2, value) {
  var data = getMapData(this, key2), size2 = data.size;
  data.set(key2, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var FUNC_ERROR_TEXT$1 = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function() {
    var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key2)) {
      return cache2.get(key2);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key2, result) || cache2;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize(func, function(key2) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key2;
  });
  var cache2 = result.cache;
  return result;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match2, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
  });
  return result;
});
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}
function toKey(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -Infinity ? "-0" : result;
}
function baseGet(object, path) {
  path = castPath(path, object);
  var index2 = 0, length = path.length;
  while (object != null && index2 < length) {
    object = object[toKey(path[index2++])];
  }
  return index2 && index2 == length ? object : void 0;
}
function get$2(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet(object, path);
  return result === void 0 ? defaultValue : result;
}
function arrayPush(array, values2) {
  var index2 = -1, length = values2.length, offset = array.length;
  while (++index2 < length) {
    array[offset + index2] = values2[index2];
  }
  return array;
}
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable(value) {
  return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index2 = -1, length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index2 < length) {
    var value = array[index2];
    if (predicate(value)) {
      {
        arrayPush(result, value);
      }
    } else {
      result[result.length] = value;
    }
  }
  return result;
}
function flatten$2(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array) : [];
}
function flatRest(func) {
  return setToString(overRest(func, void 0, flatten$2), func + "");
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
var objectTag$3 = "[object Object]";
var funcProto = Function.prototype, objectProto$6 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$5.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
function baseSlice(array, start2, end) {
  var index2 = -1, length = array.length;
  if (start2 < 0) {
    start2 = -start2 > length ? 0 : length + start2;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start2 > end ? 0 : end - start2 >>> 0;
  start2 >>>= 0;
  var result = Array(length);
  while (++index2 < length) {
    result[index2] = array[index2 + start2];
  }
  return result;
}
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key2) {
  var data = this.__data__, result = data["delete"](key2);
  this.size = data.size;
  return result;
}
function stackGet(key2) {
  return this.__data__.get(key2);
}
function stackHas(key2) {
  return this.__data__.has(key2);
}
var LARGE_ARRAY_SIZE = 200;
function stackSet(key2, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key2, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key2, value);
  this.size = data.size;
  return this;
}
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function baseAssign(object, source2) {
  return object && copyObject(source2, keys$1(source2), object);
}
function baseAssignIn(object, source2) {
  return object && copyObject(source2, keysIn(source2), object);
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer2 = moduleExports ? root$s.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}
function arrayFilter(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$5 = Object.prototype;
var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
function copySymbols(source2, object) {
  return copyObject(source2, getSymbols(source2), object);
}
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};
function copySymbolsIn(source2, object) {
  return copyObject(source2, getSymbolsIn(source2), object);
}
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}
function getAllKeys(object) {
  return baseGetAllKeys(object, keys$1, getSymbols);
}
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}
var DataView = getNative(root$s, "DataView");
var Promise$1 = getNative(root$s, "Promise");
var Set$1 = getNative(root$s, "Set");
var mapTag$5 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$5 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$3 = "[object DataView]";
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
var getTag = baseGetTag;
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag(new Map$1()) != mapTag$5 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$5 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {
  getTag = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$3;
        case mapCtorString:
          return mapTag$5;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$5;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
function initCloneArray(array) {
  var length = array.length, result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty$4.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var Uint8Array$1 = root$s.Uint8Array;
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$3 = "[object String]", symbolTag$2 = "[object Symbol]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$2:
      return cloneArrayBuffer(object);
    case boolTag$2:
    case dateTag$2:
      return new Ctor(+object);
    case dataViewTag$2:
      return cloneDataView(object, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object, isDeep);
    case mapTag$4:
      return new Ctor();
    case numberTag$2:
    case stringTag$3:
      return new Ctor(object);
    case regexpTag$2:
      return cloneRegExp(object);
    case setTag$4:
      return new Ctor();
    case symbolTag$2:
      return cloneSymbol(object);
  }
}
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}
var mapTag$3 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag$3;
}
var nodeIsMap = nodeUtil && nodeUtil.isMap;
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
var setTag$3 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag$3;
}
var nodeIsSet = nodeUtil && nodeUtil.isSet;
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
var CLONE_DEEP_FLAG$2 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$2 = 4;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$2 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$2] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$2] = cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone(value, bitmask, customizer, key2, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$2, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
  if (customizer) {
    result = object ? customizer(value, key2, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$1(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer$1(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key3) {
      result.set(key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys$1;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach(props || value, function(subValue, key3) {
    if (props) {
      key3 = subValue;
      subValue = value[key3];
    }
    assignValue(result, key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
  });
  return result;
}
var CLONE_DEEP_FLAG$1 = 1, CLONE_SYMBOLS_FLAG$1 = 4;
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value) {
  return this.__data__.has(value);
}
function SetCache(values2) {
  var index2 = -1, length = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache();
  while (++index2 < length) {
    this.add(values2[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache2, key2) {
  return cache2.has(key2);
}
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen2) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen2.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
function mapToArray(map) {
  var index2 = -1, result = Array(map.size);
  map.forEach(function(value, key2) {
    result[++index2] = [key2, value];
  });
  return result;
}
function setToArray(set2) {
  var index2 = -1, result = Array(set2.size);
  set2.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag$1 = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag$1 = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+object, +other);
    case errorTag:
      return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag$1:
      return object == other + "";
    case mapTag$1:
      var convert = mapToArray;
    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key2 = objProps[index2];
    if (!(isPartial ? key2 in other : hasOwnProperty$3.call(other, key2))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key2 = objProps[index2];
    var objValue = object[key2], othValue = other[key2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key2, other, object, stack) : customizer(objValue, othValue, key2, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key2 == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$1(object)) {
    if (!isBuffer$1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$2.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(object, source2, matchData, customizer) {
  var index2 = matchData.length, length = index2;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index2--) {
    var data = matchData[index2];
    if (data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index2 < length) {
    data = matchData[index2];
    var key2 = data[0], objValue = object[key2], srcValue = data[1];
    if (data[2]) {
      if (objValue === void 0 && !(key2 in object)) {
        return false;
      }
    } else {
      var stack = new Stack();
      var result;
      if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
function isStrictComparable(value) {
  return value === value && !isObject$1(value);
}
function getMatchData(object) {
  var result = keys$1(object), length = result.length;
  while (length--) {
    var key2 = result[length], value = object[key2];
    result[length] = [key2, value, isStrictComparable(value)];
  }
  return result;
}
function matchesStrictComparable(key2, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key2] === srcValue && (srcValue !== void 0 || key2 in Object(object));
  };
}
function baseMatches(source2) {
  var matchData = getMatchData(source2);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source2 || baseIsMatch(object, source2, matchData);
  };
}
function baseHasIn(object, key2) {
  return object != null && key2 in Object(object);
}
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index2 = -1, length = path.length, result = false;
  while (++index2 < length) {
    var key2 = toKey(path[index2]);
    if (!(result = object != null && hasFunc(object, key2))) {
      break;
    }
    object = object[key2];
  }
  if (result || ++index2 != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key2, length) && (isArray(object) || isArguments(object));
}
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get$2(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
function baseProperty(key2) {
  return function(object) {
    return object == null ? void 0 : object[key2];
  };
}
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity$1;
  }
  if (typeof value == "object") {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
function arrayAggregator(array, setter, iteratee, accumulator) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    var value = array[index2];
    setter(accumulator, value, iteratee(value), array);
  }
  return accumulator;
}
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key2 = props[++index2];
      if (iteratee(iterable[key2], key2, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var baseFor = createBaseFor();
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys$1);
}
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index2 = -1, iterable = Object(collection);
    while (++index2 < length) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var baseEach = createBaseEach(baseForOwn);
function baseAggregator(collection, setter, iteratee, accumulator) {
  baseEach(collection, function(value, key2, collection2) {
    setter(accumulator, value, iteratee(value), collection2);
  });
  return accumulator;
}
function createAggregator(setter, initializer) {
  return function(collection, iteratee) {
    var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
    return func(collection, setter, baseIteratee(iteratee), accumulator);
  };
}
function assignMergeValue(object, key2, value) {
  if (value !== void 0 && !eq(object[key2], value) || value === void 0 && !(key2 in object)) {
    baseAssignValue(object, key2, value);
  }
}
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}
function safeGet(object, key2) {
  if (key2 === "constructor" && typeof object[key2] === "function") {
    return;
  }
  if (key2 == "__proto__") {
    return;
  }
  return object[key2];
}
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}
function baseMergeDeep(object, source2, key2, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key2), srcValue = safeGet(source2, key2), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue(object, key2, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key2 + "", object, source2, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray(srcValue), isBuff = !isArr && isBuffer$1(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject$1(objValue) || isFunction$1(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue(object, key2, newValue);
}
function baseMerge(object, source2, srcIndex, customizer, stack) {
  if (object === source2) {
    return;
  }
  baseFor(source2, function(srcValue, key2) {
    stack || (stack = new Stack());
    if (isObject$1(srcValue)) {
      baseMergeDeep(object, source2, key2, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key2), srcValue, key2 + "", object, source2, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object, key2, newValue);
    }
  }, keysIn);
}
function last$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : void 0;
}
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
var groupBy = createAggregator(function(result, value, key2) {
  if (hasOwnProperty$1.call(result, key2)) {
    result[key2].push(value);
  } else {
    baseAssignValue(result, key2, [value]);
  }
});
var stringTag = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
}
function baseValues(object, props) {
  return arrayMap(props, function(key2) {
    return object[key2];
  });
}
function values(object) {
  return object == null ? [] : baseValues(object, keys$1(object));
}
function parent(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}
var mapTag = "[object Map]", setTag = "[object Set]";
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer$1(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }
  var tag = getTag(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key2 in value) {
    if (hasOwnProperty.call(value, key2)) {
      return false;
    }
  }
  return true;
}
function isEqual(value, other) {
  return baseIsEqual(value, other);
}
var nativeIsFinite = root$s.isFinite;
function isFinite$1(value) {
  return typeof value == "number" && nativeIsFinite(value);
}
function isInteger(value) {
  return typeof value == "number" && value == toInteger(value);
}
function isNil(value) {
  return value == null;
}
var merge = createAssigner(function(object, source2, srcIndex) {
  baseMerge(object, source2, srcIndex);
});
var FUNC_ERROR_TEXT = "Expected a function";
function negate(predicate) {
  if (typeof predicate != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return !predicate.call(this);
      case 1:
        return !predicate.call(this, args[0]);
      case 2:
        return !predicate.call(this, args[0], args[1]);
      case 3:
        return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}
function baseUnset(object, path) {
  path = castPath(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last$1(path))];
}
function customOmitClone(value) {
  return isPlainObject(value) ? void 0 : value;
}
var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
var omit = flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap(paths, function(path) {
    path = castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object, getAllKeysIn(object), result);
  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset(result, paths[length]);
  }
  return result;
});
function baseSet(object, path, value, customizer) {
  if (!isObject$1(object)) {
    return object;
  }
  path = castPath(path, object);
  var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index2 < length) {
    var key2 = toKey(path[index2]), newValue = value;
    if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
      return object;
    }
    if (index2 != lastIndex) {
      var objValue = nested[key2];
      newValue = void 0;
      if (newValue === void 0) {
        newValue = isObject$1(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
      }
    }
    assignValue(nested, key2, newValue);
    nested = nested[key2];
  }
  return object;
}
function basePickBy(object, paths, predicate) {
  var index2 = -1, length = paths.length, result = {};
  while (++index2 < length) {
    var path = paths[index2], value = baseGet(object, path);
    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}
function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = arrayMap(getAllKeysIn(object), function(prop2) {
    return [prop2];
  });
  predicate = baseIteratee(predicate);
  return basePickBy(object, props, function(value, path) {
    return predicate(value, path[0]);
  });
}
function omitBy(object, predicate) {
  return pickBy(object, negate(baseIteratee(predicate)));
}
function baseSortedUniq(array, iteratee) {
  var index2 = -1, length = array.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array[index2], computed = iteratee ? iteratee(value) : value;
    if (!index2 || !eq(computed, seen2)) {
      var seen2 = computed;
      result[resIndex++] = value === 0 ? 0 : value;
    }
  }
  return result;
}
function sortedUniqBy(array, iteratee) {
  return array && array.length ? baseSortedUniq(array, baseIteratee(iteratee)) : [];
}
var is_array = Array.isArray;
var index_of = Array.prototype.indexOf;
var array_from = Array.from;
var define_property = Object.defineProperty;
var get_descriptor = Object.getOwnPropertyDescriptor;
var get_descriptors = Object.getOwnPropertyDescriptors;
var object_prototype = Object.prototype;
var array_prototype = Array.prototype;
var get_prototype_of = Object.getPrototypeOf;
var is_extensible = Object.isExtensible;
function is_function(thing) {
  return typeof thing === "function";
}
const noop$1 = () => {
};
function is_promise(value) {
  return typeof (value == null ? void 0 : value.then) === "function";
}
function run(fn2) {
  return fn2();
}
function run_all(arr) {
  for (var i2 = 0; i2 < arr.length; i2++) {
    arr[i2]();
  }
}
function deferred() {
  var resolve;
  var reject;
  var promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
}
const DERIVED = 1 << 1;
const EFFECT = 1 << 2;
const RENDER_EFFECT = 1 << 3;
const BLOCK_EFFECT = 1 << 4;
const BRANCH_EFFECT = 1 << 5;
const ROOT_EFFECT = 1 << 6;
const BOUNDARY_EFFECT = 1 << 7;
const UNOWNED = 1 << 8;
const DISCONNECTED = 1 << 9;
const CLEAN = 1 << 10;
const DIRTY = 1 << 11;
const MAYBE_DIRTY = 1 << 12;
const INERT = 1 << 13;
const DESTROYED = 1 << 14;
const EFFECT_RAN = 1 << 15;
const EFFECT_TRANSPARENT = 1 << 16;
const INSPECT_EFFECT = 1 << 17;
const HEAD_EFFECT = 1 << 18;
const EFFECT_PRESERVED = 1 << 19;
const USER_EFFECT = 1 << 20;
const REACTION_IS_UPDATING = 1 << 21;
const ASYNC = 1 << 22;
const ERROR_VALUE = 1 << 23;
const STATE_SYMBOL = Symbol("$state");
const LEGACY_PROPS = Symbol("legacy props");
const LOADING_ATTR_SYMBOL = Symbol("");
const STALE_REACTION = new class StaleReactionError extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "StaleReactionError");
    __publicField(this, "message", "The reaction that called `getAbortSignal()` was re-run or destroyed");
  }
}();
function equals(value) {
  return value === this.v;
}
function safe_not_equal(a2, b2) {
  return a2 != a2 ? b2 == b2 : a2 !== b2 || a2 !== null && typeof a2 === "object" || typeof a2 === "function";
}
function not_equal(a2, b2) {
  return a2 !== b2;
}
function safe_equals(value) {
  return !safe_not_equal(value, this.v);
}
function await_outside_boundary() {
  {
    throw new Error(`https://svelte.dev/e/await_outside_boundary`);
  }
}
function lifecycle_outside_component(name) {
  {
    throw new Error(`https://svelte.dev/e/lifecycle_outside_component`);
  }
}
function async_derived_orphan() {
  {
    throw new Error(`https://svelte.dev/e/async_derived_orphan`);
  }
}
function effect_in_teardown(rune) {
  {
    throw new Error(`https://svelte.dev/e/effect_in_teardown`);
  }
}
function effect_in_unowned_derived() {
  {
    throw new Error(`https://svelte.dev/e/effect_in_unowned_derived`);
  }
}
function effect_orphan(rune) {
  {
    throw new Error(`https://svelte.dev/e/effect_orphan`);
  }
}
function effect_update_depth_exceeded() {
  {
    throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
  }
}
function props_invalid_value(key2) {
  {
    throw new Error(`https://svelte.dev/e/props_invalid_value`);
  }
}
function state_descriptors_fixed() {
  {
    throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
  }
}
function state_prototype_fixed() {
  {
    throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
  }
}
function state_unsafe_mutation() {
  {
    throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
  }
}
let legacy_mode_flag = false;
let tracing_mode_flag = false;
function enable_legacy_mode_flag() {
  legacy_mode_flag = true;
}
const EACH_ITEM_REACTIVE = 1;
const EACH_INDEX_REACTIVE = 1 << 1;
const EACH_IS_CONTROLLED = 1 << 2;
const EACH_IS_ANIMATED = 1 << 3;
const EACH_ITEM_IMMUTABLE = 1 << 4;
const PROPS_IS_IMMUTABLE = 1;
const PROPS_IS_RUNES = 1 << 1;
const PROPS_IS_UPDATED = 1 << 2;
const PROPS_IS_BINDABLE = 1 << 3;
const PROPS_IS_LAZY_INITIAL = 1 << 4;
const TEMPLATE_FRAGMENT = 1;
const TEMPLATE_USE_IMPORT_NODE = 1 << 1;
const UNINITIALIZED = Symbol();
const NAMESPACE_HTML = "http://www.w3.org/1999/xhtml";
const NAMESPACE_SVG = "http://www.w3.org/2000/svg";
const ATTACHMENT_KEY = "@attach";
let component_context = null;
function set_component_context(context) {
  component_context = context;
}
function getContext(key2) {
  const context_map = get_or_init_context_map();
  const result = (
    /** @type {T} */
    context_map.get(key2)
  );
  return result;
}
function setContext(key2, context) {
  const context_map = get_or_init_context_map();
  context_map.set(key2, context);
  return context;
}
function push(props, runes = false, fn2) {
  component_context = {
    p: component_context,
    c: null,
    e: null,
    s: props,
    x: null,
    l: legacy_mode_flag && !runes ? { s: null, u: null, $: [] } : null
  };
}
function pop(component2) {
  var context = (
    /** @type {ComponentContext} */
    component_context
  );
  var effects = context.e;
  if (effects !== null) {
    context.e = null;
    for (var fn2 of effects) {
      create_user_effect(fn2);
    }
  }
  if (component2 !== void 0) {
    context.x = component2;
  }
  component_context = context.p;
  return component2 ?? /** @type {T} */
  {};
}
function is_runes() {
  return !legacy_mode_flag || component_context !== null && component_context.l === null;
}
function get_or_init_context_map(name) {
  if (component_context === null) {
    lifecycle_outside_component();
  }
  return component_context.c ?? (component_context.c = new Map(get_parent_context(component_context) || void 0));
}
function get_parent_context(component_context2) {
  let parent2 = component_context2.p;
  while (parent2 !== null) {
    const context_map = parent2.c;
    if (context_map !== null) {
      return context_map;
    }
    parent2 = parent2.p;
  }
  return null;
}
function select_multiple_invalid_value() {
  {
    console.warn(`https://svelte.dev/e/select_multiple_invalid_value`);
  }
}
let hydrating = false;
function proxy$1(value) {
  if (typeof value !== "object" || value === null || STATE_SYMBOL in value) {
    return value;
  }
  const prototype = get_prototype_of(value);
  if (prototype !== object_prototype && prototype !== array_prototype) {
    return value;
  }
  var sources = /* @__PURE__ */ new Map();
  var is_proxied_array = is_array(value);
  var version = /* @__PURE__ */ state(0);
  var parent_version = update_version;
  var with_parent = (fn2) => {
    if (update_version === parent_version) {
      return fn2();
    }
    var reaction = active_reaction;
    var version2 = update_version;
    set_active_reaction(null);
    set_update_version(parent_version);
    var result = fn2();
    set_active_reaction(reaction);
    set_update_version(version2);
    return result;
  };
  if (is_proxied_array) {
    sources.set("length", /* @__PURE__ */ state(
      /** @type {any[]} */
      value.length
    ));
  }
  return new Proxy(
    /** @type {any} */
    value,
    {
      defineProperty(_2, prop2, descriptor) {
        if (!("value" in descriptor) || descriptor.configurable === false || descriptor.enumerable === false || descriptor.writable === false) {
          state_descriptors_fixed();
        }
        var s2 = sources.get(prop2);
        if (s2 === void 0) {
          s2 = with_parent(() => {
            var s3 = /* @__PURE__ */ state(descriptor.value);
            sources.set(prop2, s3);
            return s3;
          });
        } else {
          set(s2, descriptor.value, true);
        }
        return true;
      },
      deleteProperty(target, prop2) {
        var s2 = sources.get(prop2);
        if (s2 === void 0) {
          if (prop2 in target) {
            const s3 = with_parent(() => /* @__PURE__ */ state(UNINITIALIZED));
            sources.set(prop2, s3);
            increment(version);
          }
        } else {
          set(s2, UNINITIALIZED);
          increment(version);
        }
        return true;
      },
      get(target, prop2, receiver) {
        var _a3;
        if (prop2 === STATE_SYMBOL) {
          return value;
        }
        var s2 = sources.get(prop2);
        var exists = prop2 in target;
        if (s2 === void 0 && (!exists || ((_a3 = get_descriptor(target, prop2)) == null ? void 0 : _a3.writable))) {
          s2 = with_parent(() => {
            var p2 = proxy$1(exists ? target[prop2] : UNINITIALIZED);
            var s3 = /* @__PURE__ */ state(p2);
            return s3;
          });
          sources.set(prop2, s2);
        }
        if (s2 !== void 0) {
          var v2 = get$1(s2);
          return v2 === UNINITIALIZED ? void 0 : v2;
        }
        return Reflect.get(target, prop2, receiver);
      },
      getOwnPropertyDescriptor(target, prop2) {
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
        if (descriptor && "value" in descriptor) {
          var s2 = sources.get(prop2);
          if (s2) descriptor.value = get$1(s2);
        } else if (descriptor === void 0) {
          var source2 = sources.get(prop2);
          var value2 = source2 == null ? void 0 : source2.v;
          if (source2 !== void 0 && value2 !== UNINITIALIZED) {
            return {
              enumerable: true,
              configurable: true,
              value: value2,
              writable: true
            };
          }
        }
        return descriptor;
      },
      has(target, prop2) {
        var _a3;
        if (prop2 === STATE_SYMBOL) {
          return true;
        }
        var s2 = sources.get(prop2);
        var has = s2 !== void 0 && s2.v !== UNINITIALIZED || Reflect.has(target, prop2);
        if (s2 !== void 0 || active_effect !== null && (!has || ((_a3 = get_descriptor(target, prop2)) == null ? void 0 : _a3.writable))) {
          if (s2 === void 0) {
            s2 = with_parent(() => {
              var p2 = has ? proxy$1(target[prop2]) : UNINITIALIZED;
              var s3 = /* @__PURE__ */ state(p2);
              return s3;
            });
            sources.set(prop2, s2);
          }
          var value2 = get$1(s2);
          if (value2 === UNINITIALIZED) {
            return false;
          }
        }
        return has;
      },
      set(target, prop2, value2, receiver) {
        var _a3;
        var s2 = sources.get(prop2);
        var has = prop2 in target;
        if (is_proxied_array && prop2 === "length") {
          for (var i2 = value2; i2 < /** @type {Source<number>} */
          s2.v; i2 += 1) {
            var other_s = sources.get(i2 + "");
            if (other_s !== void 0) {
              set(other_s, UNINITIALIZED);
            } else if (i2 in target) {
              other_s = with_parent(() => /* @__PURE__ */ state(UNINITIALIZED));
              sources.set(i2 + "", other_s);
            }
          }
        }
        if (s2 === void 0) {
          if (!has || ((_a3 = get_descriptor(target, prop2)) == null ? void 0 : _a3.writable)) {
            s2 = with_parent(() => /* @__PURE__ */ state(void 0));
            set(s2, proxy$1(value2));
            sources.set(prop2, s2);
          }
        } else {
          has = s2.v !== UNINITIALIZED;
          var p2 = with_parent(() => proxy$1(value2));
          set(s2, p2);
        }
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
        if (descriptor == null ? void 0 : descriptor.set) {
          descriptor.set.call(receiver, value2);
        }
        if (!has) {
          if (is_proxied_array && typeof prop2 === "string") {
            var ls2 = (
              /** @type {Source<number>} */
              sources.get("length")
            );
            var n2 = Number(prop2);
            if (Number.isInteger(n2) && n2 >= ls2.v) {
              set(ls2, n2 + 1);
            }
          }
          increment(version);
        }
        return true;
      },
      ownKeys(target) {
        get$1(version);
        var own_keys = Reflect.ownKeys(target).filter((key3) => {
          var source3 = sources.get(key3);
          return source3 === void 0 || source3.v !== UNINITIALIZED;
        });
        for (var [key2, source2] of sources) {
          if (source2.v !== UNINITIALIZED && !(key2 in target)) {
            own_keys.push(key2);
          }
        }
        return own_keys;
      },
      setPrototypeOf() {
        state_prototype_fixed();
      }
    }
  );
}
function get_proxied_value(value) {
  try {
    if (value !== null && typeof value === "object" && STATE_SYMBOL in value) {
      return value[STATE_SYMBOL];
    }
  } catch {
  }
  return value;
}
function is(a2, b2) {
  return Object.is(get_proxied_value(a2), get_proxied_value(b2));
}
var $window;
var is_firefox;
var first_child_getter;
var next_sibling_getter;
function init_operations() {
  if ($window !== void 0) {
    return;
  }
  $window = window;
  is_firefox = /Firefox/.test(navigator.userAgent);
  var element_prototype = Element.prototype;
  var node_prototype = Node.prototype;
  var text_prototype = Text.prototype;
  first_child_getter = get_descriptor(node_prototype, "firstChild").get;
  next_sibling_getter = get_descriptor(node_prototype, "nextSibling").get;
  if (is_extensible(element_prototype)) {
    element_prototype.__click = void 0;
    element_prototype.__className = void 0;
    element_prototype.__attributes = null;
    element_prototype.__style = void 0;
    element_prototype.__e = void 0;
  }
  if (is_extensible(text_prototype)) {
    text_prototype.__t = void 0;
  }
}
function create_text(value = "") {
  return document.createTextNode(value);
}
// @__NO_SIDE_EFFECTS__
function get_first_child(node) {
  return first_child_getter.call(node);
}
// @__NO_SIDE_EFFECTS__
function get_next_sibling(node) {
  return next_sibling_getter.call(node);
}
function child(node, is_text) {
  {
    return /* @__PURE__ */ get_first_child(node);
  }
}
function first_child(fragment, is_text) {
  {
    var first = (
      /** @type {DocumentFragment} */
      /* @__PURE__ */ get_first_child(
        /** @type {Node} */
        fragment
      )
    );
    if (first instanceof Comment && first.data === "") return /* @__PURE__ */ get_next_sibling(first);
    return first;
  }
}
function sibling(node, count = 1, is_text = false) {
  let next_sibling = node;
  while (count--) {
    next_sibling = /** @type {TemplateNode} */
    /* @__PURE__ */ get_next_sibling(next_sibling);
  }
  {
    return next_sibling;
  }
}
function clear_text_content(node) {
  node.textContent = "";
}
function should_defer_append() {
  return false;
}
const adjustments = /* @__PURE__ */ new WeakMap();
function handle_error(error) {
  var effect2 = active_effect;
  if (effect2 === null) {
    active_reaction.f |= ERROR_VALUE;
    return error;
  }
  if ((effect2.f & EFFECT_RAN) === 0) {
    if ((effect2.f & BOUNDARY_EFFECT) === 0) {
      if (!effect2.parent && error instanceof Error) {
        apply_adjustments(error);
      }
      throw error;
    }
    effect2.b.error(error);
  } else {
    invoke_error_boundary(error, effect2);
  }
}
function invoke_error_boundary(error, effect2) {
  while (effect2 !== null) {
    if ((effect2.f & BOUNDARY_EFFECT) !== 0) {
      try {
        effect2.b.error(error);
        return;
      } catch (e2) {
        error = e2;
      }
    }
    effect2 = effect2.parent;
  }
  if (error instanceof Error) {
    apply_adjustments(error);
  }
  throw error;
}
function apply_adjustments(error) {
  const adjusted = adjustments.get(error);
  if (adjusted) {
    define_property(error, "message", {
      value: adjusted.message
    });
    define_property(error, "stack", {
      value: adjusted.stack
    });
  }
}
let micro_tasks = [];
let idle_tasks = [];
function run_micro_tasks() {
  var tasks2 = micro_tasks;
  micro_tasks = [];
  run_all(tasks2);
}
function run_idle_tasks() {
  var tasks2 = idle_tasks;
  idle_tasks = [];
  run_all(tasks2);
}
function queue_micro_task(fn2) {
  if (micro_tasks.length === 0) {
    queueMicrotask(run_micro_tasks);
  }
  micro_tasks.push(fn2);
}
function flush_tasks() {
  if (micro_tasks.length > 0) {
    run_micro_tasks();
  }
  if (idle_tasks.length > 0) {
    run_idle_tasks();
  }
}
function get_pending_boundary() {
  var boundary = (
    /** @type {Effect} */
    active_effect.b
  );
  while (boundary !== null && !boundary.has_pending_snippet()) {
    boundary = boundary.parent;
  }
  if (boundary === null) {
    await_outside_boundary();
  }
  return boundary;
}
// @__NO_SIDE_EFFECTS__
function derived$1(fn2) {
  var flags = DERIVED | DIRTY;
  var parent_derived = active_reaction !== null && (active_reaction.f & DERIVED) !== 0 ? (
    /** @type {Derived} */
    active_reaction
  ) : null;
  if (active_effect === null || parent_derived !== null && (parent_derived.f & UNOWNED) !== 0) {
    flags |= UNOWNED;
  } else {
    active_effect.f |= EFFECT_PRESERVED;
  }
  const signal = {
    ctx: component_context,
    deps: null,
    effects: null,
    equals,
    f: flags,
    fn: fn2,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      UNINITIALIZED
    ),
    wv: 0,
    parent: parent_derived ?? active_effect,
    ac: null
  };
  return signal;
}
// @__NO_SIDE_EFFECTS__
function async_derived(fn2, location) {
  let parent2 = (
    /** @type {Effect | null} */
    active_effect
  );
  if (parent2 === null) {
    async_derived_orphan();
  }
  var boundary = (
    /** @type {Boundary} */
    parent2.b
  );
  var promise = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  );
  var signal = source(
    /** @type {V} */
    UNINITIALIZED
  );
  var prev = null;
  var should_suspend = !active_reaction;
  async_effect(() => {
    try {
      var p2 = fn2();
    } catch (error) {
      p2 = Promise.reject(error);
    }
    var r2 = () => p2;
    promise = (prev == null ? void 0 : prev.then(r2, r2)) ?? Promise.resolve(p2);
    prev = promise;
    var batch = (
      /** @type {Batch} */
      current_batch
    );
    var pending = boundary.pending;
    if (should_suspend) {
      boundary.update_pending_count(1);
      if (!pending) batch.increment();
    }
    const handler = (value, error = void 0) => {
      prev = null;
      if (!pending) batch.activate();
      if (error) {
        if (error !== STALE_REACTION) {
          signal.f |= ERROR_VALUE;
          internal_set(signal, error);
        }
      } else {
        if ((signal.f & ERROR_VALUE) !== 0) {
          signal.f ^= ERROR_VALUE;
        }
        internal_set(signal, value);
      }
      if (should_suspend) {
        boundary.update_pending_count(-1);
        if (!pending) batch.decrement();
      }
      unset_context();
    };
    promise.then(handler, (e2) => handler(null, e2 || "unknown"));
    if (batch) {
      return () => {
        queueMicrotask(() => batch.neuter());
      };
    }
  });
  return new Promise((fulfil) => {
    function next(p2) {
      function go() {
        if (p2 === promise) {
          fulfil(signal);
        } else {
          next(promise);
        }
      }
      p2.then(go, go);
    }
    next(promise);
  });
}
// @__NO_SIDE_EFFECTS__
function user_derived(fn2) {
  const d3 = /* @__PURE__ */ derived$1(fn2);
  push_reaction_value(d3);
  return d3;
}
// @__NO_SIDE_EFFECTS__
function derived_safe_equal(fn2) {
  const signal = /* @__PURE__ */ derived$1(fn2);
  signal.equals = safe_equals;
  return signal;
}
function destroy_derived_effects(derived2) {
  var effects = derived2.effects;
  if (effects !== null) {
    derived2.effects = null;
    for (var i2 = 0; i2 < effects.length; i2 += 1) {
      destroy_effect(
        /** @type {Effect} */
        effects[i2]
      );
    }
  }
}
function get_derived_parent_effect(derived2) {
  var parent2 = derived2.parent;
  while (parent2 !== null) {
    if ((parent2.f & DERIVED) === 0) {
      return (
        /** @type {Effect} */
        parent2
      );
    }
    parent2 = parent2.parent;
  }
  return null;
}
function execute_derived(derived2) {
  var value;
  var prev_active_effect = active_effect;
  set_active_effect(get_derived_parent_effect(derived2));
  {
    try {
      destroy_derived_effects(derived2);
      value = update_reaction(derived2);
    } finally {
      set_active_effect(prev_active_effect);
    }
  }
  return value;
}
function update_derived(derived2) {
  var value = execute_derived(derived2);
  if (!derived2.equals(value)) {
    derived2.v = value;
    derived2.wv = increment_write_version();
  }
  if (is_destroying_effect) {
    return;
  }
  if (batch_deriveds !== null) {
    batch_deriveds.set(derived2, derived2.v);
  } else {
    var status = (skip_reaction || (derived2.f & UNOWNED) !== 0) && derived2.deps !== null ? MAYBE_DIRTY : CLEAN;
    set_signal_status(derived2, status);
  }
}
function flatten$1(sync, async, fn2) {
  const d3 = is_runes() ? derived$1 : derived_safe_equal;
  if (async.length === 0) {
    fn2(sync.map(d3));
    return;
  }
  var batch = current_batch;
  var parent2 = (
    /** @type {Effect} */
    active_effect
  );
  var restore = capture();
  var boundary = get_pending_boundary();
  Promise.all(async.map((expression) => /* @__PURE__ */ async_derived(expression))).then((result) => {
    batch == null ? void 0 : batch.activate();
    restore();
    try {
      fn2([...sync.map(d3), ...result]);
    } catch (error) {
      if ((parent2.f & DESTROYED) === 0) {
        invoke_error_boundary(error, parent2);
      }
    }
    batch == null ? void 0 : batch.deactivate();
    unset_context();
  }).catch((error) => {
    boundary.error(error);
  });
}
function capture() {
  var previous_effect = active_effect;
  var previous_reaction = active_reaction;
  var previous_component_context = component_context;
  return function restore() {
    set_active_effect(previous_effect);
    set_active_reaction(previous_reaction);
    set_component_context(previous_component_context);
  };
}
function unset_context() {
  set_active_effect(null);
  set_active_reaction(null);
  set_component_context(null);
}
const batches = /* @__PURE__ */ new Set();
let current_batch = null;
let batch_deriveds = null;
let effect_pending_updates = /* @__PURE__ */ new Set();
let tasks = [];
function dequeue() {
  const task = (
    /** @type {() => void} */
    tasks.shift()
  );
  if (tasks.length > 0) {
    queueMicrotask(dequeue);
  }
  task();
}
let queued_root_effects = [];
let last_scheduled_effect = null;
let is_flushing = false;
let is_flushing_sync = false;
const _Batch = class _Batch {
  constructor() {
    __privateAdd(this, _Batch_instances);
    /**
     * The current values of any sources that are updated in this batch
     * They keys of this map are identical to `this.#previous`
     * @type {Map<Source, any>}
     */
    __publicField(this, "current", /* @__PURE__ */ new Map());
    /**
     * The values of any sources that are updated in this batch _before_ those updates took place.
     * They keys of this map are identical to `this.#current`
     * @type {Map<Source, any>}
     */
    __privateAdd(this, _previous, /* @__PURE__ */ new Map());
    /**
     * When the batch is committed (and the DOM is updated), we need to remove old branches
     * and append new ones by calling the functions added inside (if/each/key/etc) blocks
     * @type {Set<() => void>}
     */
    __privateAdd(this, _callbacks, /* @__PURE__ */ new Set());
    /**
     * The number of async effects that are currently in flight
     */
    __privateAdd(this, _pending, 0);
    /**
     * A deferred that resolves when the batch is committed, used with `settled()`
     * TODO replace with Promise.withResolvers once supported widely enough
     * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
     */
    __privateAdd(this, _deferred, null);
    /**
     * True if an async effect inside this batch resolved and
     * its parent branch was already deleted
     */
    __privateAdd(this, _neutered, false);
    /**
     * Async effects (created inside `async_derived`) encountered during processing.
     * These run after the rest of the batch has updated, since they should
     * always have the latest values
     * @type {Effect[]}
     */
    __privateAdd(this, _async_effects, []);
    /**
     * The same as `#async_effects`, but for effects inside a newly-created
     * `<svelte:boundary>` — these do not prevent the batch from committing
     * @type {Effect[]}
     */
    __privateAdd(this, _boundary_async_effects, []);
    /**
     * Template effects and `$effect.pre` effects, which run when
     * a batch is committed
     * @type {Effect[]}
     */
    __privateAdd(this, _render_effects, []);
    /**
     * The same as `#render_effects`, but for `$effect` (which runs after)
     * @type {Effect[]}
     */
    __privateAdd(this, _effects, []);
    /**
     * Block effects, which may need to re-run on subsequent flushes
     * in order to update internal sources (e.g. each block items)
     * @type {Effect[]}
     */
    __privateAdd(this, _block_effects, []);
    /**
     * Deferred effects (which run after async work has completed) that are DIRTY
     * @type {Effect[]}
     */
    __privateAdd(this, _dirty_effects, []);
    /**
     * Deferred effects that are MAYBE_DIRTY
     * @type {Effect[]}
     */
    __privateAdd(this, _maybe_dirty_effects, []);
    /**
     * A set of branches that still exist, but will be destroyed when this batch
     * is committed — we skip over these during `process`
     * @type {Set<Effect>}
     */
    __publicField(this, "skipped_effects", /* @__PURE__ */ new Set());
  }
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(root_effects) {
    var _a3;
    queued_root_effects = [];
    var current_values = null;
    if (batches.size > 1) {
      current_values = /* @__PURE__ */ new Map();
      batch_deriveds = /* @__PURE__ */ new Map();
      for (const [source2, current] of this.current) {
        current_values.set(source2, { v: source2.v, wv: source2.wv });
        source2.v = current;
      }
      for (const batch of batches) {
        if (batch === this) continue;
        for (const [source2, previous] of __privateGet(batch, _previous)) {
          if (!current_values.has(source2)) {
            current_values.set(source2, { v: source2.v, wv: source2.wv });
            source2.v = previous;
          }
        }
      }
    }
    for (const root2 of root_effects) {
      __privateMethod(this, _Batch_instances, traverse_effect_tree_fn).call(this, root2);
    }
    if (__privateGet(this, _async_effects).length === 0 && __privateGet(this, _pending) === 0) {
      __privateMethod(this, _Batch_instances, commit_fn).call(this);
      var render_effects = __privateGet(this, _render_effects);
      var effects = __privateGet(this, _effects);
      __privateSet(this, _render_effects, []);
      __privateSet(this, _effects, []);
      __privateSet(this, _block_effects, []);
      current_batch = null;
      flush_queued_effects(render_effects);
      flush_queued_effects(effects);
      if (current_batch === null) {
        current_batch = this;
      } else {
        batches.delete(this);
      }
      (_a3 = __privateGet(this, _deferred)) == null ? void 0 : _a3.resolve();
    } else {
      __privateMethod(this, _Batch_instances, defer_effects_fn).call(this, __privateGet(this, _render_effects));
      __privateMethod(this, _Batch_instances, defer_effects_fn).call(this, __privateGet(this, _effects));
      __privateMethod(this, _Batch_instances, defer_effects_fn).call(this, __privateGet(this, _block_effects));
    }
    if (current_values) {
      for (const [source2, { v: v2, wv }] of current_values) {
        if (source2.wv <= wv) {
          source2.v = v2;
        }
      }
      batch_deriveds = null;
    }
    for (const effect2 of __privateGet(this, _async_effects)) {
      update_effect(effect2);
    }
    for (const effect2 of __privateGet(this, _boundary_async_effects)) {
      update_effect(effect2);
    }
    __privateSet(this, _async_effects, []);
    __privateSet(this, _boundary_async_effects, []);
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(source2, value) {
    if (!__privateGet(this, _previous).has(source2)) {
      __privateGet(this, _previous).set(source2, value);
    }
    this.current.set(source2, source2.v);
  }
  activate() {
    current_batch = this;
  }
  deactivate() {
    current_batch = null;
    for (const update of effect_pending_updates) {
      effect_pending_updates.delete(update);
      update();
      if (current_batch !== null) {
        break;
      }
    }
  }
  neuter() {
    __privateSet(this, _neutered, true);
  }
  flush() {
    if (queued_root_effects.length > 0) {
      flush_effects();
    } else {
      __privateMethod(this, _Batch_instances, commit_fn).call(this);
    }
    if (current_batch !== this) {
      return;
    }
    if (__privateGet(this, _pending) === 0) {
      batches.delete(this);
    }
    this.deactivate();
  }
  increment() {
    __privateSet(this, _pending, __privateGet(this, _pending) + 1);
  }
  decrement() {
    __privateSet(this, _pending, __privateGet(this, _pending) - 1);
    if (__privateGet(this, _pending) === 0) {
      for (const e2 of __privateGet(this, _dirty_effects)) {
        set_signal_status(e2, DIRTY);
        schedule_effect(e2);
      }
      for (const e2 of __privateGet(this, _maybe_dirty_effects)) {
        set_signal_status(e2, MAYBE_DIRTY);
        schedule_effect(e2);
      }
      __privateSet(this, _render_effects, []);
      __privateSet(this, _effects, []);
      this.flush();
    } else {
      this.deactivate();
    }
  }
  /** @param {() => void} fn */
  add_callback(fn2) {
    __privateGet(this, _callbacks).add(fn2);
  }
  settled() {
    return (__privateGet(this, _deferred) ?? __privateSet(this, _deferred, deferred())).promise;
  }
  static ensure() {
    if (current_batch === null) {
      const batch = current_batch = new _Batch();
      batches.add(current_batch);
      if (!is_flushing_sync) {
        _Batch.enqueue(() => {
          if (current_batch !== batch) {
            return;
          }
          batch.flush();
        });
      }
    }
    return current_batch;
  }
  /** @param {() => void} task */
  static enqueue(task) {
    if (tasks.length === 0) {
      queueMicrotask(dequeue);
    }
    tasks.unshift(task);
  }
};
_previous = new WeakMap();
_callbacks = new WeakMap();
_pending = new WeakMap();
_deferred = new WeakMap();
_neutered = new WeakMap();
_async_effects = new WeakMap();
_boundary_async_effects = new WeakMap();
_render_effects = new WeakMap();
_effects = new WeakMap();
_block_effects = new WeakMap();
_dirty_effects = new WeakMap();
_maybe_dirty_effects = new WeakMap();
_Batch_instances = new WeakSet();
/**
 * Traverse the effect tree, executing effects or stashing
 * them for later execution as appropriate
 * @param {Effect} root
 */
traverse_effect_tree_fn = function(root2) {
  var _a3;
  root2.f ^= CLEAN;
  var effect2 = root2.first;
  while (effect2 !== null) {
    var flags = effect2.f;
    var is_branch = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
    var is_skippable_branch = is_branch && (flags & CLEAN) !== 0;
    var skip = is_skippable_branch || (flags & INERT) !== 0 || this.skipped_effects.has(effect2);
    if (!skip && effect2.fn !== null) {
      if (is_branch) {
        effect2.f ^= CLEAN;
      } else if ((flags & CLEAN) === 0) {
        if ((flags & EFFECT) !== 0) {
          __privateGet(this, _effects).push(effect2);
        } else if ((flags & ASYNC) !== 0) {
          var effects = ((_a3 = effect2.b) == null ? void 0 : _a3.pending) ? __privateGet(this, _boundary_async_effects) : __privateGet(this, _async_effects);
          effects.push(effect2);
        } else if (is_dirty(effect2)) {
          if ((effect2.f & BLOCK_EFFECT) !== 0) __privateGet(this, _block_effects).push(effect2);
          update_effect(effect2);
        }
      }
      var child2 = effect2.first;
      if (child2 !== null) {
        effect2 = child2;
        continue;
      }
    }
    var parent2 = effect2.parent;
    effect2 = effect2.next;
    while (effect2 === null && parent2 !== null) {
      effect2 = parent2.next;
      parent2 = parent2.parent;
    }
  }
};
/**
 * @param {Effect[]} effects
 */
defer_effects_fn = function(effects) {
  for (const e2 of effects) {
    const target = (e2.f & DIRTY) !== 0 ? __privateGet(this, _dirty_effects) : __privateGet(this, _maybe_dirty_effects);
    target.push(e2);
    set_signal_status(e2, CLEAN);
  }
  effects.length = 0;
};
/**
 * Append and remove branches to/from the DOM
 */
commit_fn = function() {
  if (!__privateGet(this, _neutered)) {
    for (const fn2 of __privateGet(this, _callbacks)) {
      fn2();
    }
  }
  __privateGet(this, _callbacks).clear();
};
let Batch = _Batch;
function flushSync(fn2) {
  var was_flushing_sync = is_flushing_sync;
  is_flushing_sync = true;
  try {
    var result;
    if (fn2) ;
    while (true) {
      flush_tasks();
      if (queued_root_effects.length === 0) {
        current_batch == null ? void 0 : current_batch.flush();
        if (queued_root_effects.length === 0) {
          last_scheduled_effect = null;
          return (
            /** @type {T} */
            result
          );
        }
      }
      flush_effects();
    }
  } finally {
    is_flushing_sync = was_flushing_sync;
  }
}
function flush_effects() {
  var was_updating_effect = is_updating_effect;
  is_flushing = true;
  try {
    var flush_count = 0;
    set_is_updating_effect(true);
    while (queued_root_effects.length > 0) {
      var batch = Batch.ensure();
      if (flush_count++ > 1e3) {
        var updates, entry;
        if (DEV) ;
        infinite_loop_guard();
      }
      batch.process(queued_root_effects);
      old_values.clear();
    }
  } finally {
    is_flushing = false;
    set_is_updating_effect(was_updating_effect);
    last_scheduled_effect = null;
  }
}
function infinite_loop_guard() {
  try {
    effect_update_depth_exceeded();
  } catch (error) {
    invoke_error_boundary(error, last_scheduled_effect);
  }
}
function flush_queued_effects(effects) {
  var length = effects.length;
  if (length === 0) return;
  var i2 = 0;
  while (i2 < length) {
    var effect2 = effects[i2++];
    if ((effect2.f & (DESTROYED | INERT)) === 0 && is_dirty(effect2)) {
      var n2 = current_batch ? current_batch.current.size : 0;
      update_effect(effect2);
      if (effect2.deps === null && effect2.first === null && effect2.nodes_start === null) {
        if (effect2.teardown === null && effect2.ac === null) {
          unlink_effect(effect2);
        } else {
          effect2.fn = null;
        }
      }
      if (current_batch !== null && current_batch.current.size > n2 && (effect2.f & USER_EFFECT) !== 0) {
        break;
      }
    }
  }
  while (i2 < length) {
    schedule_effect(effects[i2++]);
  }
}
function schedule_effect(signal) {
  var effect2 = last_scheduled_effect = signal;
  while (effect2.parent !== null) {
    effect2 = effect2.parent;
    var flags = effect2.f;
    if (is_flushing && effect2 === active_effect && (flags & BLOCK_EFFECT) !== 0) {
      return;
    }
    if ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
      if ((flags & CLEAN) === 0) return;
      effect2.f ^= CLEAN;
    }
  }
  queued_root_effects.push(effect2);
}
const old_values = /* @__PURE__ */ new Map();
function source(v2, stack) {
  var signal = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: v2,
    reactions: null,
    equals,
    rv: 0,
    wv: 0
  };
  return signal;
}
// @__NO_SIDE_EFFECTS__
function state(v2, stack) {
  const s2 = source(v2);
  push_reaction_value(s2);
  return s2;
}
// @__NO_SIDE_EFFECTS__
function mutable_source(initial_value, immutable = false, trackable = true) {
  var _a3;
  const s2 = source(initial_value);
  if (!immutable) {
    s2.equals = safe_equals;
  }
  if (legacy_mode_flag && trackable && component_context !== null && component_context.l !== null) {
    ((_a3 = component_context.l).s ?? (_a3.s = [])).push(s2);
  }
  return s2;
}
function set(source2, value, should_proxy = false) {
  if (active_reaction !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!untracking || (active_reaction.f & INSPECT_EFFECT) !== 0) && is_runes() && (active_reaction.f & (DERIVED | BLOCK_EFFECT | ASYNC | INSPECT_EFFECT)) !== 0 && !(current_sources == null ? void 0 : current_sources.includes(source2))) {
    state_unsafe_mutation();
  }
  let new_value = should_proxy ? proxy$1(value) : value;
  return internal_set(source2, new_value);
}
function internal_set(source2, value) {
  if (!source2.equals(value)) {
    var old_value = source2.v;
    if (is_destroying_effect) {
      old_values.set(source2, value);
    } else {
      old_values.set(source2, old_value);
    }
    source2.v = value;
    var batch = Batch.ensure();
    batch.capture(source2, old_value);
    if ((source2.f & DERIVED) !== 0) {
      if ((source2.f & DIRTY) !== 0) {
        execute_derived(
          /** @type {Derived} */
          source2
        );
      }
      set_signal_status(source2, (source2.f & UNOWNED) === 0 ? CLEAN : MAYBE_DIRTY);
    }
    source2.wv = increment_write_version();
    mark_reactions(source2, DIRTY);
    if (is_runes() && active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {
      if (untracked_writes === null) {
        set_untracked_writes([source2]);
      } else {
        untracked_writes.push(source2);
      }
    }
  }
  return value;
}
function increment(source2) {
  set(source2, source2.v + 1);
}
function mark_reactions(signal, status) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  var runes = is_runes();
  var length = reactions.length;
  for (var i2 = 0; i2 < length; i2++) {
    var reaction = reactions[i2];
    var flags = reaction.f;
    if (!runes && reaction === active_effect) continue;
    var not_dirty = (flags & DIRTY) === 0;
    if (not_dirty) {
      set_signal_status(reaction, status);
    }
    if ((flags & DERIVED) !== 0) {
      mark_reactions(
        /** @type {Derived} */
        reaction,
        MAYBE_DIRTY
      );
    } else if (not_dirty) {
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
let is_updating_effect = false;
function set_is_updating_effect(value) {
  is_updating_effect = value;
}
let is_destroying_effect = false;
function set_is_destroying_effect(value) {
  is_destroying_effect = value;
}
let active_reaction = null;
let untracking = false;
function set_active_reaction(reaction) {
  active_reaction = reaction;
}
let active_effect = null;
function set_active_effect(effect2) {
  active_effect = effect2;
}
let current_sources = null;
function push_reaction_value(value) {
  if (active_reaction !== null && true) {
    if (current_sources === null) {
      current_sources = [value];
    } else {
      current_sources.push(value);
    }
  }
}
let new_deps = null;
let skipped_deps = 0;
let untracked_writes = null;
function set_untracked_writes(value) {
  untracked_writes = value;
}
let write_version = 1;
let read_version = 0;
let update_version = read_version;
function set_update_version(value) {
  update_version = value;
}
let skip_reaction = false;
function increment_write_version() {
  return ++write_version;
}
function is_dirty(reaction) {
  var _a3;
  var flags = reaction.f;
  if ((flags & DIRTY) !== 0) {
    return true;
  }
  if ((flags & MAYBE_DIRTY) !== 0) {
    var dependencies = reaction.deps;
    var is_unowned = (flags & UNOWNED) !== 0;
    if (dependencies !== null) {
      var i2;
      var dependency;
      var is_disconnected = (flags & DISCONNECTED) !== 0;
      var is_unowned_connected = is_unowned && active_effect !== null && !skip_reaction;
      var length = dependencies.length;
      if ((is_disconnected || is_unowned_connected) && (active_effect === null || (active_effect.f & DESTROYED) === 0)) {
        var derived2 = (
          /** @type {Derived} */
          reaction
        );
        var parent2 = derived2.parent;
        for (i2 = 0; i2 < length; i2++) {
          dependency = dependencies[i2];
          if (is_disconnected || !((_a3 = dependency == null ? void 0 : dependency.reactions) == null ? void 0 : _a3.includes(derived2))) {
            (dependency.reactions ?? (dependency.reactions = [])).push(derived2);
          }
        }
        if (is_disconnected) {
          derived2.f ^= DISCONNECTED;
        }
        if (is_unowned_connected && parent2 !== null && (parent2.f & UNOWNED) === 0) {
          derived2.f ^= UNOWNED;
        }
      }
      for (i2 = 0; i2 < length; i2++) {
        dependency = dependencies[i2];
        if (is_dirty(
          /** @type {Derived} */
          dependency
        )) {
          update_derived(
            /** @type {Derived} */
            dependency
          );
        }
        if (dependency.wv > reaction.wv) {
          return true;
        }
      }
    }
    if (!is_unowned || active_effect !== null && !skip_reaction) {
      set_signal_status(reaction, CLEAN);
    }
  }
  return false;
}
function schedule_possible_effect_self_invalidation(signal, effect2, root2 = true) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  if (current_sources == null ? void 0 : current_sources.includes(signal)) {
    return;
  }
  for (var i2 = 0; i2 < reactions.length; i2++) {
    var reaction = reactions[i2];
    if ((reaction.f & DERIVED) !== 0) {
      schedule_possible_effect_self_invalidation(
        /** @type {Derived} */
        reaction,
        effect2,
        false
      );
    } else if (effect2 === reaction) {
      if (root2) {
        set_signal_status(reaction, DIRTY);
      } else if ((reaction.f & CLEAN) !== 0) {
        set_signal_status(reaction, MAYBE_DIRTY);
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
function update_reaction(reaction) {
  var _a3;
  var previous_deps = new_deps;
  var previous_skipped_deps = skipped_deps;
  var previous_untracked_writes = untracked_writes;
  var previous_reaction = active_reaction;
  var previous_skip_reaction = skip_reaction;
  var previous_sources = current_sources;
  var previous_component_context = component_context;
  var previous_untracking = untracking;
  var previous_update_version = update_version;
  var flags = reaction.f;
  new_deps = /** @type {null | Value[]} */
  null;
  skipped_deps = 0;
  untracked_writes = null;
  skip_reaction = (flags & UNOWNED) !== 0 && (untracking || !is_updating_effect || active_reaction === null);
  active_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
  current_sources = null;
  set_component_context(reaction.ctx);
  untracking = false;
  update_version = ++read_version;
  if (reaction.ac !== null) {
    reaction.ac.abort(STALE_REACTION);
    reaction.ac = null;
  }
  try {
    reaction.f |= REACTION_IS_UPDATING;
    var result = (
      /** @type {Function} */
      (0, reaction.fn)()
    );
    var deps = reaction.deps;
    if (new_deps !== null) {
      var i2;
      remove_reactions(reaction, skipped_deps);
      if (deps !== null && skipped_deps > 0) {
        deps.length = skipped_deps + new_deps.length;
        for (i2 = 0; i2 < new_deps.length; i2++) {
          deps[skipped_deps + i2] = new_deps[i2];
        }
      } else {
        reaction.deps = deps = new_deps;
      }
      if (!skip_reaction || // Deriveds that already have reactions can cleanup, so we still add them as reactions
      (flags & DERIVED) !== 0 && /** @type {import('#client').Derived} */
      reaction.reactions !== null) {
        for (i2 = skipped_deps; i2 < deps.length; i2++) {
          ((_a3 = deps[i2]).reactions ?? (_a3.reactions = [])).push(reaction);
        }
      }
    } else if (deps !== null && skipped_deps < deps.length) {
      remove_reactions(reaction, skipped_deps);
      deps.length = skipped_deps;
    }
    if (is_runes() && untracked_writes !== null && !untracking && deps !== null && (reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0) {
      for (i2 = 0; i2 < /** @type {Source[]} */
      untracked_writes.length; i2++) {
        schedule_possible_effect_self_invalidation(
          untracked_writes[i2],
          /** @type {Effect} */
          reaction
        );
      }
    }
    if (previous_reaction !== null && previous_reaction !== reaction) {
      read_version++;
      if (untracked_writes !== null) {
        if (previous_untracked_writes === null) {
          previous_untracked_writes = untracked_writes;
        } else {
          previous_untracked_writes.push(.../** @type {Source[]} */
          untracked_writes);
        }
      }
    }
    if ((reaction.f & ERROR_VALUE) !== 0) {
      reaction.f ^= ERROR_VALUE;
    }
    return result;
  } catch (error) {
    return handle_error(error);
  } finally {
    reaction.f ^= REACTION_IS_UPDATING;
    new_deps = previous_deps;
    skipped_deps = previous_skipped_deps;
    untracked_writes = previous_untracked_writes;
    active_reaction = previous_reaction;
    skip_reaction = previous_skip_reaction;
    current_sources = previous_sources;
    set_component_context(previous_component_context);
    untracking = previous_untracking;
    update_version = previous_update_version;
  }
}
function remove_reaction(signal, dependency) {
  let reactions = dependency.reactions;
  if (reactions !== null) {
    var index2 = index_of.call(reactions, signal);
    if (index2 !== -1) {
      var new_length = reactions.length - 1;
      if (new_length === 0) {
        reactions = dependency.reactions = null;
      } else {
        reactions[index2] = reactions[new_length];
        reactions.pop();
      }
    }
  }
  if (reactions === null && (dependency.f & DERIVED) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (new_deps === null || !new_deps.includes(dependency))) {
    set_signal_status(dependency, MAYBE_DIRTY);
    if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
      dependency.f ^= DISCONNECTED;
    }
    destroy_derived_effects(
      /** @type {Derived} **/
      dependency
    );
    remove_reactions(
      /** @type {Derived} **/
      dependency,
      0
    );
  }
}
function remove_reactions(signal, start_index) {
  var dependencies = signal.deps;
  if (dependencies === null) return;
  for (var i2 = start_index; i2 < dependencies.length; i2++) {
    remove_reaction(signal, dependencies[i2]);
  }
}
function update_effect(effect2) {
  var flags = effect2.f;
  if ((flags & DESTROYED) !== 0) {
    return;
  }
  set_signal_status(effect2, CLEAN);
  var previous_effect = active_effect;
  var was_updating_effect = is_updating_effect;
  active_effect = effect2;
  is_updating_effect = true;
  try {
    if ((flags & BLOCK_EFFECT) !== 0) {
      destroy_block_effect_children(effect2);
    } else {
      destroy_effect_children(effect2);
    }
    execute_effect_teardown(effect2);
    var teardown2 = update_reaction(effect2);
    effect2.teardown = typeof teardown2 === "function" ? teardown2 : null;
    effect2.wv = write_version;
    var dep;
    if (DEV && tracing_mode_flag && (effect2.f & DIRTY) !== 0 && effect2.deps !== null) ;
  } finally {
    is_updating_effect = was_updating_effect;
    active_effect = previous_effect;
  }
}
async function tick() {
  await Promise.resolve();
  flushSync();
}
function get$1(signal) {
  var flags = signal.f;
  var is_derived = (flags & DERIVED) !== 0;
  if (active_reaction !== null && !untracking) {
    var destroyed = active_effect !== null && (active_effect.f & DESTROYED) !== 0;
    if (!destroyed && !(current_sources == null ? void 0 : current_sources.includes(signal))) {
      var deps = active_reaction.deps;
      if ((active_reaction.f & REACTION_IS_UPDATING) !== 0) {
        if (signal.rv < read_version) {
          signal.rv = read_version;
          if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
            skipped_deps++;
          } else if (new_deps === null) {
            new_deps = [signal];
          } else if (!skip_reaction || !new_deps.includes(signal)) {
            new_deps.push(signal);
          }
        }
      } else {
        (active_reaction.deps ?? (active_reaction.deps = [])).push(signal);
        var reactions = signal.reactions;
        if (reactions === null) {
          signal.reactions = [active_reaction];
        } else if (!reactions.includes(active_reaction)) {
          reactions.push(active_reaction);
        }
      }
    }
  } else if (is_derived && /** @type {Derived} */
  signal.deps === null && /** @type {Derived} */
  signal.effects === null) {
    var derived2 = (
      /** @type {Derived} */
      signal
    );
    var parent2 = derived2.parent;
    if (parent2 !== null && (parent2.f & UNOWNED) === 0) {
      derived2.f ^= UNOWNED;
    }
  }
  if (is_destroying_effect) {
    if (old_values.has(signal)) {
      return old_values.get(signal);
    }
    if (is_derived) {
      derived2 = /** @type {Derived} */
      signal;
      var value = derived2.v;
      if ((derived2.f & CLEAN) === 0 && derived2.reactions !== null || depends_on_old_values(derived2)) {
        value = execute_derived(derived2);
      }
      old_values.set(derived2, value);
      return value;
    }
  } else if (is_derived) {
    derived2 = /** @type {Derived} */
    signal;
    if (batch_deriveds == null ? void 0 : batch_deriveds.has(derived2)) {
      return batch_deriveds.get(derived2);
    }
    if (is_dirty(derived2)) {
      update_derived(derived2);
    }
  }
  if ((signal.f & ERROR_VALUE) !== 0) {
    throw signal.v;
  }
  return signal.v;
}
function depends_on_old_values(derived2) {
  if (derived2.v === UNINITIALIZED) return true;
  if (derived2.deps === null) return false;
  for (const dep of derived2.deps) {
    if (old_values.has(dep)) {
      return true;
    }
    if ((dep.f & DERIVED) !== 0 && depends_on_old_values(
      /** @type {Derived} */
      dep
    )) {
      return true;
    }
  }
  return false;
}
function untrack(fn2) {
  var previous_untracking = untracking;
  try {
    untracking = true;
    return fn2();
  } finally {
    untracking = previous_untracking;
  }
}
const STATUS_MASK = -7169;
function set_signal_status(signal, status) {
  signal.f = signal.f & STATUS_MASK | status;
}
function deep_read_state(value) {
  if (typeof value !== "object" || !value || value instanceof EventTarget) {
    return;
  }
  if (STATE_SYMBOL in value) {
    deep_read(value);
  } else if (!Array.isArray(value)) {
    for (let key2 in value) {
      const prop2 = value[key2];
      if (typeof prop2 === "object" && prop2 && STATE_SYMBOL in prop2) {
        deep_read(prop2);
      }
    }
  }
}
function deep_read(value, visited = /* @__PURE__ */ new Set()) {
  if (typeof value === "object" && value !== null && // We don't want to traverse DOM elements
  !(value instanceof EventTarget) && !visited.has(value)) {
    visited.add(value);
    if (value instanceof Date) {
      value.getTime();
    }
    for (let key2 in value) {
      try {
        deep_read(value[key2], visited);
      } catch (e2) {
      }
    }
    const proto = get_prototype_of(value);
    if (proto !== Object.prototype && proto !== Array.prototype && proto !== Map.prototype && proto !== Set.prototype && proto !== Date.prototype) {
      const descriptors = get_descriptors(proto);
      for (let key2 in descriptors) {
        const get2 = descriptors[key2].get;
        if (get2) {
          try {
            get2.call(value);
          } catch (e2) {
          }
        }
      }
    }
  }
}
function validate_effect(rune) {
  if (active_effect === null && active_reaction === null) {
    effect_orphan();
  }
  if (active_reaction !== null && (active_reaction.f & UNOWNED) !== 0 && active_effect === null) {
    effect_in_unowned_derived();
  }
  if (is_destroying_effect) {
    effect_in_teardown();
  }
}
function push_effect(effect2, parent_effect) {
  var parent_last = parent_effect.last;
  if (parent_last === null) {
    parent_effect.last = parent_effect.first = effect2;
  } else {
    parent_last.next = effect2;
    effect2.prev = parent_last;
    parent_effect.last = effect2;
  }
}
function create_effect(type, fn2, sync, push2 = true) {
  var parent2 = active_effect;
  if (parent2 !== null && (parent2.f & INERT) !== 0) {
    type |= INERT;
  }
  var effect2 = {
    ctx: component_context,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: type | DIRTY,
    first: null,
    fn: fn2,
    last: null,
    next: null,
    parent: parent2,
    b: parent2 && parent2.b,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0,
    ac: null
  };
  if (sync) {
    try {
      update_effect(effect2);
      effect2.f |= EFFECT_RAN;
    } catch (e2) {
      destroy_effect(effect2);
      throw e2;
    }
  } else if (fn2 !== null) {
    schedule_effect(effect2);
  }
  var inert = sync && effect2.deps === null && effect2.first === null && effect2.nodes_start === null && effect2.teardown === null && (effect2.f & EFFECT_PRESERVED) === 0;
  if (!inert && push2) {
    if (parent2 !== null) {
      push_effect(effect2, parent2);
    }
    if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0 && (type & ROOT_EFFECT) === 0) {
      var derived2 = (
        /** @type {Derived} */
        active_reaction
      );
      (derived2.effects ?? (derived2.effects = [])).push(effect2);
    }
  }
  return effect2;
}
function teardown(fn2) {
  const effect2 = create_effect(RENDER_EFFECT, null, false);
  set_signal_status(effect2, CLEAN);
  effect2.teardown = fn2;
  return effect2;
}
function user_effect(fn2) {
  validate_effect();
  var flags = (
    /** @type {Effect} */
    active_effect.f
  );
  var defer = !active_reaction && (flags & BRANCH_EFFECT) !== 0 && (flags & EFFECT_RAN) === 0;
  if (defer) {
    var context = (
      /** @type {ComponentContext} */
      component_context
    );
    (context.e ?? (context.e = [])).push(fn2);
  } else {
    return create_user_effect(fn2);
  }
}
function create_user_effect(fn2) {
  return create_effect(EFFECT | USER_EFFECT, fn2, false);
}
function user_pre_effect(fn2) {
  validate_effect();
  return create_effect(RENDER_EFFECT | USER_EFFECT, fn2, true);
}
function component_root(fn2) {
  Batch.ensure();
  const effect2 = create_effect(ROOT_EFFECT, fn2, true);
  return (options = {}) => {
    return new Promise((fulfil) => {
      if (options.outro) {
        pause_effect(effect2, () => {
          destroy_effect(effect2);
          fulfil(void 0);
        });
      } else {
        destroy_effect(effect2);
        fulfil(void 0);
      }
    });
  };
}
function effect(fn2) {
  return create_effect(EFFECT, fn2, false);
}
function async_effect(fn2) {
  return create_effect(ASYNC | EFFECT_PRESERVED, fn2, true);
}
function render_effect(fn2, flags = 0) {
  return create_effect(RENDER_EFFECT | flags, fn2, true);
}
function template_effect(fn2, sync = [], async = []) {
  flatten$1(sync, async, (values2) => {
    create_effect(RENDER_EFFECT, () => fn2(...values2.map(get$1)), true);
  });
}
function block(fn2, flags = 0) {
  var effect2 = create_effect(BLOCK_EFFECT | flags, fn2, true);
  return effect2;
}
function branch(fn2, push2 = true) {
  return create_effect(BRANCH_EFFECT, fn2, true, push2);
}
function execute_effect_teardown(effect2) {
  var teardown2 = effect2.teardown;
  if (teardown2 !== null) {
    const previously_destroying_effect = is_destroying_effect;
    const previous_reaction = active_reaction;
    set_is_destroying_effect(true);
    set_active_reaction(null);
    try {
      teardown2.call(null);
    } finally {
      set_is_destroying_effect(previously_destroying_effect);
      set_active_reaction(previous_reaction);
    }
  }
}
function destroy_effect_children(signal, remove_dom = false) {
  var _a3;
  var effect2 = signal.first;
  signal.first = signal.last = null;
  while (effect2 !== null) {
    (_a3 = effect2.ac) == null ? void 0 : _a3.abort(STALE_REACTION);
    var next = effect2.next;
    if ((effect2.f & ROOT_EFFECT) !== 0) {
      effect2.parent = null;
    } else {
      destroy_effect(effect2, remove_dom);
    }
    effect2 = next;
  }
}
function destroy_block_effect_children(signal) {
  var effect2 = signal.first;
  while (effect2 !== null) {
    var next = effect2.next;
    if ((effect2.f & BRANCH_EFFECT) === 0) {
      destroy_effect(effect2);
    }
    effect2 = next;
  }
}
function destroy_effect(effect2, remove_dom = true) {
  var removed = false;
  if ((remove_dom || (effect2.f & HEAD_EFFECT) !== 0) && effect2.nodes_start !== null && effect2.nodes_end !== null) {
    remove_effect_dom(
      effect2.nodes_start,
      /** @type {TemplateNode} */
      effect2.nodes_end
    );
    removed = true;
  }
  destroy_effect_children(effect2, remove_dom && !removed);
  remove_reactions(effect2, 0);
  set_signal_status(effect2, DESTROYED);
  var transitions = effect2.transitions;
  if (transitions !== null) {
    for (const transition of transitions) {
      transition.stop();
    }
  }
  execute_effect_teardown(effect2);
  var parent2 = effect2.parent;
  if (parent2 !== null && parent2.first !== null) {
    unlink_effect(effect2);
  }
  effect2.next = effect2.prev = effect2.teardown = effect2.ctx = effect2.deps = effect2.fn = effect2.nodes_start = effect2.nodes_end = effect2.ac = null;
}
function remove_effect_dom(node, end) {
  var _a3;
  while (node !== null) {
    var next = node === end ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ get_next_sibling(node)
    );
    (_a3 = node.__cleanup) == null ? void 0 : _a3.forEach((c2) => c2());
    node.__cleanup = void 0;
    node.__click = void 0;
    node.remove();
    node = next;
  }
}
function unlink_effect(effect2) {
  var parent2 = effect2.parent;
  var prev = effect2.prev;
  var next = effect2.next;
  if (prev !== null) prev.next = next;
  if (next !== null) next.prev = prev;
  if (parent2 !== null) {
    if (parent2.first === effect2) parent2.first = next;
    if (parent2.last === effect2) parent2.last = prev;
  }
}
function pause_effect(effect2, callback) {
  var transitions = [];
  pause_children(effect2, transitions, true);
  run_out_transitions(transitions, () => {
    destroy_effect(effect2);
    if (callback) callback();
  });
}
function run_out_transitions(transitions, fn2) {
  var remaining = transitions.length;
  if (remaining > 0) {
    var check = () => --remaining || fn2();
    for (var transition of transitions) {
      transition.out(check);
    }
  } else {
    fn2();
  }
}
function pause_children(effect2, transitions, local) {
  if ((effect2.f & INERT) !== 0) return;
  effect2.f ^= INERT;
  if (effect2.transitions !== null) {
    for (const transition of effect2.transitions) {
      if (transition.is_global || local) {
        transitions.push(transition);
      }
    }
  }
  var child2 = effect2.first;
  while (child2 !== null) {
    var sibling2 = child2.next;
    var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || (child2.f & BRANCH_EFFECT) !== 0;
    pause_children(child2, transitions, transparent ? local : false);
    child2 = sibling2;
  }
}
function resume_effect(effect2) {
  resume_children(effect2, true);
}
function resume_children(effect2, local) {
  if ((effect2.f & INERT) === 0) return;
  effect2.f ^= INERT;
  if ((effect2.f & CLEAN) === 0) {
    set_signal_status(effect2, DIRTY);
    schedule_effect(effect2);
  }
  var child2 = effect2.first;
  while (child2 !== null) {
    var sibling2 = child2.next;
    var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || (child2.f & BRANCH_EFFECT) !== 0;
    resume_children(child2, transparent ? local : false);
    child2 = sibling2;
  }
  if (effect2.transitions !== null) {
    for (const transition of effect2.transitions) {
      if (transition.is_global || local) {
        transition.in();
      }
    }
  }
}
function is_capture_event(name) {
  return name.endsWith("capture") && name !== "gotpointercapture" && name !== "lostpointercapture";
}
const DELEGATED_EVENTS = [
  "beforeinput",
  "click",
  "change",
  "dblclick",
  "contextmenu",
  "focusin",
  "focusout",
  "input",
  "keydown",
  "keyup",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "pointerdown",
  "pointermove",
  "pointerout",
  "pointerover",
  "pointerup",
  "touchend",
  "touchmove",
  "touchstart"
];
function is_delegated(event_name) {
  return DELEGATED_EVENTS.includes(event_name);
}
const ATTRIBUTE_ALIASES = {
  // no `class: 'className'` because we handle that separately
  formnovalidate: "formNoValidate",
  ismap: "isMap",
  nomodule: "noModule",
  playsinline: "playsInline",
  readonly: "readOnly",
  defaultvalue: "defaultValue",
  defaultchecked: "defaultChecked",
  srcobject: "srcObject",
  novalidate: "noValidate",
  allowfullscreen: "allowFullscreen",
  disablepictureinpicture: "disablePictureInPicture",
  disableremoteplayback: "disableRemotePlayback"
};
function normalize_attribute(name) {
  name = name.toLowerCase();
  return ATTRIBUTE_ALIASES[name] ?? name;
}
const PASSIVE_EVENTS = ["touchstart", "touchmove"];
function is_passive_event(name) {
  return PASSIVE_EVENTS.includes(name);
}
function autofocus(dom, value) {
  if (value) {
    const body = document.body;
    dom.autofocus = true;
    queue_micro_task(() => {
      if (document.activeElement === body) {
        dom.focus();
      }
    });
  }
}
function without_reactive_context(fn2) {
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    return fn2();
  } finally {
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
const all_registered_events = /* @__PURE__ */ new Set();
const root_event_handles = /* @__PURE__ */ new Set();
function create_event(event_name, dom, handler, options = {}) {
  function target_handler(event2) {
    if (!options.capture) {
      handle_event_propagation.call(dom, event2);
    }
    if (!event2.cancelBubble) {
      return without_reactive_context(() => {
        return handler == null ? void 0 : handler.call(this, event2);
      });
    }
  }
  if (event_name.startsWith("pointer") || event_name.startsWith("touch") || event_name === "wheel") {
    queue_micro_task(() => {
      dom.addEventListener(event_name, target_handler, options);
    });
  } else {
    dom.addEventListener(event_name, target_handler, options);
  }
  return target_handler;
}
function on(element2, type, handler, options = {}) {
  var target_handler = create_event(type, element2, handler, options);
  return () => {
    element2.removeEventListener(type, target_handler, options);
  };
}
function event(event_name, dom, handler, capture2, passive) {
  var options = { capture: capture2, passive };
  var target_handler = create_event(event_name, dom, handler, options);
  if (!Array.isArray(dom.__cleanup)) {
    dom.__cleanup = [];
  }
  const cleanup = () => {
    dom.removeEventListener(event_name, target_handler, options);
  };
  teardown(cleanup);
  dom.__cleanup.push(cleanup);
}
function delegate(events) {
  for (var i2 = 0; i2 < events.length; i2++) {
    all_registered_events.add(events[i2]);
  }
  for (var fn2 of root_event_handles) {
    fn2(events);
  }
}
let last_propagated_event = null;
function handle_event_propagation(event2) {
  var _a3;
  var handler_element = this;
  var owner_document = (
    /** @type {Node} */
    handler_element.ownerDocument
  );
  var event_name = event2.type;
  var path = ((_a3 = event2.composedPath) == null ? void 0 : _a3.call(event2)) || [];
  var current_target = (
    /** @type {null | Element} */
    path[0] || event2.target
  );
  last_propagated_event = event2;
  var path_idx = 0;
  var handled_at = last_propagated_event === event2 && event2.__root;
  if (handled_at) {
    var at_idx = path.indexOf(handled_at);
    if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */
    window)) {
      event2.__root = handler_element;
      return;
    }
    var handler_idx = path.indexOf(handler_element);
    if (handler_idx === -1) {
      return;
    }
    if (at_idx <= handler_idx) {
      path_idx = at_idx;
    }
  }
  current_target = /** @type {Element} */
  path[path_idx] || event2.target;
  if (current_target === handler_element) return;
  define_property(event2, "currentTarget", {
    configurable: true,
    get() {
      return current_target || owner_document;
    }
  });
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    var throw_error;
    var other_errors = [];
    while (current_target !== null) {
      var parent_element = current_target.assignedSlot || current_target.parentNode || /** @type {any} */
      current_target.host || null;
      try {
        var delegated = current_target["__" + event_name];
        if (delegated != null && (!/** @type {any} */
        current_target.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
        // -> the target could not have been disabled because it emits the event in the first place
        event2.target === current_target)) {
          if (is_array(delegated)) {
            var [fn2, ...data] = delegated;
            fn2.apply(current_target, [event2, ...data]);
          } else {
            delegated.call(current_target, event2);
          }
        }
      } catch (error) {
        if (throw_error) {
          other_errors.push(error);
        } else {
          throw_error = error;
        }
      }
      if (event2.cancelBubble || parent_element === handler_element || parent_element === null) {
        break;
      }
      current_target = parent_element;
    }
    if (throw_error) {
      for (let error of other_errors) {
        queueMicrotask(() => {
          throw error;
        });
      }
      throw throw_error;
    }
  } finally {
    event2.__root = handler_element;
    last_propagated_event = null;
    delete event2.currentTarget;
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
function clear_event_propagation() {
  last_propagated_event = null;
}
function create_fragment_from_html(html2) {
  var elem = document.createElement("template");
  elem.innerHTML = html2.replaceAll("<!>", "<!---->");
  return elem.content;
}
function assign_nodes(start2, end) {
  var effect2 = (
    /** @type {Effect} */
    active_effect
  );
  if (effect2.nodes_start === null) {
    effect2.nodes_start = start2;
    effect2.nodes_end = end;
  }
}
// @__NO_SIDE_EFFECTS__
function from_html(content, flags) {
  var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
  var use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;
  var node;
  var has_start = !content.startsWith("<!>");
  return () => {
    if (node === void 0) {
      node = create_fragment_from_html(has_start ? content : "<!>" + content);
      if (!is_fragment) node = /** @type {Node} */
      /* @__PURE__ */ get_first_child(node);
    }
    var clone = (
      /** @type {TemplateNode} */
      use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
    );
    if (is_fragment) {
      var start2 = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ get_first_child(clone)
      );
      var end = (
        /** @type {TemplateNode} */
        clone.lastChild
      );
      assign_nodes(start2, end);
    } else {
      assign_nodes(clone, clone);
    }
    return clone;
  };
}
// @__NO_SIDE_EFFECTS__
function from_namespace(content, flags, ns2 = "svg") {
  var has_start = !content.startsWith("<!>");
  var wrapped = `<${ns2}>${has_start ? content : "<!>" + content}</${ns2}>`;
  var node;
  return () => {
    if (!node) {
      var fragment = (
        /** @type {DocumentFragment} */
        create_fragment_from_html(wrapped)
      );
      var root2 = (
        /** @type {Element} */
        /* @__PURE__ */ get_first_child(fragment)
      );
      {
        node = /** @type {Element} */
        /* @__PURE__ */ get_first_child(root2);
      }
    }
    var clone = (
      /** @type {TemplateNode} */
      node.cloneNode(true)
    );
    {
      assign_nodes(clone, clone);
    }
    return clone;
  };
}
// @__NO_SIDE_EFFECTS__
function from_svg(content, flags) {
  return /* @__PURE__ */ from_namespace(content, flags, "svg");
}
function text(value = "") {
  {
    var t2 = create_text(value + "");
    assign_nodes(t2, t2);
    return t2;
  }
}
function comment() {
  var frag = document.createDocumentFragment();
  var start2 = document.createComment("");
  var anchor = create_text();
  frag.append(start2, anchor);
  assign_nodes(start2, anchor);
  return frag;
}
function append(anchor, dom) {
  if (anchor === null) {
    return;
  }
  anchor.before(
    /** @type {Node} */
    dom
  );
}
function set_text(text2, value) {
  var str = value == null ? "" : typeof value === "object" ? value + "" : value;
  if (str !== (text2.__t ?? (text2.__t = text2.nodeValue))) {
    text2.__t = str;
    text2.nodeValue = str + "";
  }
}
function mount(component2, options) {
  return _mount(component2, options);
}
const document_listeners = /* @__PURE__ */ new Map();
function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
  init_operations();
  var registered_events = /* @__PURE__ */ new Set();
  var event_handle = (events2) => {
    for (var i2 = 0; i2 < events2.length; i2++) {
      var event_name = events2[i2];
      if (registered_events.has(event_name)) continue;
      registered_events.add(event_name);
      var passive = is_passive_event(event_name);
      target.addEventListener(event_name, handle_event_propagation, { passive });
      var n2 = document_listeners.get(event_name);
      if (n2 === void 0) {
        document.addEventListener(event_name, handle_event_propagation, { passive });
        document_listeners.set(event_name, 1);
      } else {
        document_listeners.set(event_name, n2 + 1);
      }
    }
  };
  event_handle(array_from(all_registered_events));
  root_event_handles.add(event_handle);
  var component2 = void 0;
  var unmount2 = component_root(() => {
    var anchor_node = anchor ?? target.appendChild(create_text());
    branch(() => {
      if (context) {
        push({});
        var ctx = (
          /** @type {ComponentContext} */
          component_context
        );
        ctx.c = context;
      }
      if (events) {
        props.$$events = events;
      }
      component2 = Component(anchor_node, props) || {};
      if (context) {
        pop();
      }
    });
    return () => {
      var _a3;
      for (var event_name of registered_events) {
        target.removeEventListener(event_name, handle_event_propagation);
        var n2 = (
          /** @type {number} */
          document_listeners.get(event_name)
        );
        if (--n2 === 0) {
          document.removeEventListener(event_name, handle_event_propagation);
          document_listeners.delete(event_name);
        } else {
          document_listeners.set(event_name, n2);
        }
      }
      root_event_handles.delete(event_handle);
      if (anchor_node !== anchor) {
        (_a3 = anchor_node.parentNode) == null ? void 0 : _a3.removeChild(anchor_node);
      }
    };
  });
  mounted_components.set(component2, unmount2);
  return component2;
}
let mounted_components = /* @__PURE__ */ new WeakMap();
function unmount(component2, options) {
  const fn2 = mounted_components.get(component2);
  if (fn2) {
    mounted_components.delete(component2);
    return fn2(options);
  }
  return Promise.resolve();
}
const PENDING = 0;
const THEN = 1;
const CATCH = 2;
function await_block(node, get_input, pending_fn, then_fn, catch_fn) {
  var anchor = node;
  var runes = is_runes();
  var active_component_context = component_context;
  var input = UNINITIALIZED;
  var pending_effect;
  var then_effect;
  var catch_effect;
  var input_source = runes ? source(
    /** @type {V} */
    void 0
  ) : /* @__PURE__ */ mutable_source(
    /** @type {V} */
    void 0,
    false,
    false
  );
  var error_source = runes ? source(void 0) : /* @__PURE__ */ mutable_source(void 0, false, false);
  var resolved = false;
  function update(state2, restore) {
    resolved = true;
    if (restore) {
      set_active_effect(effect2);
      set_active_reaction(effect2);
      set_component_context(active_component_context);
    }
    try {
      if (state2 === PENDING && pending_fn) {
        if (pending_effect) resume_effect(pending_effect);
        else pending_effect = branch(() => pending_fn(anchor));
      }
      if (state2 === THEN && then_fn) {
        if (then_effect) resume_effect(then_effect);
        else then_effect = branch(() => then_fn(anchor, input_source));
      }
      if (state2 === CATCH && catch_fn) ;
      if (state2 !== PENDING && pending_effect) {
        pause_effect(pending_effect, () => pending_effect = null);
      }
      if (state2 !== THEN && then_effect) {
        pause_effect(then_effect, () => then_effect = null);
      }
      if (state2 !== CATCH && catch_effect) {
        pause_effect(catch_effect, () => catch_effect = null);
      }
    } finally {
      if (restore) {
        set_component_context(null);
        set_active_reaction(null);
        set_active_effect(null);
        flushSync();
      }
    }
  }
  var effect2 = block(() => {
    if (input === (input = get_input())) return;
    if (is_promise(input)) {
      var promise = input;
      resolved = false;
      promise.then(
        (value) => {
          if (promise !== input) return;
          internal_set(input_source, value);
          update(THEN, true);
        },
        (error) => {
          if (promise !== input) return;
          internal_set(error_source, error);
          update(CATCH, true);
          {
            throw error_source.v;
          }
        }
      );
      {
        queue_micro_task(() => {
          if (!resolved) update(PENDING, true);
        });
      }
    } else {
      internal_set(input_source, input);
      update(THEN, false);
    }
    return () => input = UNINITIALIZED;
  });
}
function if_block(node, fn2, elseif = false) {
  var anchor = node;
  var consequent_effect = null;
  var alternate_effect = null;
  var condition = UNINITIALIZED;
  var flags = elseif ? EFFECT_TRANSPARENT : 0;
  var has_branch = false;
  const set_branch = (fn3, flag = true) => {
    has_branch = true;
    update_branch(flag, fn3);
  };
  var offscreen_fragment = null;
  function commit() {
    if (offscreen_fragment !== null) {
      offscreen_fragment.lastChild.remove();
      anchor.before(offscreen_fragment);
      offscreen_fragment = null;
    }
    var active = condition ? consequent_effect : alternate_effect;
    var inactive = condition ? alternate_effect : consequent_effect;
    if (active) {
      resume_effect(active);
    }
    if (inactive) {
      pause_effect(inactive, () => {
        if (condition) {
          alternate_effect = null;
        } else {
          consequent_effect = null;
        }
      });
    }
  }
  const update_branch = (new_condition, fn3) => {
    if (condition === (condition = new_condition)) return;
    var defer = should_defer_append();
    var target = anchor;
    if (defer) {
      offscreen_fragment = document.createDocumentFragment();
      offscreen_fragment.append(target = create_text());
    }
    if (condition) {
      consequent_effect ?? (consequent_effect = fn3 && branch(() => fn3(target)));
    } else {
      alternate_effect ?? (alternate_effect = fn3 && branch(() => fn3(target)));
    }
    if (defer) {
      var batch = (
        /** @type {Batch} */
        current_batch
      );
      var active = condition ? consequent_effect : alternate_effect;
      var inactive = condition ? alternate_effect : consequent_effect;
      if (active) batch.skipped_effects.delete(active);
      if (inactive) batch.skipped_effects.add(inactive);
      batch.add_callback(commit);
    } else {
      commit();
    }
  };
  block(() => {
    has_branch = false;
    fn2(set_branch);
    if (!has_branch) {
      update_branch(null, null);
    }
  }, flags);
}
function key(node, get_key, render_fn) {
  var anchor = node;
  var key2 = UNINITIALIZED;
  var effect2;
  var pending_effect;
  var offscreen_fragment = null;
  var changed = is_runes() ? not_equal : safe_not_equal;
  function commit() {
    if (effect2) {
      pause_effect(effect2);
    }
    if (offscreen_fragment !== null) {
      offscreen_fragment.lastChild.remove();
      anchor.before(offscreen_fragment);
      offscreen_fragment = null;
    }
    effect2 = pending_effect;
  }
  block(() => {
    if (changed(key2, key2 = get_key())) {
      var target = anchor;
      var defer = should_defer_append();
      if (defer) {
        offscreen_fragment = document.createDocumentFragment();
        offscreen_fragment.append(target = create_text());
      }
      pending_effect = branch(() => render_fn(target));
      if (defer) {
        current_batch.add_callback(commit);
      } else {
        commit();
      }
    }
  });
}
function index(_2, i2) {
  return i2;
}
function pause_effects(state2, items, controlled_anchor) {
  var items_map = state2.items;
  var transitions = [];
  var length = items.length;
  for (var i2 = 0; i2 < length; i2++) {
    pause_children(items[i2].e, transitions, true);
  }
  var is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;
  if (is_controlled) {
    var parent_node = (
      /** @type {Element} */
      /** @type {Element} */
      controlled_anchor.parentNode
    );
    clear_text_content(parent_node);
    parent_node.append(
      /** @type {Element} */
      controlled_anchor
    );
    items_map.clear();
    link(state2, items[0].prev, items[length - 1].next);
  }
  run_out_transitions(transitions, () => {
    for (var i3 = 0; i3 < length; i3++) {
      var item = items[i3];
      if (!is_controlled) {
        items_map.delete(item.k);
        link(state2, item.prev, item.next);
      }
      destroy_effect(item.e, !is_controlled);
    }
  });
}
function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {
  var anchor = node;
  var state2 = { flags, items: /* @__PURE__ */ new Map(), first: null };
  var is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;
  if (is_controlled) {
    var parent_node = (
      /** @type {Element} */
      node
    );
    anchor = parent_node.appendChild(create_text());
  }
  var fallback = null;
  var was_empty = false;
  var offscreen_items = /* @__PURE__ */ new Map();
  var each_array = /* @__PURE__ */ derived_safe_equal(() => {
    var collection = get_collection();
    return is_array(collection) ? collection : collection == null ? [] : array_from(collection);
  });
  var array;
  var each_effect;
  function commit() {
    reconcile(
      each_effect,
      array,
      state2,
      offscreen_items,
      anchor,
      render_fn,
      flags,
      get_key,
      get_collection
    );
    if (fallback_fn !== null) {
      if (array.length === 0) {
        if (fallback) {
          resume_effect(fallback);
        } else {
          fallback = branch(() => fallback_fn(anchor));
        }
      } else if (fallback !== null) {
        pause_effect(fallback, () => {
          fallback = null;
        });
      }
    }
  }
  block(() => {
    each_effect ?? (each_effect = /** @type {Effect} */
    active_effect);
    array = get$1(each_array);
    var length = array.length;
    if (was_empty && length === 0) {
      return;
    }
    was_empty = length === 0;
    var item, i2, value, key2;
    {
      if (should_defer_append()) {
        var keys2 = /* @__PURE__ */ new Set();
        var batch = (
          /** @type {Batch} */
          current_batch
        );
        for (i2 = 0; i2 < length; i2 += 1) {
          value = array[i2];
          key2 = get_key(value, i2);
          var existing = state2.items.get(key2) ?? offscreen_items.get(key2);
          if (existing) {
            if ((flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0) {
              update_item(existing, value, i2, flags);
            }
          } else {
            item = create_item(
              null,
              state2,
              null,
              null,
              value,
              key2,
              i2,
              render_fn,
              flags,
              get_collection,
              true
            );
            offscreen_items.set(key2, item);
          }
          keys2.add(key2);
        }
        for (const [key3, item2] of state2.items) {
          if (!keys2.has(key3)) {
            batch.skipped_effects.add(item2.e);
          }
        }
        batch.add_callback(commit);
      } else {
        commit();
      }
    }
    get$1(each_array);
  });
}
function reconcile(each_effect, array, state2, offscreen_items, anchor, render_fn, flags, get_key, get_collection) {
  var _a3, _b3, _c2, _d2;
  var is_animated = (flags & EACH_IS_ANIMATED) !== 0;
  var should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;
  var length = array.length;
  var items = state2.items;
  var first = state2.first;
  var current = first;
  var seen2;
  var prev = null;
  var to_animate;
  var matched = [];
  var stashed = [];
  var value;
  var key2;
  var item;
  var i2;
  if (is_animated) {
    for (i2 = 0; i2 < length; i2 += 1) {
      value = array[i2];
      key2 = get_key(value, i2);
      item = items.get(key2);
      if (item !== void 0) {
        (_a3 = item.a) == null ? void 0 : _a3.measure();
        (to_animate ?? (to_animate = /* @__PURE__ */ new Set())).add(item);
      }
    }
  }
  for (i2 = 0; i2 < length; i2 += 1) {
    value = array[i2];
    key2 = get_key(value, i2);
    item = items.get(key2);
    if (item === void 0) {
      var pending = offscreen_items.get(key2);
      if (pending !== void 0) {
        offscreen_items.delete(key2);
        items.set(key2, pending);
        var next = prev ? prev.next : current;
        link(state2, prev, pending);
        link(state2, pending, next);
        move(pending, next, anchor);
        prev = pending;
      } else {
        var child_anchor = current ? (
          /** @type {TemplateNode} */
          current.e.nodes_start
        ) : anchor;
        prev = create_item(
          child_anchor,
          state2,
          prev,
          prev === null ? state2.first : prev.next,
          value,
          key2,
          i2,
          render_fn,
          flags,
          get_collection
        );
      }
      items.set(key2, prev);
      matched = [];
      stashed = [];
      current = prev.next;
      continue;
    }
    if (should_update) {
      update_item(item, value, i2, flags);
    }
    if ((item.e.f & INERT) !== 0) {
      resume_effect(item.e);
      if (is_animated) {
        (_b3 = item.a) == null ? void 0 : _b3.unfix();
        (to_animate ?? (to_animate = /* @__PURE__ */ new Set())).delete(item);
      }
    }
    if (item !== current) {
      if (seen2 !== void 0 && seen2.has(item)) {
        if (matched.length < stashed.length) {
          var start2 = stashed[0];
          var j2;
          prev = start2.prev;
          var a2 = matched[0];
          var b2 = matched[matched.length - 1];
          for (j2 = 0; j2 < matched.length; j2 += 1) {
            move(matched[j2], start2, anchor);
          }
          for (j2 = 0; j2 < stashed.length; j2 += 1) {
            seen2.delete(stashed[j2]);
          }
          link(state2, a2.prev, b2.next);
          link(state2, prev, a2);
          link(state2, b2, start2);
          current = start2;
          prev = b2;
          i2 -= 1;
          matched = [];
          stashed = [];
        } else {
          seen2.delete(item);
          move(item, current, anchor);
          link(state2, item.prev, item.next);
          link(state2, item, prev === null ? state2.first : prev.next);
          link(state2, prev, item);
          prev = item;
        }
        continue;
      }
      matched = [];
      stashed = [];
      while (current !== null && current.k !== key2) {
        if ((current.e.f & INERT) === 0) {
          (seen2 ?? (seen2 = /* @__PURE__ */ new Set())).add(current);
        }
        stashed.push(current);
        current = current.next;
      }
      if (current === null) {
        continue;
      }
      item = current;
    }
    matched.push(item);
    prev = item;
    current = item.next;
  }
  if (current !== null || seen2 !== void 0) {
    var to_destroy = seen2 === void 0 ? [] : array_from(seen2);
    while (current !== null) {
      if ((current.e.f & INERT) === 0) {
        to_destroy.push(current);
      }
      current = current.next;
    }
    var destroy_length = to_destroy.length;
    if (destroy_length > 0) {
      var controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;
      if (is_animated) {
        for (i2 = 0; i2 < destroy_length; i2 += 1) {
          (_c2 = to_destroy[i2].a) == null ? void 0 : _c2.measure();
        }
        for (i2 = 0; i2 < destroy_length; i2 += 1) {
          (_d2 = to_destroy[i2].a) == null ? void 0 : _d2.fix();
        }
      }
      pause_effects(state2, to_destroy, controlled_anchor);
    }
  }
  if (is_animated) {
    queue_micro_task(() => {
      var _a4;
      if (to_animate === void 0) return;
      for (item of to_animate) {
        (_a4 = item.a) == null ? void 0 : _a4.apply();
      }
    });
  }
  each_effect.first = state2.first && state2.first.e;
  each_effect.last = prev && prev.e;
  for (var unused of offscreen_items.values()) {
    destroy_effect(unused.e);
  }
  offscreen_items.clear();
}
function update_item(item, value, index2, type) {
  if ((type & EACH_ITEM_REACTIVE) !== 0) {
    internal_set(item.v, value);
  }
  if ((type & EACH_INDEX_REACTIVE) !== 0) {
    internal_set(
      /** @type {Value<number>} */
      item.i,
      index2
    );
  } else {
    item.i = index2;
  }
}
function create_item(anchor, state2, prev, next, value, key2, index2, render_fn, flags, get_collection, deferred2) {
  var reactive = (flags & EACH_ITEM_REACTIVE) !== 0;
  var mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;
  var v2 = reactive ? mutable ? /* @__PURE__ */ mutable_source(value, false, false) : source(value) : value;
  var i2 = (flags & EACH_INDEX_REACTIVE) === 0 ? index2 : source(index2);
  var item = {
    i: i2,
    v: v2,
    k: key2,
    a: null,
    // @ts-expect-error
    e: null,
    prev,
    next
  };
  try {
    if (anchor === null) {
      var fragment = document.createDocumentFragment();
      fragment.append(anchor = create_text());
    }
    item.e = branch(() => render_fn(
      /** @type {Node} */
      anchor,
      v2,
      i2,
      get_collection
    ), hydrating);
    item.e.prev = prev && prev.e;
    item.e.next = next && next.e;
    if (prev === null) {
      if (!deferred2) {
        state2.first = item;
      }
    } else {
      prev.next = item;
      prev.e.next = item.e;
    }
    if (next !== null) {
      next.prev = item;
      next.e.prev = item.e;
    }
    return item;
  } finally {
  }
}
function move(item, next, anchor) {
  var end = item.next ? (
    /** @type {TemplateNode} */
    item.next.e.nodes_start
  ) : anchor;
  var dest = next ? (
    /** @type {TemplateNode} */
    next.e.nodes_start
  ) : anchor;
  var node = (
    /** @type {TemplateNode} */
    item.e.nodes_start
  );
  while (node !== null && node !== end) {
    var next_node = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ get_next_sibling(node)
    );
    dest.before(node);
    node = next_node;
  }
}
function link(state2, prev, next) {
  if (prev === null) {
    state2.first = next;
  } else {
    prev.next = next;
    prev.e.next = next && next.e;
  }
  if (next !== null) {
    next.prev = prev;
    next.e.prev = prev && prev.e;
  }
}
function html(node, get_value, svg = false, mathml = false, skip_warning = false) {
  var anchor = node;
  var value = "";
  template_effect(() => {
    var effect2 = (
      /** @type {Effect} */
      active_effect
    );
    if (value === (value = get_value() ?? "")) {
      return;
    }
    if (effect2.nodes_start !== null) {
      remove_effect_dom(
        effect2.nodes_start,
        /** @type {TemplateNode} */
        effect2.nodes_end
      );
      effect2.nodes_start = effect2.nodes_end = null;
    }
    if (value === "") return;
    var html2 = value + "";
    if (svg) html2 = `<svg>${html2}</svg>`;
    else if (mathml) html2 = `<math>${html2}</math>`;
    var node2 = create_fragment_from_html(html2);
    if (svg || mathml) {
      node2 = /** @type {Element} */
      /* @__PURE__ */ get_first_child(node2);
    }
    assign_nodes(
      /** @type {TemplateNode} */
      /* @__PURE__ */ get_first_child(node2),
      /** @type {TemplateNode} */
      node2.lastChild
    );
    if (svg || mathml) {
      while (/* @__PURE__ */ get_first_child(node2)) {
        anchor.before(
          /** @type {Node} */
          /* @__PURE__ */ get_first_child(node2)
        );
      }
    } else {
      anchor.before(node2);
    }
  });
}
function slot(anchor, $$props, name, slot_props, fallback_fn) {
  var _a3;
  var slot_fn = (_a3 = $$props.$$slots) == null ? void 0 : _a3[name];
  var is_interop = false;
  if (slot_fn === true) {
    slot_fn = $$props["children"];
    is_interop = true;
  }
  if (slot_fn === void 0) ;
  else {
    slot_fn(anchor, is_interop ? () => slot_props : slot_props);
  }
}
function snippet(node, get_snippet, ...args) {
  var anchor = node;
  var snippet2 = noop$1;
  var snippet_effect;
  block(() => {
    if (snippet2 === (snippet2 = get_snippet())) return;
    if (snippet_effect) {
      destroy_effect(snippet_effect);
      snippet_effect = null;
    }
    snippet_effect = branch(() => (
      /** @type {SnippetFn} */
      snippet2(anchor, ...args)
    ));
  }, EFFECT_TRANSPARENT);
}
function component(node, get_component, render_fn) {
  var anchor = node;
  var component2;
  var effect2;
  var offscreen_fragment = null;
  var pending_effect = null;
  function commit() {
    if (effect2) {
      pause_effect(effect2);
      effect2 = null;
    }
    if (offscreen_fragment) {
      offscreen_fragment.lastChild.remove();
      anchor.before(offscreen_fragment);
      offscreen_fragment = null;
    }
    effect2 = pending_effect;
    pending_effect = null;
  }
  block(() => {
    if (component2 === (component2 = get_component())) return;
    var defer = should_defer_append();
    if (component2) {
      var target = anchor;
      if (defer) {
        offscreen_fragment = document.createDocumentFragment();
        offscreen_fragment.append(target = create_text());
      }
      pending_effect = branch(() => render_fn(target, component2));
    }
    if (defer) {
      current_batch.add_callback(commit);
    } else {
      commit();
    }
  }, EFFECT_TRANSPARENT);
}
function element(node, get_tag, is_svg, render_fn, get_namespace, location) {
  var tag;
  var current_tag;
  var element2 = null;
  var anchor = (
    /** @type {TemplateNode} */
    node
  );
  var effect2;
  block(() => {
    const next_tag = get_tag() || null;
    var ns2 = next_tag === "svg" ? NAMESPACE_SVG : null;
    if (next_tag === tag) return;
    if (effect2) {
      if (next_tag === null) {
        pause_effect(effect2, () => {
          effect2 = null;
          current_tag = null;
        });
      } else if (next_tag === current_tag) {
        resume_effect(effect2);
      } else {
        destroy_effect(effect2);
      }
    }
    if (next_tag && next_tag !== current_tag) {
      effect2 = branch(() => {
        element2 = ns2 ? document.createElementNS(ns2, next_tag) : document.createElement(next_tag);
        assign_nodes(element2, element2);
        if (render_fn) {
          var child_anchor = (
            /** @type {TemplateNode} */
            element2.appendChild(create_text())
          );
          render_fn(element2, child_anchor);
        }
        active_effect.nodes_end = element2;
        anchor.before(element2);
      });
    }
    tag = next_tag;
    if (tag) current_tag = tag;
  }, EFFECT_TRANSPARENT);
}
function append_styles$1(anchor, css) {
  effect(() => {
    var root2 = anchor.getRootNode();
    var target = (
      /** @type {ShadowRoot} */
      root2.host ? (
        /** @type {ShadowRoot} */
        root2
      ) : (
        /** @type {Document} */
        root2.head ?? /** @type {Document} */
        root2.ownerDocument.head
      )
    );
    if (!target.querySelector("#" + css.hash)) {
      const style = document.createElement("style");
      style.id = css.hash;
      style.textContent = css.code;
      target.appendChild(style);
    }
  });
}
function action(dom, action2, get_value) {
  effect(() => {
    var payload = untrack(() => action2(dom, get_value == null ? void 0 : get_value()) || {});
    if (get_value && (payload == null ? void 0 : payload.update)) {
      var inited = false;
      var prev = (
        /** @type {any} */
        {}
      );
      render_effect(() => {
        var value = get_value();
        deep_read_state(value);
        if (inited && safe_not_equal(prev, value)) {
          prev = value;
          payload.update(value);
        }
      });
      inited = true;
    }
    if (payload == null ? void 0 : payload.destroy) {
      return () => (
        /** @type {Function} */
        payload.destroy()
      );
    }
  });
}
function attach(node, get_fn) {
  var fn2 = void 0;
  var e2;
  block(() => {
    if (fn2 !== (fn2 = get_fn())) {
      if (e2) {
        destroy_effect(e2);
        e2 = null;
      }
      if (fn2) {
        e2 = branch(() => {
          effect(() => (
            /** @type {(node: Element) => void} */
            fn2(node)
          ));
        });
      }
    }
  });
}
function r$1(e2) {
  var t2, f2, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2) n2 += e2;
  else if ("object" == typeof e2) if (Array.isArray(e2)) {
    var o2 = e2.length;
    for (t2 = 0; t2 < o2; t2++) e2[t2] && (f2 = r$1(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
  } else for (f2 in e2) e2[f2] && (n2 && (n2 += " "), n2 += f2);
  return n2;
}
function clsx$1() {
  for (var e2, t2, f2 = 0, n2 = "", o2 = arguments.length; f2 < o2; f2++) (e2 = arguments[f2]) && (t2 = r$1(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
function clsx(value) {
  if (typeof value === "object") {
    return clsx$1(value);
  } else {
    return value ?? "";
  }
}
const whitespace = [..." 	\n\r\f \v\uFEFF"];
function to_class(value, hash2, directives) {
  var classname = value == null ? "" : "" + value;
  if (hash2) {
    classname = classname ? classname + " " + hash2 : hash2;
  }
  if (directives) {
    for (var key2 in directives) {
      if (directives[key2]) {
        classname = classname ? classname + " " + key2 : key2;
      } else if (classname.length) {
        var len = key2.length;
        var a2 = 0;
        while ((a2 = classname.indexOf(key2, a2)) >= 0) {
          var b2 = a2 + len;
          if ((a2 === 0 || whitespace.includes(classname[a2 - 1])) && (b2 === classname.length || whitespace.includes(classname[b2]))) {
            classname = (a2 === 0 ? "" : classname.substring(0, a2)) + classname.substring(b2 + 1);
          } else {
            a2 = b2;
          }
        }
      }
    }
  }
  return classname === "" ? null : classname;
}
function append_styles(styles, important = false) {
  var separator = important ? " !important;" : ";";
  var css = "";
  for (var key2 in styles) {
    var value = styles[key2];
    if (value != null && value !== "") {
      css += " " + key2 + ": " + value + separator;
    }
  }
  return css;
}
function to_css_name(name) {
  if (name[0] !== "-" || name[1] !== "-") {
    return name.toLowerCase();
  }
  return name;
}
function to_style(value, styles) {
  if (styles) {
    var new_style = "";
    var normal_styles;
    var important_styles;
    if (Array.isArray(styles)) {
      normal_styles = styles[0];
      important_styles = styles[1];
    } else {
      normal_styles = styles;
    }
    if (value) {
      value = String(value).replaceAll(/\s*\/\*.*?\*\/\s*/g, "").trim();
      var in_str = false;
      var in_apo = 0;
      var in_comment = false;
      var reserved_names = [];
      if (normal_styles) {
        reserved_names.push(...Object.keys(normal_styles).map(to_css_name));
      }
      if (important_styles) {
        reserved_names.push(...Object.keys(important_styles).map(to_css_name));
      }
      var start_index = 0;
      var name_index = -1;
      const len = value.length;
      for (var i2 = 0; i2 < len; i2++) {
        var c2 = value[i2];
        if (in_comment) {
          if (c2 === "/" && value[i2 - 1] === "*") {
            in_comment = false;
          }
        } else if (in_str) {
          if (in_str === c2) {
            in_str = false;
          }
        } else if (c2 === "/" && value[i2 + 1] === "*") {
          in_comment = true;
        } else if (c2 === '"' || c2 === "'") {
          in_str = c2;
        } else if (c2 === "(") {
          in_apo++;
        } else if (c2 === ")") {
          in_apo--;
        }
        if (!in_comment && in_str === false && in_apo === 0) {
          if (c2 === ":" && name_index === -1) {
            name_index = i2;
          } else if (c2 === ";" || i2 === len - 1) {
            if (name_index !== -1) {
              var name = to_css_name(value.substring(start_index, name_index).trim());
              if (!reserved_names.includes(name)) {
                if (c2 !== ";") {
                  i2++;
                }
                var property2 = value.substring(start_index, i2).trim();
                new_style += " " + property2 + ";";
              }
            }
            start_index = i2 + 1;
            name_index = -1;
          }
        }
      }
    }
    if (normal_styles) {
      new_style += append_styles(normal_styles);
    }
    if (important_styles) {
      new_style += append_styles(important_styles, true);
    }
    new_style = new_style.trim();
    return new_style === "" ? null : new_style;
  }
  return value == null ? null : String(value);
}
function set_class(dom, is_html, value, hash2, prev_classes, next_classes) {
  var prev = dom.__className;
  if (prev !== value || prev === void 0) {
    var next_class_name = to_class(value, hash2, next_classes);
    {
      if (next_class_name == null) {
        dom.removeAttribute("class");
      } else if (is_html) {
        dom.className = next_class_name;
      } else {
        dom.setAttribute("class", next_class_name);
      }
    }
    dom.__className = value;
  } else if (next_classes && prev_classes !== next_classes) {
    for (var key2 in next_classes) {
      var is_present = !!next_classes[key2];
      if (prev_classes == null || is_present !== !!prev_classes[key2]) {
        dom.classList.toggle(key2, is_present);
      }
    }
  }
  return next_classes;
}
function update_styles(dom, prev = {}, next, priority) {
  for (var key2 in next) {
    var value = next[key2];
    if (prev[key2] !== value) {
      if (next[key2] == null) {
        dom.style.removeProperty(key2);
      } else {
        dom.style.setProperty(key2, value, priority);
      }
    }
  }
}
function set_style(dom, value, prev_styles, next_styles) {
  var prev = dom.__style;
  if (prev !== value) {
    var next_style_attr = to_style(value, next_styles);
    {
      if (next_style_attr == null) {
        dom.removeAttribute("style");
      } else {
        dom.style.cssText = next_style_attr;
      }
    }
    dom.__style = value;
  } else if (next_styles) {
    if (Array.isArray(next_styles)) {
      update_styles(dom, prev_styles == null ? void 0 : prev_styles[0], next_styles[0]);
      update_styles(dom, prev_styles == null ? void 0 : prev_styles[1], next_styles[1], "important");
    } else {
      update_styles(dom, prev_styles, next_styles);
    }
  }
  return next_styles;
}
function select_option(select, value, mounting = false) {
  if (select.multiple) {
    if (value == void 0) {
      return;
    }
    if (!is_array(value)) {
      return select_multiple_invalid_value();
    }
    for (var option of select.options) {
      option.selected = value.includes(get_option_value(option));
    }
    return;
  }
  for (option of select.options) {
    var option_value = get_option_value(option);
    if (is(option_value, value)) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function init_select(select) {
  var observer = new MutationObserver(() => {
    select_option(select, select.__value);
  });
  observer.observe(select, {
    // Listen to option element changes
    childList: true,
    subtree: true,
    // because of <optgroup>
    // Listen to option element value attribute changes
    // (doesn't get notified of select value changes,
    // because that property is not reflected as an attribute)
    attributes: true,
    attributeFilter: ["value"]
  });
  teardown(() => {
    observer.disconnect();
  });
}
function get_option_value(option) {
  if ("__value" in option) {
    return option.__value;
  } else {
    return option.value;
  }
}
const CLASS = Symbol("class");
const STYLE = Symbol("style");
const IS_CUSTOM_ELEMENT = Symbol("is custom element");
const IS_HTML = Symbol("is html");
function set_selected(element2, selected) {
  if (selected) {
    if (!element2.hasAttribute("selected")) {
      element2.setAttribute("selected", "");
    }
  } else {
    element2.removeAttribute("selected");
  }
}
function set_attribute(element2, attribute, value, skip_warning) {
  var attributes2 = get_attributes(element2);
  if (attributes2[attribute] === (attributes2[attribute] = value)) return;
  if (attribute === "loading") {
    element2[LOADING_ATTR_SYMBOL] = value;
  }
  if (value == null) {
    element2.removeAttribute(attribute);
  } else if (typeof value !== "string" && get_setters(element2).includes(attribute)) {
    element2[attribute] = value;
  } else {
    element2.setAttribute(attribute, value);
  }
}
function set_attributes(element2, prev, next, css_hash, skip_warning = false) {
  var attributes2 = get_attributes(element2);
  var is_custom_element = attributes2[IS_CUSTOM_ELEMENT];
  var preserve_attribute_case = !attributes2[IS_HTML];
  var current = prev || {};
  var is_option_element = element2.tagName === "OPTION";
  for (var key2 in prev) {
    if (!(key2 in next)) {
      next[key2] = null;
    }
  }
  if (next.class) {
    next.class = clsx(next.class);
  } else if (css_hash || next[CLASS]) {
    next.class = null;
  }
  if (next[STYLE]) {
    next.style ?? (next.style = null);
  }
  var setters = get_setters(element2);
  for (const key3 in next) {
    let value = next[key3];
    if (is_option_element && key3 === "value" && value == null) {
      element2.value = element2.__value = "";
      current[key3] = value;
      continue;
    }
    if (key3 === "class") {
      var is_html = element2.namespaceURI === "http://www.w3.org/1999/xhtml";
      set_class(element2, is_html, value, css_hash, prev == null ? void 0 : prev[CLASS], next[CLASS]);
      current[key3] = value;
      current[CLASS] = next[CLASS];
      continue;
    }
    if (key3 === "style") {
      set_style(element2, value, prev == null ? void 0 : prev[STYLE], next[STYLE]);
      current[key3] = value;
      current[STYLE] = next[STYLE];
      continue;
    }
    var prev_value = current[key3];
    if (value === prev_value && !(value === void 0 && element2.hasAttribute(key3))) {
      continue;
    }
    current[key3] = value;
    var prefix = key3[0] + key3[1];
    if (prefix === "$$") continue;
    if (prefix === "on") {
      const opts = {};
      const event_handle_key = "$$" + key3;
      let event_name = key3.slice(2);
      var delegated = is_delegated(event_name);
      if (is_capture_event(event_name)) {
        event_name = event_name.slice(0, -7);
        opts.capture = true;
      }
      if (!delegated && prev_value) {
        if (value != null) continue;
        element2.removeEventListener(event_name, current[event_handle_key], opts);
        current[event_handle_key] = null;
      }
      if (value != null) {
        if (!Array.isArray(element2.__cleanup)) {
          element2.__cleanup = [];
        }
        if (!delegated) {
          let handle = function(evt) {
            current[key3].call(this, evt);
          };
          current[event_handle_key] = create_event(event_name, element2, handle, opts);
          const cleanup = () => {
            element2.removeEventListener(event_name, handle, opts);
            Reflect.deleteProperty(current, event_handle_key);
            Reflect.deleteProperty(current, key3);
          };
          element2.__cleanup.push(cleanup);
        } else {
          element2[`__${event_name}`] = value;
          delegate([event_name]);
          const cleanup = () => {
            element2[`__${event_name}`] = void 0;
            Reflect.deleteProperty(current, key3);
          };
          element2.__cleanup.push(cleanup);
        }
      } else if (delegated) {
        element2[`__${event_name}`] = void 0;
      }
    } else if (key3 === "style") {
      set_attribute(element2, key3, value);
    } else if (key3 === "autofocus") {
      autofocus(
        /** @type {HTMLElement} */
        element2,
        Boolean(value)
      );
    } else if (!is_custom_element && (key3 === "__value" || key3 === "value" && value != null)) {
      element2.value = element2.__value = value;
    } else if (key3 === "selected" && is_option_element) {
      set_selected(
        /** @type {HTMLOptionElement} */
        element2,
        value
      );
    } else {
      var name = key3;
      if (!preserve_attribute_case) {
        name = normalize_attribute(name);
      }
      var is_default = name === "defaultValue" || name === "defaultChecked";
      if (value == null && !is_custom_element && !is_default) {
        attributes2[key3] = null;
        if (name === "value" || name === "checked") {
          let input = (
            /** @type {HTMLInputElement} */
            element2
          );
          const use_default = prev === void 0;
          if (name === "value") {
            let previous = input.defaultValue;
            input.removeAttribute(name);
            input.defaultValue = previous;
            input.value = input.__value = use_default ? previous : null;
          } else {
            let previous = input.defaultChecked;
            input.removeAttribute(name);
            input.defaultChecked = previous;
            input.checked = use_default ? previous : false;
          }
        } else {
          element2.removeAttribute(key3);
        }
      } else if (is_default || setters.includes(name) && (is_custom_element || typeof value !== "string")) {
        element2[name] = value;
        if (name in attributes2) attributes2[name] = UNINITIALIZED;
      } else if (typeof value !== "function") {
        set_attribute(element2, name, value);
      }
    }
  }
  return current;
}
function attribute_effect(element2, fn2, sync = [], async = [], css_hash, skip_warning = false) {
  flatten$1(sync, async, (values2) => {
    var prev = void 0;
    var effects = {};
    var is_select = element2.nodeName === "SELECT";
    var inited = false;
    block(() => {
      var next = fn2(...values2.map(get$1));
      var current = set_attributes(element2, prev, next, css_hash, skip_warning);
      if (inited && is_select && "value" in next) {
        select_option(
          /** @type {HTMLSelectElement} */
          element2,
          next.value
        );
      }
      for (let symbol of Object.getOwnPropertySymbols(effects)) {
        if (!next[symbol]) destroy_effect(effects[symbol]);
      }
      for (let symbol of Object.getOwnPropertySymbols(next)) {
        var n2 = next[symbol];
        if (symbol.description === ATTACHMENT_KEY && (!prev || n2 !== prev[symbol])) {
          if (effects[symbol]) destroy_effect(effects[symbol]);
          effects[symbol] = branch(() => attach(element2, () => n2));
        }
        current[symbol] = n2;
      }
      prev = current;
    });
    if (is_select) {
      var select = (
        /** @type {HTMLSelectElement} */
        element2
      );
      effect(() => {
        select_option(
          select,
          /** @type {Record<string | symbol, any>} */
          prev.value,
          true
        );
        init_select(select);
      });
    }
    inited = true;
  });
}
function get_attributes(element2) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    element2.__attributes ?? (element2.__attributes = {
      [IS_CUSTOM_ELEMENT]: element2.nodeName.includes("-"),
      [IS_HTML]: element2.namespaceURI === NAMESPACE_HTML
    })
  );
}
var setters_cache = /* @__PURE__ */ new Map();
function get_setters(element2) {
  var setters = setters_cache.get(element2.nodeName);
  if (setters) return setters;
  setters_cache.set(element2.nodeName, setters = []);
  var descriptors;
  var proto = element2;
  var element_proto = Element.prototype;
  while (element_proto !== proto) {
    descriptors = get_descriptors(proto);
    for (var key2 in descriptors) {
      if (descriptors[key2].set) {
        setters.push(key2);
      }
    }
    proto = get_prototype_of(proto);
  }
  return setters;
}
function is_bound_this(bound_value, element_or_component) {
  return bound_value === element_or_component || (bound_value == null ? void 0 : bound_value[STATE_SYMBOL]) === element_or_component;
}
function bind_this(element_or_component = {}, update, get_value, get_parts) {
  effect(() => {
    var old_parts;
    var parts;
    render_effect(() => {
      old_parts = parts;
      parts = [];
      untrack(() => {
        if (element_or_component !== get_value(...parts)) {
          update(element_or_component, ...parts);
          if (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {
            update(null, ...old_parts);
          }
        }
      });
    });
    return () => {
      queue_micro_task(() => {
        if (parts && is_bound_this(get_value(...parts), element_or_component)) {
          update(null, ...parts);
        }
      });
    };
  });
  return element_or_component;
}
function init(immutable = false) {
  const context = (
    /** @type {ComponentContextLegacy} */
    component_context
  );
  const callbacks = context.l.u;
  if (!callbacks) return;
  let props = () => deep_read_state(context.s);
  if (immutable) {
    let version = 0;
    let prev = (
      /** @type {Record<string, any>} */
      {}
    );
    const d3 = /* @__PURE__ */ derived$1(() => {
      let changed = false;
      const props2 = context.s;
      for (const key2 in props2) {
        if (props2[key2] !== prev[key2]) {
          prev[key2] = props2[key2];
          changed = true;
        }
      }
      if (changed) version++;
      return version;
    });
    props = () => get$1(d3);
  }
  if (callbacks.b.length) {
    user_pre_effect(() => {
      observe_all(context, props);
      run_all(callbacks.b);
    });
  }
  user_effect(() => {
    const fns = untrack(() => callbacks.m.map(run));
    return () => {
      for (const fn2 of fns) {
        if (typeof fn2 === "function") {
          fn2();
        }
      }
    };
  });
  if (callbacks.a.length) {
    user_effect(() => {
      observe_all(context, props);
      run_all(callbacks.a);
    });
  }
}
function observe_all(context, props) {
  if (context.l.s) {
    for (const signal of context.l.s) get$1(signal);
  }
  props();
}
let is_store_binding = false;
let IS_UNMOUNTED = Symbol();
function store_get(store, store_name, stores) {
  const entry = stores[store_name] ?? (stores[store_name] = {
    store: null,
    source: /* @__PURE__ */ mutable_source(void 0),
    unsubscribe: noop$1
  });
  if (entry.store !== store && !(IS_UNMOUNTED in stores)) {
    entry.unsubscribe();
    entry.store = store ?? null;
    if (store == null) {
      entry.source.v = void 0;
      entry.unsubscribe = noop$1;
    } else {
      var is_synchronous_callback = true;
      entry.unsubscribe = subscribe_to_store(store, (v2) => {
        if (is_synchronous_callback) {
          entry.source.v = v2;
        } else {
          set(entry.source, v2);
        }
      });
      is_synchronous_callback = false;
    }
  }
  if (store && IS_UNMOUNTED in stores) {
    return get(store);
  }
  return get$1(entry.source);
}
function store_set(store, value) {
  store.set(value);
  return value;
}
function setup_stores() {
  const stores = {};
  function cleanup() {
    teardown(() => {
      for (var store_name in stores) {
        const ref = stores[store_name];
        ref.unsubscribe();
      }
      define_property(stores, IS_UNMOUNTED, {
        enumerable: false,
        value: true
      });
    });
  }
  return [stores, cleanup];
}
function capture_store_binding(fn2) {
  var previous_is_store_binding = is_store_binding;
  try {
    is_store_binding = false;
    return [fn2(), is_store_binding];
  } finally {
    is_store_binding = previous_is_store_binding;
  }
}
const rest_props_handler = {
  get(target, key2) {
    if (target.exclude.includes(key2)) return;
    return target.props[key2];
  },
  set(target, key2) {
    return false;
  },
  getOwnPropertyDescriptor(target, key2) {
    if (target.exclude.includes(key2)) return;
    if (key2 in target.props) {
      return {
        enumerable: true,
        configurable: true,
        value: target.props[key2]
      };
    }
  },
  has(target, key2) {
    if (target.exclude.includes(key2)) return false;
    return key2 in target.props;
  },
  ownKeys(target) {
    return Reflect.ownKeys(target.props).filter((key2) => !target.exclude.includes(key2));
  }
};
// @__NO_SIDE_EFFECTS__
function rest_props(props, exclude2, name) {
  return new Proxy(
    { props, exclude: exclude2 },
    rest_props_handler
  );
}
const spread_props_handler = {
  get(target, key2) {
    let i2 = target.props.length;
    while (i2--) {
      let p2 = target.props[i2];
      if (is_function(p2)) p2 = p2();
      if (typeof p2 === "object" && p2 !== null && key2 in p2) return p2[key2];
    }
  },
  set(target, key2, value) {
    let i2 = target.props.length;
    while (i2--) {
      let p2 = target.props[i2];
      if (is_function(p2)) p2 = p2();
      const desc = get_descriptor(p2, key2);
      if (desc && desc.set) {
        desc.set(value);
        return true;
      }
    }
    return false;
  },
  getOwnPropertyDescriptor(target, key2) {
    let i2 = target.props.length;
    while (i2--) {
      let p2 = target.props[i2];
      if (is_function(p2)) p2 = p2();
      if (typeof p2 === "object" && p2 !== null && key2 in p2) {
        const descriptor = get_descriptor(p2, key2);
        if (descriptor && !descriptor.configurable) {
          descriptor.configurable = true;
        }
        return descriptor;
      }
    }
  },
  has(target, key2) {
    if (key2 === STATE_SYMBOL || key2 === LEGACY_PROPS) return false;
    for (let p2 of target.props) {
      if (is_function(p2)) p2 = p2();
      if (p2 != null && key2 in p2) return true;
    }
    return false;
  },
  ownKeys(target) {
    const keys2 = [];
    for (let p2 of target.props) {
      if (is_function(p2)) p2 = p2();
      if (!p2) continue;
      for (const key2 in p2) {
        if (!keys2.includes(key2)) keys2.push(key2);
      }
      for (const key2 of Object.getOwnPropertySymbols(p2)) {
        if (!keys2.includes(key2)) keys2.push(key2);
      }
    }
    return keys2;
  }
};
function spread_props(...props) {
  return new Proxy({ props }, spread_props_handler);
}
function prop(props, key2, flags, fallback) {
  var _a3;
  var runes = !legacy_mode_flag || (flags & PROPS_IS_RUNES) !== 0;
  var bindable = (flags & PROPS_IS_BINDABLE) !== 0;
  var lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;
  var fallback_value = (
    /** @type {V} */
    fallback
  );
  var fallback_dirty = true;
  var get_fallback = () => {
    if (fallback_dirty) {
      fallback_dirty = false;
      fallback_value = lazy ? untrack(
        /** @type {() => V} */
        fallback
      ) : (
        /** @type {V} */
        fallback
      );
    }
    return fallback_value;
  };
  var setter;
  if (bindable) {
    var is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;
    setter = ((_a3 = get_descriptor(props, key2)) == null ? void 0 : _a3.set) ?? (is_entry_props && key2 in props ? (v2) => props[key2] = v2 : void 0);
  }
  var initial_value;
  var is_store_sub = false;
  if (bindable) {
    [initial_value, is_store_sub] = capture_store_binding(() => (
      /** @type {V} */
      props[key2]
    ));
  } else {
    initial_value = /** @type {V} */
    props[key2];
  }
  if (initial_value === void 0 && fallback !== void 0) {
    initial_value = get_fallback();
    if (setter) {
      if (runes) props_invalid_value();
      setter(initial_value);
    }
  }
  var getter;
  if (runes) {
    getter = () => {
      var value = (
        /** @type {V} */
        props[key2]
      );
      if (value === void 0) return get_fallback();
      fallback_dirty = true;
      return value;
    };
  } else {
    getter = () => {
      var value = (
        /** @type {V} */
        props[key2]
      );
      if (value !== void 0) {
        fallback_value = /** @type {V} */
        void 0;
      }
      return value === void 0 ? fallback_value : value;
    };
  }
  if (runes && (flags & PROPS_IS_UPDATED) === 0) {
    return getter;
  }
  if (setter) {
    var legacy_parent = props.$$legacy;
    return function(value, mutation) {
      if (arguments.length > 0) {
        if (!runes || !mutation || legacy_parent || is_store_sub) {
          setter(mutation ? getter() : value);
        }
        return value;
      }
      return getter();
    };
  }
  var overridden = false;
  var d3 = ((flags & PROPS_IS_IMMUTABLE) !== 0 ? derived$1 : derived_safe_equal)(() => {
    overridden = false;
    return getter();
  });
  if (bindable) get$1(d3);
  var parent_effect = (
    /** @type {Effect} */
    active_effect
  );
  return function(value, mutation) {
    if (arguments.length > 0) {
      const new_value = mutation ? get$1(d3) : runes && bindable ? proxy$1(value) : value;
      set(d3, new_value);
      overridden = true;
      if (fallback_value !== void 0) {
        fallback_value = new_value;
      }
      return value;
    }
    if (is_destroying_effect && overridden || (parent_effect.f & DESTROYED) !== 0) {
      return d3.v;
    }
    return get$1(d3);
  };
}
function onMount(fn2) {
  if (component_context === null) {
    lifecycle_outside_component();
  }
  if (legacy_mode_flag && component_context.l !== null) {
    init_update_callbacks(component_context).m.push(fn2);
  } else {
    user_effect(() => {
      const cleanup = untrack(fn2);
      if (typeof cleanup === "function") return (
        /** @type {() => void} */
        cleanup
      );
    });
  }
}
function onDestroy(fn2) {
  if (component_context === null) {
    lifecycle_outside_component();
  }
  onMount(() => () => untrack(fn2));
}
function init_update_callbacks(context) {
  var l2 = (
    /** @type {ComponentContextLegacy} */
    context.l
  );
  return l2.u ?? (l2.u = { a: [], b: [], m: [] });
}
function subscribe_to_store(store, run2, invalidate) {
  if (store == null) {
    run2(void 0);
    if (invalidate) invalidate(void 0);
    return noop$1;
  }
  const unsub = untrack(
    () => store.subscribe(
      run2,
      // @ts-expect-error
      invalidate
    )
  );
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
const subscriber_queue = [];
function readable(value, start2) {
  return {
    subscribe: writable(value, start2).subscribe
  };
}
function writable(value, start2 = noop$1) {
  let stop = null;
  const subscribers = /* @__PURE__ */ new Set();
  function set2(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update(fn2) {
    set2(fn2(
      /** @type {T} */
      value
    ));
  }
  function subscribe(run2, invalidate = noop$1) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start2(set2, update) || noop$1;
    }
    run2(
      /** @type {T} */
      value
    );
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set: set2, update, subscribe };
}
function derived(stores, fn2, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  if (!stores_array.every(Boolean)) {
    throw new Error("derived() expects stores as input, got a falsy value");
  }
  const auto = fn2.length < 2;
  return readable(initial_value, (set2, update) => {
    let started = false;
    const values2 = [];
    let pending = 0;
    let cleanup = noop$1;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn2(single ? values2[0] : values2, set2, update);
      if (auto) {
        set2(result);
      } else {
        cleanup = typeof result === "function" ? result : noop$1;
      }
    };
    const unsubscribers = stores_array.map(
      (store, i2) => subscribe_to_store(
        store,
        (value) => {
          values2[i2] = value;
          pending &= ~(1 << i2);
          if (started) {
            sync();
          }
        },
        () => {
          pending |= 1 << i2;
        }
      )
    );
    started = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    };
  });
}
function get(store) {
  let value;
  subscribe_to_store(store, (_2) => value = _2)();
  return value;
}
const IConfigurationService = createDecorator$1("configurationService");
var MagnetMode = /* @__PURE__ */ ((MagnetMode2) => {
  MagnetMode2[MagnetMode2["Normal"] = 0] = "Normal";
  MagnetMode2[MagnetMode2["StrongMagnet"] = 1] = "StrongMagnet";
  MagnetMode2[MagnetMode2["WeakMagnet"] = 2] = "WeakMagnet";
  return MagnetMode2;
})(MagnetMode || {});
const DemoCursorMask = 1 << 6;
const EraserCursorMask = 1 << 5;
var PaneCursor = /* @__PURE__ */ ((PaneCursor2) => {
  PaneCursor2[PaneCursor2["unset"] = 0] = "unset";
  PaneCursor2[
    PaneCursor2["cross"] = 0
    /* unset */
  ] = "cross";
  PaneCursor2[PaneCursor2["dot"] = 1] = "dot";
  PaneCursor2[PaneCursor2["pointer"] = 2] = "pointer";
  PaneCursor2[PaneCursor2["arrow"] = 3] = "arrow";
  PaneCursor2[PaneCursor2["grabbing"] = 4] = "grabbing";
  PaneCursor2[PaneCursor2["ew"] = 5] = "ew";
  PaneCursor2[PaneCursor2["ns"] = 6] = "ns";
  PaneCursor2[PaneCursor2["nesw"] = 7] = "nesw";
  PaneCursor2[PaneCursor2["nwse"] = 8] = "nwse";
  PaneCursor2[PaneCursor2["text"] = 9] = "text";
  PaneCursor2[PaneCursor2["zoomIn"] = 10] = "zoomIn";
  PaneCursor2[PaneCursor2["eraser"] = EraserCursorMask] = "eraser";
  PaneCursor2[PaneCursor2["demonstration"] = DemoCursorMask] = "demonstration";
  return PaneCursor2;
})(PaneCursor || {});
function showDemoCursor(num) {
  return (num & DemoCursorMask) !== 0;
}
function showCursor(num, p2) {
  if (p2 === PaneCursor.demonstration) return showDemoCursor(num);
  const mask = -65;
  return (num & mask) === p2;
}
function getCursorString(p2) {
  if (showCursor(p2, PaneCursor.eraser) && p2 !== PaneCursor.eraser) {
    p2 = PaneCursor.eraser;
  }
  return PaneCursor[p2];
}
const IDatafeedService = createDecorator$1("datafeedService");
const shortcutEvent = Object.freeze(function(callback, context) {
  const handle = setTimeout(callback.bind(context), 0);
  return {
    dispose() {
      clearTimeout(handle);
    }
  };
});
const NoneToken = Object.freeze({
  isCancellationRequested: false,
  onCancellationRequested: NoneEvent
});
const CancelledToken = Object.freeze({
  isCancellationRequested: true,
  onCancellationRequested: shortcutEvent
});
class MutableToken {
  constructor() {
    __publicField(this, "_isCancelled", false);
    __publicField(this, "_emitter", null);
  }
  cancel() {
    if (!this._isCancelled) {
      this._isCancelled = true;
      if (this._emitter) {
        this._emitter.fire(void 0);
        this.dispose();
      }
    }
  }
  get isCancellationRequested() {
    return this._isCancelled;
  }
  get onCancellationRequested() {
    if (this._isCancelled) {
      return shortcutEvent;
    }
    if (!this._emitter) {
      this._emitter = new Emitter();
    }
    return this._emitter.event;
  }
  dispose() {
    if (this._emitter) {
      this._emitter.dispose();
      this._emitter = null;
    }
  }
}
class CancellationTokenSource {
  constructor(parent2) {
    __publicField(this, "_token");
    __publicField(this, "_parentListener");
    this._parentListener = parent2 && parent2.onCancellationRequested(this.cancel, this);
  }
  get token() {
    if (!this._token) {
      this._token = new MutableToken();
    }
    return this._token;
  }
  cancel() {
    if (!this._token) {
      this._token = CancelledToken;
    } else if (this._token instanceof MutableToken) {
      this._token.cancel();
    }
  }
  dispose(cancel = false) {
    var _a3;
    if (cancel) {
      this.cancel();
    }
    (_a3 = this._parentListener) == null ? void 0 : _a3.dispose();
    if (!this._token) {
      this._token = NoneToken;
    } else if (this._token instanceof MutableToken) {
      this._token.dispose();
    }
  }
}
var extendStatics = function(d3, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
    d4.__proto__ = b3;
  } || function(d4, b3) {
    for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d4[p2] = b3[p2];
  };
  return extendStatics(d3, b2);
};
function __extends(d3, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d3, b2);
  function __() {
    this.constructor = d3;
  }
  d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2) return m2.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i2 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i2++], done: !o2 };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message2) {
  var e2 = new Error(message2);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
};
function isFunction(value) {
  return typeof value === "function";
}
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
      return i2 + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});
function arrRemove(arr, item) {
  if (arr) {
    var index2 = arr.indexOf(item);
    0 <= index2 && arr.splice(index2, 1);
  }
}
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a3, e_2, _b3;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a3 = _parentage_1.return)) _a3.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e2) {
          errors = e2 instanceof UnsubscriptionError ? e2.errors : [e2];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer2 = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer2);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b3 = _finalizers_1.return)) _b3.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown2) {
    var _a3;
    if (teardown2 && teardown2 !== this) {
      if (this.closed) {
        execFinalizer(teardown2);
      } else {
        if (teardown2 instanceof Subscription2) {
          if (teardown2.closed || teardown2._hasParent(this)) {
            return;
          }
          teardown2._addParent(this);
        }
        (this._finalizers = (_a3 = this._finalizers) !== null && _a3 !== void 0 ? _a3 : []).push(teardown2);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent2) {
    var _parentage = this._parentage;
    return _parentage === parent2 || Array.isArray(_parentage) && _parentage.includes(parent2);
  };
  Subscription2.prototype._addParent = function(parent2) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent2), _parentage) : _parentage ? [_parentage, parent2] : parent2;
  };
  Subscription2.prototype._removeParent = function(parent2) {
    var _parentage = this._parentage;
    if (_parentage === parent2) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent2);
    }
  };
  Subscription2.prototype.remove = function(teardown2) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown2);
    if (teardown2 instanceof Subscription2) {
      teardown2._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty = new Subscription2();
    empty.closed = true;
    return empty;
  }();
  return Subscription2;
}();
Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer2) {
  if (isFunction(finalizer2)) {
    finalizer2();
  } else {
    finalizer2.unsubscribe();
  }
}
var config = {
  Promise: void 0
};
var timeoutProvider = {
  setTimeout: function(handler, timeout) {
    var args = [];
    for (var _i2 = 2; _i2 < arguments.length; _i2++) {
      args[_i2 - 2] = arguments[_i2];
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearTimeout: function(handle) {
    return clearTimeout(handle);
  },
  delegate: void 0
};
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    {
      throw err;
    }
  });
}
function noop() {
}
function errorContext(cb) {
  {
    cb();
  }
}
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) ;
    else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) ;
    else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) ;
    else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
function identity(x2) {
  return x2;
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn2) {
      return fn2(prev);
    }, input);
  };
}
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a3 = _this, operator = _a3.operator, source2 = _a3.source;
      subscriber.add(operator ? operator.call(subscriber, source2) : source2 ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a3;
    return (_a3 = this.source) === null || _a3 === void 0 ? void 0 : _a3.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      operations[_i2] = arguments[_i2];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x2) {
        return value = x2;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a3;
  return (_a3 = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a3 !== void 0 ? _a3 : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}
function hasLift(source2) {
  return isFunction(source2 === null || source2 === void 0 ? void 0 : source2.lift);
}
function operate(init2) {
  return function(source2) {
    if (hasLift(source2)) {
      return source2.lift(function(liftedSource) {
        try {
          return init2(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a3;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a3 = this.onFinalize) === null || _a3 === void 0 ? void 0 : _a3.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);
var dateTimestampProvider = {
  now: function() {
    return Date.now();
  }
};
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler2, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state2, delay) {
    return this;
  };
  return Action2;
}(Subscription);
var intervalProvider = {
  setInterval: function(handler, timeout) {
    var args = [];
    for (var _i2 = 2; _i2 < arguments.length; _i2++) {
      args[_i2 - 2] = arguments[_i2];
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearInterval: function(handle) {
    return clearInterval(handle);
  },
  delegate: void 0
};
var AsyncAction = function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler2, work) {
    var _this = _super.call(this, scheduler2, work) || this;
    _this.scheduler = scheduler2;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state2, delay) {
    var _a3;
    if (delay === void 0) {
      delay = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state2;
    var id2 = this.id;
    var scheduler2 = this.scheduler;
    if (id2 != null) {
      this.id = this.recycleAsyncId(scheduler2, id2, delay);
    }
    this.pending = true;
    this.delay = delay;
    this.id = (_a3 = this.id) !== null && _a3 !== void 0 ? _a3 : this.requestAsyncId(scheduler2, this.id, delay);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler2, _id, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return intervalProvider.setInterval(scheduler2.flush.bind(scheduler2, this), delay);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id2, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (delay != null && this.delay === delay && this.pending === false) {
      return id2;
    }
    if (id2 != null) {
      intervalProvider.clearInterval(id2);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state2, delay) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state2, delay);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state2, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state2);
    } catch (e2) {
      errored = true;
      errorValue = e2 ? e2 : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a3 = this, id2 = _a3.id, scheduler2 = _a3.scheduler;
      var actions = scheduler2.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id2 != null) {
        this.id = this.recycleAsyncId(scheduler2, id2, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);
var Scheduler$1 = function() {
  function Scheduler2(schedulerActionCtor, now2) {
    if (now2 === void 0) {
      now2 = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now2;
  }
  Scheduler2.prototype.schedule = function(work, delay, state2) {
    if (delay === void 0) {
      delay = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state2, delay);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
}();
var AsyncScheduler = function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now2) {
    if (now2 === void 0) {
      now2 = Scheduler$1.now;
    }
    var _this = _super.call(this, SchedulerAction, now2) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action2) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action2);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action2.execute(action2.state, action2.delay)) {
        break;
      }
    } while (action2 = actions.shift());
    this._active = false;
    if (error) {
      while (action2 = actions.shift()) {
        action2.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler$1);
var asyncScheduler = new AsyncScheduler(AsyncAction);
function isScheduler(value) {
  return value && isFunction(value.schedule);
}
function last(arr) {
  return arr[arr.length - 1];
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
function executeSchedule(parentSubscription, scheduler2, work, delay, repeat) {
  if (delay === void 0) {
    delay = 0;
  }
  if (repeat === void 0) {
    repeat = false;
  }
  var scheduleSubscription = scheduler2.schedule(function() {
    work();
    if (repeat) {
      parentSubscription.add(this.schedule(null, delay));
    } else {
      this.unsubscribe();
    }
  }, delay);
  parentSubscription.add(scheduleSubscription);
  if (!repeat) {
    return scheduleSubscription;
  }
}
function filter(predicate, thisArg) {
  return operate(function(source2, subscriber) {
    var index2 = 0;
    source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index2++) && subscriber.next(value);
    }));
  });
}
function bufferTime(bufferTimeSpan) {
  var _a3, _b3;
  var otherArgs = [];
  for (var _i2 = 1; _i2 < arguments.length; _i2++) {
    otherArgs[_i2 - 1] = arguments[_i2];
  }
  var scheduler2 = (_a3 = popScheduler(otherArgs)) !== null && _a3 !== void 0 ? _a3 : asyncScheduler;
  var bufferCreationInterval = (_b3 = otherArgs[0]) !== null && _b3 !== void 0 ? _b3 : null;
  var maxBufferSize = otherArgs[1] || Infinity;
  return operate(function(source2, subscriber) {
    var bufferRecords = [];
    var restartOnEmit = false;
    var emit = function(record) {
      var buffer = record.buffer, subs = record.subs;
      subs.unsubscribe();
      arrRemove(bufferRecords, record);
      subscriber.next(buffer);
      restartOnEmit && startBuffer();
    };
    var startBuffer = function() {
      if (bufferRecords) {
        var subs = new Subscription();
        subscriber.add(subs);
        var buffer = [];
        var record_1 = {
          buffer,
          subs
        };
        bufferRecords.push(record_1);
        executeSchedule(subs, scheduler2, function() {
          return emit(record_1);
        }, bufferTimeSpan);
      }
    };
    if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
      executeSchedule(subscriber, scheduler2, startBuffer, bufferCreationInterval, true);
    } else {
      restartOnEmit = true;
    }
    startBuffer();
    var bufferTimeSubscriber = createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a4;
      var recordsCopy = bufferRecords.slice();
      try {
        for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
          var record = recordsCopy_1_1.value;
          var buffer = record.buffer;
          buffer.push(value);
          maxBufferSize <= buffer.length && emit(record);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a4 = recordsCopy_1.return)) _a4.call(recordsCopy_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    }, function() {
      while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
        subscriber.next(bufferRecords.shift().buffer);
      }
      bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
      subscriber.complete();
      subscriber.unsubscribe();
    }, void 0, function() {
      return bufferRecords = null;
    });
    source2.subscribe(bufferTimeSubscriber);
  });
}
const ChartErrors = {
  noData: Symbol.for("errors.noData")
};
var __defProp$4 = Object.defineProperty;
var __getOwnPropDesc$h = Object.getOwnPropertyDescriptor;
var __decorateClass$h = (decorators, target, key2, kind) => {
  var result = __getOwnPropDesc$h(target, key2);
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(target, key2, result) || result;
  if (result) __defProp$4(target, key2, result);
  return result;
};
class Session {
  constructor(symbol, resolution, symbolInfo) {
    __publicField(this, "_symbolInfo", /* @__PURE__ */ Object.create(null));
    __publicField(this, "subscription", null);
    __publicField(this, "loadMores", /* @__PURE__ */ new Set());
    __publicField(this, "listenerGuid", generateUuid());
    __publicField(this, "_cancellationTokenSource", new CancellationTokenSource());
    __publicField(this, "cancellationToken", this._cancellationTokenSource.token);
    __publicField(this, "_status", 0);
    __publicField(this, "_historyPromise", new DeferredPromise$1());
    __publicField(this, "historyPromise", this._historyPromise.p);
    this.symbol = symbol;
    this.resolution = resolution;
    if (symbolInfo) {
      this.symbolInfo = symbolInfo;
    }
  }
  get status() {
    return this._status;
  }
  set status(s2) {
    if (isHistoryResolved(s2)) {
      this._historyPromise.complete(true);
    }
    if (s2 === -1) {
      this._historyPromise.complete(false);
    }
    this._status = s2;
  }
  get symbolInfo() {
    return this._symbolInfo;
  }
  set symbolInfo(info) {
    this._symbolInfo = info;
    this.status |= 1;
  }
  add(source2) {
    this.loadMores.add(source2);
  }
  remove(source2) {
    this.loadMores.delete(source2);
  }
  dispose() {
    var _a3;
    this._historyPromise.complete(false);
    this._cancellationTokenSource.dispose(true);
    (_a3 = this.subscription) == null ? void 0 : _a3.unsubscribe();
    this.loadMores.values().forEach((src) => src.dispose(true));
  }
}
class ChartDataLoader extends Disposable {
  constructor(datafeed, config2) {
    super();
    __publicField(this, "_session", null);
    this.datafeed = datafeed;
    this.config = config2;
    this._register(toDisposable(() => this._cancelCurrentSession()));
  }
  get session() {
    return this._session;
  }
  loadAll(symbol, count, resolution, onResolve, onResult, onTick, onError) {
    this._cancelCurrentSession();
    const session = new Session(symbol, resolution);
    const { cancellationToken, historyPromise } = session;
    this._session = session;
    this.datafeed.resolveSymbol(
      symbol,
      (symbolInfo) => {
        if (cancellationToken.isCancellationRequested) return;
        onResolve(symbolInfo);
        should(
          session.status === 0
          /* idle */
        );
        ensure(this._session).symbolInfo = symbolInfo;
        this.loadData(session, count, resolution, onResult, onTick, onError);
      },
      (err) => {
        if (cancellationToken.isCancellationRequested) return;
        onError(err);
      },
      cancellationToken
    );
    return historyPromise;
  }
  reloadData(symbol, count, resolution, onResult, onTick, onError) {
    const symbolInfo = ensure(this._session).symbolInfo;
    this._cancelCurrentSession();
    const session = new Session(symbol, resolution);
    session.symbolInfo = symbolInfo;
    this._session = session;
    this.loadData(session, count, resolution, onResult, onTick, onError);
    return session.historyPromise;
  }
  loadData(session, count, resolution, onResult, onTick, onError) {
    const { cancellationToken } = session;
    if (cancellationToken.isCancellationRequested) return;
    const { listenerGuid, symbolInfo } = session;
    let historyDataReady = false;
    let wsBuffer = null;
    const commonOnError = (err) => {
      if (cancellationToken.isCancellationRequested) return;
      session.status = -1;
      session.dispose();
      onError(err);
    };
    this.datafeed.getBars(
      symbolInfo,
      resolution,
      {
        from: 0,
        to: (/* @__PURE__ */ new Date()).getTime() / 1e3,
        countBack: count,
        firstDataRequest: true
      },
      (bars, meta) => {
        if (cancellationToken.isCancellationRequested) return;
        should(isSymbolInfoResolved(session.status));
        if (!bars.length) {
          commonOnError(ChartErrors.noData);
          return;
        }
        session.status |= 2;
        historyDataReady = true;
        if (wsBuffer == null ? void 0 : wsBuffer.length) {
          wsBuffer.sort((a2, b2) => a2.time - b2.time);
          while (wsBuffer.length) {
            const lastBar = last$1(bars);
            const first = wsBuffer.shift();
            if (lastBar && lastBar.time === first.time) {
              Object.assign(lastBar, first);
            } else {
              bars.push(first);
            }
          }
          wsBuffer = null;
        }
        onResult(
          sortedUniqBy(bars, (b2) => b2.time),
          meta
        );
      },
      commonOnError,
      cancellationToken
    );
    const unbufferedObservable = new Observable((subscriber) => {
      const onTickInternal = (bar) => {
        if (cancellationToken.isCancellationRequested) return;
        if (!historyDataReady) {
          if (!wsBuffer) wsBuffer = [];
          wsBuffer.push(bar);
        } else {
          subscriber.next(bar);
        }
        return () => {
          this.datafeed.unsubscribeBars(listenerGuid);
        };
      };
      this.datafeed.subscribeBars(symbolInfo, resolution, onTickInternal, listenerGuid, () => {
      });
      return () => {
        this.datafeed.unsubscribeBars(listenerGuid);
      };
    });
    if (this.config.bufferTime > 0) {
      const bufferedObservable = unbufferedObservable.pipe(
        bufferTime(this.config.bufferTime),
        filter((arr) => arr.length > 0)
      );
      session.subscription = bufferedObservable.subscribe((bars) => {
        const groups = groupBy(bars, (bar) => bar.time);
        const syntheticBars = values(groups).map((bars2) => {
          return bars2.reduce((acc, i2) => {
            acc.high = Math.max(acc.high, i2.close);
            acc.low = Math.min(acc.low, i2.close);
            acc.close = i2.close;
            return acc;
          });
        });
        syntheticBars.sort((a2, b2) => a2.time - b2.time).forEach((bar) => {
          should(
            isHistoryResolved(session.status) || isSymbolInfoResolved(session.status) || isRealtimeConnected(session.status)
          );
          session.status |= 4;
          onTick(bar);
        });
      });
    } else {
      session.subscription = unbufferedObservable.subscribe((bar) => {
        onTick(bar);
      });
    }
  }
  loadMore(symbol, resolution, request, onResult, onError) {
    const session = this._session;
    if (!session) return;
    if (session.symbol !== symbol || session.resolution !== resolution) return;
    const cancellationTokenSource = new CancellationTokenSource();
    const cancellationToken = cancellationTokenSource.token;
    session.add(cancellationTokenSource);
    this.datafeed.getBars(
      session.symbolInfo,
      session.resolution,
      {
        from: 0,
        to: request.to - 1,
        // 开区间，不包含 request.to，方便后续处理
        countBack: request.countBack,
        firstDataRequest: true
      },
      (bars, meta) => {
        if (cancellationToken.isCancellationRequested) return;
        onResult(bars, meta);
        session.remove(cancellationTokenSource);
      },
      (err) => {
        if (cancellationToken.isCancellationRequested) return;
        onError == null ? void 0 : onError(err);
        session.remove(cancellationTokenSource);
      },
      cancellationToken
    );
  }
  _cancelCurrentSession() {
    if (!this._session) return;
    this._session.dispose();
    this._session = null;
  }
}
__decorateClass$h([
  debounce(500, { maxWait: 500, trailing: true })
], ChartDataLoader.prototype, "loadMore");
var DataStatusFlag = /* @__PURE__ */ ((DataStatusFlag2) => {
  DataStatusFlag2[DataStatusFlag2["error"] = -1] = "error";
  DataStatusFlag2[DataStatusFlag2["idle"] = 0] = "idle";
  DataStatusFlag2[DataStatusFlag2["symbolInfoResolved"] = 1] = "symbolInfoResolved";
  DataStatusFlag2[DataStatusFlag2["historyResolved"] = 2] = "historyResolved";
  DataStatusFlag2[DataStatusFlag2["realtimeConnected"] = 4] = "realtimeConnected";
  return DataStatusFlag2;
})(DataStatusFlag || {});
function isSymbolInfoResolved(s2) {
  return (s2 & 1) !== 0;
}
function isHistoryResolved(s2) {
  return (s2 & 2) !== 0;
}
function isRealtimeConnected(s2) {
  return (s2 & 4) !== 0;
}
var __getOwnPropDesc$g = Object.getOwnPropertyDescriptor;
var __decorateClass$g = (decorators, target, key2, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$g(target, key2) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$f = (index2, decorator) => (target, key2) => decorator(target, key2, index2);
var ChartDataStatus = /* @__PURE__ */ ((ChartDataStatus2) => {
  ChartDataStatus2[ChartDataStatus2["idle"] = 0] = "idle";
  ChartDataStatus2[ChartDataStatus2["startLoading"] = 1] = "startLoading";
  ChartDataStatus2[ChartDataStatus2["symbolInfoResolved"] = 2] = "symbolInfoResolved";
  ChartDataStatus2[ChartDataStatus2["dataLoaded"] = 3] = "dataLoaded";
  ChartDataStatus2[ChartDataStatus2["error"] = 4] = "error";
  return ChartDataStatus2;
})(ChartDataStatus || {});
class AbstractChartDataSource extends Disposable {
  constructor(_ctx, _chart, datafeed) {
    super();
    __publicField(this, "_dataLoader");
    __publicField(this, "_onDataChanged", new Emitter());
    __publicField(this, "onDataChanged", this._onDataChanged.event);
    this._ctx = _ctx;
    this._chart = _chart;
    this._register(this._dataLoader = new ChartDataLoader(datafeed, { bufferTime: -1 }));
  }
  status() {
    var _a3;
    return ((_a3 = this._dataLoader.session) == null ? void 0 : _a3.status) ?? DataStatusFlag.idle;
  }
  loadAll(onResolve, onError) {
    if (!this.symbol()) return Promise.resolve(false);
    return this._dataLoader.loadAll(
      this.symbol(),
      this._ctx.countBack(),
      this.resolution(),
      (symbolInfo) => {
        onResolve == null ? void 0 : onResolve(symbolInfo);
      },
      (bars) => {
        this.setBars(bars);
      },
      (bar) => {
        this.setBar(bar);
      },
      (err) => {
        onError == null ? void 0 : onError(err);
      }
    );
  }
  resetData(onResolve, onError) {
    if (!this.symbol()) return Promise.resolve(false);
    if (!this._dataLoader.session) {
      return this.loadAll(onResolve, onError);
    }
    if (!isSymbolInfoResolved(this._dataLoader.session.status)) {
      return this._dataLoader.session.historyPromise;
    }
    this.clearBars();
    return this._dataLoader.reloadData(
      this.symbol(),
      this._ctx.countBack(),
      this.resolution(),
      (bars) => {
        this.setBars(bars);
      },
      (bar) => {
        this.setBar(bar);
      },
      (err) => {
        onError == null ? void 0 : onError(err);
      }
    );
  }
  _registerListeners() {
    const handleRangeChange = (e2) => {
      if (e2 && e2.from < 1) {
        const bars = this.data();
        if (!this.data().length) return;
        const first = bars[0];
        this._dataLoader.loadMore(
          this.symbol(),
          this.resolution(),
          {
            to: first.time,
            countBack: Math.ceil(Math.abs(e2.from) + 100)
          },
          (more) => {
            const allBars = more.concat(this.data());
            allBars.sort((a2, b2) => a2.time - b2.time);
            this.setBars(sortedUniqBy(allBars, (b2) => b2.time));
          }
        );
      }
    };
    this._chart.timeScale().subscribeVisibleLogicalRangeChange(handleRangeChange);
    this._register(
      toDisposable(() => {
        this._chart.timeScale().unsubscribeVisibleLogicalRangeChange(handleRangeChange);
      })
    );
  }
}
let StudyDataSource = class extends AbstractChartDataSource {
  constructor(_symbol, _resolution, ctx, chart, datafeed) {
    super(ctx, chart, datafeed);
    __publicField(this, "_data", []);
    this._symbol = _symbol;
    this._resolution = _resolution;
  }
  data() {
    return this._data;
  }
  symbol() {
    return this._symbol;
  }
  resolution() {
    return this._resolution;
  }
  setResolution(resolution) {
    this._resolution = resolution;
    return this.loadAll();
  }
  clearBars() {
    this._data.length = 0;
    this._onDataChanged.fire("full");
  }
  setBars(bars) {
    this._data = barsToSingleValueData(bars, "close");
    this._onDataChanged.fire("full");
  }
  setBar(bar) {
    const newBar = barToSingleValueData(bar, "close");
    const lastBar = last$1(this._data);
    if (lastBar && lastBar.time === newBar.time) {
      this._data[this._data.length - 1] = newBar;
    } else {
      this._data.push(newBar);
    }
    this._onDataChanged.fire("update");
  }
  loadData(onResolve) {
    return this.loadAll(onResolve);
  }
};
StudyDataSource = __decorateClass$g([
  __decorateParam$f(4, IDatafeedService)
], StudyDataSource);
function barsToOhlcData(bars, upColor, downColor) {
  let lastValue = -Infinity;
  return bars.map((bar) => {
    const origin = isSeriesData(bar) ? bar.customValues : bar;
    const color = origin.close >= lastValue ? upColor : downColor;
    lastValue = origin.close;
    return {
      open: origin.open,
      high: origin.high,
      low: origin.low,
      close: origin.close,
      volume: origin.volume,
      time: bar.time,
      color,
      customValues: {
        open: origin.open,
        high: origin.high,
        low: origin.low,
        close: origin.close,
        volume: origin.volume
      }
    };
  });
}
function barsToSingleValueData(bars, key2) {
  return bars.map((bar) => {
    const origin = isSeriesData(bar) ? bar.customValues : bar;
    return {
      time: bar.time,
      value: origin[key2],
      customValues: {
        open: origin.open,
        high: origin.high,
        low: origin.low,
        close: origin.close
      }
    };
  });
}
function barToSingleValueData(bar, key2) {
  const origin = isSeriesData(bar) ? bar.customValues : bar;
  return {
    time: bar.time,
    value: origin[key2],
    customValues: {
      open: origin.open,
      high: origin.high,
      low: origin.low,
      close: origin.close
    }
  };
}
function isSeriesData(d3) {
  return "customValues" in d3;
}
function size(s2) {
  const w2 = s2.width;
  const h2 = s2.height;
  if (w2 < 0) throw new Error("Negative width is not allowed for Size");
  if (h2 < 0) throw new Error("Negative height is not allowed for Size");
  return { width: w2, height: h2 };
}
function isSizeEqual(s1, s2) {
  return s1.width == s2.width && s1.height === s2.height;
}
function derivedWithCache(stores, fn2, initial_value) {
  const cache2 = writable(initial_value);
  const originDerived = derived(stores, fn2, initial_value);
  const cleanup = originDerived.subscribe((val) => {
    if (!isEqual(val, get(cache2))) {
      cache2.set(val);
    }
  });
  onDestroy(() => cleanup());
  return cache2;
}
function watch(stores, fn2, cb) {
  let inited = false;
  const originDerived = derived(stores, fn2);
  const cleanup = originDerived.subscribe(() => {
    if (inited) {
      cb();
    }
    inited = true;
  });
  return toDisposable(() => cleanup());
}
const formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
const formatDistance = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options == null ? void 0 : options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
function buildFormatLongFn(args) {
  return (options = {}) => {
    const width = options.width ? String(options.width) : args.defaultWidth;
    const format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
const dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
const timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
const formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
const formatRelative = (token, _date, _baseDate, _options) => formatRelativeLocale[token];
function buildLocalizeFn(args) {
  return (value, options) => {
    const context = (options == null ? void 0 : options.context) ? String(options.context) : "standalone";
    let valuesArray;
    if (context === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width = (options == null ? void 0 : options.width) ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width = (options == null ? void 0 : options.width) ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[width] || args.values[defaultWidth];
    }
    const index2 = args.argumentCallback ? args.argumentCallback(value) : value;
    return valuesArray[index2];
  };
}
const eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
const quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
const monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
};
const dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
};
const dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
const formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
const ordinalNumber = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  const rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
const localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
function buildMatchFn(args) {
  return (string, options = {}) => {
    const width = options.width;
    const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];
    const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    const key2 = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
      // [TODO] -- I challenge you to fix the type
      findKey(parsePatterns, (pattern) => pattern.test(matchedString))
    );
    let value;
    value = args.valueCallback ? args.valueCallback(key2) : key2;
    value = options.valueCallback ? (
      // [TODO] -- I challenge you to fix the type
      options.valueCallback(value)
    ) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
function findKey(object, predicate) {
  for (const key2 in object) {
    if (Object.prototype.hasOwnProperty.call(object, key2) && predicate(object[key2])) {
      return key2;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (let key2 = 0; key2 < array.length; key2++) {
    if (predicate(array[key2])) {
      return key2;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return (string, options = {}) => {
    const matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    const matchedString = matchResult[0];
    const parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
const matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern = /\d+/i;
const matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
const parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
const matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
const parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
const parseMonthPatterns = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
const parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
const matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
const parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
const match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
const enUS = {
  code: "en-US",
  formatDistance,
  formatLong,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
let defaultOptions = {};
function getDefaultOptions$1() {
  return defaultOptions;
}
const millisecondsInWeek = 6048e5;
const millisecondsInDay = 864e5;
const constructFromSymbol = Symbol.for("constructDateFrom");
function constructFrom(date, value) {
  if (typeof date === "function") return date(value);
  if (date && typeof date === "object" && constructFromSymbol in date)
    return date[constructFromSymbol](value);
  if (date instanceof Date) return new date.constructor(value);
  return new Date(value);
}
function toDate$1(argument, context) {
  return constructFrom(context || argument, argument);
}
function getTimezoneOffsetInMilliseconds$1(date) {
  const _date = toDate$1(date);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds()
    )
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date - +utcDate;
}
function normalizeDates(context, ...dates) {
  const normalize = constructFrom.bind(
    null,
    dates.find((date) => typeof date === "object")
  );
  return dates.map(normalize);
}
function startOfDay(date, options) {
  const _date = toDate$1(date, options == null ? void 0 : options.in);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function differenceInCalendarDays(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  const laterStartOfDay = startOfDay(laterDate_);
  const earlierStartOfDay = startOfDay(earlierDate_);
  const laterTimestamp = +laterStartOfDay - getTimezoneOffsetInMilliseconds$1(laterStartOfDay);
  const earlierTimestamp = +earlierStartOfDay - getTimezoneOffsetInMilliseconds$1(earlierStartOfDay);
  return Math.round((laterTimestamp - earlierTimestamp) / millisecondsInDay);
}
function startOfYear(date, options) {
  const date_ = toDate$1(date, options == null ? void 0 : options.in);
  date_.setFullYear(date_.getFullYear(), 0, 1);
  date_.setHours(0, 0, 0, 0);
  return date_;
}
function getDayOfYear(date, options) {
  const _date = toDate$1(date, options == null ? void 0 : options.in);
  const diff = differenceInCalendarDays(_date, startOfYear(_date));
  const dayOfYear = diff + 1;
  return dayOfYear;
}
function startOfWeek(date, options) {
  var _a3, _b3, _c2, _d2;
  const defaultOptions2 = getDefaultOptions$1();
  const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_b3 = (_a3 = options == null ? void 0 : options.locale) == null ? void 0 : _a3.options) == null ? void 0 : _b3.weekStartsOn) ?? defaultOptions2.weekStartsOn ?? ((_d2 = (_c2 = defaultOptions2.locale) == null ? void 0 : _c2.options) == null ? void 0 : _d2.weekStartsOn) ?? 0;
  const _date = toDate$1(date, options == null ? void 0 : options.in);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  _date.setDate(_date.getDate() - diff);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function startOfISOWeek(date, options) {
  return startOfWeek(date, { ...options, weekStartsOn: 1 });
}
function getISOWeekYear(date, options) {
  const _date = toDate$1(date, options == null ? void 0 : options.in);
  const year = _date.getFullYear();
  const fourthOfJanuaryOfNextYear = constructFrom(_date, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  const fourthOfJanuaryOfThisYear = constructFrom(_date, 0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfISOWeekYear(date, options) {
  const year = getISOWeekYear(date, options);
  const fourthOfJanuary = constructFrom(date, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return startOfISOWeek(fourthOfJanuary);
}
function getISOWeek(date, options) {
  const _date = toDate$1(date, options == null ? void 0 : options.in);
  const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
  return Math.round(diff / millisecondsInWeek) + 1;
}
function getWeekYear(date, options) {
  var _a3, _b3, _c2, _d2;
  const _date = toDate$1(date, options == null ? void 0 : options.in);
  const year = _date.getFullYear();
  const defaultOptions2 = getDefaultOptions$1();
  const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b3 = (_a3 = options == null ? void 0 : options.locale) == null ? void 0 : _a3.options) == null ? void 0 : _b3.firstWeekContainsDate) ?? defaultOptions2.firstWeekContainsDate ?? ((_d2 = (_c2 = defaultOptions2.locale) == null ? void 0 : _c2.options) == null ? void 0 : _d2.firstWeekContainsDate) ?? 1;
  const firstWeekOfNextYear = constructFrom((options == null ? void 0 : options.in) || date, 0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
  const firstWeekOfThisYear = constructFrom((options == null ? void 0 : options.in) || date, 0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
  if (+_date >= +startOfNextYear) {
    return year + 1;
  } else if (+_date >= +startOfThisYear) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfWeekYear(date, options) {
  var _a3, _b3, _c2, _d2;
  const defaultOptions2 = getDefaultOptions$1();
  const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b3 = (_a3 = options == null ? void 0 : options.locale) == null ? void 0 : _a3.options) == null ? void 0 : _b3.firstWeekContainsDate) ?? defaultOptions2.firstWeekContainsDate ?? ((_d2 = (_c2 = defaultOptions2.locale) == null ? void 0 : _c2.options) == null ? void 0 : _d2.firstWeekContainsDate) ?? 1;
  const year = getWeekYear(date, options);
  const firstWeek = constructFrom((options == null ? void 0 : options.in) || date, 0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = startOfWeek(firstWeek, options);
  return _date;
}
function getWeek(date, options) {
  const _date = toDate$1(date, options == null ? void 0 : options.in);
  const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);
  return Math.round(diff / millisecondsInWeek) + 1;
}
function addLeadingZeros$2(number, targetLength) {
  const sign2 = number < 0 ? "-" : "";
  const output = Math.abs(number).toString().padStart(targetLength, "0");
  return sign2 + output;
}
const lightFormatters = {
  // Year
  y(date, token) {
    const signedYear = date.getFullYear();
    const year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros$2(token === "yy" ? year % 100 : year, token.length);
  },
  // Month
  M(date, token) {
    const month = date.getMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros$2(month + 1, 2);
  },
  // Day of the month
  d(date, token) {
    return addLeadingZeros$2(date.getDate(), token.length);
  },
  // AM or PM
  a(date, token) {
    const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(date, token) {
    return addLeadingZeros$2(date.getHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H(date, token) {
    return addLeadingZeros$2(date.getHours(), token.length);
  },
  // Minute
  m(date, token) {
    return addLeadingZeros$2(date.getMinutes(), token.length);
  },
  // Second
  s(date, token) {
    return addLeadingZeros$2(date.getSeconds(), token.length);
  },
  // Fraction of second
  S(date, token) {
    const numberOfDigits = token.length;
    const milliseconds = date.getMilliseconds();
    const fractionalSeconds = Math.trunc(
      milliseconds * Math.pow(10, numberOfDigits - 3)
    );
    return addLeadingZeros$2(fractionalSeconds, token.length);
  }
};
const dayPeriodEnum = {
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
const formatters$1 = {
  // Era
  G: function(date, token, localize2) {
    const era = date.getFullYear() > 0 ? 1 : 0;
    switch (token) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, { width: "abbreviated" });
      // A, B
      case "GGGGG":
        return localize2.era(era, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return localize2.era(era, { width: "wide" });
    }
  },
  // Year
  y: function(date, token, localize2) {
    if (token === "yo") {
      const signedYear = date.getFullYear();
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, { unit: "year" });
    }
    return lightFormatters.y(date, token);
  },
  // Local week-numbering year
  Y: function(date, token, localize2, options) {
    const signedWeekYear = getWeekYear(date, options);
    const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      const twoDigitYear = weekYear % 100;
      return addLeadingZeros$2(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize2.ordinalNumber(weekYear, { unit: "year" });
    }
    return addLeadingZeros$2(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function(date, token) {
    const isoWeekYear = getISOWeekYear(date);
    return addLeadingZeros$2(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(date, token) {
    const year = date.getFullYear();
    return addLeadingZeros$2(year, token.length);
  },
  // Quarter
  Q: function(date, token, localize2) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "Q":
        return String(quarter);
      // 01, 02, 03, 04
      case "QQ":
        return addLeadingZeros$2(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(date, token, localize2) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "q":
        return String(quarter);
      // 01, 02, 03, 04
      case "qq":
        return addLeadingZeros$2(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(date, token, localize2) {
    const month = date.getMonth();
    switch (token) {
      case "M":
      case "MM":
        return lightFormatters.M(date, token);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      // J, F, ..., D
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return localize2.month(month, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(date, token, localize2) {
    const month = date.getMonth();
    switch (token) {
      // 1, 2, ..., 12
      case "L":
        return String(month + 1);
      // 01, 02, ..., 12
      case "LL":
        return addLeadingZeros$2(month + 1, 2);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      // J, F, ..., D
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return localize2.month(month, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(date, token, localize2, options) {
    const week = getWeek(date, options);
    if (token === "wo") {
      return localize2.ordinalNumber(week, { unit: "week" });
    }
    return addLeadingZeros$2(week, token.length);
  },
  // ISO week of year
  I: function(date, token, localize2) {
    const isoWeek = getISOWeek(date);
    if (token === "Io") {
      return localize2.ordinalNumber(isoWeek, { unit: "week" });
    }
    return addLeadingZeros$2(isoWeek, token.length);
  },
  // Day of the month
  d: function(date, token, localize2) {
    if (token === "do") {
      return localize2.ordinalNumber(date.getDate(), { unit: "date" });
    }
    return lightFormatters.d(date, token);
  },
  // Day of year
  D: function(date, token, localize2) {
    const dayOfYear = getDayOfYear(date);
    if (token === "Do") {
      return localize2.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
    }
    return addLeadingZeros$2(dayOfYear, token.length);
  },
  // Day of week
  E: function(date, token, localize2) {
    const dayOfWeek = date.getDay();
    switch (token) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(date, token, localize2, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case "e":
        return String(localDayOfWeek);
      // Padded numerical value
      case "ee":
        return addLeadingZeros$2(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(date, token, localize2, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (same as in `e`)
      case "c":
        return String(localDayOfWeek);
      // Padded numerical value
      case "cc":
        return addLeadingZeros$2(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      // T
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      // Tu
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      // Tuesday
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(date, token, localize2) {
    const dayOfWeek = date.getDay();
    const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      // 2
      case "i":
        return String(isoDayOfWeek);
      // 02
      case "ii":
        return addLeadingZeros$2(isoDayOfWeek, token.length);
      // 2nd
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, { unit: "day" });
      // Tue
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(date, token, localize2) {
    const hours = date.getHours();
    const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(date, token, localize2) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(date, token, localize2) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(date, token, localize2) {
    if (token === "ho") {
      let hours = date.getHours() % 12;
      if (hours === 0) hours = 12;
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return lightFormatters.h(date, token);
  },
  // Hour [0-23]
  H: function(date, token, localize2) {
    if (token === "Ho") {
      return localize2.ordinalNumber(date.getHours(), { unit: "hour" });
    }
    return lightFormatters.H(date, token);
  },
  // Hour [0-11]
  K: function(date, token, localize2) {
    const hours = date.getHours() % 12;
    if (token === "Ko") {
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros$2(hours, token.length);
  },
  // Hour [1-24]
  k: function(date, token, localize2) {
    let hours = date.getHours();
    if (hours === 0) hours = 24;
    if (token === "ko") {
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros$2(hours, token.length);
  },
  // Minute
  m: function(date, token, localize2) {
    if (token === "mo") {
      return localize2.ordinalNumber(date.getMinutes(), { unit: "minute" });
    }
    return lightFormatters.m(date, token);
  },
  // Second
  s: function(date, token, localize2) {
    if (token === "so") {
      return localize2.ordinalNumber(date.getSeconds(), { unit: "second" });
    }
    return lightFormatters.s(date, token);
  },
  // Fraction of second
  S: function(date, token) {
    return lightFormatters.S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      // Hours and optional minutes
      case "X":
        return formatTimezoneWithOptionalMinutes$1(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case "XXXX":
      case "XX":
        return formatTimezone$1(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case "XXXXX":
      case "XXX":
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone$1(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      // Hours and optional minutes
      case "x":
        return formatTimezoneWithOptionalMinutes$1(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case "xxxx":
      case "xx":
        return formatTimezone$1(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case "xxxxx":
      case "xxx":
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone$1(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      // Short
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort$1(timezoneOffset, ":");
      // Long
      case "OOOO":
      default:
        return "GMT" + formatTimezone$1(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      // Short
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort$1(timezoneOffset, ":");
      // Long
      case "zzzz":
      default:
        return "GMT" + formatTimezone$1(timezoneOffset, ":");
    }
  },
  // Seconds timestamp
  t: function(date, token, _localize) {
    const timestamp = Math.trunc(+date / 1e3);
    return addLeadingZeros$2(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function(date, token, _localize) {
    return addLeadingZeros$2(+date, token.length);
  }
};
function formatTimezoneShort$1(offset, delimiter = "") {
  const sign2 = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = Math.trunc(absOffset / 60);
  const minutes = absOffset % 60;
  if (minutes === 0) {
    return sign2 + String(hours);
  }
  return sign2 + String(hours) + delimiter + addLeadingZeros$2(minutes, 2);
}
function formatTimezoneWithOptionalMinutes$1(offset, delimiter) {
  if (offset % 60 === 0) {
    const sign2 = offset > 0 ? "-" : "+";
    return sign2 + addLeadingZeros$2(Math.abs(offset) / 60, 2);
  }
  return formatTimezone$1(offset, delimiter);
}
function formatTimezone$1(offset, delimiter = "") {
  const sign2 = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = addLeadingZeros$2(Math.trunc(absOffset / 60), 2);
  const minutes = addLeadingZeros$2(absOffset % 60, 2);
  return sign2 + hours + delimiter + minutes;
}
const dateLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "P":
      return formatLong2.date({ width: "short" });
    case "PP":
      return formatLong2.date({ width: "medium" });
    case "PPP":
      return formatLong2.date({ width: "long" });
    case "PPPP":
    default:
      return formatLong2.date({ width: "full" });
  }
};
const timeLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "p":
      return formatLong2.time({ width: "short" });
    case "pp":
      return formatLong2.time({ width: "medium" });
    case "ppp":
      return formatLong2.time({ width: "long" });
    case "pppp":
    default:
      return formatLong2.time({ width: "full" });
  }
};
const dateTimeLongFormatter = (pattern, formatLong2) => {
  const matchResult = pattern.match(/(P+)(p+)?/) || [];
  const datePattern = matchResult[1];
  const timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  let dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({ width: "short" });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({ width: "medium" });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({ width: "full" });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
const longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
const dayOfYearTokenRE = /^D+$/;
const weekYearTokenRE = /^Y+$/;
const throwTokens = ["D", "DD", "YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return dayOfYearTokenRE.test(token);
}
function isProtectedWeekYearToken(token) {
  return weekYearTokenRE.test(token);
}
function warnOrThrowProtectedError(token, format2, input) {
  const _message = message(token, format2, input);
  console.warn(_message);
  if (throwTokens.includes(token)) throw new RangeError(_message);
}
function message(token, format2, input) {
  const subject = token[0] === "Y" ? "years" : "days of the month";
  return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
function isDate(value) {
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
function isValid(date) {
  return !(!isDate(date) && typeof date !== "number" || isNaN(+toDate$1(date)));
}
const formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
const longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
const escapedStringRegExp = /^'([^]*?)'?$/;
const doubleQuoteRegExp = /''/g;
const unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format$1(date, formatStr, options) {
  var _a3, _b3, _c2, _d2, _e, _f, _g, _h;
  const defaultOptions2 = getDefaultOptions$1();
  const locale = (options == null ? void 0 : options.locale) ?? defaultOptions2.locale ?? enUS;
  const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b3 = (_a3 = options == null ? void 0 : options.locale) == null ? void 0 : _a3.options) == null ? void 0 : _b3.firstWeekContainsDate) ?? defaultOptions2.firstWeekContainsDate ?? ((_d2 = (_c2 = defaultOptions2.locale) == null ? void 0 : _c2.options) == null ? void 0 : _d2.firstWeekContainsDate) ?? 1;
  const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_f = (_e = options == null ? void 0 : options.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.weekStartsOn) ?? defaultOptions2.weekStartsOn ?? ((_h = (_g = defaultOptions2.locale) == null ? void 0 : _g.options) == null ? void 0 : _h.weekStartsOn) ?? 0;
  const originalDate = toDate$1(date, options == null ? void 0 : options.in);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  let parts = formatStr.match(longFormattingTokensRegExp).map((substring) => {
    const firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      const longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map((substring) => {
    if (substring === "''") {
      return { isToken: false, value: "'" };
    }
    const firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return { isToken: false, value: cleanEscapedString(substring) };
    }
    if (formatters$1[firstCharacter]) {
      return { isToken: true, value: substring };
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
      );
    }
    return { isToken: false, value: substring };
  });
  if (locale.localize.preprocessor) {
    parts = locale.localize.preprocessor(originalDate, parts);
  }
  const formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale
  };
  return parts.map((part) => {
    if (!part.isToken) return part.value;
    const token = part.value;
    if (!(options == null ? void 0 : options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token) || !(options == null ? void 0 : options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
      warnOrThrowProtectedError(token, formatStr, String(date));
    }
    const formatter = formatters$1[token[0]];
    return formatter(originalDate, token, locale.localize, formatterOptions);
  }).join("");
}
function cleanEscapedString(input) {
  const matched = input.match(escapedStringRegExp);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp, "'");
}
function addDays(date, amount, options) {
  const _date = toDate$1(date, options == null ? void 0 : options.in);
  if (isNaN(amount)) return constructFrom(date, NaN);
  if (!amount) return _date;
  _date.setDate(_date.getDate() + amount);
  return _date;
}
function addMonths(date, amount, options) {
  const _date = toDate$1(date, options == null ? void 0 : options.in);
  if (isNaN(amount)) return constructFrom(date, NaN);
  if (!amount) {
    return _date;
  }
  const dayOfMonth = _date.getDate();
  const endOfDesiredMonth = constructFrom(date, _date.getTime());
  endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
  const daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  } else {
    _date.setFullYear(
      endOfDesiredMonth.getFullYear(),
      endOfDesiredMonth.getMonth(),
      dayOfMonth
    );
    return _date;
  }
}
function add(date, duration, options) {
  const {
    years = 0,
    months = 0,
    weeks = 0,
    days = 0,
    hours = 0,
    minutes = 0,
    seconds = 0
  } = duration;
  const _date = toDate$1(date, options == null ? void 0 : options.in);
  const dateWithMonths = months || years ? addMonths(_date, months + years * 12) : _date;
  const dateWithDays = days || weeks ? addDays(dateWithMonths, days + weeks * 7) : dateWithMonths;
  const minutesToAdd = minutes + hours * 60;
  const secondsToAdd = seconds + minutesToAdd * 60;
  const msToAdd = secondsToAdd * 1e3;
  return constructFrom(date, +dateWithDays + msToAdd);
}
function getDefaultOptions() {
  return Object.assign({}, getDefaultOptions$1());
}
function tzIntlTimeZoneName(length, date, options) {
  const defaultOptions2 = getDefaultOptions();
  const dtf = getDTF(length, options.timeZone, options.locale ?? defaultOptions2.locale);
  return "formatToParts" in dtf ? partsTimeZone(dtf, date) : hackyTimeZone(dtf, date);
}
function partsTimeZone(dtf, date) {
  const formatted = dtf.formatToParts(date);
  for (let i2 = formatted.length - 1; i2 >= 0; --i2) {
    if (formatted[i2].type === "timeZoneName") {
      return formatted[i2].value;
    }
  }
  return void 0;
}
function hackyTimeZone(dtf, date) {
  const formatted = dtf.format(date).replace(/\u200E/g, "");
  const tzNameMatch = / [\w-+ ]+$/.exec(formatted);
  return tzNameMatch ? tzNameMatch[0].substr(1) : "";
}
function getDTF(length, timeZone, locale) {
  return new Intl.DateTimeFormat(locale ? [locale.code, "en-US"] : void 0, {
    timeZone,
    timeZoneName: length
  });
}
function tzTokenizeDate(date, timeZone) {
  const dtf = getDateTimeFormat(timeZone);
  return "formatToParts" in dtf ? partsOffset(dtf, date) : hackyOffset(dtf, date);
}
const typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5
};
function partsOffset(dtf, date) {
  try {
    const formatted = dtf.formatToParts(date);
    const filled = [];
    for (let i2 = 0; i2 < formatted.length; i2++) {
      const pos = typeToPos[formatted[i2].type];
      if (pos !== void 0) {
        filled[pos] = parseInt(formatted[i2].value, 10);
      }
    }
    return filled;
  } catch (error) {
    if (error instanceof RangeError) {
      return [NaN];
    }
    throw error;
  }
}
function hackyOffset(dtf, date) {
  const formatted = dtf.format(date);
  const parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted);
  return [
    parseInt(parsed[3], 10),
    parseInt(parsed[1], 10),
    parseInt(parsed[2], 10),
    parseInt(parsed[4], 10),
    parseInt(parsed[5], 10),
    parseInt(parsed[6], 10)
  ];
}
const dtfCache = {};
const testDateFormatted = new Intl.DateTimeFormat("en-US", {
  hourCycle: "h23",
  timeZone: "America/New_York",
  year: "numeric",
  month: "2-digit",
  day: "2-digit",
  hour: "2-digit",
  minute: "2-digit",
  second: "2-digit"
}).format(/* @__PURE__ */ new Date("2014-06-25T04:00:00.123Z"));
const hourCycleSupported = testDateFormatted === "06/25/2014, 00:00:00" || testDateFormatted === "‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00";
function getDateTimeFormat(timeZone) {
  if (!dtfCache[timeZone]) {
    dtfCache[timeZone] = hourCycleSupported ? new Intl.DateTimeFormat("en-US", {
      hourCycle: "h23",
      timeZone,
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }) : new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone,
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
  }
  return dtfCache[timeZone];
}
function newDateUTC(fullYear, month, day, hour, minute, second, millisecond) {
  const utcDate = /* @__PURE__ */ new Date(0);
  utcDate.setUTCFullYear(fullYear, month, day);
  utcDate.setUTCHours(hour, minute, second, millisecond);
  return utcDate;
}
const MILLISECONDS_IN_HOUR$1 = 36e5;
const MILLISECONDS_IN_MINUTE$2 = 6e4;
const patterns$1 = {
  timezoneZ: /^(Z)$/,
  timezoneHH: /^([+-]\d{2})$/,
  timezoneHHMM: /^([+-])(\d{2}):?(\d{2})$/
};
function tzParseTimezone(timezoneString, date, isUtcDate) {
  if (!timezoneString) {
    return 0;
  }
  let token = patterns$1.timezoneZ.exec(timezoneString);
  if (token) {
    return 0;
  }
  let hours;
  let absoluteOffset;
  token = patterns$1.timezoneHH.exec(timezoneString);
  if (token) {
    hours = parseInt(token[1], 10);
    if (!validateTimezone(hours)) {
      return NaN;
    }
    return -(hours * MILLISECONDS_IN_HOUR$1);
  }
  token = patterns$1.timezoneHHMM.exec(timezoneString);
  if (token) {
    hours = parseInt(token[2], 10);
    const minutes = parseInt(token[3], 10);
    if (!validateTimezone(hours, minutes)) {
      return NaN;
    }
    absoluteOffset = Math.abs(hours) * MILLISECONDS_IN_HOUR$1 + minutes * MILLISECONDS_IN_MINUTE$2;
    return token[1] === "+" ? -absoluteOffset : absoluteOffset;
  }
  if (isValidTimezoneIANAString(timezoneString)) {
    date = new Date(date || Date.now());
    const utcDate = isUtcDate ? date : toUtcDate(date);
    const offset = calcOffset(utcDate, timezoneString);
    const fixedOffset = isUtcDate ? offset : fixOffset(date, offset, timezoneString);
    return -fixedOffset;
  }
  return NaN;
}
function toUtcDate(date) {
  return newDateUTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
}
function calcOffset(date, timezoneString) {
  const tokens = tzTokenizeDate(date, timezoneString);
  const asUTC = newDateUTC(tokens[0], tokens[1] - 1, tokens[2], tokens[3] % 24, tokens[4], tokens[5], 0).getTime();
  let asTS = date.getTime();
  const over = asTS % 1e3;
  asTS -= over >= 0 ? over : 1e3 + over;
  return asUTC - asTS;
}
function fixOffset(date, offset, timezoneString) {
  const localTS = date.getTime();
  let utcGuess = localTS - offset;
  const o2 = calcOffset(new Date(utcGuess), timezoneString);
  if (offset === o2) {
    return offset;
  }
  utcGuess -= o2 - offset;
  const o3 = calcOffset(new Date(utcGuess), timezoneString);
  if (o2 === o3) {
    return o2;
  }
  return Math.max(o2, o3);
}
function validateTimezone(hours, minutes) {
  return -23 <= hours && hours <= 23 && (minutes == null || 0 <= minutes && minutes <= 59);
}
const validIANATimezoneCache = {};
function isValidTimezoneIANAString(timeZoneString) {
  if (validIANATimezoneCache[timeZoneString])
    return true;
  try {
    new Intl.DateTimeFormat(void 0, { timeZone: timeZoneString });
    validIANATimezoneCache[timeZoneString] = true;
    return true;
  } catch (error) {
    return false;
  }
}
const MILLISECONDS_IN_MINUTE$1 = 60 * 1e3;
const formatters = {
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(date, token, options) {
    const timezoneOffset = getTimeZoneOffset(options.timeZone, date);
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      // Hours and optional minutes
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimeter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimeter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case "XXXXX":
      case "XXX":
      // Hours and minutes with `:` delimeter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(date, token, options) {
    const timezoneOffset = getTimeZoneOffset(options.timeZone, date);
    switch (token) {
      // Hours and optional minutes
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimeter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimeter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case "xxxxx":
      case "xxx":
      // Hours and minutes with `:` delimeter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function(date, token, options) {
    const timezoneOffset = getTimeZoneOffset(options.timeZone, date);
    switch (token) {
      // Short
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(date, token, options) {
    switch (token) {
      // Short
      case "z":
      case "zz":
      case "zzz":
        return tzIntlTimeZoneName("short", date, options);
      // Long
      case "zzzz":
      default:
        return tzIntlTimeZoneName("long", date, options);
    }
  }
};
function getTimeZoneOffset(timeZone, originalDate) {
  const timeZoneOffset = timeZone ? tzParseTimezone(timeZone, originalDate, true) / MILLISECONDS_IN_MINUTE$1 : (originalDate == null ? void 0 : originalDate.getTimezoneOffset()) ?? 0;
  if (Number.isNaN(timeZoneOffset)) {
    throw new RangeError("Invalid time zone specified: " + timeZone);
  }
  return timeZoneOffset;
}
function addLeadingZeros$1(number, targetLength) {
  const sign2 = number < 0 ? "-" : "";
  let output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign2 + output;
}
function formatTimezone(offset, delimiter = "") {
  const sign2 = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = addLeadingZeros$1(Math.floor(absOffset / 60), 2);
  const minutes = addLeadingZeros$1(Math.floor(absOffset % 60), 2);
  return sign2 + hours + delimiter + minutes;
}
function formatTimezoneWithOptionalMinutes(offset, delimiter) {
  if (offset % 60 === 0) {
    const sign2 = offset > 0 ? "-" : "+";
    return sign2 + addLeadingZeros$1(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, delimiter);
}
function formatTimezoneShort(offset, delimiter = "") {
  const sign2 = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = Math.floor(absOffset / 60);
  const minutes = absOffset % 60;
  if (minutes === 0) {
    return sign2 + String(hours);
  }
  return sign2 + String(hours) + delimiter + addLeadingZeros$1(minutes, 2);
}
function getTimezoneOffsetInMilliseconds(date) {
  const utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return +date - +utcDate;
}
const tzPattern = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/;
const MILLISECONDS_IN_HOUR = 36e5;
const MILLISECONDS_IN_MINUTE = 6e4;
const DEFAULT_ADDITIONAL_DIGITS = 2;
const patterns = {
  dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
  datePattern: /^([0-9W+-]+)(.*)/,
  // year tokens
  YY: /^(\d{2})$/,
  YYY: [
    /^([+-]\d{2})$/,
    // 0 additional digits
    /^([+-]\d{3})$/,
    // 1 additional digit
    /^([+-]\d{4})$/
    // 2 additional digits
  ],
  YYYY: /^(\d{4})/,
  YYYYY: [
    /^([+-]\d{4})/,
    // 0 additional digits
    /^([+-]\d{5})/,
    // 1 additional digit
    /^([+-]\d{6})/
    // 2 additional digits
  ],
  // date tokens
  MM: /^-(\d{2})$/,
  DDD: /^-?(\d{3})$/,
  MMDD: /^-?(\d{2})-?(\d{2})$/,
  Www: /^-?W(\d{2})$/,
  WwwD: /^-?W(\d{2})-?(\d{1})$/,
  HH: /^(\d{2}([.,]\d*)?)$/,
  HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
  HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
  // time zone tokens (to identify the presence of a tz)
  timeZone: tzPattern
};
function toDate(argument, options = {}) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  if (argument === null) {
    return /* @__PURE__ */ new Date(NaN);
  }
  const additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : Number(options.additionalDigits);
  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  }
  if (argument instanceof Date || typeof argument === "object" && Object.prototype.toString.call(argument) === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || Object.prototype.toString.call(argument) === "[object Number]") {
    return new Date(argument);
  } else if (!(Object.prototype.toString.call(argument) === "[object String]")) {
    return /* @__PURE__ */ new Date(NaN);
  }
  const dateStrings = splitDateString(argument);
  const { year, restDateString } = parseYear(dateStrings.date, additionalDigits);
  const date = parseDate(restDateString, year);
  if (date === null || isNaN(date.getTime())) {
    return /* @__PURE__ */ new Date(NaN);
  }
  if (date) {
    const timestamp = date.getTime();
    let time = 0;
    let offset;
    if (dateStrings.time) {
      time = parseTime(dateStrings.time);
      if (time === null || isNaN(time)) {
        return /* @__PURE__ */ new Date(NaN);
      }
    }
    if (dateStrings.timeZone || options.timeZone) {
      offset = tzParseTimezone(dateStrings.timeZone || options.timeZone, new Date(timestamp + time));
      if (isNaN(offset)) {
        return /* @__PURE__ */ new Date(NaN);
      }
    } else {
      offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time));
      offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time + offset));
    }
    return new Date(timestamp + time + offset);
  } else {
    return /* @__PURE__ */ new Date(NaN);
  }
}
function splitDateString(dateString) {
  const dateStrings = {};
  let parts = patterns.dateTimePattern.exec(dateString);
  let timeString;
  if (!parts) {
    parts = patterns.datePattern.exec(dateString);
    if (parts) {
      dateStrings.date = parts[1];
      timeString = parts[2];
    } else {
      dateStrings.date = null;
      timeString = dateString;
    }
  } else {
    dateStrings.date = parts[1];
    timeString = parts[3];
  }
  if (timeString) {
    const token = patterns.timeZone.exec(timeString);
    if (token) {
      dateStrings.time = timeString.replace(token[1], "");
      dateStrings.timeZone = token[1].trim();
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  if (dateString) {
    const patternYYY = patterns.YYY[additionalDigits];
    const patternYYYYY = patterns.YYYYY[additionalDigits];
    let token = patterns.YYYY.exec(dateString) || patternYYYYY.exec(dateString);
    if (token) {
      const yearString = token[1];
      return {
        year: parseInt(yearString, 10),
        restDateString: dateString.slice(yearString.length)
      };
    }
    token = patterns.YY.exec(dateString) || patternYYY.exec(dateString);
    if (token) {
      const centuryString = token[1];
      return {
        year: parseInt(centuryString, 10) * 100,
        restDateString: dateString.slice(centuryString.length)
      };
    }
  }
  return {
    year: null
  };
}
function parseDate(dateString, year) {
  if (year === null) {
    return null;
  }
  let date;
  let month;
  let week;
  if (!dateString || !dateString.length) {
    date = /* @__PURE__ */ new Date(0);
    date.setUTCFullYear(year);
    return date;
  }
  let token = patterns.MM.exec(dateString);
  if (token) {
    date = /* @__PURE__ */ new Date(0);
    month = parseInt(token[1], 10) - 1;
    if (!validateDate(year, month)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    date.setUTCFullYear(year, month);
    return date;
  }
  token = patterns.DDD.exec(dateString);
  if (token) {
    date = /* @__PURE__ */ new Date(0);
    const dayOfYear = parseInt(token[1], 10);
    if (!validateDayOfYearDate(year, dayOfYear)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    date.setUTCFullYear(year, 0, dayOfYear);
    return date;
  }
  token = patterns.MMDD.exec(dateString);
  if (token) {
    date = /* @__PURE__ */ new Date(0);
    month = parseInt(token[1], 10) - 1;
    const day = parseInt(token[2], 10);
    if (!validateDate(year, month, day)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    date.setUTCFullYear(year, month, day);
    return date;
  }
  token = patterns.Www.exec(dateString);
  if (token) {
    week = parseInt(token[1], 10) - 1;
    if (!validateWeekDate(week)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    return dayOfISOWeekYear(year, week);
  }
  token = patterns.WwwD.exec(dateString);
  if (token) {
    week = parseInt(token[1], 10) - 1;
    const dayOfWeek = parseInt(token[2], 10) - 1;
    if (!validateWeekDate(week, dayOfWeek)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  }
  return null;
}
function parseTime(timeString) {
  let hours;
  let minutes;
  let token = patterns.HH.exec(timeString);
  if (token) {
    hours = parseFloat(token[1].replace(",", "."));
    if (!validateTime(hours)) {
      return NaN;
    }
    return hours % 24 * MILLISECONDS_IN_HOUR;
  }
  token = patterns.HHMM.exec(timeString);
  if (token) {
    hours = parseInt(token[1], 10);
    minutes = parseFloat(token[2].replace(",", "."));
    if (!validateTime(hours, minutes)) {
      return NaN;
    }
    return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;
  }
  token = patterns.HHMMSS.exec(timeString);
  if (token) {
    hours = parseInt(token[1], 10);
    minutes = parseInt(token[2], 10);
    const seconds = parseFloat(token[3].replace(",", "."));
    if (!validateTime(hours, minutes, seconds)) {
      return NaN;
    }
    return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1e3;
  }
  return null;
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
  week = week || 0;
  day = day || 0;
  const date = /* @__PURE__ */ new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  const fourthOfJanuaryDay = date.getUTCDay() || 7;
  const diff = week * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date) {
  if (month < 0 || month > 11) {
    return false;
  }
  if (date != null) {
    if (date < 1) {
      return false;
    }
    const isLeapYear = isLeapYearIndex(year);
    if (isLeapYear && date > DAYS_IN_MONTH_LEAP_YEAR[month]) {
      return false;
    }
    if (!isLeapYear && date > DAYS_IN_MONTH[month]) {
      return false;
    }
  }
  return true;
}
function validateDayOfYearDate(year, dayOfYear) {
  if (dayOfYear < 1) {
    return false;
  }
  const isLeapYear = isLeapYearIndex(year);
  if (isLeapYear && dayOfYear > 366) {
    return false;
  }
  if (!isLeapYear && dayOfYear > 365) {
    return false;
  }
  return true;
}
function validateWeekDate(week, day) {
  if (week < 0 || week > 52) {
    return false;
  }
  if (day != null && (day < 0 || day > 6)) {
    return false;
  }
  return true;
}
function validateTime(hours, minutes, seconds) {
  if (hours < 0 || hours >= 25) {
    return false;
  }
  if (minutes != null && (minutes < 0 || minutes >= 60)) {
    return false;
  }
  if (seconds != null && (seconds < 0 || seconds >= 60)) {
    return false;
  }
  return true;
}
const tzFormattingTokensRegExp = /([xXOz]+)|''|'(''|[^'])+('|$)/g;
function format(date, formatStr, options = {}) {
  formatStr = String(formatStr);
  const matches2 = formatStr.match(tzFormattingTokensRegExp);
  if (matches2) {
    const d3 = toDate(options.originalDate || date, options);
    formatStr = matches2.reduce(function(result, token) {
      if (token[0] === "'") {
        return result;
      }
      const pos = result.indexOf(token);
      const precededByQuotedSection = result[pos - 1] === "'";
      const replaced = result.replace(token, "'" + formatters[token[0]](d3, token, options) + "'");
      return precededByQuotedSection ? replaced.substring(0, pos - 1) + replaced.substring(pos + 1) : replaced;
    }, formatStr);
  }
  return format$1(date, formatStr, options);
}
function toZonedTime(date, timeZone, options) {
  date = toDate(date, options);
  const offsetMilliseconds = tzParseTimezone(timeZone, date, true);
  const d3 = new Date(date.getTime() - offsetMilliseconds);
  const resultDate = /* @__PURE__ */ new Date(0);
  resultDate.setFullYear(d3.getUTCFullYear(), d3.getUTCMonth(), d3.getUTCDate());
  resultDate.setHours(d3.getUTCHours(), d3.getUTCMinutes(), d3.getUTCSeconds(), d3.getUTCMilliseconds());
  return resultDate;
}
function formatInTimeZone(date, timeZone, formatStr, options) {
  options = {
    ...options,
    timeZone,
    originalDate: date
  };
  return format(toZonedTime(date, timeZone, { timeZone: options.timeZone }), formatStr, options);
}
function fromZonedTime(date, timeZone, options) {
  if (typeof date === "string" && !date.match(tzPattern)) {
    return toDate(date, { ...options, timeZone });
  }
  date = toDate(date, options);
  const utc = newDateUTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()).getTime();
  const offsetMilliseconds = tzParseTimezone(timeZone, new Date(utc));
  return new Date(utc + offsetMilliseconds);
}
function isBuffer(obj) {
  return obj && obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function keyIdentity(key2) {
  return key2;
}
function flatten(target, opts) {
  opts = opts || {};
  const delimiter = opts.delimiter || ".";
  const maxDepth = opts.maxDepth;
  const transformKey = opts.transformKey || keyIdentity;
  const output = {};
  function step(object, prev, currentDepth) {
    currentDepth = currentDepth || 1;
    Object.keys(object).forEach(function(key2) {
      const value = object[key2];
      const isarray = opts.safe && Array.isArray(value);
      const type = Object.prototype.toString.call(value);
      const isbuffer = isBuffer(value);
      const isobject = type === "[object Object]" || type === "[object Array]";
      const newKey = prev ? prev + delimiter + transformKey(key2) : transformKey(key2);
      if (!isarray && !isbuffer && isobject && Object.keys(value).length && (!opts.maxDepth || currentDepth < maxDepth)) {
        return step(value, newKey, currentDepth + 1);
      }
      output[newKey] = value;
    });
  }
  step(target);
  return output;
}
function unflatten(target, opts) {
  opts = opts || {};
  const delimiter = opts.delimiter || ".";
  const overwrite = opts.overwrite || false;
  const transformKey = opts.transformKey || keyIdentity;
  const result = {};
  const isbuffer = isBuffer(target);
  if (isbuffer || Object.prototype.toString.call(target) !== "[object Object]") {
    return target;
  }
  function getkey(key2) {
    const parsedKey = Number(key2);
    return isNaN(parsedKey) || key2.indexOf(".") !== -1 || opts.object ? key2 : parsedKey;
  }
  function addKeys(keyPrefix, recipient, target2) {
    return Object.keys(target2).reduce(function(result2, key2) {
      result2[keyPrefix + delimiter + key2] = target2[key2];
      return result2;
    }, recipient);
  }
  function isEmpty2(val) {
    const type = Object.prototype.toString.call(val);
    const isArray2 = type === "[object Array]";
    const isObject2 = type === "[object Object]";
    if (!val) {
      return true;
    } else if (isArray2) {
      return !val.length;
    } else if (isObject2) {
      return !Object.keys(val).length;
    }
  }
  target = Object.keys(target).reduce(function(result2, key2) {
    const type = Object.prototype.toString.call(target[key2]);
    const isObject2 = type === "[object Object]" || type === "[object Array]";
    if (!isObject2 || isEmpty2(target[key2])) {
      result2[key2] = target[key2];
      return result2;
    } else {
      return addKeys(
        key2,
        result2,
        flatten(target[key2], opts)
      );
    }
  }, {});
  Object.keys(target).forEach(function(key2) {
    const split = key2.split(delimiter).map(transformKey);
    let key1 = getkey(split.shift());
    let key22 = getkey(split[0]);
    let recipient = result;
    while (key22 !== void 0) {
      if (key1 === "__proto__") {
        return;
      }
      const type = Object.prototype.toString.call(recipient[key1]);
      const isobject = type === "[object Object]" || type === "[object Array]";
      if (!overwrite && !isobject && typeof recipient[key1] !== "undefined") {
        return;
      }
      if (overwrite && !isobject || !overwrite && recipient[key1] == null) {
        recipient[key1] = typeof key22 === "number" && !opts.object ? [] : {};
      }
      recipient = recipient[key1];
      if (split.length > 0) {
        key1 = getkey(split.shift());
        key22 = getkey(split[0]);
      }
    }
    recipient[key1] = unflatten(target[key2], opts);
  });
  return result;
}
const IContextKeyService = createDecorator$1("contextKeyService");
function hasVolume(info) {
  return info.visible_plots_set === "ohlcv";
}
const MILLISECONDS_FACTOR = {
  [
    "ticks"
    /* Ticks */
  ]: 1e3,
  [
    "seconds"
    /* Seconds */
  ]: 1e3,
  [
    "minutes"
    /* Minutes */
  ]: 60 * 1e3,
  [
    "days"
    /* Days */
  ]: 1440 * 60 * 1e3,
  [
    "weeks"
    /* Weeks */
  ]: 7 * 1440 * 60 * 1e3,
  [
    "months"
    /* Months */
  ]: NaN,
  [
    "range"
    /* Range */
  ]: NaN,
  [
    "invalid"
    /* Invalid */
  ]: NaN
};
const LETTER_TO_KIND_MAP = {
  T: "ticks",
  S: "seconds",
  D: "days",
  W: "weeks",
  M: "months",
  R: "range"
  /* Range */
};
const INTRADAY_KINDS = /* @__PURE__ */ new Set([
  "ticks",
  "seconds",
  "minutes"
  /* Minutes */
]);
const INTERVAL_REGEX = /^(\d*)([TSHDWMR])$/;
const MINUTES_REGEX = /^(\d+)$/;
function parseMultiplier(raw) {
  return raw.length === 0 ? 1 : parseInt(raw, 10);
}
function isHour(minuteMultiplier) {
  return minuteMultiplier >= 60 && minuteMultiplier % 60 === 0;
}
let Interval$1 = class Interval {
  constructor(kind, multiplier) {
    __publicField(this, "_kind");
    __publicField(this, "_multiplier");
    this._kind = "invalid";
    this._multiplier = 0;
    if (kind !== "invalid" && multiplier > 0) {
      this._kind = kind;
      this._multiplier = multiplier;
    }
  }
  kind() {
    return this._kind;
  }
  guiKind() {
    return this.isMinuteHours() ? "hours" : this._kind;
  }
  multiplier() {
    return this._multiplier;
  }
  isValid() {
    return this._kind !== "invalid" && this._multiplier > 0;
  }
  isIntraday() {
    return this.isValid() && INTRADAY_KINDS.has(this._kind);
  }
  isTicks() {
    return this._kind === "ticks";
  }
  is1Tick() {
    return this.isTicks() && this._multiplier === 1;
  }
  isSeconds() {
    return this._kind === "seconds";
  }
  isMinutes() {
    return this._kind === "minutes";
  }
  isMinuteHours() {
    return this.isMinutes() && isHour(this._multiplier);
  }
  isDays() {
    return this._kind === "days";
  }
  isWeeks() {
    return this._kind === "weeks";
  }
  isMonths() {
    return this._kind === "months";
  }
  isRange() {
    return this._kind === "range";
  }
  isDWM() {
    return this.isValid() && !this.isRange() && !this.isIntraday() && !this.isTicks();
  }
  isTimeBased() {
    return !this.isRange();
  }
  letter() {
    if (!this.isValid() || this.isMinutes()) return "";
    return this._kind[0].toUpperCase();
  }
  value() {
    if (!this.isValid()) return "";
    return this.isMinutes() ? `${this._multiplier}` : `${this._multiplier}${this.letter()}`;
  }
  isEqualTo(other) {
    if (!(other instanceof Interval)) {
      throw new Error("Argument is not an Interval");
    }
    return this.isValid() && other.isValid() && this._kind === other.kind() && this._multiplier === other.multiplier();
  }
  inMilliseconds(referenceTime = Date.now()) {
    if (!this.isValid() || this.isRange()) return NaN;
    if (this.isMonths()) {
      const date = new Date(referenceTime);
      date.setUTCMonth(date.getUTCMonth() + this._multiplier);
      return date.valueOf() - referenceTime;
    }
    return (MILLISECONDS_FACTOR[this._kind] ?? NaN) * this._multiplier;
  }
  // Static factory methods
  static parse(raw) {
    return Interval.parseExt(raw).interval;
  }
  static kind(raw) {
    return Interval.parse(raw).kind();
  }
  static isEqual(a2, b2) {
    return Interval.parse(a2).isEqualTo(Interval.parse(b2));
  }
  static isValid(raw) {
    return Interval.parse(raw).isValid();
  }
  static isTicks(raw) {
    return Interval.parse(raw).isTicks();
  }
  static isRange(raw) {
    return Interval.parse(raw).isRange();
  }
  static isMinutes(raw) {
    return Interval.parse(raw).isMinutes();
  }
  static isMinuteHours(raw) {
    return Interval.parse(raw).isMinuteHours();
  }
  static isIntraday(raw) {
    return Interval.parse(raw).isIntraday();
  }
  static isDWM(raw) {
    return Interval.parse(raw).isDWM();
  }
  static isTimeBased(raw) {
    return Interval.parse(raw).isTimeBased();
  }
  static normalize(raw) {
    const interval = Interval.parse(raw);
    return interval.isValid() ? interval.value() : null;
  }
  // More flexible parse that returns gui category
  static parseExt(input) {
    const upper = String(input).toUpperCase().split(",")[0];
    let match2 = INTERVAL_REGEX.exec(upper);
    if (match2) {
      const multiplier = parseMultiplier(match2[1]);
      const kindLetter = match2[2];
      if (kindLetter === "H") {
        return {
          interval: new Interval("minutes", multiplier * 60),
          guiResolutionKind: "hours"
          /* Hours */
        };
      } else {
        const kind = LETTER_TO_KIND_MAP[kindLetter];
        return {
          interval: new Interval(kind, multiplier),
          guiResolutionKind: kind
        };
      }
    }
    match2 = MINUTES_REGEX.exec(upper);
    if (match2) {
      return {
        interval: new Interval("minutes", parseInt(match2[1], 10)),
        guiResolutionKind: "minutes"
        /* Minutes */
      };
    }
    return {
      interval: new Interval("invalid", 0),
      guiResolutionKind: "invalid"
      /* Invalid */
    };
  }
};
const InputEventType = EventType$1;
class BaseEvent {
  constructor(type, source2) {
    __publicField(this, "accepted", false);
    this.type = type;
    this.source = source2;
  }
  accept() {
    this.accepted = true;
  }
  ignore() {
    this.accepted = false;
  }
  isAccepted() {
    return this.accepted;
  }
  asMouseInputEvent() {
    return void 0;
  }
  isMouseInputEvent() {
    return false;
  }
  asChartInputEvent() {
    return void 0;
  }
  isChartInputEvent() {
    return false;
  }
  asKeyboardInputEvent() {
    return void 0;
  }
  isKeyboardInputEvent() {
    return false;
  }
}
class MouseInputEvent extends BaseEvent {
  constructor(type, init2, source2) {
    super(type, source2);
    __publicField(this, "localX");
    __publicField(this, "localY");
    __publicField(this, "shiftKey");
    __publicField(this, "originEvent");
    this.localX = init2.localX;
    this.localY = init2.localY;
    this.shiftKey = init2.shiftKey;
    this.originEvent = init2.browserEvent;
  }
  asMouseInputEvent() {
    return this;
  }
  isMouseInputEvent() {
    return true;
  }
}
class ChartInputEvent extends MouseInputEvent {
  constructor(type, params, source2) {
    var _a3, _b3, _c2;
    super(
      type,
      {
        // @ts-expect-error ignore
        browserEvent: params.sourceEvent,
        localX: ((_a3 = params.point) == null ? void 0 : _a3.x) ?? NaN,
        localY: ((_b3 = params.point) == null ? void 0 : _b3.y) ?? NaN,
        shiftKey: !!((_c2 = params.sourceEvent) == null ? void 0 : _c2.shiftKey)
      },
      source2
    );
    this.params = params;
  }
  get hoveredObjectId() {
    return this.params.hoveredObjectId;
  }
  get hoveredSeries() {
    return this.params.hoveredSeries;
  }
  get logical() {
    return this.params.logical;
  }
  get paneIndex() {
    return this.params.paneIndex;
  }
  get point() {
    return this.params.point;
  }
  get seriesData() {
    return this.params.seriesData;
  }
  get sourceEvent() {
    return this.params.sourceEvent;
  }
  get time() {
    return this.params.time;
  }
  asChartInputEvent() {
    return this;
  }
  isChartInputEvent() {
    return true;
  }
}
class KeyboardInputEvent extends BaseEvent {
  constructor(type, init2, source2) {
    super(type, source2);
    __publicField(this, "ctrlKey");
    __publicField(this, "shiftKey");
    __publicField(this, "altKey");
    __publicField(this, "metaKey");
    __publicField(this, "keyCode");
    __publicField(this, "code");
    __publicField(this, "init");
    this.ctrlKey = init2.ctrlKey;
    this.shiftKey = init2.shiftKey;
    this.altKey = init2.altKey;
    this.metaKey = init2.metaKey;
    this.keyCode = init2.keyCode;
    this.code = init2.code;
    this.init = init2;
  }
  asKeyboardInputEvent() {
    return this;
  }
  isKeyboardInputEvent() {
    return true;
  }
}
class ServiceCollection {
  constructor(...entries) {
    __publicField(this, "_entries", /* @__PURE__ */ new Map());
    for (const [id2, service] of entries) {
      this.set(id2, service);
    }
  }
  set(id2, instanceOrDescriptor) {
    const result = this._entries.get(id2);
    this._entries.set(id2, instanceOrDescriptor);
    return result;
  }
  has(id2) {
    return this._entries.has(id2);
  }
  get(id2) {
    return this._entries.get(id2);
  }
}
const IIntlService = createDecorator$1("intlService");
const IStudyService = createDecorator$1("studyService");
const studyRegistry = new class extends GenericRegistry {
}();
var ColorScheme = /* @__PURE__ */ ((ColorScheme2) => {
  ColorScheme2["DARK"] = "dark";
  ColorScheme2["LIGHT"] = "light";
  return ColorScheme2;
})(ColorScheme || {});
const IThemeService = createDecorator$1("themeService");
const chartDefaultProperties = {
  timezone: "exchange",
  "mainSeriesProperties.style": ChartStyleType.Candle,
  "mainSeriesProperties.statusViewStyle.showExchange": false,
  "mainSeriesProperties.statusViewStyle.showInterval": true,
  "mainSeriesProperties.statusViewStyle.symbolTextSource": "description",
  "mainSeriesProperties.candleStyle.upColor": "#089981",
  "mainSeriesProperties.candleStyle.downColor": "#F23645",
  "mainSeriesProperties.candleStyle.drawWick": true,
  "mainSeriesProperties.candleStyle.drawBorder": false,
  "mainSeriesProperties.candleStyle.borderColor": "#378658",
  "mainSeriesProperties.candleStyle.borderUpColor": "#089981",
  "mainSeriesProperties.candleStyle.borderDownColor": "#F23645",
  "mainSeriesProperties.candleStyle.wickColor": "#737375",
  "mainSeriesProperties.candleStyle.wickUpColor": "#089981",
  "mainSeriesProperties.candleStyle.wickDownColor": "#F23645",
  "mainSeriesProperties.candleStyle.barColorsOnPrevClose": false,
  "mainSeriesProperties.candleStyle.drawBody": true,
  "mainSeriesProperties.hollowCandleStyle.upColor": "#089981",
  "mainSeriesProperties.hollowCandleStyle.downColor": "#F23645",
  "mainSeriesProperties.hollowCandleStyle.drawWick": true,
  "mainSeriesProperties.hollowCandleStyle.drawBorder": true,
  "mainSeriesProperties.hollowCandleStyle.borderColor": "#378658",
  "mainSeriesProperties.hollowCandleStyle.borderUpColor": "#089981",
  "mainSeriesProperties.hollowCandleStyle.borderDownColor": "#F23645",
  "mainSeriesProperties.hollowCandleStyle.wickColor": "#737375",
  "mainSeriesProperties.hollowCandleStyle.wickUpColor": "#089981",
  "mainSeriesProperties.hollowCandleStyle.wickDownColor": "#F23645",
  "mainSeriesProperties.hollowCandleStyle.drawBody": true,
  "mainSeriesProperties.barStyle.upColor": "#089981",
  "mainSeriesProperties.barStyle.downColor": "#F23645",
  "mainSeriesProperties.barStyle.barColorsOnPrevClose": false,
  "mainSeriesProperties.barStyle.dontDrawOpen": false,
  "mainSeriesProperties.barStyle.thinBars": true,
  "mainSeriesProperties.lineStyle.color": "#2962FF",
  "mainSeriesProperties.lineStyle.linestyle": 0,
  "mainSeriesProperties.lineStyle.linewidth": 2,
  "mainSeriesProperties.lineStyle.priceSource": "close",
  "mainSeriesProperties.areaStyle.color1": "rgba(41, 98, 255, 0)",
  "mainSeriesProperties.areaStyle.color2": "rgba(41, 98, 255, 0.28)",
  "mainSeriesProperties.areaStyle.linecolor": "#2962FF",
  "mainSeriesProperties.areaStyle.linestyle": 0,
  "mainSeriesProperties.areaStyle.linewidth": 2,
  "mainSeriesProperties.areaStyle.priceSource": "close",
  "mainSeriesProperties.areaStyle.transparency": 100,
  // 样式已经在 chartThemes 定义
  "layout.background.color": "",
  "layout.background.type": "",
  "layout.background.topColor": "",
  "layout.background.bottomColor": "",
  "grid.vertLines.color": "",
  "grid.vertLines.style": 0,
  "grid.vertLines.visible": true,
  "grid.horzLines.color": "",
  "grid.horzLines.style": 0,
  "grid.horzLines.visible": true,
  "legend.showSeriesTitle": true,
  "legend.showBarChange": true,
  "scales.showStudyLastValue": true,
  "tool.tradeLine.buyColor": "#2A62FF",
  "tool.tradeLine.sellColor": "#F23644",
  "tool.tradeLine.tpColor": "#089981",
  "tool.tradeLine.slColor": "#FF9800"
};
class ChartContributions extends Disposable {
  constructor() {
    super();
    __publicField(this, "_instantiationService", null);
    /**
     * Contains all instantiated contributions.
     */
    __publicField(this, "_instances", this._register(new DisposableMap()));
    /**
     * Contains contributions which are not yet instantiated.
     */
    __publicField(this, "_pending", /* @__PURE__ */ new Map());
    /**
     * Tracks which instantiation kinds are still left in `_pending`.
     */
    __publicField(this, "_finishedInstantiation", []);
    this._finishedInstantiation[ChartContributionInstantiation.Eager] = false;
    this._finishedInstantiation[ChartContributionInstantiation.AfterFirstRender] = false;
    this._finishedInstantiation[ChartContributionInstantiation.Eventually] = false;
  }
  initialize(contributions, instantiationService) {
    this._instantiationService = instantiationService;
    for (const desc of contributions) {
      if (this._pending.has(desc.id)) {
        onUnexpectedError(new Error(`Cannot have two contributions with the same id ${desc.id}`));
        continue;
      }
      this._pending.set(desc.id, desc);
    }
    this._instantiateSome(ChartContributionInstantiation.Eager);
    this._register(
      runWhenIdle(() => {
        this._instantiateSome(ChartContributionInstantiation.AfterFirstRender);
      })
    );
    this._register(
      runWhenIdle(() => {
        this._instantiateSome(ChartContributionInstantiation.Eventually);
      }, 5e3)
    );
  }
  async get(id2) {
    await this._instantiateById(id2);
    return this._instances.get(id2) || null;
  }
  getNotInit(id2) {
    return this._instances.get(id2) || null;
  }
  _instantiateSome(instantiation) {
    if (this._finishedInstantiation[instantiation]) {
      return;
    }
    this._finishedInstantiation[instantiation] = true;
    const contribs = this._findPendingContributionsByInstantiation(instantiation);
    for (const contrib of contribs) {
      this._instantiateById(contrib.id);
    }
  }
  _findPendingContributionsByInstantiation(instantiation) {
    const result = [];
    for (const [, desc] of this._pending) {
      if (desc.instantiation === instantiation) {
        result.push(desc);
      }
    }
    return result;
  }
  async _instantiateById(id2) {
    const desc = this._pending.get(id2);
    if (!desc) {
      return;
    }
    this._pending.delete(id2);
    if (!this._instantiationService) {
      throw new Error(`Cannot instantiate contributions before being initialized!`);
    }
    try {
      const ctor = await desc.ctor();
      const instance = this._instantiationService.createInstance(ctor);
      this._instances.set(desc.id, instance);
    } catch (err) {
      onUnexpectedError(err);
    }
  }
}
function scheduleTimeout0(callback) {
  const task = {
    callback
  };
  setTimeout0(() => {
    var _a3;
    (_a3 = task.callback) == null ? void 0 : _a3.call(task);
  });
  return () => {
    task.callback = null;
  };
}
function scheduleTimeout(callback, ms2) {
  const timer = setTimeout(callback, ms2);
  return () => {
    clearTimeout(timer);
  };
}
function scheduleIdle(callback) {
  const task = {
    callback
  };
  runWhenIdle(() => {
    var _a3;
    (_a3 = task.callback) == null ? void 0 : _a3.call(task);
  });
  return () => {
    task.callback = null;
  };
}
function isNumberEqual(num1, num2, epsilon = 1e-3) {
  return Math.abs(num1 - num2) < epsilon;
}
function clamp(value, edge1, edge2) {
  const min = Math.min(edge1, edge2);
  const max = Math.max(edge1, edge2);
  return Math.min(Math.max(value, min), max);
}
function ceiledEven(x2) {
  const ceiled = Math.ceil(x2);
  return ceiled % 2 !== 0 ? ceiled - 1 : ceiled;
}
function sign(e2) {
  return e2 < 0 ? -1 : e2 > 0 ? 1 : 0;
}
function isEven(e2) {
  return e2 % 2 == 0;
}
function arePointsEqual(p1, p2) {
  return isNumberEqual(p1.x, p2.x) && isNumberEqual(p1.y, p2.y);
}
function euclideanDistance(x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}
function euclideanDistanceBetweenPoints(p0, p1) {
  return euclideanDistance(p0.x, p0.y, p1.x, p1.y);
}
function midPoint(p1, p2) {
  return new Point({
    x: p1.x + (p2.x - p1.x) / 2,
    y: p1.y + (p2.y - p1.y) / 2
  });
}
class Point {
  constructor(x2, y2) {
    __publicField(this, "x");
    __publicField(this, "y");
    if (isNumber(x2)) {
      this.x = x2;
      this.y = ensure(y2);
    } else {
      this.x = x2.x;
      this.y = x2.y;
    }
  }
  /** 返回当前点和另一个点相加后的新 Point。 */
  add(other) {
    return new Point(this.x + other.x, this.y + other.y);
  }
  /**
   * 返回当前向量加上一个缩放后的向量：this + n * other。
   * 通常用于线性插值。
   */
  addScaled(other, scale) {
    return new Point(this.x + scale * other.x, this.y + scale * other.y);
  }
  /** 返回当前点减去另一个点后的新 Point。 */
  subtract(other) {
    return new Point(this.x - other.x, this.y - other.y);
  }
  /** 与另一个向量做点积（内积），可用于夹角计算。 */
  dotProduct(other) {
    return this.x * other.x + this.y * other.y;
  }
  /**
   * 与另一个向量做叉积（仅限二维使用）。
   * 返回 this × other 的结果（标量值）。
   */
  crossProduct(other) {
    return this.x * other.y - this.y * other.x;
  }
  /**
   * 返回当前向量与另一向量之间的有符号夹角（弧度制）。
   * 正数表示逆时针夹角，负数为顺时针。
   */
  signedAngle(other) {
    return Math.atan2(this.crossProduct(other), this.dotProduct(other));
  }
  /**
   * 返回当前向量与另一向量之间的夹角（弧度制，始终为正）。
   */
  angle(other) {
    return Math.acos(this.dotProduct(other) / (this.length() * other.length()));
  }
  /** 返回当前向量的模（长度）。 */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  /** 返回按照指定缩放倍数的新向量。 */
  scaled(factor) {
    return new Point(this.x * factor, this.y * factor);
  }
  /** 返回当前向量的单位向量（方向不变，长度为 1）。 */
  normalized() {
    const len = this.length();
    return len === 0 ? this : this.scaled(1 / len);
  }
  /** 返回当前向量的逆时针 90 度旋转向量（等价于转置）。 */
  transposed() {
    return new Point(-this.y, this.x);
  }
  /** 创建当前点/向量的副本。 */
  clone() {
    return new Point(this.x, this.y);
  }
}
const AnchorResizeE = 1 << 0;
const AnchorResizeS = 1 << 1;
const AnchorResizeW = 1 << 2;
const AnchorResizeN = 1 << 3;
const AnchorResizeHorz = AnchorResizeE | AnchorResizeW;
const AnchorResizeVert = AnchorResizeS | AnchorResizeN;
const AnchorResizeAll = AnchorResizeHorz | AnchorResizeVert;
function canResize(num, mask) {
  return (num & mask) !== 0;
}
function canResizeE(num) {
  return canResize(num, AnchorResizeE);
}
function canResizeS(num) {
  return canResize(num, AnchorResizeS);
}
function canResizeW(num) {
  return canResize(num, AnchorResizeW);
}
function canResizeN(num) {
  return canResize(num, AnchorResizeN);
}
function canResizeHorz(num) {
  return canResizeE(num) || canResizeW(num);
}
function canResizeVert(num) {
  return canResizeN(num) || canResizeS(num);
}
function canResizeAll(num) {
  return canResizeVert(num) && canResizeHorz(num);
}
var HitTarget = /* @__PURE__ */ ((HitTarget2) => {
  HitTarget2[HitTarget2["None"] = 0] = "None";
  HitTarget2[HitTarget2["Regular"] = 1] = "Regular";
  HitTarget2[HitTarget2["MovePoint"] = 2] = "MovePoint";
  HitTarget2[HitTarget2["ChangePoint"] = 3] = "ChangePoint";
  HitTarget2[HitTarget2["Custom"] = 4] = "Custom";
  return HitTarget2;
})(HitTarget || {});
var AreaName = /* @__PURE__ */ ((AreaName2) => {
  AreaName2[AreaName2["Text"] = 0] = "Text";
  AreaName2[AreaName2["AnchorPoint"] = 1] = "AnchorPoint";
  AreaName2[AreaName2["Btn"] = 2] = "Btn";
  return AreaName2;
})(AreaName || {});
function isAnchorDetails(obj) {
  if (!obj) return false;
  return "areaName" in obj && obj.areaName === AreaName.AnchorPoint;
}
function isTextDetails(obj) {
  if (!obj) return false;
  return "areaName" in obj && obj.areaName === AreaName.Text;
}
class HitTestResult {
  constructor(target, details) {
    this.target = target;
    this.details = details;
  }
  mergeData(d3) {
    if (!this.details) {
      this.details = d3;
    } else {
      Object.assign(this.details, d3);
    }
  }
}
const DragEffectMinDistance = 5;
const MouseTolerance = {
  common: 3,
  line: 3,
  minDistanceBetweenPoints: 5,
  series: 2,
  curve: 3,
  anchor: 2,
  esd: 0
};
function interactionTolerance() {
  return MouseTolerance;
}
function getXCoordinate(chartService, x2, opt) {
  if (opt == null ? void 0 : opt.clamp) {
    const width = chartService.chartApi.timeScale().width();
    x2 = clamp(x2, 0, width);
  }
  if (opt == null ? void 0 : opt.useExtended) {
    return chartService.chartApi.timeScale().coordinateToTimeEx(x2);
  }
  let time = chartService.chartApi.timeScale().coordinateToTime(x2);
  if (!time) {
    const bars = chartService.mainSeriesApi.getSeries().data();
    const lastBar = bars[bars.length - 1];
    const lastX = ensure(chartService.chartApi.timeScale().timeToCoordinate(lastBar.time));
    should(x2 >= lastX);
    time = lastBar.time;
  }
  return time;
}
function isValidPosition(pos) {
  return isFinite(pos.x) && isFinite(pos.y) && isFiniteNumber(pos.paneIndex) && isFinite(pos.paneIndex);
}
function getLightenRGBA(color, alpha = 0.28) {
  should(color.startsWith("#"));
  const alphaHex = alphaToHex(alpha);
  if (color.length === 7) {
    return color + alphaHex;
  } else {
    return color.substring(0, 7) + alphaHex;
  }
}
function alphaToHex(alpha) {
  const clamped = Math.min(1, Math.max(0, alpha));
  const intVal = Math.round(clamped * 255);
  return intVal.toString(16).padStart(2, "0").toUpperCase();
}
const DemoHighlightBackground = getLightenRGBA("#f67782");
const TwoPI = 2 * Math.PI;
class PanePrimitive {
  constructor(chart) {
    __publicField(this, "_chart");
    __publicField(this, "_requestUpdate");
    if (chart) this._chart = chart;
  }
  requestUpdate() {
    if (this._requestUpdate) this._requestUpdate();
  }
  attached({ chart, requestUpdate }) {
    this._chart = chart;
    this._requestUpdate = requestUpdate;
    this.requestUpdate();
  }
  detached() {
    this._chart = void 0;
    this._requestUpdate = void 0;
  }
  get chart() {
    return ensure(this._chart);
  }
}
class DemoHighlightPaneRenderer {
  constructor(_data) {
    this._data = _data;
  }
  draw(target) {
    target.useBitmapCoordinateSpace((scope) => {
      const { x: x2, y: y2, background, radius } = this._data;
      if (x2 < 0 || y2 < 0) return;
      const ctx = scope.context;
      ctx.fillStyle = background;
      ctx.beginPath();
      ctx.arc(
        x2 * scope.horizontalPixelRatio,
        y2 * scope.verticalPixelRatio,
        radius * scope.horizontalPixelRatio,
        0,
        TwoPI,
        false
      );
      ctx.fill();
    });
  }
}
class DemoHighlightPaneView {
  constructor(_data) {
    this._data = _data;
  }
  renderer() {
    return new DemoHighlightPaneRenderer(this._data);
  }
  zOrder() {
    return "top";
  }
  update(data) {
    this._data = data;
  }
}
class DemoHighlightPrimitive extends PanePrimitive {
  constructor(_data, detach) {
    super();
    __publicField(this, "_paneView");
    this._data = _data;
    this.detach = detach;
    this._paneView = [new DemoHighlightPaneView(_data)];
  }
  updateData(data) {
    Object.assign(this._data, data);
    this.updateAllViews();
    this.requestUpdate();
  }
  paneViews() {
    return this._paneView;
  }
  updateAllViews() {
    this._paneView.forEach((pw) => pw.update(this._data));
  }
}
const IClipboardService = createDecorator$1("clipboardService");
const IGuiService = createDecorator$1("guiService");
const IToolService = createDecorator$1("IToolService");
const IToolRegistry = createDecorator$1("toolRegistry");
var TriggerSource = /* @__PURE__ */ ((TriggerSource2) => {
  TriggerSource2[TriggerSource2["manual"] = 0] = "manual";
  TriggerSource2[TriggerSource2["program"] = 1] = "program";
  return TriggerSource2;
})(TriggerSource || {});
var ToolInvocationPhase = /* @__PURE__ */ ((ToolInvocationPhase2) => {
  ToolInvocationPhase2[ToolInvocationPhase2["idle"] = 0] = "idle";
  ToolInvocationPhase2[ToolInvocationPhase2["activated"] = 1] = "activated";
  return ToolInvocationPhase2;
})(ToolInvocationPhase || {});
var CharCode = /* @__PURE__ */ ((CharCode2) => {
  CharCode2[CharCode2["Null"] = 0] = "Null";
  CharCode2[CharCode2["Backspace"] = 8] = "Backspace";
  CharCode2[CharCode2["Tab"] = 9] = "Tab";
  CharCode2[CharCode2["LineFeed"] = 10] = "LineFeed";
  CharCode2[CharCode2["CarriageReturn"] = 13] = "CarriageReturn";
  CharCode2[CharCode2["Space"] = 32] = "Space";
  CharCode2[CharCode2["ExclamationMark"] = 33] = "ExclamationMark";
  CharCode2[CharCode2["DoubleQuote"] = 34] = "DoubleQuote";
  CharCode2[CharCode2["Hash"] = 35] = "Hash";
  CharCode2[CharCode2["DollarSign"] = 36] = "DollarSign";
  CharCode2[CharCode2["PercentSign"] = 37] = "PercentSign";
  CharCode2[CharCode2["Ampersand"] = 38] = "Ampersand";
  CharCode2[CharCode2["SingleQuote"] = 39] = "SingleQuote";
  CharCode2[CharCode2["OpenParen"] = 40] = "OpenParen";
  CharCode2[CharCode2["CloseParen"] = 41] = "CloseParen";
  CharCode2[CharCode2["Asterisk"] = 42] = "Asterisk";
  CharCode2[CharCode2["Plus"] = 43] = "Plus";
  CharCode2[CharCode2["Comma"] = 44] = "Comma";
  CharCode2[CharCode2["Dash"] = 45] = "Dash";
  CharCode2[CharCode2["Period"] = 46] = "Period";
  CharCode2[CharCode2["Slash"] = 47] = "Slash";
  CharCode2[CharCode2["Digit0"] = 48] = "Digit0";
  CharCode2[CharCode2["Digit1"] = 49] = "Digit1";
  CharCode2[CharCode2["Digit2"] = 50] = "Digit2";
  CharCode2[CharCode2["Digit3"] = 51] = "Digit3";
  CharCode2[CharCode2["Digit4"] = 52] = "Digit4";
  CharCode2[CharCode2["Digit5"] = 53] = "Digit5";
  CharCode2[CharCode2["Digit6"] = 54] = "Digit6";
  CharCode2[CharCode2["Digit7"] = 55] = "Digit7";
  CharCode2[CharCode2["Digit8"] = 56] = "Digit8";
  CharCode2[CharCode2["Digit9"] = 57] = "Digit9";
  CharCode2[CharCode2["Colon"] = 58] = "Colon";
  CharCode2[CharCode2["Semicolon"] = 59] = "Semicolon";
  CharCode2[CharCode2["LessThan"] = 60] = "LessThan";
  CharCode2[CharCode2["Equals"] = 61] = "Equals";
  CharCode2[CharCode2["GreaterThan"] = 62] = "GreaterThan";
  CharCode2[CharCode2["QuestionMark"] = 63] = "QuestionMark";
  CharCode2[CharCode2["AtSign"] = 64] = "AtSign";
  CharCode2[CharCode2["A"] = 65] = "A";
  CharCode2[CharCode2["B"] = 66] = "B";
  CharCode2[CharCode2["C"] = 67] = "C";
  CharCode2[CharCode2["D"] = 68] = "D";
  CharCode2[CharCode2["E"] = 69] = "E";
  CharCode2[CharCode2["F"] = 70] = "F";
  CharCode2[CharCode2["G"] = 71] = "G";
  CharCode2[CharCode2["H"] = 72] = "H";
  CharCode2[CharCode2["I"] = 73] = "I";
  CharCode2[CharCode2["J"] = 74] = "J";
  CharCode2[CharCode2["K"] = 75] = "K";
  CharCode2[CharCode2["L"] = 76] = "L";
  CharCode2[CharCode2["M"] = 77] = "M";
  CharCode2[CharCode2["N"] = 78] = "N";
  CharCode2[CharCode2["O"] = 79] = "O";
  CharCode2[CharCode2["P"] = 80] = "P";
  CharCode2[CharCode2["Q"] = 81] = "Q";
  CharCode2[CharCode2["R"] = 82] = "R";
  CharCode2[CharCode2["S"] = 83] = "S";
  CharCode2[CharCode2["T"] = 84] = "T";
  CharCode2[CharCode2["U"] = 85] = "U";
  CharCode2[CharCode2["V"] = 86] = "V";
  CharCode2[CharCode2["W"] = 87] = "W";
  CharCode2[CharCode2["X"] = 88] = "X";
  CharCode2[CharCode2["Y"] = 89] = "Y";
  CharCode2[CharCode2["Z"] = 90] = "Z";
  CharCode2[CharCode2["OpenSquareBracket"] = 91] = "OpenSquareBracket";
  CharCode2[CharCode2["Backslash"] = 92] = "Backslash";
  CharCode2[CharCode2["CloseSquareBracket"] = 93] = "CloseSquareBracket";
  CharCode2[CharCode2["Caret"] = 94] = "Caret";
  CharCode2[CharCode2["Underline"] = 95] = "Underline";
  CharCode2[CharCode2["BackTick"] = 96] = "BackTick";
  CharCode2[CharCode2["a"] = 97] = "a";
  CharCode2[CharCode2["b"] = 98] = "b";
  CharCode2[CharCode2["c"] = 99] = "c";
  CharCode2[CharCode2["d"] = 100] = "d";
  CharCode2[CharCode2["e"] = 101] = "e";
  CharCode2[CharCode2["f"] = 102] = "f";
  CharCode2[CharCode2["g"] = 103] = "g";
  CharCode2[CharCode2["h"] = 104] = "h";
  CharCode2[CharCode2["i"] = 105] = "i";
  CharCode2[CharCode2["j"] = 106] = "j";
  CharCode2[CharCode2["k"] = 107] = "k";
  CharCode2[CharCode2["l"] = 108] = "l";
  CharCode2[CharCode2["m"] = 109] = "m";
  CharCode2[CharCode2["n"] = 110] = "n";
  CharCode2[CharCode2["o"] = 111] = "o";
  CharCode2[CharCode2["p"] = 112] = "p";
  CharCode2[CharCode2["q"] = 113] = "q";
  CharCode2[CharCode2["r"] = 114] = "r";
  CharCode2[CharCode2["s"] = 115] = "s";
  CharCode2[CharCode2["t"] = 116] = "t";
  CharCode2[CharCode2["u"] = 117] = "u";
  CharCode2[CharCode2["v"] = 118] = "v";
  CharCode2[CharCode2["w"] = 119] = "w";
  CharCode2[CharCode2["x"] = 120] = "x";
  CharCode2[CharCode2["y"] = 121] = "y";
  CharCode2[CharCode2["z"] = 122] = "z";
  CharCode2[CharCode2["OpenCurlyBrace"] = 123] = "OpenCurlyBrace";
  CharCode2[CharCode2["Pipe"] = 124] = "Pipe";
  CharCode2[CharCode2["CloseCurlyBrace"] = 125] = "CloseCurlyBrace";
  CharCode2[CharCode2["Tilde"] = 126] = "Tilde";
  CharCode2[CharCode2["NoBreakSpace"] = 160] = "NoBreakSpace";
  return CharCode2;
})(CharCode || {});
function roundFloat(number, decimalPoints) {
  const decimal = Math.pow(10, decimalPoints);
  return Math.round(number * decimal) / decimal;
}
class RGBA {
  constructor(r2, g2, b2, a2 = 1) {
    __publicField(this, "_rgbaBrand");
    /**
     * Red: integer in [0-255]
     */
    __publicField(this, "r");
    /**
     * Green: integer in [0-255]
     */
    __publicField(this, "g");
    /**
     * Blue: integer in [0-255]
     */
    __publicField(this, "b");
    /**
     * Alpha: float in [0-1]
     */
    __publicField(this, "a");
    this.r = Math.min(255, Math.max(0, r2)) | 0;
    this.g = Math.min(255, Math.max(0, g2)) | 0;
    this.b = Math.min(255, Math.max(0, b2)) | 0;
    this.a = roundFloat(Math.max(Math.min(1, a2), 0), 3);
  }
  static equals(a2, b2) {
    return a2.r === b2.r && a2.g === b2.g && a2.b === b2.b && a2.a === b2.a;
  }
}
class HSLA {
  constructor(h2, s2, l2, a2) {
    __publicField(this, "_hslaBrand");
    /**
     * Hue: integer in [0, 360]
     */
    __publicField(this, "h");
    /**
     * Saturation: float in [0, 1]
     */
    __publicField(this, "s");
    /**
     * Luminosity: float in [0, 1]
     */
    __publicField(this, "l");
    /**
     * Alpha: float in [0, 1]
     */
    __publicField(this, "a");
    this.h = Math.max(Math.min(360, h2), 0) | 0;
    this.s = roundFloat(Math.max(Math.min(1, s2), 0), 3);
    this.l = roundFloat(Math.max(Math.min(1, l2), 0), 3);
    this.a = roundFloat(Math.max(Math.min(1, a2), 0), 3);
  }
  static equals(a2, b2) {
    return a2.h === b2.h && a2.s === b2.s && a2.l === b2.l && a2.a === b2.a;
  }
  /**
   * Converts an RGB color value to HSL. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes r, g, and b are contained in the set [0, 255] and
   * returns h in the set [0, 360], s, and l in the set [0, 1].
   */
  static fromRGBA(rgba2) {
    const r2 = rgba2.r / 255;
    const g2 = rgba2.g / 255;
    const b2 = rgba2.b / 255;
    const a2 = rgba2.a;
    const max = Math.max(r2, g2, b2);
    const min = Math.min(r2, g2, b2);
    let h2 = 0;
    let s2 = 0;
    const l2 = (min + max) / 2;
    const chroma = max - min;
    if (chroma > 0) {
      s2 = Math.min(l2 <= 0.5 ? chroma / (2 * l2) : chroma / (2 - 2 * l2), 1);
      switch (max) {
        case r2:
          h2 = (g2 - b2) / chroma + (g2 < b2 ? 6 : 0);
          break;
        case g2:
          h2 = (b2 - r2) / chroma + 2;
          break;
        case b2:
          h2 = (r2 - g2) / chroma + 4;
          break;
      }
      h2 *= 60;
      h2 = Math.round(h2);
    }
    return new HSLA(h2, s2, l2, a2);
  }
  static _hue2rgb(p2, q2, t2) {
    if (t2 < 0) {
      t2 += 1;
    }
    if (t2 > 1) {
      t2 -= 1;
    }
    if (t2 < 1 / 6) {
      return p2 + (q2 - p2) * 6 * t2;
    }
    if (t2 < 1 / 2) {
      return q2;
    }
    if (t2 < 2 / 3) {
      return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
    }
    return p2;
  }
  /**
   * Converts an HSL color value to RGB. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and
   * returns r, g, and b in the set [0, 255].
   */
  static toRGBA(hsla) {
    const h2 = hsla.h / 360;
    const { s: s2, l: l2, a: a2 } = hsla;
    let r2, g2, b2;
    if (s2 === 0) {
      r2 = g2 = b2 = l2;
    } else {
      const q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
      const p2 = 2 * l2 - q2;
      r2 = HSLA._hue2rgb(p2, q2, h2 + 1 / 3);
      g2 = HSLA._hue2rgb(p2, q2, h2);
      b2 = HSLA._hue2rgb(p2, q2, h2 - 1 / 3);
    }
    return new RGBA(Math.round(r2 * 255), Math.round(g2 * 255), Math.round(b2 * 255), a2);
  }
}
class HSVA {
  constructor(h2, s2, v2, a2) {
    __publicField(this, "_hsvaBrand");
    /**
     * Hue: integer in [0, 360]
     */
    __publicField(this, "h");
    /**
     * Saturation: float in [0, 1]
     */
    __publicField(this, "s");
    /**
     * Value: float in [0, 1]
     */
    __publicField(this, "v");
    /**
     * Alpha: float in [0, 1]
     */
    __publicField(this, "a");
    this.h = Math.max(Math.min(360, h2), 0) | 0;
    this.s = roundFloat(Math.max(Math.min(1, s2), 0), 3);
    this.v = roundFloat(Math.max(Math.min(1, v2), 0), 3);
    this.a = roundFloat(Math.max(Math.min(1, a2), 0), 3);
  }
  static equals(a2, b2) {
    return a2.h === b2.h && a2.s === b2.s && a2.v === b2.v && a2.a === b2.a;
  }
  // from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm
  static fromRGBA(rgba2) {
    const r2 = rgba2.r / 255;
    const g2 = rgba2.g / 255;
    const b2 = rgba2.b / 255;
    const cmax = Math.max(r2, g2, b2);
    const cmin = Math.min(r2, g2, b2);
    const delta = cmax - cmin;
    const s2 = cmax === 0 ? 0 : delta / cmax;
    let m2;
    if (delta === 0) {
      m2 = 0;
    } else if (cmax === r2) {
      m2 = ((g2 - b2) / delta % 6 + 6) % 6;
    } else if (cmax === g2) {
      m2 = (b2 - r2) / delta + 2;
    } else {
      m2 = (r2 - g2) / delta + 4;
    }
    return new HSVA(Math.round(m2 * 60), s2, cmax, rgba2.a);
  }
  // from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm
  static toRGBA(hsva) {
    const { h: h2, s: s2, v: v2, a: a2 } = hsva;
    const c2 = v2 * s2;
    const x2 = c2 * (1 - Math.abs(h2 / 60 % 2 - 1));
    const m2 = v2 - c2;
    let [r2, g2, b2] = [0, 0, 0];
    if (h2 < 60) {
      r2 = c2;
      g2 = x2;
    } else if (h2 < 120) {
      r2 = x2;
      g2 = c2;
    } else if (h2 < 180) {
      g2 = c2;
      b2 = x2;
    } else if (h2 < 240) {
      g2 = x2;
      b2 = c2;
    } else if (h2 < 300) {
      r2 = x2;
      b2 = c2;
    } else if (h2 <= 360) {
      r2 = c2;
      b2 = x2;
    }
    r2 = Math.round((r2 + m2) * 255);
    g2 = Math.round((g2 + m2) * 255);
    b2 = Math.round((b2 + m2) * 255);
    return new RGBA(r2, g2, b2, a2);
  }
}
const _Color = class _Color {
  constructor(arg) {
    __publicField(this, "rgba");
    __publicField(this, "_hsla");
    __publicField(this, "_hsva");
    __publicField(this, "_toString");
    if (!arg) {
      throw new Error("Color needs a value");
    } else if (arg instanceof RGBA) {
      this.rgba = arg;
    } else if (arg instanceof HSLA) {
      this._hsla = arg;
      this.rgba = HSLA.toRGBA(arg);
    } else if (arg instanceof HSVA) {
      this._hsva = arg;
      this.rgba = HSVA.toRGBA(arg);
    } else {
      throw new Error("Invalid color ctor argument");
    }
  }
  static fromHex(hex) {
    return _Color.Format.CSS.parseHex(hex) || _Color.white;
  }
  static equals(a2, b2) {
    if (!a2 && !b2) {
      return true;
    }
    if (!a2 || !b2) {
      return false;
    }
    return a2.equals(b2);
  }
  get hsla() {
    if (this._hsla) {
      return this._hsla;
    } else {
      return HSLA.fromRGBA(this.rgba);
    }
  }
  get hsva() {
    if (this._hsva) {
      return this._hsva;
    }
    return HSVA.fromRGBA(this.rgba);
  }
  equals(other) {
    return !!other && RGBA.equals(this.rgba, other.rgba) && HSLA.equals(this.hsla, other.hsla) && HSVA.equals(this.hsva, other.hsva);
  }
  isOpaque() {
    return this.rgba.a === 1;
  }
  toString() {
    if (!this._toString) {
      this._toString = _Color.Format.CSS.format(this);
    }
    return this._toString;
  }
};
__publicField(_Color, "white", new _Color(new RGBA(255, 255, 255, 1)));
__publicField(_Color, "transparent", new _Color(new RGBA(0, 0, 0, 0)));
let Color = _Color;
function _toTwoDigitHex(n2) {
  const r2 = n2.toString(16);
  return r2.length !== 2 ? "0" + r2 : r2;
}
function _parseHexDigit(charCode) {
  switch (charCode) {
    case CharCode.Digit0:
      return 0;
    case CharCode.Digit1:
      return 1;
    case CharCode.Digit2:
      return 2;
    case CharCode.Digit3:
      return 3;
    case CharCode.Digit4:
      return 4;
    case CharCode.Digit5:
      return 5;
    case CharCode.Digit6:
      return 6;
    case CharCode.Digit7:
      return 7;
    case CharCode.Digit8:
      return 8;
    case CharCode.Digit9:
      return 9;
    case CharCode.a:
      return 10;
    case CharCode.A:
      return 10;
    case CharCode.b:
      return 11;
    case CharCode.B:
      return 11;
    case CharCode.c:
      return 12;
    case CharCode.C:
      return 12;
    case CharCode.d:
      return 13;
    case CharCode.D:
      return 13;
    case CharCode.e:
      return 14;
    case CharCode.E:
      return 14;
    case CharCode.f:
      return 15;
    case CharCode.F:
      return 15;
  }
  return 0;
}
((Color2) => {
  ((Format2) => {
    ((CSS2) => {
      function formatRGB(color) {
        if (color.rgba.a === 1) {
          return `rgb(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b})`;
        }
        return Color2.Format.CSS.formatRGBA(color);
      }
      CSS2.formatRGB = formatRGB;
      function formatRGBA(color) {
        return `rgba(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b}, ${+color.rgba.a.toFixed(2)})`;
      }
      CSS2.formatRGBA = formatRGBA;
      function formatHSL(color) {
        if (color.hsla.a === 1) {
          return `hsl(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%)`;
        }
        return Color2.Format.CSS.formatHSLA(color);
      }
      CSS2.formatHSL = formatHSL;
      function formatHSLA(color) {
        return `hsla(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%, ${color.hsla.a.toFixed(2)})`;
      }
      CSS2.formatHSLA = formatHSLA;
      function formatHex(color) {
        return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}`;
      }
      CSS2.formatHex = formatHex;
      function formatHexA(color, compact = false) {
        if (compact && color.rgba.a === 1) {
          return Color2.Format.CSS.formatHex(color);
        }
        return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}${_toTwoDigitHex(Math.round(color.rgba.a * 255))}`;
      }
      CSS2.formatHexA = formatHexA;
      function format2(color) {
        if (color.isOpaque()) {
          return Color2.Format.CSS.formatHex(color);
        }
        return Color2.Format.CSS.formatRGBA(color);
      }
      CSS2.format = format2;
      function parse(css) {
        var _a3, _b3, _c2, _d2, _e, _f, _g;
        if (css === "transparent") {
          return Color2.transparent;
        }
        if (css.startsWith("#")) {
          return parseHex(css);
        }
        if (css.startsWith("rgba(")) {
          const color = css.match(
            /rgba\((?<r>(?:\+|-)?\d+), *(?<g>(?:\+|-)?\d+), *(?<b>(?:\+|-)?\d+), *(?<a>(?:\+|-)?\d+(\.\d+)?)\)/
          );
          if (!color) {
            throw new Error("Invalid color format " + css);
          }
          const r2 = parseInt(((_a3 = color.groups) == null ? void 0 : _a3.r) ?? "0");
          const g2 = parseInt(((_b3 = color.groups) == null ? void 0 : _b3.g) ?? "0");
          const b2 = parseInt(((_c2 = color.groups) == null ? void 0 : _c2.b) ?? "0");
          const a2 = parseFloat(((_d2 = color.groups) == null ? void 0 : _d2.a) ?? "0");
          return new Color2(new RGBA(r2, g2, b2, a2));
        }
        if (css.startsWith("rgb(")) {
          const color = css.match(
            /rgb\((?<r>(?:\+|-)?\d+), *(?<g>(?:\+|-)?\d+), *(?<b>(?:\+|-)?\d+)\)/
          );
          if (!color) {
            throw new Error("Invalid color format " + css);
          }
          const r2 = parseInt(((_e = color.groups) == null ? void 0 : _e.r) ?? "0");
          const g2 = parseInt(((_f = color.groups) == null ? void 0 : _f.g) ?? "0");
          const b2 = parseInt(((_g = color.groups) == null ? void 0 : _g.b) ?? "0");
          return new Color2(new RGBA(r2, g2, b2));
        }
        return NOTIMPLEMENTED("named key is not supported");
      }
      CSS2.parse = parse;
      function parseHex(hex) {
        const length = hex.length;
        if (length === 0) {
          return null;
        }
        if (hex.charCodeAt(0) !== CharCode.Hash) {
          return null;
        }
        if (length === 7) {
          const r2 = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));
          const g2 = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));
          const b2 = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));
          return new Color2(new RGBA(r2, g2, b2, 1));
        }
        if (length === 9) {
          const r2 = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));
          const g2 = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));
          const b2 = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));
          const a2 = 16 * _parseHexDigit(hex.charCodeAt(7)) + _parseHexDigit(hex.charCodeAt(8));
          return new Color2(new RGBA(r2, g2, b2, a2 / 255));
        }
        if (length === 4) {
          const r2 = _parseHexDigit(hex.charCodeAt(1));
          const g2 = _parseHexDigit(hex.charCodeAt(2));
          const b2 = _parseHexDigit(hex.charCodeAt(3));
          return new Color2(new RGBA(16 * r2 + r2, 16 * g2 + g2, 16 * b2 + b2));
        }
        if (length === 5) {
          const r2 = _parseHexDigit(hex.charCodeAt(1));
          const g2 = _parseHexDigit(hex.charCodeAt(2));
          const b2 = _parseHexDigit(hex.charCodeAt(3));
          const a2 = _parseHexDigit(hex.charCodeAt(4));
          return new Color2(new RGBA(16 * r2 + r2, 16 * g2 + g2, 16 * b2 + b2, (16 * a2 + a2) / 255));
        }
        return null;
      }
      CSS2.parseHex = parseHex;
    })(Format2.CSS || (Format2.CSS = {}));
  })(Color2.Format || (Color2.Format = {}));
})(Color || (Color = {}));
function resetTransparency(color) {
  if (color === "transparent") {
    return color;
  }
  if (isHexColor(color)) {
    return color.slice(0, 7);
  }
  const rgb = parseRgb(color);
  const alpha = normalizeAlphaComponent(1);
  const rgbaObj = rgba(rgb, alpha);
  return rgbaToString(rgbaObj);
}
function isHexColor(color) {
  return 0 === color.indexOf("#");
}
const NAMED_COLORS = {
  red: "#ff0000",
  green: "#008000",
  blue: "#0000ff",
  white: "#ffffff",
  black: "#000000",
  yellow: "#ffff00",
  cyan: "#00ffff"
  // ...（省略中间列表，使用时可添加完整命名颜色）
};
function clampInt(min, value, max) {
  return isNaN(value) || value < min ? min : value > max ? max : Math.round(value);
}
function clampFloat(min, value, max) {
  return isNaN(value) || value < min ? min : value > max ? max : Math.round(value * 1e4) / 1e4;
}
function clamp255(value) {
  return clampInt(0, value, 255);
}
function normalizeAlphaComponent(value) {
  return clampFloat(0, value, 1);
}
const rgbParser = {
  re: /^rgb\(\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*\)$/,
  parse: (match2) => [
    clamp255(parseInt(match2[1], 10)),
    clamp255(parseInt(match2[2], 10)),
    clamp255(parseInt(match2[3], 10))
  ]
};
const rgbaParser = {
  re: /^rgba\(\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?[\d]{0,10}(?:\.\d+)?)\s*\)$/,
  parse: (match2) => [
    clamp255(parseInt(match2[1], 10)),
    clamp255(parseInt(match2[2], 10)),
    clamp255(parseInt(match2[3], 10)),
    normalizeAlphaComponent(parseFloat(match2[4]))
  ]
};
const hexParser = {
  re: /^#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  parse: (match2) => [parseInt(match2[1], 16), parseInt(match2[2], 16), parseInt(match2[3], 16)]
};
const shortHexParser = {
  re: /^#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])$/,
  parse: (match2) => [
    parseInt(match2[1] + match2[1], 16),
    parseInt(match2[2] + match2[2], 16),
    parseInt(match2[3] + match2[3], 16)
  ]
};
function tryParsers(parsers, str) {
  for (const parser of parsers) {
    const match2 = parser.re.exec(str);
    if (match2) return parser.parse(match2);
  }
  return null;
}
function tryParseRgba(input) {
  var _a3, _b3;
  input = input.toLowerCase().trim();
  if (input in NAMED_COLORS) {
    const hexColor = NAMED_COLORS[input];
    const rgb = tryParsers([hexParser], hexColor);
    return rgb ? [...rgb, 1] : null;
  }
  return ((_a3 = tryParsers([rgbParser], input)) == null ? void 0 : _a3.concat(1)) || ((_b3 = tryParsers([hexParser, shortHexParser], input)) == null ? void 0 : _b3.concat(1)) || tryParsers([rgbaParser], input) || null;
}
function parseRgba(input) {
  const result = tryParseRgba(input);
  if (!result) {
    throw new Error("Invalid color format: " + input);
  }
  return result;
}
function parseRgb(input) {
  const rgba2 = parseRgba(input);
  return [rgba2[0], rgba2[1], rgba2[2]];
}
function rgba(...args) {
  if (Array.isArray(args[0])) {
    const [r2, g2, b2] = args[0];
    const a2 = normalizeAlphaComponent(args[1]);
    return [r2, g2, b2, a2];
  } else {
    const [r2, g2, b2, a2 = 1] = args;
    return [clamp255(r2), clamp255(g2), clamp255(b2), normalizeAlphaComponent(a2)];
  }
}
function rgbaToString(color) {
  const [r2, g2, b2, a2] = color;
  return `rgba(${r2}, ${g2}, ${b2}, ${a2})`;
}
function generateColor(color, transparency, forceAlpha) {
  const normalizedTransparency = typeof transparency === "number" ? transparency : 0;
  if (!isHexColor(color)) {
    const rgb = parseRgb(color);
    const a22 = normalizeAlphaComponent(transparencyToAlpha(normalizedTransparency));
    return forceAlpha ? rgbaToString(rgba(rgb, a22)) : color;
  }
  const [r2, g2, b2] = parseRgb(color);
  const a2 = normalizeAlphaComponent(transparencyToAlpha(normalizedTransparency));
  return rgbaToString([r2, g2, b2, a2]);
}
function transparencyToAlpha(t2) {
  if (t2 < 0 || t2 > 100) throw new Error("invalid transparency");
  return 1 - t2 / 100;
}
function gradientColorAtPercent(fromColor, toColor, percent) {
  const [r1, g1, b1, a1] = parseRgba(fromColor);
  const [r2, g2, b2, a2] = parseRgba(toColor);
  const interpolated = rgba(
    Math.round(r1 + percent * (r2 - r1)),
    Math.round(g1 + percent * (g2 - g1)),
    Math.round(b1 + percent * (b2 - b1)),
    a1 + percent * (a2 - a1)
  );
  return rgbaToString(interpolated);
}
function rgbaFromInteger(value) {
  value = Math.round(value);
  const r2 = value % 256;
  value = (value - r2) / 256;
  const g2 = value % 256;
  value = (value - g2) / 256;
  const b2 = value % 256;
  value = (value - b2) / 256;
  const a2 = value / 255;
  return `rgba(${r2},${g2},${b2},${a2})`;
}
class GradientColorCache {
  constructor() {
    __publicField(this, "_color1", "");
    // 起始颜色
    __publicField(this, "_color2", "");
    // 终止颜色
    __publicField(this, "_colors", /* @__PURE__ */ new Map());
  }
  // 缓存渐变颜色结果，key是百分比（0-100）
  /**
   * 获取 e 到 t 之间，百分比 i 对应的渐变颜色
   * @param fromColor 起始颜色（例如 '#ff0000'）
   * @param toColor 终止颜色（例如 '#00ff00'）
   * @param percent 在两者间的百分比，范围 [0, 1]
   * @returns 渐变颜色字符串
   */
  gradientColor(fromColor, toColor, percent) {
    if (fromColor === toColor) {
      return toColor;
    }
    const percentInt = Math.max(0, Math.min(100, Math.round(percent * 100)));
    if (this._color1 !== fromColor || this._color2 !== toColor) {
      this._colors.clear();
      this._color1 = fromColor;
      this._color2 = toColor;
    }
    let result = this._colors.get(percentInt);
    if (result === void 0) {
      result = gradientColorAtPercent(fromColor, toColor, percentInt / 100);
      this._colors.set(percentInt, result);
    }
    return result;
  }
}
var FocusEventSource = /* @__PURE__ */ ((FocusEventSource2) => {
  FocusEventSource2[FocusEventSource2["select"] = 0] = "select";
  FocusEventSource2[FocusEventSource2["drag"] = 1] = "drag";
  return FocusEventSource2;
})(FocusEventSource || {});
class ChartModel {
  constructor(chartService, themeService) {
    __publicField(this, "_currentPoint", null);
    __publicField(this, "_currentCreating", null);
    __publicField(this, "_currentActive", null);
    __publicField(this, "_hoveredSource", null);
    __publicField(this, "_currentEditing", null);
    __publicField(this, "_pointEditing", null);
    __publicField(this, "_pointCreating", null);
    __publicField(this, "_lastHoverDetails", null);
    __publicField(this, "_onFocus", new Emitter());
    __publicField(this, "onFocus", this._onFocus.event);
    __publicField(this, "_onBlur", new Emitter());
    __publicField(this, "onBlur", this._onBlur.event);
    __publicField(this, "_backgroundColorAtYPercentFromTop", new GradientColorCache());
    this.chartService = chartService;
    this.themeService = themeService;
  }
  isDarkTheme() {
    return this.themeService.isDark();
  }
  backgroundColorAtYPercentFromTop(percentage) {
    const bg = this.chartService.chartApi.options().layout.background;
    if (bg.type === Oi.Solid) {
      return bg.color;
    } else {
      const top2 = bg.topColor;
      const bottom = bg.bottomColor;
      return this._backgroundColorAtYPercentFromTop.gradientColor(top2, bottom, percentage);
    }
  }
  get currentCreating() {
    return this._currentCreating;
  }
  get currentActive() {
    return this._currentActive;
  }
  get currentHovered() {
    return this._hoveredSource;
  }
  get pointEditing() {
    return this._pointEditing;
  }
  get pointCreating() {
    return this._pointCreating;
  }
  get currentEditing() {
    return this._currentEditing;
  }
  get currentPoint() {
    return this._currentPoint;
  }
  setCurrentPoint(p2) {
    this._currentPoint = p2;
  }
  lastHittestData() {
    return this._lastHoverDetails;
  }
  markPointEditingStarted(target, pointIndex) {
    this._currentEditing = target;
    this._pointEditing = pointIndex;
  }
  markPointEditingFinishedOrAborted() {
    this._currentEditing = null;
    this._pointEditing = -1;
  }
  markCreatingStarted(target) {
    this._currentCreating = target;
  }
  markCreatingPoint(index2) {
    this._pointCreating = index2;
  }
  markCreatingFinishedOrAborted(primitive) {
    if (this._currentCreating === primitive) {
      this._currentCreating = null;
      this._pointCreating = null;
    }
  }
  setHoveredSource(target, hitTestResult) {
    var _a3, _b3, _c2, _d2, _e;
    if (this._hoveredSource !== target) {
      (_a3 = this._hoveredSource) == null ? void 0 : _a3.updateHover();
      (_c2 = (_b3 = this._lastHoverDetails) == null ? void 0 : _b3.onHover) == null ? void 0 : _c2.call(_b3);
    }
    this._lastHoverDetails = hitTestResult.details ?? null;
    if (this._lastHoverDetails) {
      (_e = (_d2 = this._lastHoverDetails).onHover) == null ? void 0 : _e.call(_d2, {
        target,
        details: this._lastHoverDetails,
        x: NaN,
        y: NaN
      });
    }
    target.updateHover(this._lastHoverDetails);
    this._hoveredSource = target;
  }
  unhover(target) {
    var _a3, _b3;
    target == null ? void 0 : target.updateHover();
    if (target === this._hoveredSource) {
      this._hoveredSource = null;
    }
    (_b3 = (_a3 = this._lastHoverDetails) == null ? void 0 : _a3.onHover) == null ? void 0 : _b3.call(_a3);
    this._lastHoverDetails = null;
  }
  focus(target, source2) {
    var _a3;
    if (target.disableUserSelection) return;
    if (target !== this._currentActive) {
      (_a3 = this._currentActive) == null ? void 0 : _a3.updateActive(false);
    }
    target.updateActive(true);
    this._currentActive = target;
    this._onFocus.fire({
      target,
      source: source2
    });
  }
  blur(target) {
    target == null ? void 0 : target.updateActive(false);
    if (target === this._currentActive) {
      if (this._currentActive) {
        this._onBlur.fire(this._currentActive);
      }
      this._currentActive = null;
    }
  }
  reset() {
    const active = this._currentActive;
    this._currentPoint = null;
    this._currentCreating = null;
    this._currentActive = null;
    this._hoveredSource = null;
    this._currentEditing = null;
    this._pointEditing = null;
    this._pointCreating = null;
    if (active) {
      this._onBlur.fire(active);
    }
  }
  isSelected(source2) {
    return source2 === this._currentActive;
  }
  isHovered(source2) {
    return source2 === this._hoveredSource;
  }
}
const RemoveDrawingCommand = "drawing.remove";
const CopyDrawingCommand = "drawing.copy";
const CloneDrawingCommand = "drawing.clone";
const DrawingFragmentBrand = "data-chartles-drawing";
const FileNameKey = "_imgFileName_";
function parseFragmentString(html2) {
  if (!html2) return;
  if (html2.slice(0, 1024).indexOf(DrawingFragmentBrand) === -1) return;
  const node = new DOMParser().parseFromString(html2, "text/html").querySelector(`[${DrawingFragmentBrand}]`);
  if (!node) return;
  try {
    return JSON.parse(node.getAttribute(DrawingFragmentBrand) ?? "");
  } catch {
  }
}
const PasteImageToolType = "_tool.image.parse";
const ImageToolType = "tool.content.image";
const ArrowMarkDownToolType = "tool.arrow.arrowMarkDown";
const ArrowMarkUpToolType = "tool.arrow.arrowMarkUp";
const EmojiToolType = "tool.emoji";
const IconToolType = "tool.icon";
const HorizontalLineToolType = "tool.line.horizontalLine";
const VerticalLineToolType = "tool.line.verticalLine";
const MeasureToolType = "tool.measure";
const LongPositionToolType = "tool.projection.longPosition";
const ShortPositionToolType = "tool.projection.shortPosition";
const FlagMarkToolType = "tool.text.flagMark";
const PinToolType = "tool.text.pin";
const PinFixedToolType = "tool.text.pinFixed";
const TextToolType = "tool.text.text";
const AnchoredTextToolType = "tool.text.anchoredText";
const PreOrderToolType = "tool.trade.preOrder";
const PUBLIC_VERSION = "5";
if (typeof window !== "undefined") {
  ((_c = window.__svelte ?? (window.__svelte = {})).v ?? (_c.v = /* @__PURE__ */ new Set())).add(PUBLIC_VERSION);
}
var e = { dragStart: true }, t = { delay: 0, distance: 3 };
var n = (e2, t2, n2) => Math.min(Math.max(e2, t2), n2), r = (e2) => "string" == typeof e2, o = ([e2, t2], n2, r2) => {
  const o2 = (e3, t3) => 0 === t3 ? 0 : Math.ceil(e3 / t3) * t3;
  return [o2(n2, e2), o2(r2, t2)];
};
var a = (e2, t2) => e2.some((e3) => t2.some((t3) => e3.contains(t3)));
function i(e2, t2) {
  if (void 0 === e2) return;
  if (l(e2)) return e2.getBoundingClientRect();
  if ("object" == typeof e2) {
    const { top: t3 = 0, left: n3 = 0, right: r2 = 0, bottom: o2 = 0 } = e2;
    return { top: t3, right: window.innerWidth - r2, bottom: window.innerHeight - o2, left: n3 };
  }
  if ("parent" === e2) return t2.parentNode.getBoundingClientRect();
  const n2 = document.querySelector(e2);
  if (null === n2) throw new Error("The selector provided for bound doesn't exists in the document.");
  return n2.getBoundingClientRect();
}
var s = (e2, t2, n2) => e2.style.setProperty(t2, n2), l = (e2) => e2 instanceof HTMLElement, d2 = function(d3, c2 = {}) {
  let u2, f2, { bounds: g2, axis: h2 = "both", gpuAcceleration: p2 = true, legacyTranslate: m2 = false, transform: y2, applyUserSelectHack: w2 = true, disabled: b2 = false, ignoreMultitouch: v2 = false, recomputeBounds: x2 = e, grid: E2, threshold: S2 = t, position: A2, cancel: C2, handle: D2, defaultClass: N2 = "neodrag", defaultClassDragging: M2 = "neodrag-dragging", defaultClassDragged: B2 = "neodrag-dragged", defaultPosition: R2 = { x: 0, y: 0 }, onDragStart: $2, onDrag: X2, onDragEnd: Y2 } = c2, q2 = false, H2 = false, P2 = 0, T2 = false, k2 = false, L2 = 0, z2 = 0, I2 = 0, U2 = 0, W2 = 0, j2 = 0, { x: F2, y: G2 } = A2 ? { x: (A2 == null ? void 0 : A2.x) ?? 0, y: (A2 == null ? void 0 : A2.y) ?? 0 } : R2;
  oe(F2, G2);
  let J2, K2, O2, Q2, V2, Z2 = "", _2 = !!A2;
  x2 = { ...e, ...x2 }, S2 = { ...t, ...S2 ?? {} };
  let ee2 = /* @__PURE__ */ new Set();
  function te2(e2) {
    q2 && !H2 && k2 && T2 && V2 && (H2 = true, function(e3) {
      ae2("neodrag:start", $2, e3);
    }(e2), re2.add(M2), w2 && (Z2 = ne2.userSelect, ne2.userSelect = "none"));
  }
  const ne2 = document.body.style, re2 = d3.classList;
  function oe(e2 = L2, t2 = z2) {
    if (!y2) {
      if (m2) {
        let n3 = `${+e2}px, ${+t2}px`;
        return s(d3, "transform", p2 ? `translate3d(${n3}, 0)` : `translate(${n3})`);
      }
      return s(d3, "translate", `${+e2}px ${+t2}px`);
    }
    const n2 = y2({ offsetX: e2, offsetY: t2, rootNode: d3 });
    r(n2) && s(d3, "transform", n2);
  }
  function ae2(e2, t2, n2) {
    const r2 = /* @__PURE__ */ function(e3) {
      return { offsetX: L2, offsetY: z2, rootNode: d3, currentNode: V2, event: e3 };
    }(n2);
    d3.dispatchEvent(new CustomEvent(e2, { detail: r2 })), t2 == null ? void 0 : t2(r2);
  }
  const ie2 = addEventListener, se2 = new AbortController(), le = { signal: se2.signal, capture: false };
  function de() {
    let e2 = d3.offsetWidth / K2.width;
    return isNaN(e2) && (e2 = 1), e2;
  }
  return s(d3, "touch-action", "none"), ie2("pointerdown", (e2) => {
    if (b2) return;
    if (2 === e2.button) return;
    if (ee2.add(e2.pointerId), v2 && ee2.size > 1) return e2.preventDefault();
    if (x2.dragStart && (J2 = i(g2, d3)), r(D2) && r(C2) && D2 === C2) throw new Error("`handle` selector can't be same as `cancel` selector");
    if (re2.add(N2), O2 = function(e3, t3) {
      if (!e3) return [t3];
      if (l(e3)) return [e3];
      if (Array.isArray(e3)) return e3;
      const n3 = t3.querySelectorAll(e3);
      if (null === n3) throw new Error("Selector passed for `handle` option should be child of the element on which the action is applied");
      return Array.from(n3.values());
    }(D2, d3), Q2 = function(e3, t3) {
      if (!e3) return [];
      if (l(e3)) return [e3];
      if (Array.isArray(e3)) return e3;
      const n3 = t3.querySelectorAll(e3);
      if (null === n3) throw new Error("Selector passed for `cancel` option should be child of the element on which the action is applied");
      return Array.from(n3.values());
    }(C2, d3), u2 = /(both|x)/.test(h2), f2 = /(both|y)/.test(h2), a(Q2, O2)) throw new Error("Element being dragged can't be a child of the element on which `cancel` is applied");
    const t2 = e2.composedPath()[0];
    if (!O2.some((e3) => {
      var _a3;
      return e3.contains(t2) || ((_a3 = e3.shadowRoot) == null ? void 0 : _a3.contains(t2));
    }) || a(Q2, [t2])) return;
    V2 = 1 === O2.length ? d3 : O2.find((e3) => e3.contains(t2)), q2 = true, P2 = Date.now(), S2.delay || (T2 = true), K2 = d3.getBoundingClientRect();
    const { clientX: n2, clientY: o2 } = e2, s2 = de();
    u2 && (I2 = n2 - F2 / s2), f2 && (U2 = o2 - G2 / s2), J2 && (W2 = n2 - K2.left, j2 = o2 - K2.top);
  }, le), ie2("pointermove", (e2) => {
    if (!q2 || v2 && ee2.size > 1) return;
    if (!H2) {
      if (!T2) {
        Date.now() - P2 >= S2.delay && (T2 = true, te2(e2));
      }
      if (!k2) {
        const t3 = e2.clientX - I2, n2 = e2.clientY - U2;
        Math.sqrt(t3 ** 2 + n2 ** 2) >= S2.distance && (k2 = true, te2(e2));
      }
      if (!H2) return;
    }
    x2.drag && (J2 = i(g2, d3)), e2.preventDefault(), K2 = d3.getBoundingClientRect();
    let t2 = e2.clientX, r2 = e2.clientY;
    const a2 = de();
    if (J2) {
      const e3 = { left: J2.left + W2, top: J2.top + j2, right: J2.right + W2 - K2.width, bottom: J2.bottom + j2 - K2.height };
      t2 = n(t2, e3.left, e3.right), r2 = n(r2, e3.top, e3.bottom);
    }
    if (Array.isArray(E2)) {
      let [e3, n2] = E2;
      if (isNaN(+e3) || e3 < 0) throw new Error("1st argument of `grid` must be a valid positive number");
      if (isNaN(+n2) || n2 < 0) throw new Error("2nd argument of `grid` must be a valid positive number");
      let i2 = t2 - I2, s2 = r2 - U2;
      [i2, s2] = o([e3 / a2, n2 / a2], i2, s2), t2 = I2 + i2, r2 = U2 + s2;
    }
    u2 && (L2 = Math.round((t2 - I2) * a2)), f2 && (z2 = Math.round((r2 - U2) * a2)), F2 = L2, G2 = z2, ae2("neodrag", X2, e2), oe();
  }, le), ie2("pointerup", (e2) => {
    (ee2.delete(e2.pointerId), q2) && (H2 && (ie2("click", (e3) => e3.stopPropagation(), { once: true, signal: se2.signal, capture: true }), x2.dragEnd && (J2 = i(g2, d3)), re2.remove(M2), re2.add(B2), w2 && (ne2.userSelect = Z2), ae2("neodrag:end", Y2, e2), u2 && (I2 = L2), f2 && (U2 = z2)), q2 = false, H2 = false, T2 = false, k2 = false);
  }, le), { destroy: () => se2.abort(), update: (n2) => {
    var _a3, _b3;
    h2 = n2.axis || "both", b2 = n2.disabled ?? false, v2 = n2.ignoreMultitouch ?? false, D2 = n2.handle, g2 = n2.bounds, x2 = n2.recomputeBounds ?? e, C2 = n2.cancel, w2 = n2.applyUserSelectHack ?? true, E2 = n2.grid, p2 = n2.gpuAcceleration ?? true, m2 = n2.legacyTranslate ?? false, y2 = n2.transform, S2 = { ...t, ...n2.threshold ?? {} };
    const r2 = re2.contains(B2);
    re2.remove(N2, B2), N2 = n2.defaultClass ?? "neodrag", M2 = n2.defaultClassDragging ?? "neodrag-dragging", B2 = n2.defaultClassDragged ?? "neodrag-dragged", re2.add(N2), r2 && re2.add(B2), _2 && (F2 = L2 = ((_a3 = n2.position) == null ? void 0 : _a3.x) ?? L2, G2 = z2 = ((_b3 = n2.position) == null ? void 0 : _b3.y) ?? z2, oe());
  } };
};
function useService(desc) {
  const chart = getContext(IChartService);
  const getService = (accessor) => accessor.get(desc);
  return chart ? chart.invokeWithinContext(getService) : getContext(IInstantiationService).invokeFunction(getService);
}
var root_1$v = /* @__PURE__ */ from_html(`<div class="toolbar svelte-1t62qsn"><div class="handle svelte-1t62qsn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 8 12" width="8" height="12" fill="currentColor"><rect width="2" height="2" rx="1"></rect><rect width="2" height="2" rx="1" y="5"></rect><rect width="2" height="2" rx="1" y="10"></rect><rect width="2" height="2" rx="1" x="6"></rect><rect width="2" height="2" rx="1" x="6" y="5"></rect><rect width="2" height="2" rx="1" x="6" y="10"></rect></svg></div>     <button class="button svelte-1t62qsn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><path fill="currentColor" d="M18 7h5v1h-2.01l-1.33 14.64a1.5 1.5 0 0 1-1.5 1.36H9.84a1.5 1.5 0 0 1-1.49-1.36L7.01 8H5V7h5V6c0-1.1.9-2 2-2h4a2 2 0 0 1 2 2v1Zm-6-2a1 1 0 0 0-1 1v1h6V6a1 1 0 0 0-1-1h-4ZM8.02 8l1.32 14.54a.5.5 0 0 0 .5.46h8.33a.5.5 0 0 0 .5-.46L19.99 8H8.02Z"></path></svg></button></div>`);
const $$css$z = {
  hash: "svelte-1t62qsn",
  code: '.toolbar.svelte-1t62qsn {height:38px;position:absolute;display:flex;flex-direction:row;background-color:var(--cl-background);border-radius:6px;box-shadow:0 2px 4px 0 var(--cl-dialog-shadow);z-index:4;}.handle.svelte-1t62qsn {width:24px;display:flex;justify-content:center;align-items:center;color:var(--cl-handle-foreground);cursor:grab;}.button.svelte-1t62qsn {outline:none;border:none;background:none;padding-block:initial;padding-inline:initial;font-family:inherit;color:inherit;height:100%;color:var(--cl-foreground);font-size:14px;display:flex;flex-direction:row;align-items:center;justify-content:center;cursor:default;position:relative;z-index:0;height:100%;width:38px;}\n@media (hover: hover) and (pointer: fine) {.button.svelte-1t62qsn:hover:before {position:absolute;top:2px;right:2px;bottom:2px;left:2px;z-index:-1;border-radius:4px;content:"";background-color:var(--cl-button-hoverBackground);}\n} .toolbar .row {height:32px;font-size:14px;padding:0 10px 0 8px;white-space:nowrap;display:flex;align-items:center;color:var(--cl-listItem-foreground);background:var(--cl-listItem-background);} .toolbar .row:hover {background-color:var(--cl-listItem-hoverBackground);} .toolbar .row.selected {background-color:var(--cl-listItem-selectedBackground);color:var(--cl-listItem-selectedForeground);}'
};
function Toolbar($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$z);
  const chartManagementService = useService(IChartManagementService);
  const el = ensure(chartManagementService.getDomElement());
  const rect = el.getBoundingClientRect();
  const defaultPosition = { x: rect.x + rect.width / 2, y: rect.y + 15 };
  let position = proxy$1(defaultPosition);
  const config2 = {
    bounds: "body",
    applyUserSelectHack: true,
    handle: ".handle",
    position,
    onDrag: ({ offsetX, offsetY }) => {
      Object.assign(position, { x: offsetX, y: offsetY });
    }
  };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var div = root_1$v();
      var button = sibling(child(div), 2);
      button.__click = function(...$$args) {
        var _a3;
        (_a3 = $$props.onRemove) == null ? void 0 : _a3.apply(this, $$args);
      };
      action(div, ($$node, $$action_arg) => d2 == null ? void 0 : d2($$node, $$action_arg), () => config2);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.visible) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  pop();
}
delegate(["click"]);
var __getOwnPropDesc$f = Object.getOwnPropertyDescriptor;
var __decorateClass$f = (decorators, target, key2, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$f(target, key2) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$e = (index2, decorator) => (target, key2) => decorator(target, key2, index2);
let ChartController = class extends Disposable {
  constructor(chartService, chartManagementService, toolService, guiService, commandService, clipboardService) {
    super();
    __publicField(this, "_userShapesOptions", /* @__PURE__ */ new Map());
    __publicField(this, "_toolPrimitives", /* @__PURE__ */ new Map());
    __publicField(this, "_hiddenToolPrimitives", /* @__PURE__ */ new Map());
    __publicField(this, "_toolHitTestObjects", /* @__PURE__ */ new Map());
    __publicField(this, "_pendingToolHitTestObjects", /* @__PURE__ */ new Map());
    __publicField(this, "_series", /* @__PURE__ */ new Map());
    __publicField(this, "_seriesHitTestObjects", /* @__PURE__ */ new Map());
    __publicField(this, "_pendingSeriesHitTestObjects", /* @__PURE__ */ new Map());
    __publicField(this, "_currentDrag");
    __publicField(this, "_demoHighlight");
    __publicField(this, "_toolbar", null);
    __publicField(this, "_visible", true);
    this.chartService = chartService;
    this.chartManagementService = chartManagementService;
    this.toolService = toolService;
    this.guiService = guiService;
    this.commandService = commandService;
    let cleanupLazyFocus = null;
    const model = chartService.getModel();
    this._register(
      model.onFocus(({ target, source: source2 }) => {
        var _a3;
        cleanupLazyFocus == null ? void 0 : cleanupLazyFocus();
        if (!((_a3 = target.isTool) == null ? void 0 : _a3.call(target))) {
          return;
        }
        cleanupLazyFocus = scheduleTimeout(() => {
          if (model.currentActive === target && !target.disableUserSelection && !target.disableToolbar && source2 === FocusEventSource.select) {
            this.lazyToolbar().update({ visible: true });
          }
          cleanupLazyFocus = null;
        }, 16);
      })
    );
    this._register(
      model.onBlur(() => {
        var _a3;
        cleanupLazyFocus == null ? void 0 : cleanupLazyFocus();
        cleanupLazyFocus = null;
        (_a3 = this._toolbar) == null ? void 0 : _a3.update({ visible: false });
      })
    );
    this._register(
      chartService.onChartBlur(() => {
        if (model.currentActive) {
          model.blur(model.currentActive);
        }
      })
    );
    this._register(
      chartService.onCrosshairMove((e2) => {
        var _a3;
        model.setCurrentPoint(e2.point ? new Point(e2.localX, e2.localY) : null);
        const paneCursor = chartManagementService.getDefaultPaneCursor();
        if (showDemoCursor(paneCursor) && !this._demoHighlight && e2.point) {
          const paneIndex = ensure(e2.paneIndex);
          const pane = ensure(this.chartService.getPane(paneIndex));
          this._demoHighlight = new DemoHighlightPrimitive(
            {
              x: e2.point.x,
              y: e2.point.y,
              radius: 18,
              background: DemoHighlightBackground
            },
            () => {
              if (this._demoHighlight) {
                pane == null ? void 0 : pane.detachPrimitive(this._demoHighlight);
              }
            }
          );
          pane.attachPrimitive(this._demoHighlight);
        }
        if (this._demoHighlight && (!showDemoCursor(paneCursor) || !e2.point)) {
          this._demoHighlight.detach();
          this._demoHighlight = void 0;
        }
        if (this._currentDrag) return;
        if (!e2.point) {
          model.unhover(model.currentHovered);
          return;
        }
        const { x: x2, y: y2 } = e2.point;
        (_a3 = this._demoHighlight) == null ? void 0 : _a3.updateData({ x: x2, y: y2 });
        const result = this._hitTest(x2, y2, e2);
        if (!result) {
          model.unhover(model.currentHovered);
          return;
        }
        if (model.currentCreating || model.currentEditing) {
          return;
        }
        const { primitiveId, hitTestResult } = result;
        const toolPrimitive = this._toolPrimitives.get(primitiveId);
        if (toolPrimitive) {
          model.setHoveredSource(toolPrimitive, hitTestResult);
        }
        if (!showCursor(paneCursor, PaneCursor.eraser)) {
          this._updateCursor(hitTestResult, false);
        }
      })
    );
    this._register(
      chartService.onClick((e2) => {
        var _a3, _b3, _c2;
        if ((_a3 = e2.sourceEvent) == null ? void 0 : _a3.shiftKey) {
          const paneIndex = ensure(e2.paneIndex);
          const time = ensure(getXCoordinate(this.chartService, e2.localX, { useExtended: true }));
          const price = ensure(
            ensure(this.chartService.getPaneSeries(paneIndex)).coordinateToPrice(e2.localY)
          );
          this.commandService.executeCommand(MeasureToolType, {
            preset: {
              chartService: this.chartService,
              paneIndex: 0,
              props: {
                points: [{ time, price }]
              }
            }
          });
          return;
        }
        const hit = this._hitTest(e2.localX, e2.localY, e2);
        if (!hit) {
          if (model.currentActive) {
            model.blur(model.currentActive);
          }
          return;
        }
        const toolPrimitive = this._toolPrimitives.get(hit.primitiveId);
        if (toolPrimitive) {
          if (showCursor(chartManagementService.getDefaultPaneCursor(), PaneCursor.eraser)) {
            this.detachToolPrimitive(toolPrimitive);
          } else {
            if (model.currentActive === toolPrimitive && isTextDetails(hit.hitTestResult.details)) {
              ensure(toolPrimitive.asTextToolPrimitive()).startTextEditing();
            }
            model.focus(toolPrimitive, FocusEventSource.select);
            if (hit.hitTestResult.details) {
              (_c2 = (_b3 = hit.hitTestResult.details).onClick) == null ? void 0 : _c2.call(_b3, {
                target: toolPrimitive,
                details: hit.hitTestResult.details,
                x: e2.localX,
                y: e2.localY
              });
            }
          }
        }
        const series = this._series.get(hit.primitiveId);
        if (series) {
          model.focus(series, FocusEventSource.select);
        }
      })
    );
    this._register(
      chartService.onMouseDragStart(() => {
        var _a3;
        if (((_a3 = this.toolService.activeTool) == null ? void 0 : _a3.type) !== MeasureToolType) {
          this._clearMeasure();
        }
        const pos = this.chartService.chartApi.getCrosshairPosition();
        if (!isValidPosition(pos)) return;
        const result = this._hitTest(pos.x, pos.y);
        if (!result) return;
        const { primitiveId, hitTestResult } = result;
        const toolPrimitive = this._toolPrimitives.get(primitiveId);
        if (!toolPrimitive) return;
        const startTime = ensure(
          this.chartService.chartApi.timeScale().coordinateToTimeEx(pos.x)
        );
        const paneIndex = ensure(pos.paneIndex);
        const series = ensure(this.chartService.getPaneSeries(paneIndex));
        const startPrice = ensure(series.coordinateToPrice(pos.y));
        this._currentDrag = {
          primitive: toolPrimitive,
          hitTestResult,
          points: cloneDeep(toolPrimitive.controlPoints),
          startX: pos.x,
          startTime,
          startY: pos.y,
          startPrice,
          takeEffect: false,
          series,
          editScope: toolService.acquireToolScope({
            useMagnet: hitTestResult.target === HitTarget.ChangePoint,
            isDrawing: true
          })
        };
        model.setHoveredSource(toolPrimitive, hitTestResult);
        this._disableDefaultDrag();
        this._updateCursor(hitTestResult, true);
      })
    );
    this._register(
      chartService.onMouseDrag((e2) => {
        var _a3, _b3, _c2, _d2, _e;
        if (!this._currentDrag) return;
        this._updateCursor(this._currentDrag.hitTestResult, true);
        const pos = this.chartService.chartApi.getCrosshairPosition();
        if (!this._currentDrag.takeEffect) {
          const distance = euclideanDistance(
            pos.x,
            pos.y,
            this._currentDrag.startX,
            this._currentDrag.startY
          );
          if (distance < DragEffectMinDistance) return;
          this._currentDrag.takeEffect = true;
          (_b3 = (_a3 = this._currentDrag.primitive).onDragStart) == null ? void 0 : _b3.call(_a3, this._currentDrag.hitTestResult);
          (_d2 = (_c2 = this._currentDrag.hitTestResult.details) == null ? void 0 : _c2.onDragStart) == null ? void 0 : _d2.call(_c2, {
            target: this._currentDrag.primitive,
            details: this._currentDrag.hitTestResult.details,
            x: e2.localX,
            y: e2.localY
          });
          model.focus(this._currentDrag.primitive, FocusEventSource.drag);
          (_e = this._toolbar) == null ? void 0 : _e.update({ visible: false });
        }
        const screenPoint = new Point(pos);
        const details = this._currentDrag.hitTestResult.details;
        let time = void 0;
        let price = void 0;
        if (isAnchorDetails(details)) {
          model.markPointEditingStarted(this._currentDrag.primitive, details.componentIndex);
          if (!canResizeHorz(details.resizeDirections)) {
            time = this._currentDrag.startTime;
          }
          if (!canResizeVert(details.resizeDirections)) {
            price = this._currentDrag.startPrice;
          }
        }
        if (time === void 0) {
          time = getXCoordinate(this.chartService, pos.x, {
            clamp: true,
            useExtended: !this._currentDrag.primitive.disableExtendTime
          });
        }
        if (price === void 0) {
          const y2 = clamp(pos.y, 0, this._currentDrag.series.getPane().getHeight());
          price = ensure(this._currentDrag.series.coordinateToPrice(y2));
        }
        this._currentDrag.primitive.updateDrag(
          this._currentDrag.hitTestResult.target,
          this._currentDrag.points,
          this._currentDrag.startTime,
          time,
          this._currentDrag.startPrice,
          price,
          screenPoint,
          this._currentDrag.hitTestResult.details,
          { shiftkey: e2.shiftKey }
        );
      })
    );
    this._register(
      chartService.onMouseDrop((e2) => {
        var _a3, _b3, _c2;
        if (((_a3 = this._currentDrag) == null ? void 0 : _a3.takeEffect) && this._currentDrag.primitive) {
          const pos = this.chartService.chartApi.getCrosshairPosition();
          const { _currentDrag } = this;
          const screenPoint = new Point(pos);
          const details = this._currentDrag.hitTestResult.details;
          let time = void 0;
          let price = void 0;
          if (isAnchorDetails(details)) {
            model.markPointEditingStarted(this._currentDrag.primitive, details.componentIndex);
            if (!canResizeHorz(details.resizeDirections)) {
              time = this._currentDrag.startTime;
            }
            if (!canResizeVert(details.resizeDirections)) {
              price = this._currentDrag.startPrice;
            }
          }
          if (time === void 0) {
            time = getXCoordinate(this.chartService, pos.x, {
              clamp: true,
              useExtended: !this._currentDrag.primitive.disableExtendTime
            });
          }
          if (price === void 0) {
            const y2 = clamp(pos.y, 0, this._currentDrag.series.getPane().getHeight());
            price = ensure(this._currentDrag.series.coordinateToPrice(y2));
          }
          this._currentDrag.primitive.updateDrag(
            this._currentDrag.hitTestResult.target,
            this._currentDrag.points,
            this._currentDrag.startTime,
            time,
            this._currentDrag.startPrice,
            price,
            screenPoint,
            this._currentDrag.hitTestResult.details,
            { shiftkey: e2.shiftKey }
          );
          (_c2 = (_b3 = _currentDrag == null ? void 0 : _currentDrag.hitTestResult.details) == null ? void 0 : _b3.onDrop) == null ? void 0 : _c2.call(_b3, {
            target: _currentDrag.primitive,
            details: _currentDrag.hitTestResult.details,
            x: pos.x,
            y: pos.y,
            price,
            time
          });
          if (!_currentDrag.primitive.disableUserSelection && !_currentDrag.primitive.disableToolbar) {
            this.lazyToolbar().update({ visible: true });
          }
        }
        this._resetDragStatus();
      })
    );
    this._register(
      chartService.onMouseDropCanceled(() => {
        this._resetDragStatus();
      })
    );
    this._register(
      chartService.onDrawingsVisibility((visible) => {
        if (this._visible === visible) return;
        this._visible = visible;
        model.reset();
        if (visible) {
          should(!this._toolPrimitives.size);
          this._toolPrimitives = this._hiddenToolPrimitives;
          this._hiddenToolPrimitives = /* @__PURE__ */ new Map();
          this._toolPrimitives.values().forEach((pm) => {
            pm.reAttach();
          });
        } else {
          should(!this._hiddenToolPrimitives.size);
          this._hiddenToolPrimitives = this._toolPrimitives;
          this._toolPrimitives = /* @__PURE__ */ new Map();
          this._toolHitTestObjects.clear();
          this._pendingToolHitTestObjects.clear();
          this._hiddenToolPrimitives.values().forEach((pm) => {
            pm.detach();
          });
        }
      })
    );
    this._register(
      clipboardService.onPaste((data) => {
        this.handlePaste(data);
      })
    );
    this._register(
      chartService.onMouseUp((e2) => {
        var _a3, _b3;
        const browserEvent = e2.originEvent;
        if (browserEvent.button !== 2) {
          return;
        }
        const result = this._hitTest(e2.localX, e2.localY);
        if (!result) {
          return;
        }
        const primitive = this._toolPrimitives.get(result.primitiveId);
        if (primitive) {
          (_b3 = (_a3 = result.hitTestResult.details) == null ? void 0 : _a3.onContextMenu) == null ? void 0 : _b3.call(_a3, {
            target: primitive,
            details: result.hitTestResult.details,
            x: e2.localX,
            y: e2.localY
          });
        }
      })
    );
  }
  lazyToolbar() {
    if (!this._toolbar) {
      this._register(
        this._toolbar = this.guiService.showComponent({
          Component: Toolbar,
          props: { visible: false, ...this.getToolbarHandlers() }
        })
      );
    }
    return this._toolbar;
  }
  dispose() {
    super.dispose();
    this._toolPrimitives.values().forEach((p2) => p2.detach());
    this._toolPrimitives.clear();
    this._hiddenToolPrimitives.values().forEach((p2) => p2.detach());
    this._hiddenToolPrimitives.clear();
    this._toolHitTestObjects.clear();
    this._pendingToolHitTestObjects.clear();
  }
  handlePaste(data) {
    var _a3;
    const fragment = parseFragmentString(data.html);
    const images = (_a3 = data.files) == null ? void 0 : _a3.filter((f2) => f2.type.startsWith("image"));
    if (images && images.length) {
      for (const img of images) {
        const fileName = Reflect.get(fragment ?? {}, FileNameKey);
        this._pasteImage(img, fileName === img.name ? fragment ?? void 0 : void 0);
      }
    }
    if (fragment && fragment.type !== ImageToolType) {
      this._pasteFragment(fragment);
      return;
    }
  }
  getToolbarHandlers() {
    return {
      onRemove: () => {
        this.commandService.executeCommand(RemoveDrawingCommand);
      },
      onLock: () => {
      },
      onCopy: () => {
        this.commandService.executeCommand(CopyDrawingCommand);
      },
      onClone: () => {
        this.commandService.executeCommand(CloneDrawingCommand);
      }
    };
  }
  _updateCursor(hitTestResult, dragging) {
    const details = hitTestResult.details;
    if (isAnchorDetails(details)) {
      const { resizeDirections } = details;
      if (canResizeAll(resizeDirections) && !details.cursorType) {
        this.chartService.showPaneCursor(PaneCursor.arrow);
        return;
      }
      if (canResizeHorz(resizeDirections) && !details.cursorType) {
        this.chartService.showPaneCursor(PaneCursor.ew);
        return;
      }
      if (canResizeVert(resizeDirections) && !details.cursorType) {
        this.chartService.showPaneCursor(PaneCursor.ns);
        return;
      }
    }
    if (details == null ? void 0 : details.cursorType) {
      this.chartService.showPaneCursor(details.cursorType);
      return;
    }
    if (dragging) {
      this.chartService.showPaneCursor(PaneCursor.grabbing);
      return;
    }
    if (hitTestResult.target === HitTarget.ChangePoint) {
      this.chartService.showPaneCursor(PaneCursor.arrow);
      return;
    }
    if (hitTestResult.target === HitTarget.MovePoint || hitTestResult.target === HitTarget.Regular) {
      this.chartService.showPaneCursor(PaneCursor.pointer);
    }
  }
  _resetDragStatus() {
    var _a3, _b3, _c2;
    if (!this._currentDrag) return;
    this._enableDefaultDrag();
    (_a3 = this._currentDrag.editScope) == null ? void 0 : _a3.dispose();
    if (this._currentDrag.takeEffect) {
      (_c2 = (_b3 = this._currentDrag.primitive).onDragEnd) == null ? void 0 : _c2.call(_b3, this._currentDrag.hitTestResult);
      this.chartService.showPaneCursor(PaneCursor.pointer);
      if (isAnchorDetails(this._currentDrag.hitTestResult.details)) {
        this.chartService.getModel().markPointEditingFinishedOrAborted();
      }
    }
    this._currentDrag = void 0;
  }
  _disableDefaultDrag() {
    this.chartService.chartApi.applyOptions({
      handleScale: false,
      handleScroll: false,
      crosshair: {
        horzLine: {
          visible: false,
          labelVisible: false
        },
        vertLine: {
          visible: false,
          labelVisible: false
        }
      }
    });
  }
  _enableDefaultDrag() {
    this.chartService.chartApi.applyOptions({
      handleScale: true,
      handleScroll: true,
      crosshair: {
        horzLine: {
          visible: true,
          labelVisible: true
        },
        vertLine: {
          visible: true,
          labelVisible: true
        }
      }
    });
  }
  _hitTest(x2, y2, e2) {
    const { paneIndex } = this.chartService.chartApi.getCrosshairPosition();
    if (isUndefinedOrNull(paneIndex)) return null;
    const point = new Point(x2, y2);
    const scope = {
      mediaSize: {
        width: this.chartService.chartApi.timeScale().width(),
        height: this.chartService.mainSeriesApi.getSeries().getPane().getHeight()
      }
    };
    const { currentActive } = this.chartService.getModel();
    if (currentActive && currentActive.paneIndex() === paneIndex) {
      const objs = this._toolHitTestObjects.get(currentActive.id) ?? [];
      for (let i2 = objs.length - 1; i2 >= 0; i2--) {
        const hit = objs[i2].hitTest(point, scope);
        if (hit)
          return {
            hitTestResult: hit,
            primitiveId: currentActive.id
          };
      }
    }
    for (const [id2, objs] of this._toolHitTestObjects.entries()) {
      const pm = ensure(this._toolPrimitives.get(id2));
      if (pm.paneIndex() === paneIndex) {
        for (let i2 = objs.length - 1; i2 >= 0; i2--) {
          const hit = objs[i2].hitTest(point, scope);
          if (hit)
            return {
              hitTestResult: hit,
              primitiveId: id2
            };
        }
      }
    }
    for (const [id2, objs] of this._seriesHitTestObjects.entries()) {
      const series = ensure(this._series.get(id2));
      if (series.paneIndex() === paneIndex) {
        for (let i2 = objs.length - 1; i2 >= 0; i2--) {
          const hit = objs[i2].hitTest(point, scope);
          if (hit)
            return {
              hitTestResult: hit,
              primitiveId: id2
            };
        }
      }
    }
    if (e2 == null ? void 0 : e2.hoveredSeries) {
      return {
        hitTestResult: new HitTestResult(HitTarget.Regular),
        primitiveId: this.chartService.mainSeriesApi.id
      };
    }
    return null;
  }
  _pasteFragment(fragment) {
    const width = this.chartService.chartApi.timeScale().width();
    const height = this.chartService.mainSeriesApi.getSeries().getPane().getHeight();
    const centerTime = this.chartService.chartApi.timeScale().coordinateToTimeEx(width / 2);
    if (centerTime === null) return;
    const centerPrice = this.chartService.mainSeriesApi.getSeries().coordinateToPrice(height / 2);
    if (centerPrice === null) return;
    const { props } = fragment;
    const deltaTime = centerTime - props.points[0].time;
    const deltaPrice = centerPrice - props.points[0].price;
    props.points.forEach((p2) => {
      p2.time = p2.time + deltaTime;
      p2.price = p2.price + deltaPrice;
    });
    Reflect.deleteProperty(props, "id");
    this.commandService.executeCommand(fragment.type, {
      source: TriggerSource.program,
      preset: {
        chartService: this.chartService,
        paneIndex: 0,
        props
      }
    });
  }
  async _pasteImage(imgFile, fragment) {
    await this.toolService.switchTool(PasteImageToolType, TriggerSource.manual);
    const activeTool = this.toolService.activeTool;
    if (fragment) {
      const width = this.chartService.chartApi.timeScale().width();
      const height = this.chartService.mainSeriesApi.getSeries().getPane().getHeight();
      const centerTime = this.chartService.chartApi.timeScale().coordinateToTimeEx(width / 2);
      if (centerTime === null) return;
      const centerPrice = this.chartService.mainSeriesApi.getSeries().coordinateToPrice(height / 2);
      if (centerPrice === null) return;
      const props = fragment.props;
      const deltaTime = centerTime - props.points[0].time;
      const deltaPrice = centerPrice - props.points[0].price;
      props.points.forEach((p2) => {
        p2.time = p2.time + deltaTime;
        p2.price = p2.price + deltaPrice;
      });
      Reflect.deleteProperty(props, "id");
      props.image = imgFile;
      activeTool.receivePresetProps({
        paneIndex: 0,
        props
      });
    } else {
      activeTool.onImage(imgFile);
    }
  }
  _clearMeasure() {
    const measures = Array.from(
      this._toolPrimitives.values().filter((p2) => p2.type === MeasureToolType)
    );
    while (measures.length) {
      const pm = ensure(measures.pop());
      this.detachToolPrimitive(pm);
    }
  }
  detachToolPrimitive(pm) {
    var _a3;
    should(pm);
    const id2 = pm.id;
    const model = this.chartService.getModel();
    if (model.currentHovered === pm) {
      model.unhover(model.currentHovered);
    }
    if (model.currentActive === pm) {
      model.blur(model.currentActive);
    }
    if (model.currentCreating === pm) {
      model.markCreatingFinishedOrAborted(pm);
    }
    if (pm === ((_a3 = this._currentDrag) == null ? void 0 : _a3.primitive)) {
      this._resetDragStatus();
    }
    pm.detach();
    this._toolPrimitives.delete(id2);
    this._toolHitTestObjects.delete(id2);
    this._pendingToolHitTestObjects.delete(id2);
    this.chartService.getStoreHandler().removeDrawingInfo(pm.id);
  }
  attachToolPrimitive(pm, focus) {
    should(!this._toolPrimitives.has(pm.id));
    should(pm.isAttached);
    if (pm.type === MeasureToolType) {
      this._clearMeasure();
    }
    if (!this._visible) {
      this.chartManagementService.setHideBits(0);
    }
    this._toolPrimitives.set(pm.id, pm);
    this.chartService.getStoreHandler().addDrawingInfo({ id: pm.id });
    if (focus && !pm.disableUserSelection) {
      this.chartService.getModel().focus(pm, FocusEventSource.select);
    }
  }
  detachToolPrimitiveById(id2) {
    const pm = this._toolPrimitives.get(id2);
    if (pm) {
      this.detachToolPrimitive(pm);
    }
  }
  getToolPrimitiveById(id2) {
    return this._toolPrimitives.get(id2) ?? null;
  }
  collectToolHitTestObjects(id2, objects) {
    var _a3;
    if (!objects) return;
    const pm = ensure(this._toolPrimitives.get(id2));
    if (this.chartService.getModel().currentCreating === pm) return;
    if ((_a3 = this._userShapesOptions.get(id2)) == null ? void 0 : _a3.disableSelection) return;
    if (!this._pendingToolHitTestObjects.has(id2)) this._pendingToolHitTestObjects.set(id2, []);
    const arr = ensure(this._pendingToolHitTestObjects.get(id2));
    if (Array.isArray(objects)) arr.push(...objects);
    else arr.push(objects);
    tick$1(() => {
      if (!this._toolPrimitives.has(id2)) return;
      const pending = ensure(this._pendingToolHitTestObjects.get(id2));
      if (!pending.length) return;
      this._toolHitTestObjects.set(id2, pending);
      this._pendingToolHitTestObjects.set(id2, []);
    });
  }
  onSeriesCreated(id2, series) {
    this._series.set(id2, series);
  }
  onSeriesRemoved(id2) {
    this._series.delete(id2);
    this._seriesHitTestObjects.delete(id2);
    this._pendingSeriesHitTestObjects.delete(id2);
  }
  collectSeriesHitTestObjects(id2, objects) {
    if (!objects) return;
    if (!this._pendingSeriesHitTestObjects.has(id2)) this._pendingSeriesHitTestObjects.set(id2, []);
    const arr = ensure(this._pendingSeriesHitTestObjects.get(id2));
    if (Array.isArray(objects)) {
      arr.push(...objects);
    } else {
      arr.push(objects);
    }
    tick$1(() => {
      if (!this._series.has(id2)) return;
      const pending = ensure(this._pendingSeriesHitTestObjects.get(id2));
      if (!pending.length) return;
      this._seriesHitTestObjects.set(id2, pending);
      this._pendingSeriesHitTestObjects.set(id2, []);
    });
  }
  removeAll() {
    this._toolPrimitives.values().forEach((p2) => {
      p2.detach();
    });
    this.chartService.getStoreHandler().removeAllDrawingInfos();
    this._toolPrimitives.clear();
    this._hiddenToolPrimitives.clear();
    this._toolHitTestObjects.clear();
    this._pendingToolHitTestObjects.clear();
    this.chartService.getModel().reset();
  }
  async createShape(point, options) {
    var _a3;
    const shapeMap = {
      arrow_up: ArrowMarkUpToolType,
      arrow_down: ArrowMarkDownToolType,
      flag: FlagMarkToolType,
      vertical_line: VerticalLineToolType,
      horizontal_line: HorizontalLineToolType,
      long_position: LongPositionToolType,
      short_position: ShortPositionToolType,
      icon: IconToolType,
      emoji: EmojiToolType,
      text: TextToolType,
      anchored_text: AnchoredTextToolType,
      note: PinToolType,
      anchored_note: PinFixedToolType
    };
    const primitiveId = await this.commandService.executeCommand(shapeMap[options.shape], {
      source: TriggerSource.program,
      preset: {
        chartService: this.chartService,
        paneIndex: 0,
        props: point ? {
          points: [point],
          ...options.overrides
        } : { ...options.overrides }
      }
    });
    if (((_a3 = this.chartService.getModel().currentActive) == null ? void 0 : _a3.id) === primitiveId) {
      this.chartService.getModel().reset();
    }
    const entityId = ensure(primitiveId);
    this._userShapesOptions.set(entityId, {
      disableSelection: options.disableSelection
    });
    return entityId;
  }
  removeEntity(entityId) {
    this._userShapesOptions.delete(entityId);
    const pm = this._toolPrimitives.get(entityId);
    if (!pm) return;
    this.detachToolPrimitive(pm);
  }
};
ChartController = __decorateClass$f([
  __decorateParam$e(0, IChartService),
  __decorateParam$e(1, IChartManagementService),
  __decorateParam$e(2, IToolService),
  __decorateParam$e(3, IGuiService),
  __decorateParam$e(4, ICommandService),
  __decorateParam$e(5, IClipboardService)
], ChartController);
class DeferredPromise2 {
  constructor() {
    __publicField(this, "completeCallback");
    __publicField(this, "errorCallback");
    __publicField(this, "outcome");
    __publicField(this, "p");
    this.p = new Promise((c2, e2) => {
      this.completeCallback = c2;
      this.errorCallback = e2;
    });
  }
  get isRejected() {
    var _a3;
    return ((_a3 = this.outcome) == null ? void 0 : _a3.outcome) === 1;
  }
  get isResolved() {
    var _a3;
    return ((_a3 = this.outcome) == null ? void 0 : _a3.outcome) === 0;
  }
  get isSettled() {
    return !!this.outcome;
  }
  get value() {
    var _a3, _b3;
    return ((_a3 = this.outcome) == null ? void 0 : _a3.outcome) === 0 ? (_b3 = this.outcome) == null ? void 0 : _b3.value : void 0;
  }
  complete(value) {
    return new Promise((resolve) => {
      this.completeCallback(value);
      this.outcome = { outcome: 0, value };
      resolve();
    });
  }
  error(err) {
    return new Promise((resolve) => {
      this.errorCallback(err);
      this.outcome = { outcome: 1, value: err };
      resolve();
    });
  }
}
class ChartGuiService extends Disposable {
  constructor() {
    super();
    __publicField(this, "_onPaneTooltipRequested", this._register(new Emitter()));
    __publicField(this, "onPaneTooltipRequested", this._onPaneTooltipRequested.event);
    __publicField(this, "_onPaneTooltipCancelled", this._register(new Emitter()));
    __publicField(this, "onPaneTooltipCancelled", this._onPaneTooltipCancelled.event);
    __publicField(this, "store");
    __publicField(this, "instanceMap", /* @__PURE__ */ new Map());
    __publicField(this, "apiMap", /* @__PURE__ */ new Map());
    this.store = writable({
      components: []
    });
    this._register(
      toDisposable(() => {
        this.instanceMap.clear();
        this.apiMap.clear();
      })
    );
  }
  showPaneTooltip(params) {
    this._onPaneTooltipRequested.fire(params);
  }
  hidePaneTooltip() {
    this._onPaneTooltipCancelled.fire();
  }
  showComponent(params) {
    const id2 = generateUuid();
    this.store.update((store) => {
      store.components.push({
        id: id2,
        Component: params.Component,
        props: params.props
      });
      return store;
    });
    const promise = new DeferredPromise2();
    const componentApi = {
      dispose: () => {
        this.store.update((store) => {
          const idx = store.components.findIndex((c2) => c2.id === id2);
          if (idx !== -1) {
            store.components.splice(idx, 1);
          }
          return { ...store };
        });
        this.apiMap.delete(id2);
      },
      update: (props) => {
        this.store.update((store) => {
          const info = store.components.find((c2) => c2.id === id2);
          if (!info) return store;
          const isSame = Object.keys(props).every((key2) => {
            return info.props[key2] === props[key2];
          });
          if (isSame) return store;
          Object.assign(info.props, props);
          return { ...store };
        });
      },
      getInstance: () => {
        return this.instanceMap.get(id2);
      },
      promise,
      get mounted() {
        return promise.p;
      }
    };
    this.apiMap.set(id2, componentApi);
    return componentApi;
  }
  onComponentMounted(id2, instance) {
    ensure(this.apiMap.get(id2)).promise.complete(void 0);
    this.instanceMap.set(id2, instance);
  }
}
const SUNDAY = 1;
const MONDAY = 2;
const TUESDAY = 3;
const WEDNESDAY = 4;
const THURSDAY = 5;
const FRIDAY = 6;
const SATURDAY = 7;
const minutesPerDay = 1440;
const millisecondsPerDay = 864e5;
const DaysOfWeek = [SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY];
function getUTCFullYear(date) {
  return date.getUTCFullYear();
}
function getUTCMonth(date) {
  return date.getUTCMonth();
}
function getUTCHours(date) {
  return date.getUTCHours();
}
function getUTCMinutes(date) {
  return date.getUTCMinutes();
}
function getUTCDayOfMonth(date) {
  return date.getUTCDate();
}
function getUTCDayOfWeek(date) {
  return date.getUTCDay() + 1;
}
function getDayOfWeek(date) {
  return date.getDay() + 1;
}
function getNextDay(day) {
  const idx = DaysOfWeek.indexOf(day);
  return DaysOfWeek[idx + 1] ?? DaysOfWeek[0];
}
function getUTCMinutesFromMidnight(date) {
  return getUTCHours(date) * 60 + getUTCMinutes(date);
}
function getUTCMinutesWithHours(date) {
  return getUTCMinutesFromMidnight(date);
}
function getMinutesFromMidnight(date) {
  return date.getHours() * 60 + date.getMinutes();
}
function getMinutesWithHours(date) {
  return getMinutesFromMidnight(date);
}
function set_utc_hms(date, h2, m2, s2, ms2) {
  date.setUTCHours(h2);
  date.setUTCMinutes(m2);
  date.setUTCSeconds(s2);
  date.setUTCMilliseconds(ms2);
}
function set_hms(date, h2, m2, s2, ms2) {
  date.setHours(h2);
  date.setMinutes(m2);
  date.setSeconds(s2);
  date.setMilliseconds(ms2);
}
function add_date(date, days) {
  date.setTime(date.getTime() + days * millisecondsPerDay);
}
function add_minutes(date, minutes) {
  date.setTime(date.getTime() + minutes * 6e4);
}
function cloneDate(date) {
  return new Date(date.getTime());
}
function is_leap_year(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function get_cal(year, month, day, hour = 0, minute = 0, second = 0) {
  return new Date(Date.UTC(year, month, day, hour, minute, second));
}
function get_cal_from_unix_timestamp_ms(timestamp) {
  return new Date(timestamp);
}
function get_cal_utc(year, month, day, hour = 0, minute = 0, second = 0) {
  return new Date(Date.UTC(year, month, day, hour, minute, second));
}
function addLeadingZero(num) {
  return addLeadingZeros(num, 2);
}
function addLeadingZeros(num, length = 2) {
  const str = num.toString();
  const zerosNeeded = Math.max(0, length - str.length);
  return "0".repeat(zerosNeeded) + str;
}
class BusinessDay {
  constructor(year, month, day) {
    __publicField(this, "year");
    __publicField(this, "month");
    // 1-based (1=January)
    __publicField(this, "day");
    this.year = year;
    this.month = month;
    this.day = day;
  }
  /**
   * Return formatted string "YYYY-MM-DD"
   */
  toString() {
    return `${addLeadingZeros(this.year, 4)}-${addLeadingZero(this.month)}-${addLeadingZero(this.day)}`;
  }
  /**
   * Return string in format "YYYYMMDD" (e.g., 20240205)
   */
  toyyyymmdd() {
    return `${addLeadingZeros(this.year, 4)}${addLeadingZero(this.month)}${addLeadingZero(this.day)}`;
  }
  /**
   * Compare with another BusinessDay (returns 1 / 0 / -1)
   */
  compareTo(other) {
    if (this.year > other.year || this.year === other.year && this.month > other.month || this.year === other.year && this.month === other.month && this.day > other.day) {
      return 1;
    } else if (this.year === other.year && this.month === other.month && this.day === other.day) {
      return 0;
    } else {
      return -1;
    }
  }
  /**
   * Check if this date is before another one
   */
  before(other) {
    return this.compareTo(other) === -1;
  }
  /**
   * Convert to a Date object (with optional timezone)
   */
  toCalendar() {
    return get_cal(this.year, this.month - 1, this.day);
  }
  /**
   * Add n days and return a new BusinessDay
   */
  // addDays(days: number): BusinessDay {
  //   const date = this.toCalendar(get_timezone('Etc/UTC'));
  //   add_date(date, days); // mutate date
  //   return BusinessDay.fromCalendar(date);
  // }
  /**
   * Return the first day of the same year
   */
  firstDayOfYear() {
    return new BusinessDay(this.year, 1, 1);
  }
  /**
   * Get the day of the week (1~7: Sun~Sat or Mon~Sun depends on implementation)
   */
  // getDayOfWeek(): number {
  //   const date = this.toCalendar();
  //   return get_day_of_week(date);
  // }
  /**
   * Static method: create BusinessDay from Date object
   */
  static fromCalendar(date) {
    return new BusinessDay(
      getUTCFullYear(date),
      getUTCMonth(date) + 1,
      // month is returned as 0-based
      getUTCDayOfMonth(date)
    );
  }
}
const WorkingDays = [MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY];
const monthLengths = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function devFormatTime(totalMinutes) {
  const MINUTES_IN_DAY = 1440;
  while (totalMinutes > MINUTES_IN_DAY) {
    totalMinutes -= MINUTES_IN_DAY;
  }
  const minutes = totalMinutes % 60;
  const hours = Math.floor((totalMinutes - minutes) / 60);
  return hours + ":" + minutes;
}
let _devWeekDayLabels = null;
function devGetWeekDayLabels() {
  if (_devWeekDayLabels) return _devWeekDayLabels;
  _devWeekDayLabels = DaysOfWeek.reduce(
    (labelMap, dayOfMonth) => {
      const dayIndex = dayOfMonth < 7 ? dayOfMonth + 1 : 1;
      const weekdayName = new Date(2018, 0, dayOfMonth).toLocaleString(window.navigator.language, {
        weekday: "short"
      });
      labelMap[dayIndex] = weekdayName;
      return labelMap;
    },
    {}
  );
  return _devWeekDayLabels;
}
class SessionEntry {
  // 持续时间（分钟）
  constructor(dayOfWeek, startOffset, length) {
    __publicField(this, "_dayOfWeek");
    // 星期几 [0 = SUNDAY, ... 6 = SATURDAY]
    __publicField(this, "_start");
    // 起始分钟偏移（可为负数，表示跨夜）
    __publicField(this, "_length");
    should(
      Number.isFinite(dayOfWeek) && Number.isFinite(startOffset) && Number.isFinite(length),
      "Invalid arguments"
    );
    this._dayOfWeek = dayOfWeek;
    this._start = startOffset;
    this._length = length;
  }
  /**
  获取会话起始的绝对分钟位置（包括前导跨日偏移），适合排序或比较
  */
  start() {
    return this._start + minutesPerDay * this.sessionStartDaysOffset();
  }
  end() {
    const end = this.start() + this.length();
    if (end > minutesPerDay) {
      return end % minutesPerDay;
    }
    return end;
  }
  /**
  获取当天内的起始分钟偏移（可能为负，表示跨日）
  */
  startOffset() {
    return this._start;
  }
  /**
  返回当前会话实际从哪个“自然日”开始（相对 dayOfWeek 向前偏移的天数）
  默认返回 0，跨夜场景返回 -1 或 -2 …
  */
  sessionStartDaysOffset() {
    if (this._start >= 0) return 0;
    return this._start % minutesPerDay === 0 ? -Math.ceil(this._start / minutesPerDay) : -Math.floor(this._start / minutesPerDay);
  }
  /**
  判断该会话是否为跨日交易段（即开始时间为负）
  */
  isOvernight() {
    return this._start < 0;
  }
  /**
  获取这条 entry 本地定义的工作日（注意不是 session 实际起始日）
  */
  dayOfWeek() {
    return this._dayOfWeek;
  }
  /**
  获取该 Session 实际“所属的自然日”（用于对齐左边界）
  = dayOfWeek - offset（必要时循环加 7）
  */
  sessionStartDayOfWeek() {
    let day = this._dayOfWeek - this.sessionStartDaysOffset();
    if (day < SUNDAY) day += 7;
    return day;
  }
  /**
  获取会话持续时长（单位：分钟）
  */
  length() {
    return this._length;
  }
  /**
  比较两个 SessionEntry 是否有时间重叠
  若重叠返回 0，若当前在参数之后返回 1，否则返回 -1（用于排序）
  */
  compareTo(other) {
    const startA = this._weight();
    const endA = startA + this._length;
    const startB = other._weight();
    const endB = startB + other._length;
    const overlaps = startA <= startB && startB < endA || startB <= startA && startA < endB;
    if (overlaps) return 0;
    if (startA > startB) return 1;
    return -1;
  }
  /**
  判断给定日期时间是否落入该 SessionEntry
  */
  containsUTC(date) {
    const minutesOfDay = getUTCMinutesWithHours(date);
    const dayOfWeek = getUTCDayOfWeek(date);
    return this._contains(minutesOfDay, dayOfWeek);
  }
  containsZoned(zonedDate) {
    const minutesOfDay = getMinutesWithHours(zonedDate);
    const dayOfWeek = getDayOfWeek(zonedDate);
    return this._contains(minutesOfDay, dayOfWeek);
  }
  /**
  将该 entry 的排序基权重（用于排序比较）
  将当前 weekday 和起始分钟组合为一个线性值
  */
  _weight() {
    return this._dayOfWeek * minutesPerDay + this._start;
  }
  /**
  内部检测时间是否包含（更基础的重载版本）
  @param minuteOfDay 当天中分钟数
  @param dayOfWeek 当前星期（0–6）
  */
  _contains(minuteOfDay, dayOfWeek) {
    let deltaDays = dayOfWeek - this._dayOfWeek;
    if (deltaDays > 0) {
      deltaDays -= 7;
    }
    const totalOffset = deltaDays * minutesPerDay + minuteOfDay;
    return totalOffset >= this._start && totalOffset < this._start + this._length;
  }
  toString() {
    const sessionStartDay = this.sessionStartDayOfWeek();
    const offset = this.sessionStartDaysOffset();
    const endOffset = this.sessionStartDaysOffset() + this.length();
    let sessionEndDay = sessionStartDay + (offset === endOffset ? 0 : offset);
    while (sessionEndDay > 7) sessionEndDay -= 7;
    const isCrossDay = sessionStartDay !== this.dayOfWeek() || sessionEndDay !== this.dayOfWeek();
    const startDayLabel = isCrossDay ? devGetWeekDayLabels()[sessionStartDay] : "";
    const endDayLabel = isCrossDay ? devGetWeekDayLabels()[sessionEndDay] : "";
    return `${devFormatTime(this.start())}/${startDayLabel}-${devFormatTime(this.start() + this.length())}/${endDayLabel}`;
  }
}
function compareSessions(l2, r2) {
  return l2.compareTo(r2);
}
class SessionEntries {
  /**
  
     @param entriesList 所有 session 条目的有序列表
     @param entriesByDay Map，每天的 sessionEntry 列表
     @param firstDayOfWeek 该容器的“首日”定义（如周一或周日）
     @param weekEndsCount 一周中非交易日的天数（即没有 entries 的日子数）
     */
  constructor(entriesList, entriesByDay, firstDayOfWeek, weekEndsCount) {
    __publicField(this, "_entriesList");
    __publicField(this, "_entriesByDay");
    __publicField(this, "_firstDayOfWeek");
    __publicField(this, "_weekEndsCount");
    this._entriesList = entriesList;
    this._entriesByDay = entriesByDay;
    this._firstDayOfWeek = firstDayOfWeek;
    this._weekEndsCount = weekEndsCount;
  }
  /**
  
     返回定义的一周中首个交易日（如 MONDAY）
     */
  firstDayOfWeek() {
    return this._firstDayOfWeek;
  }
  /**
  
     返回按星期分组的所有 session 条目
     */
  entriesByDay() {
    return this._entriesByDay;
  }
  entryOfDay(day) {
    return this._entriesByDay.get(day) ?? null;
  }
  /**
  
     返回包含所有 SessionEntry 的完整列表（扁平结构）
     */
  list() {
    return this._entriesList;
  }
  /**
  
     判断指定星期是否为空，即是否是周末/非交易日
     @param dayOfWeek 0 = 周日，6 = 周六
     */
  isWeekEnd(dayOfWeek) {
    return !this._entriesByDay.has(dayOfWeek);
  }
  /**
  
     返回非交易日总数（即 entriesByDay 中缺失的星期几数量）
     */
  weekEndsCount() {
    return this._weekEndsCount;
  }
}
class SessionHistoryEntry {
  /**
  
     构造函数
     @param startDay 该段历史的实际起始日期，如果没有自动对齐历史则可能为 null
     @param specEndDay 明确指定的结束日期（不包含该日），为 null 表示开放式（即当前session）
     @param entries 一个周为单位的 SessionEntries 容器，包含本段交易时间定义
     */
  constructor(startDay, specEndDay, entries) {
    __publicField(this, "_startDay");
    __publicField(this, "_specEndDay");
    __publicField(this, "_entries");
    this._startDay = startDay;
    this._specEndDay = specEndDay;
    this._entries = entries;
  }
  /**
  
     获取该 session 区段的会话时段定义（容器包含该段的按周定义）
     */
  getEntries() {
    return this._entries;
  }
  /**
  
     返回起始日期（用于定位在哪一段生效）
     */
  getStartDay() {
    return this._startDay;
  }
  /**
  
     返回该段定义的“结束日期”（不包含这一天），为 null 表示延续到 present
     */
  getSpecEndDay() {
    return this._specEndDay;
  }
  /**
  
     是否为开放式 session（即当前 session，没有结束定义）
     */
  isOpenEnded() {
    return this._specEndDay == null;
  }
}
class SessionParser {
  constructor() {
    __publicField(this, "historyEntries", []);
    __publicField(this, "timezone", "");
    __publicField(this, "hasHistoryCorrections", false);
    __publicField(this, "adjustSessionsIndexes", null);
    __publicField(this, "_firstDayOfWeek", null);
  }
  parseSessions(timezone, sessions) {
    this._parseHistoryEntries(timezone, sessions, false);
  }
  parseSessionsAndValidateDateTime(timezone, sessions) {
    this._parseHistoryEntries(timezone, sessions, true);
  }
  static parseHolidaysAndCorrections(timezone, holidays, corrections, validate) {
    return this._parseHolidaysAndCorrectionsImpl(timezone, holidays, corrections, validate);
  }
  static parseHolidaysAndCorrectionsAndValidateDateTime(timezone, holidays, corrections) {
    return this._parseHolidaysAndCorrectionsImpl(timezone, holidays, corrections, true);
  }
  _clearAll() {
    this.timezone = "";
    this.historyEntries = [];
    this.adjustSessionsIndexes = [];
  }
  _parseHistoryEntries(timezone, definition, validate) {
    this._clearAll();
    const parts = definition.split("/");
    let prevEndDay = null;
    this.hasHistoryCorrections = parts.length > 1;
    for (let i2 = 0; i2 < parts.length; i2++) {
      const segment = parts[i2].split("#");
      let endDate;
      if (i2 !== parts.length - 1) {
        if (segment.length !== 2)
          throw new Error(`bad session history entry definition: ${parts[i2]}`);
        endDate = SessionParser._parseDay(
          segment[1],
          "session history entry end",
          validate
        ).toCalendar();
      } else {
        if (segment.length !== 1)
          throw new Error(`bad session history entry definition: ${parts[i2]}`);
        endDate = null;
      }
      if (prevEndDay !== null && endDate !== null && endDate.getTime() < prevEndDay.getTime()) {
        throw new Error(
          `history sessions are not listed in ascending order (${prevEndDay} -> ${endDate})`
        );
      }
      const sessionEntries = this._parseSessionsImpl(timezone, segment[0], validate);
      const startDay = this._adjustStartToPreviousSession(sessionEntries.firstDayOfWeek());
      const historyEntry = new SessionHistoryEntry(startDay, endDate, sessionEntries);
      this.historyEntries.push(historyEntry);
      prevEndDay = endDate;
    }
  }
  _parseSessionsImpl(timezone, spec, validate) {
    this.timezone = timezone;
    spec = this._parseFirstDayOfWeek(spec);
    const entriesByDay = /* @__PURE__ */ new Map();
    const allEntries = [];
    if (spec.toLowerCase() === "24x7") {
      for (const day of DaysOfWeek) {
        const entry = SessionParser._createSessionEntry(day, 0, 0, 0, 0);
        allEntries.push(entry);
        entriesByDay.set(day, [entry]);
      }
    } else {
      let hasDefault = false;
      const sectionMap = /* @__PURE__ */ new Map();
      for (const section of spec.split("|")) {
        const parts = section.split(":").filter(Boolean);
        if (parts.length !== 1 && parts.length !== 2)
          throw new Error(`bad session section: ${section}`);
        const isDefault = parts.length === 1;
        if (isDefault) {
          if (hasDefault) throw new Error(`duplicated default section: ${section}`);
          hasDefault = true;
        }
        const days = isDefault ? WorkingDays : SessionParser._parseWorkingDays(parts[1]);
        for (const day of days) {
          if (isDefault && sectionMap.has(day)) continue;
          sectionMap.set(day, parts[0]);
        }
      }
      for (const day of DaysOfWeek) {
        const entryString = sectionMap.get(day);
        if (entryString !== void 0) {
          for (const rawEntry of entryString.split(",").filter(Boolean)) {
            const entry = SessionParser._parseSessionEntry(day, rawEntry, validate);
            const list = entriesByDay.get(day) ?? [];
            list.push(entry);
            allEntries.push(entry);
            entriesByDay.set(day, list);
          }
        }
      }
    }
    allEntries.sort(compareSessions);
    const definedDays = /* @__PURE__ */ new Set();
    for (const entry of allEntries) {
      definedDays.add(entry.dayOfWeek());
    }
    const nonWorkingDays = 7 - definedDays.size;
    return new SessionEntries(
      allEntries,
      entriesByDay,
      ensure(this._firstDayOfWeek),
      nonWorkingDays
    );
  }
  _parseFirstDayOfWeek(spec) {
    const parts = spec.split(";");
    this._firstDayOfWeek = MONDAY;
    if (parts.length > 2) throw new Error(`bad sessions spec: ${spec}`);
    if (parts.length === 1) return spec;
    let index2 = 1;
    let day = parts[0].includes("-") ? NaN : parseInt(parts[0]);
    if (isNaN(day)) {
      index2 = 0;
      day = parseInt(parts[1]);
    }
    if (day < SUNDAY || day > SATURDAY) {
      throw new Error(`bad sessions spec: ${spec}`);
    }
    this._firstDayOfWeek = day;
    return parts[index2];
  }
  _adjustStartToPreviousSession(firstDay) {
    if (this.historyEntries.length === 0) {
      return null;
    }
    const lastEndDate = ensure(this.historyEntries[this.historyEntries.length - 1].getSpecEndDay());
    const offset = firstDay - getUTCDayOfWeek(lastEndDate);
    if (offset === 0) return lastEndDate;
    let fixedStart = add(cloneDate(lastEndDate), { days: offset });
    if (fixedStart.getTime() <= lastEndDate.getTime()) {
      fixedStart = add(fixedStart, { days: 7 });
    }
    return fixedStart;
  }
  static _parseSessionEntry(day, entryStr, validate) {
    const range = entryStr.split("-");
    if (range.length !== 2) throw new Error(`bad session entry: ${entryStr}`);
    let fromOffset = 0;
    let start2 = range[0];
    if (start2.includes("F")) {
      const seg = start2.split("F");
      start2 = seg[0];
      fromOffset = seg[1] !== "" ? parseInt(seg[1]) : 1;
    }
    let toOffset = 0;
    let end = range[1];
    if (end.includes("F")) {
      const seg = end.split("F");
      end = seg[0];
      toOffset = seg[1] !== "" ? parseInt(seg[1]) : 1;
    }
    const startMin = this._minutesFromHHMM(start2, entryStr, validate);
    const endMin = this._minutesFromHHMM(end, entryStr, validate);
    return this._createSessionEntry(day, startMin, endMin, fromOffset, toOffset);
  }
  static _minutesFromHHMM(segment, fullStr, validate) {
    if (segment.length === 4 && /^[0-9]+$/.test(segment)) {
      const value = parseInt(segment);
      const hour = Math.trunc(value / 100);
      const min = value % 100;
      if (!validate || hour < 24 && min < 60) return hour * 60 + min;
    }
    throw new Error(`incorrect entry syntax: ${fullStr}`);
  }
  static _parseDay(value, label, validate) {
    if (value.length === 8 && /^[0-9]+$/.test(value)) {
      const year = parseInt(value.substring(0, 4));
      const month = parseInt(value.substring(4, 6));
      const day = parseInt(value.substring(6, 8));
      if (!validate || this._isValidDayOfMonth(day, month, year)) {
        return new BusinessDay(year, month, day);
      }
    }
    throw new Error(`bad ${label} date: ${value}`);
  }
  static _isValidDayOfMonth(day, month, year) {
    if (month < 1 || month > 12 || day < 1 || day > monthLengths[month]) {
      if (month === 2 && day === 29 && is_leap_year(year)) return true;
      return false;
    }
    return true;
  }
  static _parseWorkingDays(dayString) {
    const days = [];
    for (let i2 = 0; i2 < dayString.length; i2++) {
      const day = dayString.charCodeAt(i2) - 48;
      if (day < 1 || day > 7) {
        throw new Error(`Invalid days specification: ${dayString}`);
      }
      if (!days.includes(day)) {
        days.push(day);
      }
    }
    return days;
  }
  static _createSessionEntry(day, start2, end, startOffset, endOffset) {
    should(startOffset >= 0 && startOffset < 7);
    should(endOffset >= 0 && endOffset < 7);
    if (end === 0) end = minutesPerDay;
    if (startOffset === endOffset && end <= start2) startOffset++;
    should(startOffset >= endOffset);
    if (startOffset > 0) start2 -= startOffset * minutesPerDay;
    if (endOffset > 0) end -= endOffset * minutesPerDay;
    const length = end - start2;
    should(day >= SUNDAY && day <= SATURDAY);
    should(start2 < minutesPerDay);
    should(length > 0);
    return new SessionEntry(day, start2, length);
  }
  static _parseHolidaysAndCorrectionsImpl(timezone, holidaysDef, correctionsDef, validate) {
    const map = /* @__PURE__ */ new Map();
    if (holidaysDef !== "") {
      const entries = [];
      for (const dateStr of holidaysDef.split(",")) {
        const day = this._parseDay(dateStr, "holiday", validate);
        map.set(day, entries);
      }
    }
    if (correctionsDef === "") return map;
    for (const section of correctionsDef.split(";")) {
      const parts = section.split(":");
      if (parts.length !== 2) throw new Error(`bad correction section: ${section}`);
      const entryDefs = parts[0];
      const dateDefs = parts[1];
      const entries = [];
      if (entryDefs !== "dayoff") {
        for (const entryStr of entryDefs.split(",")) {
          const entry = this._parseSessionEntry(1, entryStr, validate);
          entries.push(entry);
        }
      }
      for (const dateStr of dateDefs.split(",")) {
        const day = this._parseDay(dateStr, "correction", validate);
        const dayOfWeek = getUTCDayOfWeek(day.toCalendar());
        const correctedEntries = entries.map(
          (e2) => new SessionEntry(dayOfWeek, e2.startOffset(), e2.length())
        );
        map.set(day, correctedEntries);
      }
    }
    return map;
  }
}
class Cache {
  constructor(initialValue) {
    __publicField(this, "_value");
    this._value = initialValue;
  }
  /**
  获取当前缓存的值。
  */
  get() {
    return this._value;
  }
  /**
   设置缓存的新值。
   */
  set(value) {
    this._value = value;
  }
}
class SessionsSpec {
  constructor(timezone = "Etc/UTC", raw = "0000-0000", holidays = "", corrections = "", withValidation = false) {
    __publicField(this, "_entries");
    __publicField(this, "_presentHistoryEntry");
    __publicField(this, "_holidayAndCorrectionMap");
    __publicField(this, "_entriesHash");
    __publicField(this, "_borderWeeksIndicesHash");
    __publicField(this, "_yearToWeeksIndicesHash");
    __publicField(this, "_weekIndicesOfLastHistoryWeek");
    __publicField(this, "_presentStartWeekIndex");
    __publicField(this, "_isThereCorrections");
    const parser = new SessionParser();
    if (withValidation) {
      parser.parseSessionsAndValidateDateTime(timezone, raw);
    } else {
      parser.parseSessions(timezone, raw);
    }
    this._entries = parser.historyEntries;
    this._presentHistoryEntry = parser.historyEntries[parser.historyEntries.length - 1];
    this._holidayAndCorrectionMap = withValidation ? SessionParser.parseHolidaysAndCorrectionsAndValidateDateTime(
      timezone,
      holidays,
      corrections
    ) : SessionParser.parseHolidaysAndCorrections(timezone, holidays, corrections, withValidation);
    this._entriesHash = /* @__PURE__ */ new Map();
    const sessionBorders = this._prepareSessionsBorderParams();
    this._borderWeeksIndicesHash = sessionBorders.borderWeeksIndicesHash;
    this._yearToWeeksIndicesHash = sessionBorders.yearToWeeksIndicesHash;
    this._weekIndicesOfLastHistoryWeek = sessionBorders.weekIndicesOfLastHistoryWeek;
    this._presentStartWeekIndex = sessionBorders.startPresentSessionWeekIndex;
    this._isThereCorrections = !(holidays === "" && corrections === "" && this._weekIndicesOfLastHistoryWeek === null);
    for (const [day] of this._holidayAndCorrectionMap) {
      NOTIMPLEMENTED(day);
    }
  }
  dump() {
  }
  _prepareSessionsBorderParams() {
    const borderWeeksIndicesHash = /* @__PURE__ */ new Map();
    const yearToWeeksIndicesHash = /* @__PURE__ */ new Map();
    let weekIndicesOfLastHistoryWeek = null;
    if (this._entries.length > 1) {
      weekIndicesOfLastHistoryWeek = Array.from({ length: this._entries.length - 1 }, () => 0);
    }
    let startPresentSessionWeekIndex = 0;
    for (let index2 = 0; index2 < this._entries.length - 1; index2++) {
      const nextHistoryEntry = this._entries[index2 + 1];
      const startDate = ensure(nextHistoryEntry.getStartDay());
      const weekIndex = SessionsSpec._getWeekIndexImpl(startDate);
      borderWeeksIndicesHash.set(weekIndex, index2 + 1);
      this._addToYearHash(yearToWeeksIndicesHash, startDate, weekIndex);
      this._entriesHash.set(weekIndex, new Cache(null));
      if (weekIndicesOfLastHistoryWeek) {
        weekIndicesOfLastHistoryWeek[index2] = weekIndex;
      }
      startPresentSessionWeekIndex = weekIndex;
    }
    return {
      borderWeeksIndicesHash,
      yearToWeeksIndicesHash,
      startPresentSessionWeekIndex,
      weekIndicesOfLastHistoryWeek
    };
  }
  _addToYearHash(yearToWeekIndicesMap, date, weekIndex) {
    const year = getUTCFullYear(date);
    let weekIndices = yearToWeekIndicesMap.get(year);
    if (weekIndices === void 0) {
      weekIndices = [];
      yearToWeekIndicesMap.set(year, weekIndices);
    }
    weekIndices.push(weekIndex);
  }
  getWeekIndex(e2) {
    return this._isThereCorrections ? SessionsSpec._getWeekIndexImpl(e2) : 0;
  }
  //
  // hasHistoryCorrections(): boolean {
  //   return this._hasHistoryCorrections;
  // }
  //
  // firstDayOfWeek(): number {
  //   return this._presentHistoryEntry.getEntries().firstDayOfWeek();
  // }
  //
  // includesDay(date: CalDate): boolean {
  //   return this._getEntriesForDay(date).length > 0;
  // }
  getEntriesForWeek(index2) {
    var _a3;
    if (!this._isThereCorrections) {
      return this._presentHistoryEntry.getEntries();
    }
    should(index2 >= 0);
    const cache2 = this._entriesHash.get(index2);
    if (cache2 !== void 0) {
      const cached = cache2.get();
      if (cached !== null) return cached;
    }
    let baseEntries;
    const borderIdx = this._borderWeeksIndicesHash.get(index2);
    if (borderIdx === void 0) {
      baseEntries = this._getHistoryAndIndexForWeek(index2).getEntries();
    } else {
      baseEntries = this._prepareBorderWeekHistory(borderIdx);
    }
    const entriesMap = new Map(baseEntries.entriesByDay());
    const fullList = [...baseEntries.list()];
    const start2 = this._weekIndexToLocalDateTime(index2);
    const end = this._weekIndexToLocalDateTime(index2 + 1);
    const from = BusinessDay.fromCalendar(start2);
    const to = BusinessDay.fromCalendar(end);
    for (const [day, overrides] of this._selectHolidays(from, to)) {
      const dow = getUTCDayOfWeek(day.toCalendar());
      const indexList = overrides;
      const filtered = fullList.filter((entry) => entry.dayOfWeek() !== dow);
      filtered.push(...indexList);
      if (indexList.length === 0) {
        entriesMap.delete(dow);
      } else {
        entriesMap.set(dow, indexList);
      }
    }
    fullList.sort(compareSessions);
    const leftDays = DaysOfWeek.length - entriesMap.size;
    const result = new SessionEntries(fullList, entriesMap, baseEntries.firstDayOfWeek(), leftDays);
    (_a3 = this._entriesHash.get(index2)) == null ? void 0 : _a3.set(result);
    return result;
  }
  _selectHolidays(start2, end) {
    const result = /* @__PURE__ */ new Set();
    for (const [holidayDate, entries] of this._holidayAndCorrectionMap) {
      if (holidayDate.compareTo(start2) >= 0 && holidayDate.compareTo(end) < 0) {
        result.add([holidayDate, entries]);
      }
    }
    return result;
  }
  _prepareBorderWeekHistory(currentIndex) {
    const prevEntry = this._entries[currentIndex - 1];
    const currEntry = this._entries[currentIndex];
    const entriesByDay = /* @__PURE__ */ new Map();
    const allEntries = [];
    const boundaryDayOfWeek = getUTCDayOfWeek(ensure(currEntry.getStartDay()));
    for (let i2 = 0; i2 < DaysOfWeek.length; i2++) {
      const day = DaysOfWeek[i2];
      if (day < boundaryDayOfWeek) {
        const entries = prevEntry.getEntries().entriesByDay().get(day);
        if (entries !== void 0) {
          allEntries.push(...entries);
          entriesByDay.set(day, entries);
        }
      } else {
        const entries = currEntry.getEntries().entriesByDay().get(day);
        if (entries !== void 0) {
          allEntries.push(...entries);
          entriesByDay.set(day, entries);
        }
      }
    }
    const firstDayOfWeek = currEntry.getEntries().firstDayOfWeek();
    return new SessionEntries(allEntries, entriesByDay, firstDayOfWeek, 0);
  }
  _weekIndexToLocalDateTime(weekIndex) {
    const secondsPerDay = 86400;
    const secondsSinceUnixEpoch = Math.floor(
      secondsPerDay * weekIndex * 7 + secondsPerDay - 62167219200
    );
    const baseDate = get_cal_from_unix_timestamp_ms(secondsSinceUnixEpoch * 1e3);
    set_utc_hms(baseDate, 0, 0, 0, 0);
    return baseDate;
  }
  _getHistoryAndIndexForWeek(e2) {
    if (this._presentStartWeekIndex <= e2) return this._presentHistoryEntry;
    const t2 = this._getIndexOfHistoryEntry(e2);
    return this._entries[t2];
  }
  _getIndexOfHistoryEntry(weekIndex) {
    let low = 0;
    let high = this._entries.length - 1;
    let mid = Math.floor((low + high) / 2);
    should(this._weekIndicesOfLastHistoryWeek !== null);
    while (true) {
      const weekBoundary = this._weekIndicesOfLastHistoryWeek[mid];
      if (weekBoundary >= weekIndex) {
        high = mid - 1;
        if (high < low) return mid;
      } else {
        low = mid + 1;
        if (high < low) return mid + 1;
      }
      mid = Math.floor((low + high) / 2);
    }
  }
  // getHistoryByIndex(index: number): HistoryEntry {
  //   return this._entries[index];
  // }
  //
  // timezone(): string {
  //   return this._timezone;
  // }
  //
  // timezoneObj(): TimeZone {
  //   return this._timezoneObj;
  // }
  //
  // longestSessionLength(): number {
  //   let maxLen = this._presentHistoryEntry.getEntries().longestSessionLength();
  //   for (let i = 0; i < this._entries.length - 1; i++) {
  //     const entryLen = this._entries[i].getEntries().longestSessionLength();
  //     maxLen = Math.max(maxLen, entryLen);
  //   }
  //
  //   for (const overrides of this._holidayAndCorrectionMap.values()) {
  //     for (const session of overrides) {
  //       maxLen = Math.max(maxLen, session.length());
  //     }
  //   }
  //
  //   return maxLen;
  // }
  //
  // isWeekEnd(date: CalDate): boolean {
  //   const weekIdx = this.getWeekIndex(date);
  //   const entries = this._borderWeeksIndicesHash.has(weekIdx)
  //     ? this.getEntriesForWeek(weekIdx)
  //     : this._getHistoryAndIndexForWeek(weekIdx).getEntries();
  //   return entries.isWeekEnd(get_day_of_week(date));
  // }
  //
  // isCalWeekEnd(date: CalDate): boolean {
  //   const dow = get_day_of_week(date);
  //   if (!this._isThereCorrections) {
  //     return this._presentHistoryEntry.getEntries().isWeekEnd(dow);
  //   }
  //
  //   const weekIndex = this.getWeekIndex(date);
  //   const entries = this.getEntriesForWeek(weekIndex);
  //   const businessDay = BusinessDay.fromCalendar(date);
  //   const override = this._holidayAndCorrectionMap.get(businessDay);
  //   if (override === undefined) {
  //     return entries.isWeekEnd(dow);
  //   } else {
  //     return override.length === 0;
  //   }
  // }
  //
  // holidaysFromYearStart(date: CalDate | BusinessDay): number {
  //   const bd = date instanceof BusinessDay ? date : BusinessDay.fromCalendar(date);
  //   return this._holidaysFromYearStart(bd);
  // }
  static _getWeekIndexImpl(date) {
    const year = getUTCFullYear(date);
    const month = getUTCMonth(date);
    let firstOfMonth = get_cal_utc(year, month, 1);
    const dayOffset = getUTCDayOfMonth(date) - getUTCDayOfWeek(date);
    firstOfMonth = add(firstOfMonth, { days: dayOffset });
    const timestampInSeconds = firstOfMonth.getTime() / 1e3;
    should((timestampInSeconds + 62167219200) % 86400 === 0);
    const totalDays = (timestampInSeconds + 62167219200) / 86400;
    const weekIndex = Math.floor(totalDays / 7);
    return weekIndex;
  }
}
function getRegularSessionEntries(spec) {
  return spec.getEntriesForWeek(0);
}
var SourceType = /* @__PURE__ */ ((SourceType2) => {
  SourceType2[SourceType2["Main"] = 0] = "Main";
  SourceType2[SourceType2["Study"] = 1] = "Study";
  SourceType2[SourceType2["Compare"] = 2] = "Compare";
  return SourceType2;
})(SourceType || {});
var __defProp$3 = Object.defineProperty;
var __getOwnPropDesc$e = Object.getOwnPropertyDescriptor;
var __decorateClass$e = (decorators, target, key2, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$e(target, key2) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
  if (kind && result) __defProp$3(target, key2, result);
  return result;
};
var __decorateParam$d = (index2, decorator) => (target, key2) => decorator(target, key2, index2);
let ChartMainSeriesApi = class extends AbstractChartDataSource {
  constructor(ctx, serialized, chartService, datafeed, intlService) {
    super(ctx, chartService.chartApi, datafeed);
    __publicField(this, "id", `main@${generateUuid()}`);
    __publicField(this, "_series");
    __publicField(this, "_priceLineLastVisible", null);
    __publicField(this, "_priceFormatter");
    __publicField(this, "_sessionsSpec", null);
    __publicField(this, "_onDataLoaded", this._register(new Emitter()));
    __publicField(this, "onDataLoaded", this._onDataLoaded.event);
    __publicField(this, "_seriesDisposables", null);
    this.chartService = chartService;
    this.intlService = intlService;
    this.setChartType(
      (serialized == null ? void 0 : serialized.state.style) ?? this.chartService.getStoreHandler().getChartProperty("mainSeriesProperties.style"),
      void 0,
      true
    );
    this._registerListeners();
    this.loadAll();
  }
  _registerListeners() {
    super._registerListeners();
    this._register(
      toDisposable(() => {
        var _a3;
        (_a3 = this._seriesDisposables) == null ? void 0 : _a3.dispose();
      })
    );
  }
  isSeries() {
    return true;
  }
  updateActive(active) {
    this.chartService.getStoreHandler().set("mainLegend", {
      ...this.chartService.getStoreHandler().get("mainLegend"),
      selected: !!active
    });
    this._chart.setSelectedSource(active ? this._series : null);
    this._series.requestUpdate();
  }
  updateHover() {
  }
  _registerSeriesListeners() {
    this._seriesDisposables = new DisposableStore();
    const handleDataChange = (scope) => {
      this._updatePriceLines();
      this._onDataChanged.fire(scope);
    };
    const handleRangeChange = () => {
      this._updatePriceLines();
    };
    this._series.subscribeDataChanged(handleDataChange);
    this.chartService.getTimeScale().subscribeVisibleLogicalRangeChange(handleRangeChange);
    this._seriesDisposables.add(
      toDisposable(() => {
        this._series.unsubscribeDataChanged(handleDataChange);
        this.chartService.getTimeScale().unsubscribeVisibleLogicalRangeChange(handleRangeChange);
      })
    );
  }
  getSessionsSpec() {
    return this._sessionsSpec;
  }
  getSeries() {
    return this._series;
  }
  paneIndex() {
    return this._series.getPane().paneIndex();
  }
  getLastPrice() {
    const lastOne = last$1(this.data());
    return ensure(lastOne).customValues.close;
  }
  data() {
    return this._series.data();
  }
  symbol() {
    return this.chartService.getStoreHandler().get("symbol");
  }
  setSymbol(symbol) {
    this.chartService.getStoreHandler().set("symbol", symbol);
    this._series.setData([]);
    return this.loadAll();
  }
  chartType() {
    return this.chartService.getStoreHandler().getChartProperty("mainSeriesProperties.style");
  }
  resolution() {
    return this.chartService.getStoreHandler().get("resolution");
  }
  setResolution(resolution) {
    this.chartService.getStoreHandler().set("resolution", resolution);
    return this.loadAll();
  }
  setChartType(type, cb, force = false) {
    var _a3;
    const chartProperties = this.chartService.getStoreHandler().get("chartProperties");
    if (chartProperties["mainSeriesProperties.style"] !== type) {
      this.chartService.getStoreHandler().setChartProperty("mainSeriesProperties.style", type);
    } else {
      if (!force) return;
    }
    this._priceLineLastVisible = null;
    (_a3 = this._seriesDisposables) == null ? void 0 : _a3.dispose();
    const prevSeries = this._series;
    const bars = prevSeries == null ? void 0 : prevSeries.data().slice();
    let primitives = [];
    if (prevSeries) {
      primitives = prevSeries.primitives();
      this._chart.removeSeries(prevSeries);
    }
    switch (type) {
      case ChartStyleType.Bar: {
        this._series = this._chart.addSeries(Ee, {
          priceScaleId: "right",
          upColor: chartProperties["mainSeriesProperties.barStyle.upColor"],
          downColor: chartProperties["mainSeriesProperties.barStyle.downColor"],
          openVisible: !chartProperties["mainSeriesProperties.barStyle.dontDrawOpen"],
          thinBars: chartProperties["mainSeriesProperties.barStyle.thinBars"]
        });
        break;
      }
      case ChartStyleType.Candle: {
        this._series = this._chart.addSeries(Le, {
          priceScaleId: "right",
          upColor: chartProperties["mainSeriesProperties.candleStyle.upColor"],
          downColor: chartProperties["mainSeriesProperties.candleStyle.downColor"],
          borderVisible: chartProperties["mainSeriesProperties.candleStyle.drawBorder"],
          borderColor: chartProperties["mainSeriesProperties.candleStyle.borderColor"],
          borderUpColor: chartProperties["mainSeriesProperties.candleStyle.borderUpColor"],
          borderDownColor: chartProperties["mainSeriesProperties.candleStyle.borderDownColor"],
          wickVisible: chartProperties["mainSeriesProperties.candleStyle.drawWick"],
          wickColor: chartProperties["mainSeriesProperties.candleStyle.wickColor"],
          wickUpColor: chartProperties["mainSeriesProperties.candleStyle.wickUpColor"],
          wickDownColor: chartProperties["mainSeriesProperties.candleStyle.wickDownColor"]
        });
        break;
      }
      case ChartStyleType.HollowCandle: {
        this._series = this._chart.addSeries(Fe, {
          priceScaleId: "right",
          upColor: chartProperties["mainSeriesProperties.hollowCandleStyle.upColor"],
          downColor: chartProperties["mainSeriesProperties.hollowCandleStyle.downColor"],
          borderVisible: chartProperties["mainSeriesProperties.hollowCandleStyle.drawBorder"],
          borderColor: chartProperties["mainSeriesProperties.hollowCandleStyle.borderColor"],
          borderUpColor: chartProperties["mainSeriesProperties.hollowCandleStyle.borderUpColor"],
          borderDownColor: chartProperties["mainSeriesProperties.hollowCandleStyle.borderDownColor"],
          wickVisible: chartProperties["mainSeriesProperties.hollowCandleStyle.drawWick"],
          wickColor: chartProperties["mainSeriesProperties.hollowCandleStyle.wickColor"],
          wickUpColor: chartProperties["mainSeriesProperties.hollowCandleStyle.wickUpColor"],
          wickDownColor: chartProperties["mainSeriesProperties.hollowCandleStyle.wickDownColor"]
        });
        break;
      }
      case ChartStyleType.Line: {
        this._series = this._chart.addSeries(ae, {
          priceScaleId: "right",
          color: chartProperties["mainSeriesProperties.lineStyle.color"],
          lineStyle: chartProperties["mainSeriesProperties.lineStyle.linestyle"],
          lineWidth: chartProperties["mainSeriesProperties.lineStyle.linewidth"],
          lineType: r$2.Simple
        });
        break;
      }
      case ChartStyleType.Area: {
        this._series = this._chart.addSeries(ke, {
          priceScaleId: "right",
          topColor: chartProperties["mainSeriesProperties.areaStyle.color2"],
          bottomColor: chartProperties["mainSeriesProperties.areaStyle.color1"],
          lineColor: chartProperties["mainSeriesProperties.areaStyle.linecolor"],
          lineStyle: chartProperties["mainSeriesProperties.areaStyle.linestyle"],
          lineType: r$2.Simple,
          lineWidth: chartProperties["mainSeriesProperties.areaStyle.linewidth"]
        });
        break;
      }
      default:
        NOTIMPLEMENTED();
    }
    primitives.forEach((p2) => this._series.attachPrimitive(p2));
    if (bars) this._series.setData(this._mapBars(bars));
    this._updatePriceLines();
    this._registerSeriesListeners();
    cb == null ? void 0 : cb();
  }
  async loadAll() {
    this.chartService.getStoreHandler().set("dataStatus", ChartDataStatus.startLoading);
    const loaded = await super.loadAll(
      (symbolInfo) => {
        this.chartService.getStoreHandler().set("dataStatus", ChartDataStatus.symbolInfoResolved);
        this.chartService.getStoreHandler().set("symbolInfo", symbolInfo);
        this._priceFormatter = new it(
          symbolInfo.pricescale ?? 100,
          symbolInfo.minmov ?? 1
        );
        this._sessionsSpec = new SessionsSpec(symbolInfo.timezone, symbolInfo.session);
      },
      (reason) => {
        const store = this.chartService.getStoreHandler();
        store.set("dataStatus", ChartDataStatus.error);
        let message2;
        if (isString$1(reason)) {
          message2 = reason;
        } else {
          const key2 = Symbol.keyFor(reason) || "unknown error";
          if (this.intlService.isI18nKey(key2)) {
            message2 = this.intlService.t(key2);
          } else {
            message2 = key2;
          }
        }
        store.set("error", { message: message2 });
      }
    );
    if (loaded) this._onDataLoaded.fire();
    return loaded;
  }
  clearBars() {
    this._series.setData([]);
  }
  setBars(bars) {
    this.chartService.getStoreHandler().set("dataStatus", ChartDataStatus.dataLoaded);
    this._series.setData(this._mapBars(bars));
  }
  setBar(bar) {
    const newBar = this._mapBar(bar);
    this._series.update(newBar);
  }
  resetData() {
    this._series.setData([]);
    this.chartService.getStoreHandler().set("dataStatus", ChartDataStatus.startLoading);
    return this.loadAll();
  }
  updateLegend(param) {
    let lastData = void 0;
    if (param && param.time) {
      lastData = param.seriesData.get(this._series);
    } else {
      lastData = last$1(this._series.data());
    }
    if (!lastData) return;
    const isOhlc = isOhlcSeries(this.chartType());
    const formatter = this.priceFormatter();
    const bars = this._series.data();
    const idx = bars.findIndex((b2) => b2.time == lastData.time);
    const last2Data = this._series.dataByIndex(idx - 1);
    if (isOhlc) {
      const lastBar = lastData;
      const last2Bar = last2Data;
      const prevClose = last2Bar ? last2Bar.close : lastBar.open;
      const change = lastBar.close - prevClose;
      const percentage = change / prevClose * 100;
      const sign2 = change >= 0 ? "+" : "";
      this.chartService.getStoreHandler().set("mainLegend", {
        open: formatter.format(lastBar.open),
        high: formatter.format(lastBar.high),
        low: formatter.format(lastBar.low),
        close: formatter.format(lastBar.close),
        value: "",
        change: `${sign2}${formatter.format(change)}(${sign2}${formatter.format(percentage)}%)`,
        color: lastBar.color ?? "",
        selected: this.chartService.getStoreHandler().get("mainLegend").selected
      });
    } else {
      const lastBar = lastData;
      const last2Bar = last2Data;
      const prevValue = last2Bar ? last2Bar.value : lastBar.value;
      const change = lastBar.value - prevValue;
      const percentage = change / prevValue * 100;
      const sign2 = change >= 0 ? "+" : "";
      let color = "";
      switch (this.chartType()) {
        case ChartStyleType.Line:
          color = this.chartService.getStoreHandler().getChartProperty("mainSeriesProperties.lineStyle.color");
          break;
        case ChartStyleType.Area:
          color = this.chartService.getStoreHandler().getChartProperty("mainSeriesProperties.areaStyle.linecolor");
          break;
        default:
          NOTREACHED();
      }
      this.chartService.getStoreHandler().set("mainLegend", {
        open: "",
        high: "",
        low: "",
        close: "",
        value: formatter.format(lastBar.value),
        change: `${sign2}${formatter.format(change)}(${sign2}${formatter.format(percentage)}%)`,
        color: color ?? "",
        selected: this.chartService.getStoreHandler().get("mainLegend").selected
      });
    }
  }
  _updatePriceLines() {
    const range = this._chart.timeScale().getVisibleLogicalRange();
    if (!range) return;
    if (!isFinite(range.to)) return;
    const lastIndex = this._series.barsProvider().lastIndex();
    if (isUndefinedOrNull(lastIndex)) return;
    const lastVisibleIndex = Math.min(Math.round(range.to), lastIndex);
    const isLast = lastVisibleIndex === lastIndex;
    const lastVisibleData = this._series.dataByIndex(
      lastVisibleIndex,
      Tt.NearestLeft
    );
    if (!lastVisibleData) return;
    const lastData = this._series.dataByIndex(lastIndex, Tt.NearestLeft);
    if (!lastData) return;
    let lastVisibleColor = "";
    let lastVisiblePrice;
    if (isOhlcSeries(this.chartType())) {
      const lastVisibleBar = lastVisibleData;
      lastVisibleColor = lastVisibleBar.color;
      lastVisiblePrice = lastVisibleBar.close;
    } else {
      const lastVisibleBar = lastVisibleData;
      lastVisiblePrice = lastVisibleBar.value;
      switch (this.chartType()) {
        case ChartStyleType.Line:
          lastVisibleColor = this.chartService.getStoreHandler().getChartProperty("mainSeriesProperties.lineStyle.color");
          break;
        case ChartStyleType.Area:
          lastVisibleColor = this.chartService.getStoreHandler().getChartProperty("mainSeriesProperties.areaStyle.linecolor");
          break;
        default:
          NOTREACHED();
      }
    }
    const height = this._series.getPane().getHeight();
    {
      const y2 = ensure(this._series.priceToCoordinate(lastVisiblePrice));
      const mainColor = lastVisibleColor;
      const bgColor = this.chartService.getModel().backgroundColorAtYPercentFromTop(y2 / height);
      const option = {
        price: lastVisiblePrice,
        color: mainColor,
        lineVisible: false,
        axisLabelVisible: !isLast,
        axisLabelColor: bgColor,
        axisLabelTextColor: mainColor,
        axisLabelBorderColor: mainColor
      };
      if (this._priceLineLastVisible) {
        const prev = this._priceLineLastVisible.options();
        if (prev.price === option.price && prev.color === option.color && prev.axisLabelVisible === option.axisLabelVisible) {
          return;
        }
        this._priceLineLastVisible.applyOptions(option);
      } else if (!isLast) {
        this._priceLineLastVisible = this._series.createPriceLine({
          ...option,
          price: lastVisiblePrice
        });
      }
    }
  }
  _mapBars(bars) {
    const chartProperties = this.chartService.getStoreHandler().get("chartProperties");
    const type = this.chartType();
    switch (type) {
      case ChartStyleType.Bar: {
        return barsToOhlcData(
          bars,
          chartProperties["mainSeriesProperties.barStyle.upColor"],
          chartProperties["mainSeriesProperties.barStyle.downColor"]
        );
      }
      case ChartStyleType.Candle: {
        return barsToOhlcData(
          bars,
          chartProperties["mainSeriesProperties.candleStyle.upColor"],
          chartProperties["mainSeriesProperties.candleStyle.downColor"]
        );
      }
      case ChartStyleType.HollowCandle: {
        return barsToOhlcData(
          bars,
          chartProperties["mainSeriesProperties.hollowCandleStyle.upColor"],
          chartProperties["mainSeriesProperties.hollowCandleStyle.downColor"]
        );
      }
      case ChartStyleType.Line: {
        return barsToSingleValueData(
          bars,
          chartProperties["mainSeriesProperties.lineStyle.priceSource"]
        );
      }
      case ChartStyleType.Area: {
        return barsToSingleValueData(
          bars,
          chartProperties["mainSeriesProperties.areaStyle.priceSource"]
        );
      }
      default:
        NOTIMPLEMENTED();
    }
  }
  _mapBar(bar) {
    const newBar = /* @__PURE__ */ Object.create(null);
    let open = bar.open;
    let high = Math.max(bar.open, bar.high, bar.low, bar.close);
    let low = Math.max(bar.open, bar.high, bar.low, bar.close);
    const close = bar.close;
    const volume = bar.volume;
    newBar.time = bar.time;
    newBar.customValues = {
      open,
      high,
      low,
      close,
      volume
    };
    const chartProperties = this.chartService.getStoreHandler().get("chartProperties");
    const type = this.chartType();
    let upColor = "";
    let downColor = "";
    let defaultColor = "";
    switch (type) {
      case ChartStyleType.Bar: {
        upColor = chartProperties["mainSeriesProperties.barStyle.upColor"];
        downColor = chartProperties["mainSeriesProperties.barStyle.downColor"];
        break;
      }
      case ChartStyleType.Candle: {
        upColor = chartProperties["mainSeriesProperties.candleStyle.upColor"];
        downColor = chartProperties["mainSeriesProperties.candleStyle.downColor"];
        defaultColor = chartProperties["mainSeriesProperties.candleStyle.wickColor"];
        break;
      }
      case ChartStyleType.HollowCandle: {
        upColor = chartProperties["mainSeriesProperties.hollowCandleStyle.upColor"];
        downColor = chartProperties["mainSeriesProperties.hollowCandleStyle.downColor"];
        defaultColor = chartProperties["mainSeriesProperties.hollowCandleStyle.wickColor"];
        break;
      }
      case ChartStyleType.Area: {
        newBar.value = bar[chartProperties["mainSeriesProperties.areaStyle.priceSource"]];
        break;
      }
      case ChartStyleType.Line: {
        newBar.value = bar[chartProperties["mainSeriesProperties.lineStyle.priceSource"]];
        break;
      }
    }
    if (isOhlcSeries(this.chartType())) {
      const idx = this._chart.timeScale().timeToIndex(bar.time, false);
      let barInSameInterval;
      let barInPrevInterval;
      let color = defaultColor;
      if (idx) {
        barInSameInterval = this._series.dataByIndex(idx);
        barInPrevInterval = this._series.dataByIndex(idx - 1);
      }
      if (barInSameInterval) {
        should(barInSameInterval.time === bar.time);
        should(isFiniteNumber(barInSameInterval.time));
        open = barInSameInterval.open;
        high = Math.max(barInSameInterval.high, bar.high);
        low = Math.min(barInSameInterval.low, bar.low);
        Object.assign(newBar.customValues, {
          open,
          high,
          low
        });
      }
      if (barInPrevInterval) {
        color = bar.close >= barInPrevInterval.close ? upColor : downColor;
      }
      Object.assign(
        newBar,
        {
          open,
          high,
          low,
          close: bar.close,
          volume: bar.volume,
          color,
          wickColor: color,
          borderColor: color
        }
      );
    } else {
      newBar.value = bar.close;
    }
    return newBar;
  }
  priceFormatter() {
    return ensure(this._priceFormatter);
  }
  save() {
    return {
      type: SourceType.Main,
      state: {
        style: this.chartType()
      }
    };
  }
};
__decorateClass$e([
  memoize$1
], ChartMainSeriesApi.prototype, "paneIndex", 1);
ChartMainSeriesApi = __decorateClass$e([
  __decorateParam$d(2, IChartService),
  __decorateParam$d(3, IDatafeedService),
  __decorateParam$d(4, IIntlService)
], ChartMainSeriesApi);
var ResolutionUnit = /* @__PURE__ */ ((ResolutionUnit2) => {
  ResolutionUnit2["T"] = "T";
  ResolutionUnit2["s"] = "S";
  ResolutionUnit2["m"] = "m";
  ResolutionUnit2["H"] = "H";
  ResolutionUnit2["D"] = "D";
  ResolutionUnit2["W"] = "W";
  ResolutionUnit2["M"] = "M";
  ResolutionUnit2["Y"] = "Y";
  return ResolutionUnit2;
})(ResolutionUnit || {});
const SecondsOfResolution = {
  T: 1,
  S: 1,
  m: 60,
  H: 3600,
  D: 24 * 60 * 60,
  W: 7 * 24 * 60 * 60,
  get M() {
    return NOTIMPLEMENTED();
  },
  get Y() {
    return NOTIMPLEMENTED();
  }
};
function getSecondsOfResolutionUnit(res) {
  return ensure(SecondsOfResolution[res]);
}
const unitGroupI18nKey = {
  [
    "T"
    /* T */
  ]: "resolutionGroup.ticks",
  [
    "S"
    /* s */
  ]: "resolutionGroup.seconds",
  [
    "m"
    /* m */
  ]: "resolutionGroup.minutes",
  [
    "H"
    /* H */
  ]: "resolutionGroup.minutes",
  [
    "D"
    /* D */
  ]: "resolutionGroup.days",
  [
    "W"
    /* W */
  ]: "resolutionGroup.days",
  [
    "M"
    /* M */
  ]: "resolutionGroup.days",
  [
    "Y"
    /* Y */
  ]: "resolutionGroup.days"
};
const unitI18nKey = {
  [
    "T"
    /* T */
  ]: "resolution.tick",
  [
    "S"
    /* s */
  ]: "resolution.second",
  [
    "m"
    /* m */
  ]: "resolution.minute",
  [
    "H"
    /* H */
  ]: "resolution.hour",
  [
    "D"
    /* D */
  ]: "resolution.day",
  [
    "W"
    /* W */
  ]: "resolution.weak",
  [
    "M"
    /* M */
  ]: "resolution.month",
  [
    "Y"
    /* Y */
  ]: "resolution.year"
};
function formatUnit(u2) {
  return [
    "D",
    "W",
    "M",
    "Y"
    /* Y */
  ].includes(u2) ? u2 : u2.toLowerCase();
}
const IChartResolutionRegistry = createDecorator$1(
  "chartResolutionRegistry "
);
class ChartResolutionRegistry extends Disposable {
  constructor() {
    super();
    __publicField(this, "_serviceBrand");
    __publicField(this, "store", writable({ groups: [], items: /* @__PURE__ */ Object.create(null) }));
    this._register(toDisposable(() => Reflect.set(this, "store", null)));
  }
  value(id2) {
    return get(this.store).items[id2];
  }
  registerResolution(resolutionString) {
    if (!/^\d/.test(resolutionString)) {
      resolutionString = "1" + resolutionString;
    }
    const { value, unit, groupi18nkey, groupUnit, equivalent } = parseResolution(resolutionString);
    const item = {
      resolutionString,
      label: unitI18nKey[unit],
      labelShort: `${value}${formatUnit(unit)}`,
      equivalent,
      value,
      unit
    };
    this.store.update((store) => {
      store.items[resolutionString] = item;
      let group = store.groups.find((g2) => g2.unit === groupUnit);
      if (!group) {
        group = {
          i18nKey: groupi18nkey,
          unit: groupUnit,
          items: []
        };
        store.groups.push(group);
      }
      group.items.push(item);
      group.items.sort((a2, b2) => a2.equivalent - b2.equivalent);
      return store;
    });
  }
}
function parseResolution(resolution) {
  const regex = /^(\d*)([TSHDWMY]?)$/i;
  const match2 = resolution.match(regex);
  if (!match2) {
    NOTREACHED("Invalid resolution format", resolution);
  }
  let value = parseInt(match2[1], 10);
  let unit = match2[2] || "m";
  let equivalent = value;
  let groupUnit = unit;
  switch (unit) {
    case "m": {
      if (value % 60 === 0) {
        unit = "H";
        value = value / 60;
      }
      break;
    }
    case "W": {
      equivalent = value * 7;
      groupUnit = "D";
      break;
    }
    case "M": {
      equivalent = value * 30;
      groupUnit = "D";
      if (value % 12 === 0) {
        unit = "M";
        value = value / 12;
      }
      break;
    }
  }
  return {
    value,
    unit,
    equivalent,
    groupi18nkey: unitGroupI18nKey[unit],
    groupUnit
  };
}
function createChartStoreHandler(base) {
  return {
    getStore: base.getStore,
    get: base.get,
    set(key2, value) {
      base.update((store) => {
        store[key2] = value;
      });
    },
    getChartProperty(key2) {
      return base.get("chartProperties")[key2];
    },
    setChartProperty(key2, value) {
      base.update((store) => {
        const props = store.chartProperties;
        props[key2] = value;
      });
    },
    addStudy(study) {
      base.update((store) => {
        const list = store.studyList;
        list.push(study);
      });
    },
    removeStudy(id2) {
      base.update((store) => {
        const list = store.studyList;
        const idx = list.findIndex((s2) => s2.id === id2);
        list.splice(idx, 1);
        delete store.studyLegend[id2];
      });
    },
    addDrawingInfo(study) {
      base.update((store) => {
        const list = store.drawingInfos;
        list.push(study);
      });
    },
    removeDrawingInfo(id2) {
      base.update((store) => {
        const list = store.drawingInfos;
        const idx = list.findIndex((s2) => s2.id === id2);
        list.splice(idx, 1);
      });
    },
    removeAllDrawingInfos() {
      base.update((store) => {
        store.drawingInfos.length = 0;
      });
    },
    updateStudyLegend(id2, cb) {
      base.update((store) => {
        let legend = store.studyLegend[id2];
        if (!legend) {
          legend = {
            selected: false,
            values: []
          };
          store.studyLegend[id2] = legend;
        }
        cb(legend);
      });
    },
    zoomToViewport(vp) {
      base.update((store) => {
        store.viewports.push(vp);
      });
    },
    zoomFromViewport() {
      base.update((store) => {
        store.viewports.pop();
      });
    }
  };
}
const ZOrderMainSeries = 999;
const ZOrderBottom = 0;
const ZorderTop = ZOrderMainSeries + 1;
function isStudyLinePlotSingleColorPreferences(obj) {
  return !isStudyLinePlotMultiColorPreferences(obj);
}
function isStudyLinePlotMultiColorPreferences(obj) {
  return "color" in obj && Array.isArray(obj.color);
}
const studyDefaultProperties = {
  "compare.plot.display": 15,
  "compare.plot.lineStyle": 0,
  "compare.plot.lineWidth": 2,
  "compare.plot.plotType": "line",
  "compare.plot.transparency": 0,
  "compare.plot.color": "#9C27B0",
  "compare.source": "close",
  "compare.symbol": ""
};
var LineStyleType = /* @__PURE__ */ ((LineStyleType2) => {
  LineStyleType2[LineStyleType2["solid"] = 0] = "solid";
  LineStyleType2[LineStyleType2["dotted"] = 1] = "dotted";
  LineStyleType2[LineStyleType2["dashed"] = 2] = "dashed";
  LineStyleType2[LineStyleType2["largeDashed"] = 3] = "largeDashed";
  LineStyleType2[LineStyleType2["sparseDotted"] = 4] = "sparseDotted";
  LineStyleType2[LineStyleType2["smallDashed"] = 5] = "smallDashed";
  return LineStyleType2;
})(LineStyleType || {});
function getLineDash(e2, t2) {
  return [
    [e2, 2 * e2],
    [5 * e2, 6 * e2],
    [6 * e2, 6 * e2],
    [e2, 4 * e2],
    [2 * e2, e2]
  ][t2 - 1];
}
function setLineStyle(context, lineStyle) {
  let dashPattern = [];
  if (lineStyle !== 0) {
    dashPattern = getLineDash(context.lineWidth, lineStyle);
  }
  context.setLineDash(dashPattern);
}
var LineEnd = /* @__PURE__ */ ((LineEnd2) => {
  LineEnd2[LineEnd2["Normal"] = 0] = "Normal";
  LineEnd2[LineEnd2["Arrow"] = 1] = "Arrow";
  return LineEnd2;
})(LineEnd || {});
class PaneRenderer {
  constructor(_data = null, _hitTestCollector, hitTest, backgroundHitTest) {
    __publicField(this, "_hitTest", null);
    __publicField(this, "_backgroundHitTest", null);
    this._data = _data;
    this._hitTestCollector = _hitTestCollector;
    if (hitTest) this._hitTest = hitTest;
    if (backgroundHitTest) this._backgroundHitTest = backgroundHitTest;
  }
  setData(data) {
    this._data = data;
  }
  data() {
    return ensure(this._data);
  }
  setHitTest(hitTest) {
    this._hitTest = hitTest;
  }
  setBackgroundHitTest(hitTest) {
    this._backgroundHitTest = hitTest;
  }
}
class BitmapCoordinatesPaneRenderer extends PaneRenderer {
  draw(target) {
    target.useBitmapCoordinateSpace((scope) => {
      this.drawImpl(scope);
    });
  }
}
class MediaCoordinatesPaneRenderer extends PaneRenderer {
  draw(target) {
    return target.useMediaCoordinateSpace((scope) => {
      return this.drawImpl(scope);
    });
  }
}
class PaneRendererColumns extends BitmapCoordinatesPaneRenderer {
  constructor() {
    super(...arguments);
    __publicField(this, "_precalculatedCache", []);
  }
  setData(data) {
    this._data = data;
    this._precalculatedCache = [];
  }
  hitTest(point) {
    var _a3, _b3;
    if (this._data === null) return null;
    const start2 = ((_a3 = this._data.visibleItemsRange) == null ? void 0 : _a3.startItemIndex) ?? 0;
    const end = (((_b3 = this._data.visibleItemsRange) == null ? void 0 : _b3.endItemIndex) ?? this._data.items.length) - 1;
    for (let i2 = start2; i2 <= end; i2++) {
      const item = this._data.items[i2];
      if (point.x >= item.left && point.x <= item.right) {
        const y2 = item.y;
        const base = this._data.histogramBase;
        if (point.y >= Math.min(y2, base) && point.y <= Math.max(y2, base)) {
          return new HitTestResult(HitTarget.Regular);
        }
      }
    }
    return null;
  }
  drawImpl(param) {
    var _a3, _b3, _c2;
    if (!this._data || this._data.items.length === 0) return;
    const { context, horizontalPixelRatio, verticalPixelRatio } = param;
    if (this._precalculatedCache.length === 0) {
      this._fillPrecalculatedCache(horizontalPixelRatio);
    }
    const barWidth = Math.max(1, Math.floor(horizontalPixelRatio));
    const barHeightUnit = Math.max(1, Math.floor(verticalPixelRatio));
    const baseY = Math.round(this._data.histogramBase * verticalPixelRatio) - Math.floor(barWidth / 2);
    const endBaseY = baseY + barWidth;
    const defaultColor = this._data.lineColor;
    const startIndex = ((_a3 = this._data.visibleItemsRange) == null ? void 0 : _a3.startItemIndex) ?? 0;
    const endIndex = (((_b3 = this._data.visibleItemsRange) == null ? void 0 : _b3.endItemIndex) ?? this._data.items.length) - 1;
    for (let i2 = startIndex; i2 <= endIndex; i2++) {
      const item = this._data.items[i2];
      const cached = this._precalculatedCache[i2 - startIndex];
      const itemY = Math.round(item.y * verticalPixelRatio);
      let top2, bottom;
      const color = ((_c2 = item.style) == null ? void 0 : _c2.color) ?? defaultColor;
      context.fillStyle = color;
      if (itemY <= baseY) {
        top2 = itemY;
        bottom = endBaseY;
      } else {
        top2 = baseY;
        bottom = itemY - Math.floor(barHeightUnit / 2) + barHeightUnit;
      }
      context.fillRect(cached.left, top2, cached.right - cached.left + 1, bottom - top2);
    }
  }
  _fillPrecalculatedCache(pixelRatio) {
    if (!this._data || this._data.items.length === 0) {
      this._precalculatedCache = [];
      return;
    }
    const { barSpacing, visibleItemsRange, items } = this._data;
    const barWidth = Math.ceil(barSpacing * pixelRatio) <= 1 ? 0 : Math.max(1, Math.floor(pixelRatio));
    const start2 = (visibleItemsRange == null ? void 0 : visibleItemsRange.startItemIndex) ?? 0;
    const end = ((visibleItemsRange == null ? void 0 : visibleItemsRange.endItemIndex) ?? items.length) - 1;
    const count = end - start2 + 1;
    if (count <= 0) {
      this._precalculatedCache = [];
      return;
    }
    this._precalculatedCache = new Array(count);
    for (let i2 = start2; i2 <= end; i2++) {
      const item = items[i2];
      const center = Math.round(item.center * pixelRatio);
      const width = Math.round((item.right - item.left) * pixelRatio) - barWidth;
      let left, right;
      if (width % 2) {
        const half = (width - 1) / 2;
        left = center - half;
        right = center + half;
      } else {
        const half = width / 2;
        left = center - half;
        right = center + half - 1;
      }
      this._precalculatedCache[i2 - start2] = {
        left,
        right,
        roundedCenter: center,
        center: item.center * pixelRatio,
        time: item.timePointIndex
      };
    }
    for (let i2 = start2 + 1; i2 <= end; i2++) {
      const curr = this._precalculatedCache[i2 - start2];
      const prev = this._precalculatedCache[i2 - start2 - 1];
      if (curr.time === prev.time + 1) {
        if (curr.left - prev.right !== barWidth + 1) {
          if (prev.roundedCenter > prev.center) {
            prev.right = curr.left - barWidth - 1;
          } else {
            curr.left = prev.right + barWidth + 1;
          }
        }
      }
    }
    let minBarW = Math.ceil(barSpacing * pixelRatio);
    for (let i2 = start2 + 1; i2 <= end; i2++) {
      const item = this._precalculatedCache[i2 - start2];
      if (item.right < item.left) item.right = item.left;
      const width = item.right - item.left + 1;
      minBarW = Math.min(width, minBarW);
    }
    if (barWidth > 0 && minBarW < 4) {
      for (let i2 = start2 + 1; i2 <= end; i2++) {
        const item = this._precalculatedCache[i2 - start2];
        if (item.right - item.left + 1 > minBarW) {
          if (item.roundedCenter > item.center) {
            item.right -= 1;
          } else {
            item.left += 1;
          }
        }
      }
    }
  }
}
function distanceToSegment(p0, p1, point) {
  const a2 = new Point(p0);
  const b2 = new Point(p1);
  const p2 = new Point(point);
  const ab = b2.subtract(a2);
  const ap = p2.subtract(a2);
  const abLengthSquared = ab.x * ab.x + ab.y * ab.y;
  const dot = ab.x * ap.x + ab.y * ap.y;
  const t2 = abLengthSquared > 0 ? dot / abLengthSquared : 0;
  const tClamped = Math.max(0, Math.min(1, t2));
  const projection = new Point(a2.x + ab.x * tClamped, a2.y + ab.y * tClamped);
  return {
    coeff: t2,
    distance: projection.subtract(p2).length()
  };
}
function distanceToLine(start2, end, point) {
  const direction = end.subtract(start2);
  const vectorToPoint = point.subtract(start2);
  const projCoeff = vectorToPoint.dotProduct(direction) / direction.dotProduct(direction);
  const closestPointOnLine = start2.addScaled(direction, projCoeff);
  const distance = closestPointOnLine.subtract(point).length();
  return {
    coeff: projCoeff,
    distance
  };
}
class PaneRendererCross extends BitmapCoordinatesPaneRenderer {
  hitTest(point) {
    if (!this._data) return null;
    const tolerance = interactionTolerance().series + this._data.lineWidth / 2;
    let prevItem, currItem, x1, x2;
    for (let i2 = 1; i2 < this._data.items.length; ++i2) {
      prevItem = this._data.items[i2 - 1];
      currItem = this._data.items[i2];
      x1 = prevItem.center;
      x2 = currItem.center;
      const dist = distanceToSegment(
        new Point(x1, prevItem.y),
        new Point(x2, currItem.y),
        new Point(point.x, point.y)
      ).distance;
      if (dist <= tolerance) {
        return new HitTestResult(HitTarget.Regular);
      }
    }
    return null;
  }
  drawImpl(params) {
    var _a3, _b3, _c2, _d2;
    if (!this._data) return;
    const { context, horizontalPixelRatio, verticalPixelRatio } = params;
    let lastColor = "";
    let pathStarted = false;
    const startIndex = ((_a3 = this._data.visibleItemsRange) == null ? void 0 : _a3.startItemIndex) ?? 0;
    const endIndex = (((_b3 = this._data.visibleItemsRange) == null ? void 0 : _b3.endItemIndex) ?? this._data.items.length) - 1;
    for (let i2 = startIndex; i2 <= endIndex; i2++) {
      const item = this._data.items[i2];
      if (isNaN(item.center) || isNaN(item.y)) continue;
      const itemColor = ((_c2 = item.style) == null ? void 0 : _c2.color) ?? this._data.lineColor;
      const lineWidth = ((_d2 = item.style) == null ? void 0 : _d2.width) ?? this._data.lineWidth;
      const widthPx = Math.max(1, Math.floor(lineWidth * horizontalPixelRatio));
      const heightPx = Math.max(1, Math.floor(lineWidth * verticalPixelRatio));
      if (itemColor !== lastColor || isSafari) {
        lastColor = itemColor;
        if (pathStarted) context.fill();
        context.beginPath();
        context.fillStyle = itemColor;
      }
      let outerWidth = 3 * widthPx;
      if (outerWidth % 2 !== widthPx % 2) outerWidth += 1;
      let outerHeight = 3 * heightPx;
      if (outerHeight % 2 !== heightPx % 2) outerHeight += 1;
      const centerX = Math.round(item.center * horizontalPixelRatio);
      const centerY = Math.round(item.y * verticalPixelRatio);
      const outerLeft = Math.round(centerX - outerWidth / 2);
      const outerTop = Math.round(centerY - outerHeight / 2);
      const innerLeft = outerLeft + Math.floor(outerWidth / 2 - widthPx / 2);
      const innerTop = outerTop + Math.floor(outerHeight / 2 - heightPx / 2);
      context.rect(outerLeft, innerTop, outerWidth, heightPx);
      context.rect(innerLeft, outerTop, widthPx, outerHeight);
      pathStarted = true;
    }
    if (pathStarted) context.fill();
  }
}
function detachItem(item) {
  const { prevItem, nextItem } = item;
  if (prevItem !== null) {
    prevItem.nextItem = nextItem;
  }
  if (nextItem !== null) {
    nextItem.prevItem = prevItem;
  }
}
class CircularCacheBuffer {
  constructor(size2 = 0, capacityFactor = 1.3) {
    __publicField(this, "_cache", /* @__PURE__ */ new Map());
    __publicField(this, "_firstItem", null);
    __publicField(this, "_lastItem", null);
    __publicField(this, "_size");
    __publicField(this, "_sizeLimited");
    __publicField(this, "_capacityFactor");
    this._size = size2;
    this._sizeLimited = size2 > 0;
    this._capacityFactor = capacityFactor;
  }
  set(key2, value) {
    const newItem = {
      key: key2,
      value,
      prevItem: this._lastItem,
      nextItem: null
    };
    if (this._lastItem !== null) {
      this._lastItem.nextItem = newItem;
    }
    const existingItem = this._cache.get(key2);
    if (existingItem !== void 0) {
      detachItem(existingItem);
      if (existingItem === this._firstItem) {
        this._firstItem = existingItem.nextItem;
      }
    }
    this._cache.set(key2, newItem);
    this._lastItem = newItem;
    if (this._firstItem === null) {
      this._firstItem = newItem;
    }
    if (this._sizeLimited && this._cache.size > this._size * this._capacityFactor) {
      this._removeExtraItems();
    }
    return this;
  }
  has(key2) {
    return this._cache.has(key2);
  }
  get(key2) {
    const item = this._cache.get(key2);
    if (item === void 0) {
      return void 0;
    }
    if (item === this._firstItem) {
      this._firstItem = item.nextItem ?? item;
    }
    if (item !== this._lastItem) {
      detachItem(item);
      const lastItem = ensure(this._lastItem);
      lastItem.nextItem = item;
      item.prevItem = lastItem;
      item.nextItem = null;
      this._lastItem = item;
    }
    return item.value;
  }
  clear() {
    this._cache.clear();
    this._firstItem = null;
    this._lastItem = null;
  }
  delete(key2) {
    const item = this._cache.get(key2);
    if (item !== void 0) {
      detachItem(item);
      if (item === this._lastItem) {
        this._lastItem = item.prevItem;
      }
      if (item === this._firstItem) {
        this._firstItem = item.nextItem;
      }
    }
    return this._cache.delete(key2);
  }
  *entries() {
    let current = this._firstItem;
    while (current !== null) {
      yield [current.key, current.value];
      current = current.nextItem;
    }
  }
  state() {
    const result = [];
    for (const [key2, value] of this.entries()) {
      result.push([key2, value]);
    }
    return result;
  }
  restoreState(state2) {
    for (const [key2, value] of state2) {
      this.set(key2, value);
    }
  }
  _removeExtraItems() {
    const excess = this._cache.size - this._size;
    let current = ensure(this._firstItem);
    for (let i2 = 0; i2 < excess; i2++) {
      this._cache.delete(current.key);
      current = ensure(current.nextItem);
    }
    current.prevItem = null;
    this._firstItem = current;
  }
}
var ColorType = /* @__PURE__ */ ((ColorType2) => {
  ColorType2["Solid"] = "solid";
  ColorType2["Gradient"] = "gradient";
  return ColorType2;
})(ColorType || {});
const gradientCache = /* @__PURE__ */ new WeakMap();
function applyColor(params, color, gradientSizeRef = 0, applyMode = 3) {
  const { context, bitmapSize, mediaSize } = params;
  let style;
  if (isString$1(color)) {
    style = color;
  } else if (color.type === ColorType.Solid) {
    style = color.color;
  } else {
    let cache2 = gradientCache.get(context);
    if (cache2 === void 0) {
      cache2 = new CircularCacheBuffer(1e3);
      gradientCache.set(context, cache2);
    }
    const gradientHeight = gradientSizeRef === 0 ? mediaSize.height : bitmapSize.height;
    const gradientKey = `${color.startColor}_${color.endColor}_${gradientHeight}`;
    let gradient = cache2.get(gradientKey);
    if (gradient === void 0) {
      gradient = context.createLinearGradient(0, 0, 0, gradientHeight);
      gradient.addColorStop(0, color.startColor);
      gradient.addColorStop(1, color.endColor);
      cache2.set(gradientKey, gradient);
    }
    style = gradient;
  }
  if (applyMode & 1) {
    context.strokeStyle = style;
  }
  if (applyMode & 2) {
    context.fillStyle = style;
  }
}
const HoleValue = { y: NaN };
function isValidPoint(p2) {
  return !!p2 && !isNaN(p2.y);
}
class PaneRendererLineItemsIterator {
  constructor(items, from, to, skipHoles) {
    __publicField(this, "_items");
    __publicField(this, "_firstIndexWithRange");
    __publicField(this, "_lastIndexWithRange");
    __publicField(this, "_skipHoles");
    __publicField(this, "_calculatedPrev", {
      index: null,
      currentBreakProcessed: false,
      value: null
    });
    __publicField(this, "_calculatedCurrent", {
      index: null,
      currentBreakProcessed: false,
      value: null
    });
    __publicField(this, "_calculatedNext", {
      index: null,
      currentBreakProcessed: false,
      value: null
    });
    __publicField(this, "_preallocated", {
      index: null,
      currentBreakProcessed: false,
      value: null
    });
    if (items.length > 0) {
      should(from <= to, "First index must be less or equal to last index");
      should(from < items.length, "First index must be less than array length");
      should(to <= items.length, "Last index must be less or equal to array length");
    }
    this._items = items;
    this._firstIndexWithRange = from;
    this._lastIndexWithRange = to;
    this._skipHoles = !!skipHoles;
  }
  next() {
    if (this._items.length === 0) return false;
    if (this._calculatedNext.index !== null) {
      if (this._calculatedNext.value !== null) {
        this._calculatedPrev = this._calculatedCurrent;
        this._calculatedCurrent = this._calculatedNext;
        this._calculatedNext = { index: null, currentBreakProcessed: false, value: null };
        return true;
      }
      return false;
    }
    let hasMore = false;
    this._preallocated = { ...this._calculatedCurrent };
    do {
      if (this._preallocated.index === null) {
        this._preallocated.index = this._firstIndexWithRange;
        this._preallocated.currentBreakProcessed = false;
        hasMore = this._preallocated.index < this._lastIndexWithRange;
      } else {
        this._incrementPointer(this._preallocated);
        hasMore = this._isValidPointer(this._preallocated);
      }
      if (hasMore) {
        this._calculateValue(this._preallocated);
      }
    } while (hasMore && this._skipHoles && !isValidPoint(this._preallocated.value));
    if (hasMore) {
      this._calculatedPrev = this._calculatedCurrent;
      this._calculatedCurrent = this._preallocated;
      this._calculatedNext = {
        index: null,
        currentBreakProcessed: false,
        value: null
      };
    }
    return hasMore;
  }
  prevValue() {
    return this._calculatedPrev.value;
  }
  currentValue() {
    return ensure(this._calculatedCurrent.value);
  }
  currentValueIsLast() {
    return ensure(this._calculatedCurrent.index) === this._items.length - 1;
  }
  currentValueIsFirst() {
    return ensure(this._calculatedCurrent.index) === 0;
  }
  nextValue() {
    if (this._calculatedNext.index !== null) {
      return this._calculatedNext.value;
    }
    let hasNext = false;
    this._calculatedNext = { ...this._calculatedCurrent, value: null };
    do {
      this._incrementPointer(this._calculatedNext);
      hasNext = this._isValidPointer(this._calculatedNext);
      if (hasNext) {
        this._calculateValue(this._calculatedNext);
      } else {
        this._calculatedNext.value = null;
      }
    } while (hasNext && this._skipHoles && !isValidPoint(this._calculatedNext.value));
    return this._calculatedNext.value;
  }
  atStart() {
    return this._calculatedCurrent.index === this._firstIndexWithRange && !this._calculatedCurrent.currentBreakProcessed;
  }
  atEnd() {
    const index2 = ensure(this._calculatedCurrent.index);
    return index2 < this._lastIndexWithRange && (this._calculatedCurrent.currentBreakProcessed || !this._needsBreakBefore(index2));
  }
  _needsBreakBefore(index2) {
    return !!this._items[index2].breakBefore && !this._skipHoles;
  }
  _calculateValue(position) {
    const index2 = ensure(position.index);
    if (this._needsBreakBefore(index2) && !position.currentBreakProcessed) {
      position.value = HoleValue;
    } else {
      position.value = this._items[index2];
    }
  }
  _incrementPointer(position) {
    const index2 = ensure(position.index);
    if (this._needsBreakBefore(index2) && !this._calculatedCurrent.currentBreakProcessed) {
      position.currentBreakProcessed = true;
    } else {
      position.index = index2 + 1;
      position.currentBreakProcessed = false;
    }
  }
  _isValidPointer(position) {
    const index2 = ensure(position.index);
    return index2 < this._lastIndexWithRange || index2 === this._lastIndexWithRange - 1 && this._needsBreakBefore(index2) && position.currentBreakProcessed;
  }
}
class PaneRendererLine extends BitmapCoordinatesPaneRenderer {
  hitTest(point) {
    var _a3, _b3;
    if (!this._data) return null;
    const tolerance = interactionTolerance().series + this._data.lineWidth / 2;
    let startIndex = ((_a3 = this._data.visibleItemsRange) == null ? void 0 : _a3.startItemIndex) ?? 0;
    let endIndex = (((_b3 = this._data.visibleItemsRange) == null ? void 0 : _b3.endItemIndex) ?? this._data.items.length) - 1;
    while (endIndex - startIndex > 2) {
      const midIndex = Math.round((startIndex + endIndex) / 2);
      if (this._data.items[midIndex].center <= point.x) {
        startIndex = midIndex;
      } else {
        endIndex = midIndex;
      }
    }
    startIndex = Math.max(1, startIndex - 1);
    endIndex = Math.min(this._data.items.length - 1, endIndex + 1);
    for (let i2 = startIndex; i2 <= endIndex; ++i2) {
      const prev = this._data.items[i2 - 1];
      const curr = this._data.items[i2];
      const x1 = prev.center;
      const x2 = curr.center;
      const dist = distanceToSegment(
        new Point(x1, prev.y),
        new Point(x2, curr.y),
        new Point(point.x, point.y)
      ).distance;
      if (dist <= tolerance) {
        return this._data.hittest ?? new HitTestResult(HitTarget.Regular);
      }
    }
    return null;
  }
  drawImpl(scope) {
    if (!this._data) return;
    const { context, horizontalPixelRatio, verticalPixelRatio } = scope;
    context.scale(horizontalPixelRatio, verticalPixelRatio);
    context.lineCap = "round";
    context.lineJoin = "round";
    applyColor(scope, this._data.lineColor, 0, 3);
    context.lineWidth = this._data.lineWidth;
    if (this._data.lineStyle) {
      setLineStyle(context, this._data.lineStyle);
    }
    if (this._data.simpleMode) {
      this._drawSimpleMode(scope);
    } else {
      this._drawLines(context);
    }
  }
  _drawSimpleMode(scope) {
    var _a3, _b3;
    should(this._data);
    const { context, horizontalPixelRatio, verticalPixelRatio } = scope;
    context.beginPath();
    this._walkLine(context, this._data.items, false, NaN);
    context.stroke();
    const radius = this._data.lineWidth + 2;
    if (this._data.withMarkers && 2 * radius < this._data.barSpacing) {
      context.scale(1 / horizontalPixelRatio, 1 / verticalPixelRatio);
      applyColor(scope, this._data.lineColor, 1, 2);
      const offset = Math.max(1, Math.floor(horizontalPixelRatio)) % 2 / 2;
      const markerRadius = radius * verticalPixelRatio + offset;
      const fullCircle = 2 * Math.PI;
      context.beginPath();
      const startIndex = ((_a3 = this._data.visibleItemsRange) == null ? void 0 : _a3.startItemIndex) ?? 0;
      const endIndex = ((_b3 = this._data.visibleItemsRange) == null ? void 0 : _b3.endItemIndex) ?? this._data.items.length;
      for (let i2 = endIndex - 1; i2 >= startIndex; --i2) {
        const item = this._data.items[i2];
        if (item) {
          const x2 = Math.round(item.center * horizontalPixelRatio) + offset;
          const y2 = item.y * verticalPixelRatio;
          context.moveTo(x2, y2);
          context.arc(x2, y2, markerRadius, 0, fullCircle);
        }
      }
      context.fill();
    }
  }
  _walkLine(context, items, connectThroughHoles, baseY, drawAll = false) {
    var _a3, _b3;
    if (!items) return;
    should(this._data);
    const segmentWidth = 0.25 * this._data.barSpacing;
    let current, next, prev = null;
    const startIndex = drawAll ? 0 : ((_a3 = this._data.visibleItemsRange) == null ? void 0 : _a3.startItemIndex) ?? 0;
    const endIndex = drawAll ? items.length : Math.min(((_b3 = this._data.visibleItemsRange) == null ? void 0 : _b3.endItemIndex) ?? items.length, items.length);
    if (startIndex > endIndex || startIndex >= items.length) return;
    const iterator = new PaneRendererLineItemsIterator(
      items,
      startIndex,
      endIndex,
      this._data.skipHoles
    );
    while (iterator.next()) {
      current = iterator.currentValue();
      next = iterator.nextValue();
      if (isValidPoint(current)) {
        const x2 = Math.round(current.center);
        if (prev && isValidPoint(prev)) {
          context.lineTo(x2, current.y);
          if (connectThroughHoles && !isValidPoint(next)) {
            context.lineTo(x2, baseY);
          }
        } else {
          if (next && isValidPoint(next)) {
            if (connectThroughHoles) {
              if (!iterator.atStart()) {
                context.lineTo(x2, baseY);
              }
              context.lineTo(x2, current.y);
            } else {
              context.moveTo(x2, current.y);
            }
          } else {
            if (connectThroughHoles) {
              if (!iterator.atStart()) {
                context.lineTo(x2 - segmentWidth, baseY);
              }
              context.lineTo(x2 - segmentWidth, current.y);
              context.lineTo(x2 + segmentWidth, current.y);
              context.lineTo(x2 + segmentWidth, baseY);
            } else {
              context.moveTo(x2 - segmentWidth, current.y);
              context.lineTo(x2 + segmentWidth, current.y);
            }
          }
        }
      }
      prev = current;
    }
  }
  _drawLines(context) {
    var _a3, _b3, _c2;
    if (!((_a3 = this._data) == null ? void 0 : _a3.items.length)) return;
    const segmentWidth = 0.25 * this._data.barSpacing;
    context.beginPath();
    const startIndex = ((_b3 = this._data.visibleItemsRange) == null ? void 0 : _b3.startItemIndex) ?? 0;
    const endIndex = ((_c2 = this._data.visibleItemsRange) == null ? void 0 : _c2.endItemIndex) ?? this._data.items.length;
    if (startIndex > endIndex || startIndex >= this._data.items.length) return;
    const firstItem = this._data.items[startIndex];
    if (firstItem) context.moveTo(firstItem.center, firstItem.y);
    let prevColor = context.strokeStyle;
    let prevWidth = context.lineWidth;
    let prevStyle;
    const iterator = new PaneRendererLineItemsIterator(
      this._data.items,
      startIndex,
      endIndex,
      this._data.skipHoles
    );
    while (iterator.next()) {
      const prevItem = iterator.prevValue();
      const currentItem = iterator.currentValue();
      const nextItem = iterator.nextValue();
      if (!isValidPoint(currentItem)) continue;
      let currentColor = this._data.lineColor;
      let currentWidth = this._data.lineWidth;
      let currentStyle = this._data.lineStyle;
      if (currentItem.style && !this._data.forceLineColor) {
        currentColor = currentItem.style.color;
        currentWidth = currentItem.style.width;
        currentStyle = currentItem.style.style;
      }
      if (this._data.ignorePaletteLineWidth) {
        currentWidth = this._data.lineWidth;
      }
      const colorChanged = currentColor !== prevColor || currentWidth !== prevWidth || currentStyle !== prevStyle;
      if (colorChanged) {
        context.stroke();
        context.beginPath();
        context.strokeStyle = currentColor;
        context.lineWidth = currentWidth;
        if (currentStyle) {
          setLineStyle(context, currentStyle);
        }
        if (isValidPoint(prevItem)) {
          context.moveTo(prevItem.center, prevItem.y);
        } else {
          context.moveTo(currentItem.center, currentItem.y);
        }
        prevColor = currentColor;
        prevWidth = currentWidth;
        prevStyle = currentStyle;
      }
      if (isValidPoint(prevItem)) {
        context.lineTo(currentItem.center, currentItem.y);
      } else if (isValidPoint(nextItem)) {
        context.moveTo(currentItem.center, currentItem.y);
      } else {
        context.moveTo(currentItem.center - segmentWidth, currentItem.y);
        context.lineTo(currentItem.center + segmentWidth, currentItem.y);
      }
    }
    context.stroke();
  }
}
function intersectLineSegments(start1, end1, start2, end2) {
  const dir1 = end1.subtract(start1);
  const dir2 = end2.subtract(start2);
  const denominator = dir1.x * dir2.y - dir1.y * dir2.x;
  if (Math.abs(denominator) < 1e-6) {
    return null;
  }
  const delta = start1.subtract(start2);
  const t2 = (delta.y * dir2.x - delta.x * dir2.y) / denominator;
  const intersectionPoint = dir1.scaled(t2).add(start1);
  const distanceResult = distanceToSegment(start2, end2, intersectionPoint);
  return Math.abs(distanceResult.distance) < 1e-6 ? t2 : null;
}
function pointInHalfplane(point, halfplane2) {
  const edge = halfplane2.edge;
  const value = edge.A * point.x + edge.B * point.y + edge.C;
  return value > 0 === halfplane2.isPositive;
}
function pointInBox$1(point, box2) {
  return point.x >= box2.min.x && point.x <= box2.max.x && point.y >= box2.min.y && point.y <= box2.max.y;
}
function pointInPolygon(point, polygon) {
  let inside = false;
  const x2 = point.x;
  const y2 = point.y;
  let j2 = polygon.length - 1;
  for (let i2 = 0; i2 < polygon.length; i2++) {
    const pi2 = polygon[i2];
    const pj = polygon[j2];
    const intersect = (pi2.y < y2 && pj.y >= y2 || pj.y < y2 && pi2.y >= y2) && pi2.x + (y2 - pi2.y) / (pj.y - pi2.y) * (pj.x - pi2.x) < x2;
    if (intersect) inside = !inside;
    j2 = i2;
  }
  return inside;
}
function pointInCircle(point, center, radius) {
  const dx = point.x - center.x;
  const dy = point.y - center.y;
  return dx * dx + dy * dy <= radius * radius;
}
function box(e2, t2) {
  return {
    min: new Point(Math.min(e2.x, t2.x), Math.min(e2.y, t2.y)),
    max: new Point(Math.max(e2.x, t2.x), Math.max(e2.y, t2.y))
  };
}
function lineThroughPoints(e2, t2) {
  if (arePointsEqual(e2, t2)) throw new Error("Points should be distinct");
  return createLine(e2.y - t2.y, t2.x - e2.x, e2.x * t2.y - t2.x * e2.y);
}
function createLine(A2, B2, C2) {
  if (A2 === 0 && B2 === 0) {
    throw new Error("A and B cannot both be zero: not a valid line.");
  }
  return { A: A2, B: B2, C: C2 };
}
function intersectAtX(line, x2, box2) {
  const y2 = -(line.C + line.A * x2) / line.B;
  return y2 >= box2.min.y && y2 <= box2.max.y ? { x: x2, y: y2 } : null;
}
function intersectAtY(line, y2, box2) {
  const x2 = -(line.C + line.B * y2) / line.A;
  return x2 >= box2.min.x && x2 <= box2.max.x ? { x: x2, y: y2 } : null;
}
function intersectLineAndBox(line, box2) {
  const { min, max } = box2;
  const intersections = [];
  if (line.A === 0) {
    const y2 = -line.C / line.B;
    if (y2 >= min.y && y2 <= max.y) {
      return [
        { x: min.x, y: y2 },
        { x: max.x, y: y2 }
      ];
    }
    return null;
  }
  if (line.B === 0) {
    const x2 = -line.C / line.A;
    if (x2 >= min.x && x2 <= max.x) {
      return [
        { x: x2, y: min.y },
        { x: x2, y: max.y }
      ];
    }
    return null;
  }
  const candidates = [
    intersectAtX(line, min.x, box2),
    // left
    intersectAtY(line, min.y, box2),
    // top
    intersectAtX(line, max.x, box2),
    // right
    intersectAtY(line, max.y, box2)
    // bottom
  ];
  for (const pt2 of candidates) {
    if (pt2 && !intersections.some((p2) => arePointsEqual(p2, pt2))) {
      intersections.push(pt2);
    }
  }
  switch (intersections.length) {
    case 0:
      return null;
    case 1:
      return intersections[0];
    case 2:
      return intersections;
    default:
      throw new Error("Unexpected: Line intersects box at more than 2 points.");
  }
}
function pointInBox(p2, box2) {
  return p2.x >= box2.min.x && p2.x <= box2.max.x && p2.y >= box2.min.y && p2.y <= box2.max.y;
}
function intersectRayWithSegment(origin, direction, p1, p2) {
  const r2 = direction.subtract(origin);
  const s2 = p2.subtract(p1);
  const rxs = r2.x * s2.y - r2.y * s2.x;
  const qp = p1.subtract(origin);
  const qpxr = qp.x * r2.y - qp.y * r2.x;
  if (rxs === 0) return null;
  const t2 = (qp.x * s2.y - qp.y * s2.x) / rxs;
  const u2 = qpxr / rxs;
  if (u2 >= 0 && u2 <= 1 && t2 >= 0) {
    return t2;
  }
  return null;
}
function intersectRayAndBox(origin, directionPoint, box2) {
  const topLeft = box2.min;
  const topRight = new Point(box2.max.x, box2.min.y);
  const bottomRight = box2.max;
  const bottomLeft = new Point(box2.min.x, box2.max.y);
  const dir = directionPoint.subtract(origin);
  const intersectionTs = [];
  const t1 = intersectRayWithSegment(origin, directionPoint, topLeft, topRight);
  const t2 = intersectRayWithSegment(origin, directionPoint, topRight, bottomRight);
  const t3 = intersectRayWithSegment(origin, directionPoint, bottomRight, bottomLeft);
  const t4 = intersectRayWithSegment(origin, directionPoint, bottomLeft, topLeft);
  if (t1 !== null && t1 >= 0) intersectionTs.push(t1);
  if (t2 !== null && t2 >= 0) intersectionTs.push(t2);
  if (t3 !== null && t3 >= 0) intersectionTs.push(t3);
  if (t4 !== null && t4 >= 0) intersectionTs.push(t4);
  if (intersectionTs.length === 0) return null;
  intersectionTs.sort((a2, b2) => a2 - b2);
  const tHit = pointInBox(origin, box2) ? intersectionTs[0] : intersectionTs[intersectionTs.length - 1];
  return origin.addScaled(dir, tHit);
}
function lineSegment(start2, end) {
  if (arePointsEqual(start2, end)) {
    throw new Error("Points of a segment should be distinct");
  }
  return [start2, end];
}
function getRegionCode(x2, y2, box2) {
  let code = 0;
  if (x2 < box2.min.x)
    code |= 1;
  else if (x2 > box2.max.x) code |= 2;
  if (y2 < box2.min.y)
    code |= 4;
  else if (y2 > box2.max.y) code |= 8;
  return code;
}
function intersectLineSegmentAndBox(segment, box2) {
  let [x0, y0] = [segment[0].x, segment[0].y];
  let [x1, y1] = [segment[1].x, segment[1].y];
  let code0 = getRegionCode(x0, y0, box2);
  let code1 = getRegionCode(x1, y1, box2);
  let accept = false;
  let maxIterations = 0;
  while (true) {
    if (++maxIterations > 1e3) {
      throw new Error("Cohen-Sutherland: infinite loop detected");
    }
    if (!(code0 | code1)) {
      accept = true;
      break;
    } else if (code0 & code1) {
      break;
    } else {
      const outCode = code0 ? code0 : code1;
      let x2 = 0, y2 = 0;
      if (outCode & 8) {
        x2 = x0 + (x1 - x0) * (box2.max.y - y0) / (y1 - y0);
        y2 = box2.max.y;
      } else if (outCode & 4) {
        x2 = x0 + (x1 - x0) * (box2.min.y - y0) / (y1 - y0);
        y2 = box2.min.y;
      } else if (outCode & 2) {
        y2 = y0 + (y1 - y0) * (box2.max.x - x0) / (x1 - x0);
        x2 = box2.max.x;
      } else if (outCode & 1) {
        y2 = y0 + (y1 - y0) * (box2.min.x - x0) / (x1 - x0);
        x2 = box2.min.x;
      }
      if (outCode === code0) {
        x0 = x2;
        y0 = y2;
        code0 = getRegionCode(x0, y0, box2);
      } else {
        x1 = x2;
        y1 = y2;
        code1 = getRegionCode(x1, y1, box2);
      }
    }
  }
  if (accept) {
    const p0 = new Point(x0, y0);
    const p1 = new Point(x1, y1);
    return arePointsEqual(p0, p1) ? p0 : lineSegment(p0, p1);
  }
  return null;
}
function halfplaneThroughPoint(line, point) {
  const isPositiveSide = line.A * point.x + line.B * point.y + line.C > 0;
  return halfplane(line, isPositiveSide);
}
function halfplane(e2, t2) {
  return { edge: e2, isPositive: t2 };
}
function intersectPolygonAndHalfplane(polygon, halfplane2) {
  const result = [];
  for (let i2 = 0; i2 < polygon.length; ++i2) {
    const current = polygon[i2];
    const next = polygon[(i2 + 1) % polygon.length];
    const edgeLine = lineThroughPoints(current, next);
    const isCurrentInside = pointInHalfplane(current, halfplane2);
    const isNextInside = pointInHalfplane(next, halfplane2);
    if (isCurrentInside) {
      result.push(current);
      if (!isNextInside) {
        const intersection = intersectLines(edgeLine, halfplane2.edge);
        if (intersection !== null) result.push(intersection);
      }
    } else if (isNextInside) {
      const intersection = intersectLines(edgeLine, halfplane2.edge);
      if (intersection !== null) result.push(intersection);
    }
  }
  return result.length >= 3 ? result : null;
}
function intersectLines(line1, line2) {
  const A1 = line1.A, B1 = line1.B, C1 = line1.C;
  const A2 = line2.A, B2 = line2.B, C2 = line2.C;
  const denominator = A1 * B2 - A2 * B1;
  if (Math.abs(denominator) < 1e-6) {
    return null;
  }
  const x2 = (B1 * C2 - B2 * C1) / denominator;
  const y2 = (A2 * C1 - A1 * C2) / denominator;
  return new Point(x2, y2);
}
const dpr1PixelRatioInfo = { horizontalPixelRatio: 1, verticalPixelRatio: 1 };
function addPixelPerfectLineToPath(ctx, x1, y1, x2, y2, scope) {
  const { horizontalPixelRatio: hpx, verticalPixelRatio: vpx } = scope;
  let pixelPoints;
  if (y1 === y2) {
    const yPx = Math.round(y1 * vpx);
    pixelPoints = [x1 * hpx, yPx, x2 * hpx, yPx];
    addHorizontalLineToPath(ctx, pixelPoints[1], pixelPoints[0], pixelPoints[2]);
  } else if (x1 === x2) {
    const xPx = Math.round(x1 * hpx);
    pixelPoints = [xPx, y1 * vpx, xPx, y2 * vpx];
    addVerticalLineToPath(ctx, pixelPoints[0], pixelPoints[1], pixelPoints[3]);
  } else {
    pixelPoints = [x1 * hpx, y1 * vpx, x2 * hpx, y2 * vpx];
    addLineToPath(ctx, pixelPoints[0], pixelPoints[1], pixelPoints[2], pixelPoints[3]);
  }
  return pixelPoints;
}
function addVerticalLineToPath(ctx, x2, yStart, yEnd) {
  const offset = ctx.lineWidth % 2 === 1 ? 0.5 : 0;
  const alignedX = x2 + offset;
  ctx.moveTo(alignedX, yStart);
  ctx.lineTo(alignedX, yEnd);
}
function addHorizontalLineToPath(ctx, y2, xStart, xEnd) {
  const offset = ctx.lineWidth % 2 === 1 ? 0.5 : 0;
  const alignedY = y2 + offset;
  ctx.moveTo(xStart, alignedY);
  ctx.lineTo(xEnd, alignedY);
}
function addLineToPath(ctx, x0, y0, x1, y1) {
  ctx.moveTo(x0, y0);
  ctx.lineTo(x1, y1);
}
function drawHorizontalLine(e2, t2, i2, s2) {
  e2.beginPath();
  addHorizontalLineToPath(e2, t2, i2, s2);
  e2.stroke();
}
function scaleDashPattern(dashPattern, lineWidth) {
  lineWidth = Math.max(1, lineWidth);
  return dashPattern.map((e2) => e2 * lineWidth);
}
function computeDashPattern(lineWidth, lineStyle) {
  const presets = [
    [lineWidth, 2 * lineWidth],
    // index === 1
    [5 * lineWidth, 6 * lineWidth],
    // index === 2
    [6 * lineWidth, 6 * lineWidth],
    // index === 3
    [lineWidth, 4 * lineWidth],
    // index === 4
    [2 * lineWidth, lineWidth]
    // index === 5
  ];
  return presets[lineStyle - 1];
}
function fillRectWithBorder(scope, left, right, top2, bottom, fillWidth, background, border, middleLine) {
  const ctx = scope.context;
  const fillOffset = fillWidth % 2 / 2;
  const adjustedLeft = left + fillOffset;
  const adjustedRight = right + fillOffset;
  let drawFillArea;
  let strokeRect;
  if (border) {
    const { color: borderColor, borderWidth, borderMode, lineStyle, dashPattern } = border;
    switch (borderMode) {
      case "outer": {
        const halfFill = fillWidth / 2;
        const offset = -halfFill - borderWidth / 2;
        const offsetY = -borderWidth / 2;
        strokeRect = {
          left: adjustedLeft + offset,
          right: adjustedRight - offset,
          top: top2 + offsetY,
          bottom: bottom - offsetY
        };
        break;
      }
      case "center": {
        const centerOffset = borderWidth % 2 / 2;
        strokeRect = {
          left: left + centerOffset,
          right: right + centerOffset,
          top: top2 + centerOffset,
          bottom: bottom + centerOffset
        };
        break;
      }
      case "inner": {
        const halfFill = fillWidth / 2;
        const offset = -halfFill + borderWidth / 2;
        const offsetY = borderWidth / 2;
        strokeRect = {
          left: adjustedLeft + offset,
          right: adjustedRight - offset,
          top: top2 + offsetY,
          bottom: bottom - offsetY
        };
        break;
      }
    }
    ctx.strokeStyle = borderColor;
    ctx.lineWidth = borderWidth;
    if (dashPattern) {
      ctx.setLineDash(scaleDashPattern(dashPattern, borderWidth));
    } else if (lineStyle !== void 0) {
      setLineStyle(ctx, lineStyle);
      const adjustCenter = lineStyle === LineStyleType.solid ? 1 : -1;
      drawFillArea = {
        left: strokeRect.left + adjustCenter * border.borderWidth / 2,
        top: strokeRect.top + adjustCenter * border.borderWidth / 2,
        right: strokeRect.right - adjustCenter * border.borderWidth / 2,
        bottom: strokeRect.bottom - adjustCenter * border.borderWidth / 2
      };
    }
  }
  if (background) {
    ctx.fillStyle = background.color;
    if (!drawFillArea) {
      const halfWidth = fillWidth / 2;
      drawFillArea = {
        left: adjustedLeft - halfWidth,
        right: adjustedRight + halfWidth,
        top: top2,
        bottom
      };
    }
    ctx.fillRect(
      drawFillArea.left,
      drawFillArea.top,
      drawFillArea.right - drawFillArea.left,
      drawFillArea.bottom - drawFillArea.top
    );
  }
  if (middleLine) {
    const { lineWidth, lineColor, lineStyle, excludeBoundaries } = middleLine;
    ctx.save();
    ctx.lineCap = "butt";
    ctx.lineWidth = lineWidth;
    ctx.strokeStyle = lineColor;
    setLineStyle(ctx, lineStyle);
    const midY = Math.floor((top2 + bottom) / 2);
    const drawMiddleLine = () => {
      drawHorizontalLine(ctx, midY, left, right);
    };
    if (excludeBoundaries) {
      drawWithExclusionAreaByScope(scope, excludeBoundaries, drawMiddleLine);
    } else {
      drawMiddleLine();
    }
    ctx.restore();
  }
  if (strokeRect) {
    ctx.strokeRect(
      strokeRect.left,
      strokeRect.top,
      strokeRect.right - strokeRect.left,
      strokeRect.bottom - strokeRect.top
    );
  }
}
function addExclusionAreaByScope(scope, polygonPoints) {
  const {
    context: ctx,
    horizontalPixelRatio: hRatio,
    verticalPixelRatio: vRatio,
    bitmapSize
  } = scope;
  ctx.beginPath();
  ctx.rect(0, 0, bitmapSize.width, bitmapSize.height);
  for (let i2 = 0; i2 < polygonPoints.length; i2++) {
    const point = polygonPoints[i2];
    const x2 = point.x * hRatio;
    const y2 = point.y * vRatio;
    if (i2 === 0) {
      ctx.moveTo(x2, y2);
    } else {
      ctx.lineTo(x2, y2);
    }
  }
  ctx.closePath();
  ctx.clip("evenodd");
}
function drawWithExclusionAreaByScope(scope, points, callback) {
  scope.context.save();
  addExclusionAreaByScope(scope, points);
  callback();
  scope.context.restore();
}
function drawRoundRect(ctx, x2, y2, width, height, cornerRadius, skipBeginPath = false) {
  let radiusTopLeft, radiusTopRight, radiusBottomRight, radiusBottomLeft;
  if (Array.isArray(cornerRadius)) {
    if (cornerRadius.length === 2) {
      const horizontal = Math.max(0, cornerRadius[0]);
      const vertical = Math.max(0, cornerRadius[1]);
      radiusTopLeft = radiusTopRight = horizontal;
      radiusBottomRight = radiusBottomLeft = vertical;
    } else if (cornerRadius.length === 4) {
      radiusTopLeft = Math.max(0, cornerRadius[0]);
      radiusTopRight = Math.max(0, cornerRadius[1]);
      radiusBottomRight = Math.max(0, cornerRadius[2]);
      radiusBottomLeft = Math.max(0, cornerRadius[3]);
    } else {
      throw new Error("Invalid corner radius array. Must be either [tl/tr] or [tl, tr, br, bl].");
    }
  } else {
    const radius = Math.max(0, cornerRadius);
    radiusTopLeft = radiusTopRight = radiusBottomRight = radiusBottomLeft = radius;
  }
  if (!skipBeginPath) ctx.beginPath();
  if (ctx.roundRect) {
    ctx.roundRect(x2, y2, width, height, [
      radiusTopLeft,
      radiusTopRight,
      radiusBottomRight,
      radiusBottomLeft
    ]);
    return;
  }
  ctx.moveTo(x2 + radiusTopLeft, y2);
  ctx.lineTo(x2 + width - radiusTopRight, y2);
  if (radiusTopRight !== 0) ctx.arcTo(x2 + width, y2, x2 + width, y2 + radiusTopRight, radiusTopRight);
  ctx.lineTo(x2 + width, y2 + height - radiusBottomRight);
  if (radiusBottomRight !== 0)
    ctx.arcTo(x2 + width, y2 + height, x2 + width - radiusBottomRight, y2 + height, radiusBottomRight);
  ctx.lineTo(x2 + radiusBottomLeft, y2 + height);
  if (radiusBottomLeft !== 0)
    ctx.arcTo(x2, y2 + height, x2, y2 + height - radiusBottomLeft, radiusBottomLeft);
  ctx.lineTo(x2, y2 + radiusTopLeft);
  if (radiusTopLeft !== 0) ctx.arcTo(x2, y2, x2 + radiusTopLeft, y2, radiusTopLeft);
}
function createCircle(ctx, x2, y2, radius) {
  ctx.beginPath();
  ctx.arc(x2, y2, radius, 0, 2 * Math.PI, false);
  ctx.closePath();
}
function drawLine(ctx, x1, y1, x2, y2) {
  const allNumbersFinite = isFinite(x1) && isFinite(y1) && isFinite(x2) && isFinite(y2);
  if (!allNumbersFinite) return;
  ctx.beginPath();
  addLineToPath(ctx, x1, y1, x2, y2);
  ctx.stroke();
}
function drawRoundRectWithBorder(ctx, left, top2, width, height, backgroundColor, borderWidth = 0, outerBorderRadius = [0, 0, 0, 0], borderColor = "", lineDash = [], boxShadow = null) {
  ctx.save();
  ctx.setLineDash(lineDash);
  if (boxShadow) {
    ctx.shadowColor = boxShadow.shadowColor;
    ctx.shadowBlur = boxShadow.shadowBlur;
    ctx.shadowOffsetX = boxShadow.shadowOffsetX ?? 0;
    ctx.shadowOffsetY = boxShadow.shadowOffsetY ?? 0;
  }
  if (!borderWidth || !borderColor || borderColor === backgroundColor) {
    drawRoundRect(ctx, left, top2, width, height, outerBorderRadius);
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
    return;
  }
  const halfBorderWidth = borderWidth / 2;
  const radii = changeBorderRadius(outerBorderRadius, -halfBorderWidth);
  drawRoundRect(
    ctx,
    left + halfBorderWidth,
    top2 + halfBorderWidth,
    width - borderWidth,
    height - borderWidth,
    radii
  );
  if (backgroundColor !== "transparent") {
    ctx.fillStyle = backgroundColor;
    ctx.fill();
  }
  if (borderColor !== "transparent") {
    ctx.lineWidth = borderWidth;
    ctx.strokeStyle = borderColor;
    ctx.closePath();
    ctx.stroke();
  }
  ctx.restore();
}
function changeBorderRadius(borderRadius, offset) {
  return borderRadius.map((x2) => x2 === 0 ? x2 : x2 + offset);
}
function clipPolygonByEdge(polygon, fromPoint, toPoint, directionPoints) {
  const [dir1, dir2] = directionPoints;
  const referencePoint = arePointsEqual(toPoint, dir1) ? arePointsEqual(toPoint, dir2) ? null : dir2 : dir1;
  if (polygon !== null && referencePoint !== null) {
    const line = lineThroughPoints(fromPoint, toPoint);
    const halfplane2 = halfplaneThroughPoint(line, referencePoint);
    return intersectPolygonAndHalfplane(polygon, halfplane2);
  }
  return null;
}
function drawVerticalLine(ctx, x2, yStart, yEnd) {
  ctx.beginPath();
  addVerticalLineToPath(ctx, x2, yStart, yEnd);
  ctx.stroke();
}
function drawPixelPerfectLine(ctx, x1, y1, x2, y2, scope = dpr1PixelRatioInfo) {
  ctx.beginPath();
  addPixelPerfectLineToPath(ctx, x1, y1, x2, y2, scope);
  ctx.stroke();
}
var AnchorStyle = /* @__PURE__ */ ((AnchorStyle2) => {
  AnchorStyle2[AnchorStyle2["circle"] = 1] = "circle";
  AnchorStyle2[AnchorStyle2["square"] = 2] = "square";
  return AnchorStyle2;
})(AnchorStyle || {});
class AnchorPoint extends Point {
  constructor(p2, overrides = /* @__PURE__ */ Object.create(null)) {
    super(p2);
    __publicField(this, "pointIndex", 0);
    __publicField(this, "cursorType");
    __publicField(this, "style", 1);
    __publicField(this, "hitTarget", HitTarget.ChangePoint);
    __publicField(this, "resizeDirections", AnchorResizeAll);
    Object.assign(this, overrides);
  }
  get point() {
    return this;
  }
}
class LineAnchorRenderer extends BitmapCoordinatesPaneRenderer {
  drawImpl(scope) {
    if (!this._data || !this._data.visible) return;
    const squarePoints = [];
    const squareColors = [];
    const circlePoints = [];
    const circleColors = [];
    for (let i2 = 0; i2 < this._data.points.length; ++i2) {
      const point = this._data.points[i2];
      const color = this._data.backgroundColors[i2];
      if (point.style === 2 || point.resizeDirections === AnchorResizeVert || point.resizeDirections === AnchorResizeHorz) {
        squarePoints.push(point);
        squareColors.push(color);
      } else {
        circlePoints.push(point);
        circleColors.push(color);
      }
    }
    if (squarePoints.length > 0) {
      this._drawPoints(scope, squarePoints, squareColors, drawSquare, drawSquareOutline);
    }
    if (circlePoints.length > 0) {
      this._drawPoints(scope, circlePoints, circleColors, drawCircle, drawCircleOutline);
    }
  }
  hitTest(mousePoint) {
    if (!this._data) {
      return null;
    }
    const { radius: markerRadius, points: anchorPoints } = this._data;
    const anchorTolerance = interactionTolerance().anchor;
    for (let i2 = 0; i2 < anchorPoints.length; ++i2) {
      const point = anchorPoints[i2];
      if (new Point(point).subtract(mousePoint).length() <= markerRadius + anchorTolerance) {
        return new HitTestResult(point.hitTarget, {
          areaName: AreaName.AnchorPoint,
          componentIndex: point.pointIndex,
          cursorType: point.cursorType ?? PaneCursor.unset,
          resizeDirections: point.resizeDirections
        });
      }
    }
    return null;
  }
  _drawPoints(scope, points, fillColors, drawMarker, drawHighlight) {
    const { context: ctx, horizontalPixelRatio: hRatio, verticalPixelRatio: vRatio } = scope;
    const settings = ensure(this._data);
    const baseRadius = settings.radius;
    let strokeWidth = Math.max(1, Math.floor((settings.strokeWidth || 2) * hRatio));
    if (settings.selected) {
      strokeWidth += Math.max(1, Math.floor(hRatio / 2));
    }
    const basePixel = Math.max(1, Math.floor(hRatio));
    let markerSize = Math.round(baseRadius * hRatio * 2);
    if (markerSize % 2 !== basePixel % 2) {
      markerSize += 1;
    }
    const pixelOffset = basePixel % 2 / 2;
    const interactionMargin = interactionTolerance().anchor;
    ctx.strokeStyle = settings.color;
    setLineStyle(ctx, LineStyleType.solid);
    for (let i2 = 0; i2 < points.length; ++i2) {
      const point = points[i2];
      ctx.fillStyle = fillColors[i2];
      if (!(isInteger(point.pointIndex) && settings.linePointBeingEdited === point.pointIndex)) {
        const px = Math.round(point.x * hRatio) + pixelOffset;
        const py = Math.round(point.y * vRatio) + pixelOffset;
        drawMarker(ctx, { x: px, y: py }, markerSize / 2, strokeWidth);
        let dist = Number.MAX_SAFE_INTEGER;
        if (settings.currentPoint) {
          dist = euclideanDistanceBetweenPoints(point, settings.currentPoint);
        }
        if (dist <= baseRadius + interactionMargin) {
          const highlightLineWidth = Math.max(1, Math.floor(settings.selectedStrokeWidth * hRatio));
          let highlightSize = Math.round(baseRadius * hRatio * 2);
          if (highlightSize % 2 !== basePixel % 2) {
            highlightSize += 1;
          }
          drawHighlight(ctx, { x: px, y: py }, highlightSize / 2, highlightLineWidth);
        }
      }
    }
  }
}
function doDrawSquare(ctx, center, innerRadius, lineWidth) {
  const outerRadius = innerRadius + lineWidth / 2;
  drawRoundRect(
    ctx,
    center.x - outerRadius,
    center.y - outerRadius,
    2 * outerRadius,
    2 * outerRadius,
    (innerRadius + lineWidth) / 2
  );
  ctx.closePath();
  ctx.lineWidth = lineWidth;
}
function drawSquare(ctx, center, innerRadius, lineWidth) {
  doDrawSquare(ctx, center, innerRadius - lineWidth, lineWidth);
  ctx.fill();
  ctx.stroke();
}
function drawSquareOutline(ctx, center, innerRadius, lineWidth) {
  ctx.globalAlpha = 0.2;
  doDrawSquare(ctx, center, innerRadius, lineWidth);
  ctx.stroke();
  ctx.globalAlpha = 1;
}
function drawCircle(ctx, center, radius, lineWidth) {
  ctx.beginPath();
  ctx.arc(center.x, center.y, radius - lineWidth / 2, 0, 2 * Math.PI, true);
  ctx.closePath();
  ctx.lineWidth = lineWidth;
  ctx.fill();
  ctx.stroke();
}
function drawCircleOutline(ctx, center, radius, lineWidth) {
  ctx.globalAlpha = 0.2;
  ctx.beginPath();
  ctx.arc(center.x, center.y, radius + lineWidth / 2, 0, 2 * Math.PI, true);
  ctx.closePath();
  ctx.lineWidth = lineWidth;
  ctx.stroke();
  ctx.globalAlpha = 1;
}
const DEFAULT_COLOR = "#2A62FF";
class SelectionRenderer extends BitmapCoordinatesPaneRenderer {
  /**
   * 鼠标命中检测：如果某点靠近鼠标，返回命中结果
   */
  hitTest(point) {
    if (!this._data || !this._data.visible) return null;
    for (let i2 = 0; i2 < this._data.points.length; i2++) {
      const marker = this._data.points[i2];
      const distance = new Point(marker).subtract(point).length();
      if (distance <= 5.5) {
        return new HitTestResult(this._data.hitTarget, {
          areaName: AreaName.AnchorPoint,
          componentIndex: marker.pointIndex,
          cursorType: marker.cursorType ?? PaneCursor.unset,
          resizeDirections: 0
        });
      }
    }
    return null;
  }
  /**
   * 判断是否有任何点落在指定矩形框内
   */
  doesIntersectWithBox(box2) {
    return !!this._data && this._data.points.some((point) => pointInBox$1(point, box2));
  }
  /**
   * 在画布上绘制所有标记点
   */
  drawImpl(scope) {
    if (!this._data || !this._data.visible) return;
    const { context: ctx, horizontalPixelRatio: hRatio } = scope;
    ctx.strokeStyle = this._data.color ?? DEFAULT_COLOR;
    ctx.lineCap = "butt";
    const lineWidth = Math.max(1, Math.floor(hRatio));
    ctx.lineWidth = lineWidth;
    const verticalOffset = this._data.vertOffset ?? 0;
    for (let i2 = 0; i2 < this._data.points.length; ++i2) {
      const point = this._data.points[i2];
      if (Number.isFinite(point.x) && Number.isFinite(point.y)) {
        ctx.fillStyle = this._data.bgColors[i2];
        this._drawMarker(scope, { x: point.x, y: point.y }, verticalOffset, lineWidth);
      }
    }
  }
  /**
   * 绘制单个标记点（外圈实心，内圈描边）
   */
  _drawMarker(scope, position, verticalOffset, lineWidth) {
    const { context: ctx, horizontalPixelRatio: hRatio, verticalPixelRatio: vRatio } = scope;
    let outerRadius = Math.round(3.5 * hRatio * 2);
    if (outerRadius % 2 !== lineWidth % 2) outerRadius += 1;
    let totalRadius = Math.round(outerRadius + 2 * (0.5 * lineWidth + 0.75 * hRatio));
    if (totalRadius % 2 !== lineWidth % 2) totalRadius += 1;
    const cx = Math.round(position.x * hRatio);
    const cy = Math.round((position.y + verticalOffset) * vRatio);
    const offset = lineWidth % 2 / 2;
    ctx.beginPath();
    ctx.arc(cx + offset, cy + offset, totalRadius / 2, 0, 2 * Math.PI, true);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.arc(cx + offset, cy + offset, outerRadius / 2, 0, 2 * Math.PI, true);
    ctx.closePath();
    ctx.stroke();
  }
}
class SelectionIndexes {
  constructor(timescale) {
    __publicField(this, "_baseIndex", null);
    __publicField(this, "_offsetInBar", null);
    __publicField(this, "_barsBetweenPoints", null);
    __publicField(this, "_timescale");
    this._timescale = timescale;
  }
  // 获取选中的索引数组
  indexes() {
    const visibleRange = this._timescale.getVisibleLogicalRange();
    if (visibleRange === null) return [];
    const firstVisibleBar = Math.round(visibleRange.from);
    const lastVisibleBar = Math.round(visibleRange.to);
    const currentBaseIndex = this._timescale.baseIndex();
    if (this._offsetInBar === null || this._barsBetweenPoints === null || this._baseIndex !== currentBaseIndex) {
      const barSpacing = this._timescale.barSpacing();
      this._barsBetweenPoints = Math.floor(120 / barSpacing);
      this._offsetInBar = lastVisibleBar % this._barsBetweenPoints;
      this._baseIndex = currentBaseIndex;
    }
    const offsetIndex = ensure(this._offsetInBar);
    const result = [];
    let start2 = Math.floor((firstVisibleBar - offsetIndex) / this._barsBetweenPoints);
    const end = Math.floor((lastVisibleBar - offsetIndex) / this._barsBetweenPoints);
    for (; start2 <= end; start2++) {
      result.push(offsetIndex + start2 * this._barsBetweenPoints);
    }
    return result;
  }
  // 清除缓存状况（通常在图表重建时调用）
  clear() {
    this._offsetInBar = null;
    this._baseIndex = null;
    this._barsBetweenPoints = null;
  }
}
class HorizontalLineRenderer extends BitmapCoordinatesPaneRenderer {
  hitTest(point) {
    if (!this._data || !this._hitTest) {
      return null;
    }
    const tolerance = interactionTolerance().line;
    const isYWithinRange = Math.abs(point.y - this._data.y) <= tolerance + this._data.lineWidth / 2;
    const isLeftWithinRange = this._data.left === void 0 || this._data.left - point.x <= tolerance;
    const isRightWithinRange = this._data.right === void 0 || point.x - this._data.right <= tolerance;
    return isYWithinRange && isLeftWithinRange && isRightWithinRange ? this._hitTest : null;
  }
  drawImpl(scope) {
    if (!this._data) return;
    const {
      context: ctx,
      horizontalPixelRatio: hRatio,
      verticalPixelRatio: vRatio,
      mediaSize
    } = scope;
    if (this._data.y < -this._data.lineWidth / 2 || this._data.y > mediaSize.height + this._data.lineWidth / 2) {
      return;
    }
    ctx.lineCap = "butt";
    ctx.strokeStyle = this._data.lineColor;
    ctx.lineWidth = Math.max(1, Math.floor(this._data.lineWidth * hRatio));
    if (this._data.lineStyle !== void 0) {
      setLineStyle(ctx, this._data.lineStyle);
    }
    const left = this._data.left !== void 0 ? Math.max(this._data.left, 0) : 0;
    const right = this._data.right !== void 0 ? Math.min(this._data.right, mediaSize.width) : mediaSize.width;
    const y2 = Math.round(this._data.y * vRatio);
    const x1 = Math.round(left * hRatio);
    const x2 = Math.round(right * hRatio);
    const exclude2 = this._data.excludeBoundaries;
    if (exclude2 !== void 0) {
      addExclusionAreaByScope(scope, exclude2);
    }
    drawHorizontalLine(ctx, y2, x1, x2);
  }
}
class BandPaneView {
  constructor(source2, properties) {
    __publicField(this, "_invalidated", true);
    __publicField(this, "_lineRenderer");
    __publicField(this, "_source");
    __publicField(this, "_properties");
    // 当前用于绘制的一个点（只用到了 y 值）
    __publicField(this, "_points", [new Point(-1, -1)]);
    this._source = source2;
    this._properties = properties;
    this._lineRenderer = new HorizontalLineRenderer();
  }
  update() {
    this._invalidated = true;
  }
  /**
   * 获取渲染器，确保坐标已同步更新
   */
  renderer() {
    if (this._invalidated) {
      this._updateImpl();
      this._invalidated = false;
    }
    this._lineRenderer.setData({
      y: this._points[0].y,
      // 仅 y 生效
      lineColor: this._properties.color,
      lineWidth: this._properties.lineWidth,
      lineStyle: this._properties.lineStyle
    });
    return this._lineRenderer;
  }
  /**
   * 内部更新逻辑：根据属性值和坐标系统计算水平线位置
   */
  _updateImpl() {
    const priceScale = this._source.priceScale();
    if (!priceScale) {
      this._points[0] = new Point(-1, -1);
      return;
    }
    const price = this._properties.value;
    const y2 = isNumber(price) ? ensure(priceScale.priceToCoordinate(price)) : NaN;
    this._points[0] = new Point(-1, y2);
  }
}
let AreaBackgroundRenderer$1 = class AreaBackgroundRenderer extends MediaCoordinatesPaneRenderer {
  drawImpl(scope) {
    if (!this._data || !this._data.points.length) return;
    const ctx = scope.context;
    const canvasWidth = scope.mediaSize.width;
    if (this._data.gradient) {
      const gradient = ctx.createLinearGradient(
        0,
        this._data.coordinate1,
        0,
        this._data.coordinate2
      );
      gradient.addColorStop(0, this._data.backColor1 ?? "transparent");
      gradient.addColorStop(1, this._data.backColor2 ?? "transparent");
      ctx.fillStyle = gradient;
    } else {
      ctx.fillStyle = this._data.backcolor;
    }
    const y1 = Math.min(this._data.points[0], this._data.points[1]);
    const y2 = Math.max(this._data.points[0], this._data.points[1]);
    ctx.fillRect(0, y1, canvasWidth, y2 - y1);
  }
};
class HlineFilledAreaPaneView {
  constructor(source2, filledArea) {
    __publicField(this, "_areaRenderer", new AreaBackgroundRenderer$1());
    __publicField(this, "_source");
    __publicField(this, "_invalidated", true);
    __publicField(this, "_fillProps");
    this._source = source2;
    should(filledArea.type === "hline_hline", "Wrong filledArea type: " + filledArea.type);
    this._fillProps = filledArea;
  }
  _plotAId() {
    return this._fillProps.objAId;
  }
  _plotBId() {
    return this._fillProps.objBId;
  }
  update() {
    this._invalidated = true;
  }
  renderer() {
    if (this._invalidated) {
      this._updateImpl();
      this._invalidated = false;
    }
    return this._areaRenderer;
  }
  _updateImpl() {
    this._areaRenderer.setData(null);
    const bands = ensure(this._source.getStyleValues().bands);
    const bandA = bands[this._plotAId()];
    const bandB = bands[this._plotBId()];
    should(bandA && bandB);
    const scale = this._source.priceScale();
    if (!scale) return;
    const linePoints = [
      ensure(scale.priceToCoordinate(bandA.value)),
      ensure(scale.priceToCoordinate(bandB.value))
    ];
    const transparency = clamp(this._fillProps.transparency ?? 0, 0, 100);
    const props = this._fillProps;
    if (props.fillType === "gradient") {
      const value1 = props.topValue;
      const value2 = props.bottomValue;
      if (value1 === void 0 || value2 === void 0) return;
      const color1 = props.topColor;
      const color2 = props.bottomColor;
      if (color1 === void 0 && color2 === void 0) return;
      this._areaRenderer.setData({
        gradient: true,
        points: linePoints,
        backColor1: color1 ? generateColor(color1, transparency) : void 0,
        backColor2: color2 ? generateColor(color2, transparency) : void 0,
        coordinate1: ensure(scale.priceToCoordinate(value1)),
        coordinate2: ensure(scale.priceToCoordinate(value2))
      });
    } else {
      const bgColor = generateColor(props.color, transparency);
      this._areaRenderer.setData({
        gradient: false,
        points: linePoints,
        backcolor: bgColor
      });
    }
  }
}
function generateColorCached(cacheSize = 1e3) {
  const originalCache = memoize.Cache;
  memoize.Cache = CircularCacheBuffer.bind(CircularCacheBuffer, cacheSize);
  const memoizedFn = memoize(
    generateColor,
    (color, transparency, extra) => `${color}_${transparency}_${extra}`
  );
  memoize.Cache = originalCache;
  return memoizedFn;
}
function rgbaFromIntegerCached(size2 = 1e3) {
  const previousCacheImpl = memoize.Cache;
  memoize.Cache = CircularCacheBuffer.bind(CircularCacheBuffer, size2);
  const cached = memoize(rgbaFromInteger);
  memoize.Cache = previousCacheImpl;
  return cached;
}
function keys(obj) {
  return Object.keys(obj);
}
const CacheConfig = {
  PurgeCachedContainerCacheIterations: 3e3
};
class ForwardBackwardIterator {
  constructor(items, actualLength, startIndex, reverse) {
    __publicField(this, "_items");
    __publicField(this, "_actualLength");
    __publicField(this, "_step");
    __publicField(this, "_currentIndex");
    this._items = items;
    this._actualLength = actualLength;
    this._step = reverse ? -1 : 1;
    this._currentIndex = startIndex - this._step;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    this._currentIndex += this._step;
    if (this._currentIndex >= this._actualLength || this._currentIndex < 0) {
      return { done: true, value: void 0 };
    }
    return { done: false, value: this._items[this._currentIndex] };
  }
}
class CachedContainer {
  constructor() {
    __publicField(this, "_items", []);
    __publicField(this, "_actualLength", 0);
    __publicField(this, "_invalidations", 0);
  }
  push(item) {
    if (this._items.length === this._actualLength) {
      this._items.push(item);
    } else if (this._items[this._actualLength] !== item) {
      this._items[this._actualLength] = item;
    }
    this._actualLength += 1;
  }
  newItem() {
    const item = this._items.length > this._actualLength ? this._items[this._actualLength] : null;
    if (item !== null && typeof item.invalidateCache === "function") {
      item.invalidateCache();
    }
    return item;
  }
  invalidateCache() {
    this._invalidations += 1;
    if (this._invalidations === CacheConfig.PurgeCachedContainerCacheIterations) {
      this._items.splice(this._actualLength);
      this._invalidations = 0;
    }
    this._actualLength = 0;
  }
  at(index2) {
    return this._items[index2];
  }
  data() {
    return this._items;
  }
  length() {
    return this._actualLength;
  }
  isEmpty() {
    return this._actualLength === 0;
  }
  iterator(start2, reverse) {
    return new ForwardBackwardIterator(this._items, this._actualLength, start2, reverse);
  }
}
class AreaBackgroundItemsGroup extends CachedContainer {
  constructor(color) {
    super();
    __publicField(this, "color");
    this.color = color;
  }
}
const PURGE_CACHE_EVERY = 50;
class CachedMap {
  constructor() {
    __publicField(this, "_map", /* @__PURE__ */ new Map());
    __publicField(this, "_usedKeys", /* @__PURE__ */ new Set());
    __publicField(this, "_invalidations", 0);
  }
  invalidateCache() {
    this._invalidations += 1;
    if (this._invalidations === PURGE_CACHE_EVERY) {
      this._deleteUnused();
      this._invalidations = 0;
    }
    this._usedKeys.clear();
    this._map.forEach((value) => {
      value.invalidateCache();
    });
  }
  get(key2) {
    const value = this._map.get(key2);
    if (value !== void 0) {
      this._usedKeys.add(key2);
    }
    return value;
  }
  set(key2, value) {
    this._usedKeys.add(key2);
    this._map.set(key2, value);
  }
  [Symbol.iterator]() {
    const iterator = Array.from(this._usedKeys)[Symbol.iterator]();
    const map = this._map;
    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        const next = iterator.next();
        if (!next.done) {
          const key2 = next.value;
          const value = ensure(map.get(key2));
          return { value: [key2, value], done: false };
        }
        return { value: void 0, done: true };
      }
    };
  }
  forEach(callback) {
    this._map.forEach((value, key2) => {
      if (this._usedKeys.has(key2)) {
        callback(value, key2);
      }
    });
  }
  delete(key2) {
    const value = this._map.get(key2);
    if (value !== void 0) {
      value.invalidateCache();
    }
    this._usedKeys.delete(key2);
  }
  _deleteUnused() {
    const unusedKeys = [];
    this._map.forEach((_2, key2) => {
      if (!this._usedKeys.has(key2)) {
        unusedKeys.push(key2);
      }
    });
    for (const key2 of unusedKeys) {
      this._map.delete(key2);
    }
  }
}
class AreaBackgroundItem extends CachedContainer {
  constructor() {
    super();
    __publicField(this, "points1");
    __publicField(this, "points2");
    this.points1 = new CachedContainer();
    this.points2 = new CachedContainer();
    this.push(this.points1);
    this.push(this.points2);
  }
  addPoints1Point(x2, y2) {
    let point = this.points1.newItem();
    if (point !== null) {
      point.x = x2;
      point.y = y2;
    } else {
      point = { x: x2, y: y2 };
    }
    this.points1.push(point);
  }
  addPoints2Point(x2, y2) {
    let point = this.points2.newItem();
    if (point !== null) {
      point.x = x2;
      point.y = y2;
    } else {
      point = { x: x2, y: y2 };
    }
    this.points2.push(point);
  }
  invalidateCache() {
    this.points1.invalidateCache();
    this.points2.invalidateCache();
  }
}
class AreaBackgroundRenderer2 extends BitmapCoordinatesPaneRenderer {
  drawImpl(scope) {
    if (this._data === null) return;
    const { context, horizontalPixelRatio: hRatio, verticalPixelRatio: vRatio } = scope;
    const halfBarSpacing = 0.25 * this._data.barSpacing;
    for (const [, areaGroup] of this._data.colorAreas) {
      context.beginPath();
      for (let i2 = 0; i2 < areaGroup.length(); i2++) {
        const item = areaGroup.at(i2);
        if (item.points1.isEmpty() || item.points2.isEmpty()) {
          continue;
        }
        const first1 = item.points1.at(0);
        context.moveTo(Math.round(first1.x * hRatio), first1.y * vRatio);
        if (item.points1.length() !== 1 && item.points2.length() !== 1) {
          for (const p2 of item.points1.iterator(1)) {
            context.lineTo(Math.round(p2.x * hRatio), p2.y * vRatio);
          }
          for (const p2 of item.points2.iterator(item.points2.length() - 1, true)) {
            context.lineTo(Math.round(p2.x * hRatio), p2.y * vRatio);
          }
        } else {
          const second = item.points2.at(0);
          context.lineTo(Math.round((first1.x + halfBarSpacing) * hRatio), first1.y * vRatio);
          context.lineTo(Math.round((second.x + halfBarSpacing) * hRatio), second.y * vRatio);
          context.lineTo(Math.round((second.x - halfBarSpacing) * hRatio), second.y * vRatio);
          context.lineTo(Math.round((first1.x - halfBarSpacing) * hRatio), first1.y * vRatio);
        }
      }
      context.closePath();
      if (areaGroup.color.type === 0) {
        context.fillStyle = areaGroup.color.color;
      } else {
        const gradient = context.createLinearGradient(
          0,
          areaGroup.color.coordinate1 * vRatio,
          0,
          areaGroup.color.coordinate2 * vRatio
        );
        gradient.addColorStop(0, areaGroup.color.color1 ?? "transparent");
        gradient.addColorStop(1, areaGroup.color.color2 ?? "transparent");
        context.fillStyle = gradient;
      }
      context.fill();
    }
  }
}
function createTimePointItems(count, startIndex) {
  return Array.from({ length: count }, (_2, i2) => ({
    timePointIndex: i2 + startIndex,
    xCoordinate: NaN
  }));
}
function findValidRangeIndex(items, from, step) {
  let found1, found2;
  const n2 = items.length;
  for (let i2 = from; i2 >= 0 && i2 < n2; i2 += step) {
    const item = items[i2];
    if (found1 === void 0 && item.plot1Value !== void 0) found1 = i2;
    if (found2 === void 0 && item.plot2Value !== void 0) found2 = i2;
    if (found1 !== void 0 && found2 !== void 0) return i2;
  }
  return null;
}
function serializeColorKey(color) {
  return color.type === 0 ? `${color.color}` : `${color.color1}:${color.color2}:${color.coordinate1}:${color.coordinate2}`;
}
function isSameColor(a2, b2) {
  if (a2 === null || b2 === null) return false;
  if (a2.type !== b2.type) return false;
  if (a2.type === 0 && b2.type === 0) {
    return a2.color === b2.color;
  } else if (a2.type === 1 && b2.type === 1) {
    return a2.color1 === b2.color1 && a2.color2 === b2.color2 && a2.coordinate1 === b2.coordinate1 && a2.coordinate2 === b2.coordinate2;
  } else {
    NOTREACHED();
  }
}
class AbstractFilledAreaPaneView {
  constructor(source2, model, options) {
    __publicField(this, "_source");
    __publicField(this, "_model");
    __publicField(this, "_fillGaps");
    __publicField(this, "_fillToIntersection");
    __publicField(this, "_isHlineFill", false);
    __publicField(this, "_colorPlotIndex", null);
    __publicField(this, "_areaRenderer", new AreaBackgroundRenderer2());
    __publicField(this, "_dataInvalidated", null);
    __publicField(this, "_viewportInvalidated", false);
    __publicField(this, "_plIndex1", null);
    __publicField(this, "_plIndex2", null);
    __publicField(this, "_items", []);
    __publicField(this, "_colorAreas", new CachedMap());
    __publicField(this, "_generateColor", generateColorCached());
    this._source = source2;
    this._model = model;
    this._fillGaps = !!(options == null ? void 0 : options.fillgaps);
    this._fillToIntersection = !!(options == null ? void 0 : options.fillToIntersection);
  }
  update() {
    this._dataInvalidated = true;
  }
  renderer() {
    if (this._dataInvalidated) {
      this._updateImplFull(this._dataInvalidated);
      this._dataInvalidated = null;
      this._viewportInvalidated = false;
    } else if (this._viewportInvalidated) {
      this._updateImplLight();
      this._viewportInvalidated = false;
    }
    return this._areaRenderer;
  }
  _minFirstBarIndex() {
    return -Infinity;
  }
  _priceScale() {
    return this._source.priceScale();
  }
  _plotNames() {
    return keys(this._source.getStyleValues().plots);
  }
  _plotIndex1() {
    if (this._plIndex1 === null) {
      this._plIndex1 = this._plotNames().indexOf(this._plotAId()) + 1;
    }
    return this._plIndex1;
  }
  _plotIndex2() {
    if (this._plIndex2 === null) {
      this._plIndex2 = this._plotNames().indexOf(this._plotBId()) + 1;
    }
    return this._plIndex2;
  }
  _updateImplFull(invalidation) {
    this._areaRenderer.setData(null);
    if (invalidation == null ? void 0 : invalidation.clearData) {
      this._items = [];
    }
    if (!this._visible()) return false;
    const priceScale = this._priceScale();
    if (!priceScale) return false;
    const range = this._source.plots();
    const size2 = range.size();
    if (size2 === 0) return false;
    const minOffset = 0;
    const maxOffset = 0;
    let firstIndex = invalidation.firstIndex;
    const needed = size2 + (maxOffset - minOffset) + 1;
    const pi1 = this._plotIndex1();
    const pi2 = this._plotIndex2();
    if (needed !== this._items.length) {
      if (firstIndex === void 0 || this._items.length === 0 || firstIndex < this._items[0].timePointIndex + minOffset) {
        firstIndex = void 0;
        this._items = createTimePointItems(needed, 1e10);
      } else {
        this._items = this._items.concat(
          createTimePointItems(needed - this._items.length, 1e10 + this._items.length)
        );
      }
    }
    const colorPlot = this._colorPlotIndex;
    const transparency = this._transparency();
    const iterator = firstIndex === void 0 ? range.fullRangeIterator() : range.rangeIterator(firstIndex, ensure(range.lastIndex()));
    let itemOffset = firstIndex !== void 0 ? lowerbound(this._items, firstIndex + minOffset, (a2, b2) => a2.timePointIndex < b2) - minOffset : -0;
    for (const plotPoint of iterator) {
      const indexA = plotPoint.index;
      const indexB = plotPoint.index;
      const itemA = this._items[itemOffset];
      const itemB = this._items[itemOffset];
      itemA.timePointIndex = indexA;
      itemB.timePointIndex = indexB;
      if (!this._isHlineFill) {
        itemA.plot1Value = plotPoint.value[pi1] ?? void 0;
        itemB.plot2Value = plotPoint.value[pi2] ?? void 0;
      }
      if (colorPlot !== null) {
        const idx = itemOffset + minOffset - 1;
        if (idx >= 0 && idx < this._items.length) {
          const colorItem = this._items[idx];
          const rawColor = colorPlot.type === 0 ? {
            type: 0,
            colorIndexOrRgba: plotPoint.value[colorPlot.colorIndexOrRgba + 1]
          } : {
            type: 1,
            colorIndexOrRgba1: colorPlot.colorIndexOrRgba1 !== void 0 ? plotPoint.value[colorPlot.colorIndexOrRgba1 + 1] : void 0,
            colorIndexOrRgba2: colorPlot.colorIndexOrRgba2 !== void 0 ? plotPoint.value[colorPlot.colorIndexOrRgba2 + 1] : void 0,
            value1: colorPlot.valueIndex1 !== void 0 ? plotPoint.value[colorPlot.valueIndex1 + 1] : void 0,
            value2: colorPlot.valueIndex2 !== void 0 ? plotPoint.value[colorPlot.valueIndex2 + 1] : void 0
          };
          const color = colorItem.color = this._getColorByPlotValue(rawColor) ?? void 0;
          if (color !== void 0) {
            if (color.type === 1) {
              color.color1 = color.color1 && this._generateColor(color.color1, transparency);
              color.color2 = color.color2 && this._generateColor(color.color2, transparency);
            } else {
              color.color = this._generateColor(color.color, transparency);
            }
          }
        }
      }
      itemOffset += 1;
    }
    this._updateImplLight();
    return true;
  }
  _updateImplLight() {
    if (!this._visible()) return;
    const priceScale = this._priceScale();
    if (priceScale === null) return;
    if (this._items.length === 0) return;
    let horizontalLevels;
    if (this._isHlineFill) {
      const bands = ensure(this._source.getStyleValues().bands);
      const bandA = bands[this._plotAId()];
      const bandB = bands[this._plotBId()];
      horizontalLevels = {
        level1: priceScale.priceToCoordinate(bandA.value),
        level2: priceScale.priceToCoordinate(bandB.value)
      };
    }
    const timeScale = this._model.timeScale();
    const visibleBars = timeScale.getVisibleLogicalRange();
    if (visibleBars === null) return;
    const transparency = this._transparency();
    const minFirstIndex = this._minFirstBarIndex();
    const startBar = Math.max(minFirstIndex, visibleBars.from);
    const startIndex = lowerbound(this._items, startBar, (a2, b2) => a2.timePointIndex < b2);
    if (startIndex >= this._items.length) return;
    const endIndex = Math.min(
      this._items.length - 1,
      lowerbound(this._items, visibleBars.to, (a2, b2) => a2.timePointIndex < b2)
    );
    const left = this._isHlineFill ? minFirstIndex === startBar ? startIndex : Math.max(0, startIndex - 1) : minFirstIndex === startBar ? startIndex : findValidRangeIndex(this._items, startIndex - 1, -1) ?? startIndex;
    const right = this._isHlineFill ? Math.min(this._items.length - 1, endIndex + 1) : findValidRangeIndex(this._items, endIndex + 1, 1) ?? endIndex;
    const colorAreas = this._colorAreas;
    colorAreas.invalidateCache();
    let prevItem = void 0;
    let currentGroup = null;
    let prevGroup = null;
    let prevColor = null;
    const checkIntersection = (y1, y2, x2) => {
      if (timeScale.barSpacing() < 1 || !this._fillToIntersection || prevItem === void 0 || prevItem.xCoordinate === void 0 || prevItem.plot1Coordinate === void 0 || prevItem.plot2Coordinate === void 0 || currentGroup === null || prevGroup === null || currentGroup.points1.length() === 0 || y1 === void 0 || y2 === void 0) {
        return;
      }
      const a1 = new Point(prevItem.xCoordinate, prevItem.plot1Coordinate);
      const a2 = new Point(prevItem.xCoordinate, prevItem.plot2Coordinate);
      const b1 = new Point(x2, y1);
      const b2 = new Point(x2, y2);
      const intersection = intersectLineSegments(a1, b1, a2, b2);
      if (intersection !== null) {
        const ip = a1.add(a1.subtract(b1).scaled(-intersection));
        prevGroup.addPoints1Point(
          currentGroup.points1.at(currentGroup.points1.length() - 1).x,
          currentGroup.points1.at(currentGroup.points1.length() - 1).y
        );
        prevGroup.addPoints2Point(
          currentGroup.points2.at(currentGroup.points1.length() - 1).x,
          currentGroup.points2.at(currentGroup.points1.length() - 1).y
        );
        prevGroup.addPoints1Point(ip.x, ip.y);
        prevGroup.addPoints1Point(ip.x, ip.y);
        currentGroup.points1.at(currentGroup.points1.length() - 1).x = ip.x;
        currentGroup.points1.at(currentGroup.points1.length() - 1).y = ip.y;
        currentGroup.points2.at(currentGroup.points2.length() - 1).x = ip.x;
        currentGroup.points2.at(currentGroup.points2.length() - 1).y = ip.y;
      }
    };
    const fallbackColor = { type: 0, color: "" };
    const baseColor = this._commonColor();
    if (baseColor.type === 1) {
      baseColor.coordinate1 = ensure(priceScale.priceToCoordinate(baseColor.value1));
      baseColor.coordinate2 = ensure(priceScale.priceToCoordinate(baseColor.value2));
      baseColor.color1 = baseColor.color1 && this._generateColor(baseColor.color1, transparency);
      baseColor.color2 = baseColor.color2 && this._generateColor(baseColor.color2, transparency);
    } else {
      baseColor.color = this._generateColor(baseColor.color, transparency);
    }
    let previousTime = void 0;
    for (let i2 = left; i2 <= right; i2++) {
      const item = this._items[i2];
      const time = item.timePointIndex;
      if (!this._fillGaps && previousTime !== void 0 && time - previousTime > 1) {
        currentGroup = null;
      }
      let y1, y2;
      if (horizontalLevels !== void 0) {
        y1 = horizontalLevels.level1;
        y2 = horizontalLevels.level2;
      } else {
        y1 = item.plot1Coordinate = item.plot1Value !== void 0 ? ensure(priceScale.priceToCoordinate(item.plot1Value)) : void 0;
        y2 = item.plot2Coordinate = item.plot2Value !== void 0 ? ensure(priceScale.priceToCoordinate(item.plot2Value)) : void 0;
      }
      item.xCoordinate = ensure(timeScale.logicalToCoordinate(item.timePointIndex));
      const x2 = item.xCoordinate;
      if (item.color && item.color.type === 1) {
        item.color.coordinate1 = ensure(priceScale.priceToCoordinate(item.color.value1));
        item.color.coordinate2 = ensure(priceScale.priceToCoordinate(item.color.value2));
      }
      if (this._fillGaps ? y1 || y2 : y1 && y2) {
        const color = this._colorPlotIndex !== null ? item.color || fallbackColor : baseColor;
        checkIntersection(ensure(y1), ensure(y2), x2);
        if (prevColor === null || !isSameColor(prevColor, color) || currentGroup === null) {
          if (currentGroup !== null) {
            if (y1) currentGroup.addPoints1Point(x2, y1);
            if (y2) currentGroup.addPoints2Point(x2, y2);
            if (i2 === right) continue;
          }
          prevColor = color;
          const colorKey = serializeColorKey(color);
          let areaGroup = colorAreas.get(colorKey);
          if (!areaGroup) {
            areaGroup = new AreaBackgroundItemsGroup(color);
            colorAreas.set(colorKey, areaGroup);
          }
          prevGroup = currentGroup;
          currentGroup = areaGroup.newItem() ?? new AreaBackgroundItem();
          areaGroup.push(currentGroup);
        }
        if (y1) currentGroup.addPoints1Point(x2, y1);
        if (y2) currentGroup.addPoints2Point(x2, y2);
      } else {
        if (!this._fillGaps) {
          currentGroup = null;
          prevGroup = null;
          prevColor = null;
        }
      }
      previousTime = time;
      prevItem = item;
    }
    colorAreas.delete(serializeColorKey(fallbackColor));
    this._areaRenderer.setData({
      barSpacing: timeScale.barSpacing(),
      colorAreas
    });
  }
}
class PlotFilledAreaPaneView extends AbstractFilledAreaPaneView {
  constructor(source2, model, styleInfo) {
    super(source2, model);
    __publicField(this, "_fillProps");
    __publicField(this, "_rgbaFromInteger");
    this._rgbaFromInteger = rgbaFromIntegerCached();
    this._isHlineFill = styleInfo.type === "hline_hline";
    should(
      this._isHlineFill || styleInfo.type === "plot_plot",
      "Wrong filledArea type: " + styleInfo.type
    );
    this._fillProps = styleInfo;
  }
  _plotAId() {
    return this._fillProps.objAId;
  }
  _plotBId() {
    return this._fillProps.objBId;
  }
  _commonColor() {
    const props = this._fillProps;
    if (props.fillType === "gradient") {
      return {
        type: 1,
        color1: ensure(props.topColor),
        color2: ensure(props.bottomColor),
        value1: ensure(props.topValue),
        value2: ensure(props.bottomValue),
        coordinate1: NaN,
        coordinate2: NaN
      };
    }
    return {
      type: 0,
      color: props.color
    };
  }
  _transparency() {
    return this._fillProps.transparency ?? 0;
  }
  _visible() {
    return true;
  }
  _getColorByPlotValue(plotInfo) {
    if (plotInfo.type === 0) {
      if (plotInfo.colorIndexOrRgba == null) return null;
      const resolvedColor = this._rgbaFromInteger(plotInfo.colorIndexOrRgba);
      return {
        type: 0,
        color: resolvedColor
      };
    }
    const commonColor = this._commonColor();
    should(commonColor.type === 1);
    let color1;
    let color2;
    if (plotInfo.colorIndexOrRgba1 != null) {
      color1 = this._rgbaFromInteger(plotInfo.colorIndexOrRgba1);
    }
    if (plotInfo.colorIndexOrRgba2 != null) {
      color2 = this._rgbaFromInteger(plotInfo.colorIndexOrRgba2);
    }
    const value1 = plotInfo.value1 ?? commonColor.value1;
    const value2 = plotInfo.value2 ?? commonColor.value2;
    color1 = color1 ?? commonColor.color1;
    color2 = color2 ?? commonColor.color2;
    if (value1 === void 0 || value2 === void 0 || color1 === void 0 && color2 === void 0) {
      return null;
    }
    return {
      type: 1,
      color1,
      color2,
      value1,
      value2,
      coordinate1: NaN,
      coordinate2: NaN
    };
  }
}
class CallbackHitTestObject {
  constructor(cb) {
    __publicField(this, "componentId", 0);
    this.cb = cb;
  }
  hitTest(point, scope) {
    return this.cb(point, scope);
  }
}
class StudyCompositeRenderer {
  constructor(_hitTestCollector) {
    __publicField(this, "_renderers", []);
    this._hitTestCollector = _hitTestCollector;
  }
  append(r2) {
    this._renderers.push(r2);
  }
  clean() {
    this._renderers.length = 0;
  }
  draw(target) {
    target.useBitmapCoordinateSpace((scope) => {
      const ctx = scope.context;
      ctx.save();
      this._renderers.map((r2) => {
        var _a3;
        r2.draw(target);
        if (r2.hitTest) {
          (_a3 = this._hitTestCollector) == null ? void 0 : _a3.call(
            this,
            new CallbackHitTestObject((point, scope2) => {
              var _a4;
              return ((_a4 = r2.hitTest) == null ? void 0 : _a4.call(r2, point, scope2)) ?? null;
            })
          );
        }
      });
      ctx.restore();
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  update(data, options) {
  }
}
class StudySeriesPaneView {
  constructor(outputs, study, model, chartApi, hitTestCollector, timeScale) {
    __publicField(this, "_renderer");
    __publicField(this, "_selectionIndexer");
    __publicField(this, "seriesApi", () => /* @__PURE__ */ Object.create(null));
    __publicField(this, "fillAreaPaneViews", []);
    __publicField(this, "bandPaneViews", []);
    this.outputs = outputs;
    this.study = study;
    this.model = model;
    this.timeScale = timeScale;
    this._renderer = new StudyCompositeRenderer(hitTestCollector);
    this._selectionIndexer = new SelectionIndexes(timeScale);
    const styles = study.getStyleValues();
    values(styles.filledAreas || {}).forEach((fillArea) => {
      switch (fillArea.type) {
        case "plot_plot": {
          this.fillAreaPaneViews.push(new PlotFilledAreaPaneView(study, chartApi, fillArea));
          break;
        }
        case "hline_hline": {
          this.fillAreaPaneViews.push(new HlineFilledAreaPaneView(study, fillArea));
          break;
        }
        default:
          NOTIMPLEMENTED();
      }
    });
    values(styles.bands).forEach((band) => {
      this.bandPaneViews.push(new BandPaneView(study, band));
    });
  }
  priceValueBuilder(plotRow) {
    return this.outputs.map((k2) => plotRow.study[k2]);
  }
  isWhitespace(data) {
    return data.study === void 0;
  }
  renderer() {
    return this._renderer;
  }
  update(data) {
    this._renderer.clean();
    const { visibleRange, barSpacing, bars } = data;
    if (!visibleRange) return;
    if (!bars.length) return;
    this.fillAreaPaneViews.forEach((p2) => {
      p2.update();
      this._renderer.append(p2.renderer());
    });
    this.bandPaneViews.forEach((p2) => {
      p2.update();
      this._renderer.append(p2.renderer());
    });
    const isSelected = this.model.isSelected(this.seriesApi());
    let indexes = [];
    if (isSelected) {
      indexes = this._selectionIndexer.indexes();
    } else {
      this._selectionIndexer.clear();
    }
    const highlightWidth = isSelected ? 1 : 0;
    const styles = this.study.getStyleValues();
    this.outputs.forEach((key2) => {
      const plotStyle = ensure(styles.plots[key2]);
      switch (plotStyle.plotType) {
        case "line": {
          should(isStudyLinePlotSingleColorPreferences(plotStyle));
          const items = [];
          for (let i2 = visibleRange.from; i2 < visibleRange.to; i2++) {
            const bar = bars[i2];
            items.push({
              center: bar.x,
              y: ensure(this.seriesApi().priceToCoordinate(bar.originalData.study[key2]))
            });
          }
          const data2 = {
            items,
            lineWidth: plotStyle.lineWidth + highlightWidth,
            lineStyle: LineStyleType.solid,
            lineColor: plotStyle.color,
            barSpacing
          };
          this._renderer.append(new PaneRendererLine(data2));
          break;
        }
        case "cross": {
          should(isStudyLinePlotSingleColorPreferences(plotStyle));
          const items = [];
          for (let i2 = visibleRange.from; i2 < visibleRange.to; i2++) {
            const bar = bars[i2];
            items.push({
              center: bar.x,
              y: ensure(this.seriesApi().priceToCoordinate(bar.originalData.study[key2]))
            });
          }
          const data2 = {
            items,
            lineWidth: plotStyle.lineWidth + highlightWidth,
            lineColor: plotStyle.color
          };
          this._renderer.append(new PaneRendererCross(data2));
          break;
        }
        case "columns": {
          should(isStudyLinePlotMultiColorPreferences(plotStyle));
          const items = [];
          for (let i2 = visibleRange.from; i2 < visibleRange.to; i2++) {
            const bar = bars[i2];
            const center = bar.x;
            items.push({
              center: bar.x,
              left: center - barSpacing / 2,
              right: center + barSpacing / 2,
              y: ensure(this.seriesApi().priceToCoordinate(bar.originalData.study[key2])),
              timePointIndex: i2,
              style: {
                color: bar.barColor
              }
            });
          }
          const base = ensure(this.seriesApi().priceToCoordinate(0));
          const data2 = {
            items,
            barSpacing,
            lineColor: plotStyle.color[0],
            histogramBase: base
          };
          this._renderer.append(new PaneRendererColumns(data2));
          break;
        }
        default:
          NOTIMPLEMENTED();
      }
      if (isSelected && indexes.length) {
        this._renderer.append(new SelectionRenderer(this._createSelection(key2, indexes)));
      }
    });
  }
  _createSelection(key2, indexes) {
    const pane = this.seriesApi().series.getPane();
    const paneHeight = pane.getHeight();
    const selectionData = {
      points: [],
      bgColors: [],
      visible: true,
      hitTarget: HitTarget.Regular
      // barSpacing: this.timeScale.barSpacing(),
    };
    for (const index2 of indexes) {
      const bar = this.seriesApi().series.dataByIndex(index2);
      if (!bar) continue;
      if (!bar.study) continue;
      const x2 = this.timeScale.logicalToCoordinate(Math.floor(index2));
      if (isNil(x2)) continue;
      const value = bar.study[key2];
      const y2 = this.seriesApi().series.priceToCoordinate(value);
      if (isNil(y2)) continue;
      const selectionDataPoint = new AnchorPoint({ x: x2, y: y2 });
      selectionData.points.push(selectionDataPoint);
      const yPercent = selectionDataPoint.point.y / paneHeight;
      const bgColor = this.model.backgroundColorAtYPercentFromTop(yPercent);
      selectionData.bgColors.push(bgColor);
    }
    return selectionData;
  }
  defaultOptions() {
    return {
      ...zr
    };
  }
}
var __getOwnPropDesc$d = Object.getOwnPropertyDescriptor;
var __decorateClass$d = (decorators, target, key2, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$d(target, key2) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$c = (index2, decorator) => (target, key2) => decorator(target, key2, index2);
let ChartStudy = class extends Disposable {
  constructor(_studyInfo, _dataSource, _chartService, _configurationService, _studyService) {
    super();
    __publicField(this, "series");
    __publicField(this, "id");
    __publicField(this, "_priceLines", /* @__PURE__ */ new Map());
    __publicField(this, "_usedStyleValues");
    __publicField(this, "_priceLineEnabled");
    __publicField(this, "_handleRangeChange", () => {
      this._updatePriceLines();
    });
    __publicField(this, "_handleDataChange", async (scope) => {
      var _a3, _b3;
      const sourceData = this._dataSource.data();
      const newData = await this._studyService.exec(
        this._studyInfo.cal,
        sourceData,
        this.getInputs()
      );
      (_b3 = (_a3 = this._studyInfo).coloring) == null ? void 0 : _b3.call(_a3, newData, this.getStyleValues());
      const lastBar = last$1(newData);
      if (scope === "update") {
        if (!lastBar) return;
        this.series.update(lastBar);
      } else {
        this.series.setData(newData);
      }
      this._updatePriceLines();
      this._handleRangeChange();
    });
    this._studyInfo = _studyInfo;
    this._dataSource = _dataSource;
    this._chartService = _chartService;
    this._configurationService = _configurationService;
    this._studyService = _studyService;
    this.id = `${_studyInfo.abbr}@${generateUuid()}`;
    this._priceLineEnabled = _configurationService.getValue("chartProperties").scales.showStudyLastValue;
    this.series = this._createSeries();
    this._register(
      toDisposable(() => {
        if (this._chartService.getModel().currentActive === this) {
          this._chartService.getModel().blur();
        }
        this._chartService.getController().onSeriesRemoved(this.id);
        if (this._studyInfo.overlap) {
          this._chartService.chartApi.removeSeries(this.series);
        } else {
          const paneIndex = this.paneIndex();
          this._chartService.chartApi.removePane(paneIndex);
        }
      })
    );
    this._registerListeners();
  }
  get studyInfo() {
    return this._studyInfo;
  }
  getPriceScaleOptions() {
    return null;
  }
  _computeUsedStyleValues() {
    const preset = this._configurationService.getValue("studyProperties")[this._studyInfo.abbr.toLowerCase()];
    const instanceProps = this._studyInfo.styleValues;
    return merge({}, preset, instanceProps);
  }
  _createSeries() {
    const paneView = new StudySeriesPaneView(
      this._studyInfo.outputs,
      this,
      this._chartService.getModel(),
      this._chartService.chartApi,
      (shapes) => {
        this._chartService.getController().collectSeriesHitTestObjects(this.id, shapes);
      },
      this._chartService.getTimeScale()
    );
    const format2 = this._studyInfo.format;
    const priceScaleOptions = this.getPriceScaleOptions();
    const series = this._chartService.chartApi.addCustomSeries(
      paneView,
      {
        // disabling built-in price lines
        lastValueVisible: false,
        priceLineVisible: false,
        priceScaleId: priceScaleOptions ? "" : void 0,
        priceFormat: format2.type === "inherit" ? {
          type: "custom",
          formatter: (val) => this._chartService.mainSeriesApi.priceFormatter().format(val),
          tickmarksFormatter: (prices) => this._chartService.mainSeriesApi.priceFormatter().formatTickmarks(prices),
          minMove: this._chartService.symbolInfo().minmov
        } : format2
      },
      this._studyInfo.overlap ? 0 : this._chartService.chartApi.panes().length + 1
    );
    if (priceScaleOptions) {
      series.priceScale().applyOptions(priceScaleOptions);
    }
    this._chartService.mainSeriesApi.getSeries().setSeriesOrder(ZOrderMainSeries);
    paneView.seriesApi = () => this;
    this._chartService.getController().onSeriesCreated(this.id, this);
    return series;
  }
  _onStyleChange() {
    this._usedStyleValues = void 0;
    this._handleDataChange("full");
  }
  priceToCoordinate(price) {
    return this.series.priceToCoordinate(price);
  }
  requestUpdate() {
    this.series.requestUpdate();
  }
  updateActive(active) {
    this.series.setSeriesOrder(active ? ZorderTop : ZOrderBottom);
    this._chartService.getStoreHandler().updateStudyLegend(this.id, (legend) => {
      legend.selected = active;
    });
    this.series.updateAllViews();
    this.requestUpdate();
  }
  updateHover() {
  }
  isSeries() {
    return true;
  }
  plots() {
    return this.series.plots();
  }
  _registerListeners() {
    const handleRangeChange = this._handleRangeChange.bind(this);
    this._chartService.getTimeScale().subscribeVisibleLogicalRangeChange(handleRangeChange);
    this._register(
      toDisposable(() => {
        this._chartService.getTimeScale().unsubscribeVisibleLogicalRangeChange(handleRangeChange);
      })
    );
    this._register(this._dataSource.onDataChanged(this._handleDataChange.bind(this)));
    this._register(
      watch(
        this._configurationService.store,
        (store) => store.studyProperties[this._studyInfo.abbr.toLowerCase()],
        () => this._onStyleChange()
      )
    );
  }
  async loadData() {
    const status = this._dataSource.status();
    if (status === DataStatusFlag.error) {
      return;
    }
    if (isHistoryResolved(status)) {
      this._handleDataChange("full");
    }
  }
  async resetData() {
    this.series.setData([]);
    return true;
  }
  getStyleValues() {
    if (!this._usedStyleValues) {
      this._usedStyleValues = this._computeUsedStyleValues();
    }
    return this._usedStyleValues;
  }
  getInputs() {
    return this._studyInfo.inputs;
  }
  paneHTMLElement() {
    return ensure(this.series.getPane().getHTMLElement());
  }
  paneIndex() {
    try {
      return this.series.getPane().paneIndex();
    } catch {
      return -1;
    }
  }
  async paneReady() {
    return wait(16);
  }
  _updatePriceLines() {
    if (!this._priceLineEnabled) {
      return;
    }
    const range = this._chartService.getTimeScale().getVisibleLogicalRange();
    if (!range) return;
    if (!isFinite$1(range.to)) return;
    const lastIndex = this.series.barsProvider().lastIndex();
    if (isUndefinedOrNull(lastIndex)) return;
    const barIndex = Math.min(Math.round(range.to), lastIndex);
    const isLast = barIndex === lastIndex;
    const lastBar = this.series.dataByIndex(barIndex, Tt.NearestLeft);
    if (!lastBar) return;
    this._studyInfo.outputs.forEach((key2) => {
      var _a3;
      const style = ensure(this.getStyleValues().plots[key2]);
      const price = ensure(((_a3 = lastBar.study) == null ? void 0 : _a3[key2]) ?? lastBar.value);
      let priceLine = this._priceLines.get(key2);
      const y2 = ensure(this.series.priceToCoordinate(price));
      const height = this.series.getPane().getHeight();
      let mainColor;
      if (isStudyLinePlotSingleColorPreferences(style)) {
        mainColor = style.color;
      } else {
        mainColor = ensure(lastBar.color);
      }
      const bgColor = this._chartService.getModel().backgroundColorAtYPercentFromTop(y2 / height);
      const option = {
        price,
        color: mainColor,
        lineVisible: false,
        axisLabelVisible: true,
        axisLabelColor: isLast ? mainColor : bgColor,
        axisLabelTextColor: isLast ? bgColor : mainColor,
        axisLabelBorderColor: mainColor,
        title: this.isChartCompare() ? this.symbolInfo().name : ""
      };
      if (!priceLine) {
        priceLine = this.series.createPriceLine({
          ...option,
          price
        });
        this._priceLines.set(key2, priceLine);
      } else {
        if (priceLine.options().price === option.price) return;
        priceLine.applyOptions(option);
      }
    });
  }
  updateLegend(param) {
    let lastData = void 0;
    const series = this.series;
    if (param && param.time) {
      lastData = param.seriesData.get(series);
    } else {
      lastData = last$1(series.data());
    }
    if (!lastData) return;
    const formatter = series.priceFormatter();
    const styleValues = this.getStyleValues();
    this._chartService.getStoreHandler().updateStudyLegend(this.id, (legend) => {
      this._studyInfo.outputs.forEach((key2, i2) => {
        var _a3;
        const plotStyles = ensure(styleValues.plots[key2]);
        legend.values[i2] = {
          key: key2,
          title: plotStyles.title ?? "",
          value: formatter.format(((_a3 = lastData.study) == null ? void 0 : _a3[key2]) ?? (lastData == null ? void 0 : lastData.value)),
          color: isStudyLinePlotSingleColorPreferences(plotStyles) ? plotStyles.color : ensure(lastData.color)
        };
      });
    });
  }
  isChartCompare() {
    return false;
  }
  toggleVisible(visible) {
    this.series.applyOptions({ visible });
  }
  save() {
    const { plots } = this.getStyleValues();
    return {
      type: SourceType.Study,
      name: this.studyInfo.name,
      state: {
        inputs: this.studyInfo.inputs,
        styles: flatten(plots)
      }
    };
  }
  priceScale() {
    return this.series;
  }
};
ChartStudy = __decorateClass$d([
  __decorateParam$c(2, IChartService),
  __decorateParam$c(3, IConfigurationService),
  __decorateParam$c(4, IStudyService)
], ChartStudy);
async function calculateCompare(worker, bars) {
  return bars.map((b2) => {
    const bar = {
      ...b2,
      study: {
        plot: b2.customValues.close
      }
    };
    return bar;
  });
}
let ChartCompare = class extends ChartStudy {
  constructor(_symbolInfo, dataSource, chartService, configurationService, studyService) {
    super(
      {
        id: generateUuid(),
        name: _symbolInfo.name,
        overlap: true,
        optionInfos: [],
        cal: calculateCompare,
        abbr: _symbolInfo.name,
        outputs: ["plot"],
        styleValues: {
          plots: {
            plot: {
              color: "#FF0000",
              lineWidth: 1,
              plotType: "line"
            }
          },
          bands: {},
          filledAreas: {}
        },
        format: {
          type: "price",
          precision: _symbolInfo.pricescale
        }
      },
      dataSource,
      chartService,
      configurationService,
      studyService
    );
    this._symbolInfo = _symbolInfo;
  }
  async loadData() {
  }
  async resetData() {
    return this._dataSource.resetData();
  }
  symbolInfo() {
    return this._symbolInfo;
  }
  isChartCompare() {
    return true;
  }
};
ChartCompare = __decorateClass$d([
  __decorateParam$c(2, IChartService),
  __decorateParam$c(3, IConfigurationService),
  __decorateParam$c(4, IStudyService)
], ChartCompare);
async function calculateVolume(worker, bars) {
  return bars.map((b2) => {
    const val = ensure(b2.customValues.volume);
    const color = b2.color;
    const bar = {
      time: b2.time,
      customValues: b2.customValues,
      color: getLightenRGBA(color, 0.5),
      study: {
        plot: val
      },
      value: val
    };
    return bar;
  });
}
let ChartVolume = class extends ChartStudy {
  constructor(dataSource, chartService, configurationService, studyService) {
    super(
      {
        id: "Volume",
        name: "Volume",
        overlap: true,
        optionInfos: [],
        cal: calculateVolume,
        abbr: "Volume",
        outputs: ["plot"],
        styleValues: {
          plots: {
            plot: {
              plotType: "columns",
              color: []
            }
          },
          bands: {},
          filledAreas: {}
        },
        format: {
          type: "volume",
          precision: 4
        }
      },
      dataSource,
      chartService,
      configurationService,
      studyService
    );
  }
  getPriceScaleOptions() {
    return {
      scaleMargins: {
        top: 0.75,
        bottom: 0
      }
    };
  }
};
ChartVolume = __decorateClass$d([
  __decorateParam$c(1, IChartService),
  __decorateParam$c(2, IConfigurationService),
  __decorateParam$c(3, IStudyService)
], ChartVolume);
const chartConfigLight = {
  layout: {
    background: {
      type: Oi.Solid,
      color: "#ffffff"
    },
    textColor: "#1A1A1A",
    panes: {
      separatorColor: "#EBEBEB"
    }
  },
  rightPriceScale: {
    background: {
      type: Oi.Solid,
      color: "#ffffff"
    },
    textColor: "#1A1A1A"
  },
  timeScale: {},
  grid: {
    vertLines: {
      color: "rgba(48, 48, 48, 0.06)"
    },
    horzLines: {
      color: "rgba(48, 48, 48, 0.06)"
    }
  },
  crosshair: {
    vertLine: {
      color: "#9C9C9C",
      labelBackgroundColor: "#191919"
    },
    horzLine: {
      color: "#9C9C9C",
      labelBackgroundColor: "#191919"
    }
  }
};
const chartConfigDark = {
  layout: {
    background: {
      type: Oi.VerticalGradient,
      topColor: "#1C1C1C",
      bottomColor: "#1A1A1A"
    },
    textColor: "#B8B8B8",
    panes: {
      separatorColor: "#303030"
    }
  },
  rightPriceScale: {
    background: {
      type: Oi.VerticalGradient,
      topColor: "#1C1C1C",
      bottomColor: "#1A1A1A"
    },
    textColor: "#B8B8B8"
  },
  timeScale: {},
  grid: {
    vertLines: {
      color: "rgba(242, 242, 242, 0.06)"
    },
    horzLines: {
      color: "rgba(242, 242, 242, 0.06)"
    }
  },
  crosshair: {
    vertLine: {
      color: "#9C9C9C",
      labelBackgroundColor: "#353535"
    },
    horzLine: {
      color: "#9C9C9C",
      labelBackgroundColor: "#353535"
    }
  }
};
const defaultBarSpacing = 6;
const defaultRightOffset = 10;
function getFutureTime(timezone, sessionsSpec, fromTimestamp, offsetUnit, res) {
  const regularSessionEntries = getRegularSessionEntries(sessionsSpec);
  const secondsOfResolutionUnit = getSecondsOfResolutionUnit(res.unit);
  if (res.unit === ResolutionUnit.Y || res.unit === ResolutionUnit.M || res.unit === ResolutionUnit.W) {
    const offsetSeconds = secondsOfResolutionUnit * offsetUnit * res.value;
    return fromTimestamp + offsetSeconds;
  }
  if (res.unit === ResolutionUnit.D) {
    should(res.value === 1);
    const fromTime = new Date(fromTimestamp * 1e3);
    const zonedTime = toZonedTime(fromTime, timezone);
    let day2 = getDayOfWeek(zonedTime);
    let daysElapsed = 0;
    while (offsetUnit > 0) {
      daysElapsed++;
      day2 = getNextDay(day2);
      const nextDay = getNextDay(day2);
      const entries = regularSessionEntries.entryOfDay(day2);
      if (entries) {
        const overnight = entries[0].isOvernight();
        if (overnight) {
          const isLastTradingDayOfWeek = regularSessionEntries.isWeekEnd(nextDay);
          if (!isLastTradingDayOfWeek) {
            offsetUnit--;
          }
        } else {
          offsetUnit--;
        }
      } else {
        const entriesOfNextDay = regularSessionEntries.entryOfDay(nextDay);
        if (entriesOfNextDay && entriesOfNextDay.length && entriesOfNextDay[0].isOvernight()) {
          offsetUnit--;
        }
      }
    }
    const offsetSeconds = secondsOfResolutionUnit * daysElapsed;
    return fromTimestamp + offsetSeconds;
  }
  let day;
  let currentTimestamp = fromTimestamp;
  let offset = offsetUnit;
  const secondsOfResolution = secondsOfResolutionUnit * res.value;
  while (offset > 0) {
    const currentTime = new Date(currentTimestamp * 1e3);
    const zonedTime = toZonedTime(currentTime, timezone);
    day = getDayOfWeek(zonedTime);
    const entries = [];
    entries.push(...regularSessionEntries.entryOfDay(day) ?? []);
    const nextDay = getNextDay(day);
    const entriesOfNextDay = regularSessionEntries.entryOfDay(nextDay);
    if (entriesOfNextDay && entriesOfNextDay.length && entriesOfNextDay[0].isOvernight()) {
      entries.push(...entriesOfNextDay);
    }
    const offsetSeconds = offset * secondsOfResolution;
    const maybeTimestamp = currentTimestamp + offsetSeconds;
    if (!entries.length) {
      console.warn(
        `timestamp ${fromTimestamp} offset ${offsetUnit} is not within the trading session`
      );
      return maybeTimestamp;
    }
    const sessionIdx = entries.findIndex((e2) => e2.containsZoned(zonedTime));
    if (sessionIdx === -1) {
      console.warn(
        `cannot handle timestamp ${currentTimestamp} in sessions ${entries.map((e2) => e2.toString()).join(",")}`
      );
      return maybeTimestamp;
    }
    const maybeTime = new Date(maybeTimestamp * 1e3);
    const session = entries[sessionIdx];
    if (session.containsZoned(toZonedTime(maybeTime, timezone))) {
      return maybeTimestamp;
    }
    const zonedMins = getMinutesFromMidnight(zonedTime);
    const minsToSessionEnd = session.end() - zonedMins;
    const barsElapsed = minsToSessionEnd * 60 / secondsOfResolution;
    offset -= barsElapsed;
    if (offset <= 0) {
      console.warn(`session.contains(maybeTime)判断有误：${maybeTime} ${session.toString()}`);
      return maybeTimestamp;
    }
    const nextSession = entries[sessionIdx + 1];
    if (nextSession) {
      set_hms(zonedTime, 0, 0, 0, 0);
      add_minutes(zonedTime, nextSession.start());
      currentTimestamp = fromZonedTime(zonedTime, timezone).getTime() / 1e3;
    } else {
      while (true) {
        day = getNextDay(day);
        add_date(zonedTime, 1);
        let entries2 = null;
        entries2 = regularSessionEntries.entryOfDay(day);
        if (!entries2 && regularSessionEntries.isWeekEnd(day)) {
          const nextDay2 = getNextDay(day);
          const entriesOfNextDay2 = regularSessionEntries.entryOfDay(nextDay2);
          if (entriesOfNextDay2 && entriesOfNextDay2.length && entriesOfNextDay2[0].isOvernight()) {
            entries2 = entriesOfNextDay2;
          }
        }
        if (entries2) {
          set_hms(zonedTime, 0, 0, 0, 0);
          add_minutes(zonedTime, entries2[0].start());
          currentTimestamp = fromZonedTime(zonedTime, timezone).getTime() / 1e3;
          break;
        }
      }
    }
  }
  NOTREACHED();
}
var __getOwnPropDesc$c = Object.getOwnPropertyDescriptor;
var __decorateClass$c = (decorators, target, key2, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$c(target, key2) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$b = (index2, decorator) => (target, key2) => decorator(target, key2, index2);
const AvailableTimezoneInfos = [
  {
    id: "Etc/UTC",
    offset: 0,
    offsetStr: "",
    titleI18nKey: "tz.Etc/UTC"
  },
  {
    id: "Pacific/Honolulu",
    offset: -36e6,
    offsetStr: "UTC-10",
    titleI18nKey: "tz.Pacific/Honolulu"
  },
  {
    id: "America/Anchorage",
    offset: -288e5,
    offsetStr: "UTC-8",
    titleI18nKey: "tz.America/Anchorage"
  },
  {
    id: "America/Juneau",
    offset: -288e5,
    offsetStr: "UTC-8",
    titleI18nKey: "tz.America/Juneau"
  },
  {
    id: "America/Los_Angeles",
    offset: -252e5,
    offsetStr: "UTC-7",
    titleI18nKey: "tz.America/Los_Angeles"
  },
  {
    id: "America/Phoenix",
    offset: -252e5,
    offsetStr: "UTC-7",
    titleI18nKey: "tz.America/Phoenix"
  },
  {
    id: "America/Vancouver",
    offset: -252e5,
    offsetStr: "UTC-7",
    titleI18nKey: "tz.America/Vancouver"
  },
  {
    id: "America/El_Salvador",
    offset: -216e5,
    offsetStr: "UTC-6",
    titleI18nKey: "tz.America/El_Salvador"
  },
  {
    id: "America/Mexico_City",
    offset: -216e5,
    offsetStr: "UTC-6",
    titleI18nKey: "tz.America/Mexico_City"
  },
  {
    id: "US/Mountain",
    offset: -216e5,
    offsetStr: "UTC-6",
    titleI18nKey: "tz.US/Mountain"
  },
  {
    id: "America/Bogota",
    offset: -18e6,
    offsetStr: "UTC-5",
    titleI18nKey: "tz.America/Bogota"
  },
  {
    id: "America/Chicago",
    offset: -18e6,
    offsetStr: "UTC-5",
    titleI18nKey: "tz.America/Chicago"
  },
  {
    id: "America/Lima",
    offset: -18e6,
    offsetStr: "UTC-5",
    titleI18nKey: "tz.America/Lima"
  },
  {
    id: "America/Caracas",
    offset: -144e5,
    offsetStr: "UTC-4",
    titleI18nKey: "tz.America/Caracas"
  },
  {
    id: "America/New_York",
    offset: -144e5,
    offsetStr: "UTC-4",
    titleI18nKey: "tz.America/New_York"
  },
  {
    id: "America/Santiago",
    offset: -144e5,
    offsetStr: "UTC-4",
    titleI18nKey: "tz.America/Santiago"
  },
  {
    id: "America/Toronto",
    offset: -144e5,
    offsetStr: "UTC-4",
    titleI18nKey: "tz.America/Toronto"
  },
  {
    id: "America/Argentina/Buenos_Aires",
    offset: -108e5,
    offsetStr: "UTC-3",
    titleI18nKey: "tz.America/Argentina/Buenos_Aires"
  },
  {
    id: "America/Sao_Paulo",
    offset: -108e5,
    offsetStr: "UTC-3",
    titleI18nKey: "tz.America/Sao_Paulo"
  },
  {
    id: "Atlantic/Azores",
    offset: 0,
    offsetStr: "UTC+0",
    titleI18nKey: "tz.Atlantic/Azores"
  },
  {
    id: "Atlantic/Reykjavik",
    offset: 0,
    offsetStr: "UTC+0",
    titleI18nKey: "tz.Atlantic/Reykjavik"
  },
  {
    id: "Africa/Casablanca",
    offset: 36e5,
    offsetStr: "UTC+1",
    titleI18nKey: "tz.Africa/Casablanca"
  },
  {
    id: "Africa/Lagos",
    offset: 36e5,
    offsetStr: "UTC+1",
    titleI18nKey: "tz.Africa/Lagos"
  },
  {
    id: "Africa/Tunis",
    offset: 36e5,
    offsetStr: "UTC+1",
    titleI18nKey: "tz.Africa/Tunis"
  },
  {
    id: "Europe/Dublin",
    offset: 36e5,
    offsetStr: "UTC+1",
    titleI18nKey: "tz.Europe/Dublin"
  },
  {
    id: "Europe/Lisbon",
    offset: 36e5,
    offsetStr: "UTC+1",
    titleI18nKey: "tz.Europe/Lisbon"
  },
  {
    id: "Europe/London",
    offset: 36e5,
    offsetStr: "UTC+1",
    titleI18nKey: "tz.Europe/London"
  },
  {
    id: "Africa/Johannesburg",
    offset: 72e5,
    offsetStr: "UTC+2",
    titleI18nKey: "tz.Africa/Johannesburg"
  },
  {
    id: "Europe/Amsterdam",
    offset: 72e5,
    offsetStr: "UTC+2",
    titleI18nKey: "tz.Europe/Amsterdam"
  },
  {
    id: "Europe/Belgrade",
    offset: 72e5,
    offsetStr: "UTC+2",
    titleI18nKey: "tz.Europe/Belgrade"
  },
  {
    id: "Europe/Berlin",
    offset: 72e5,
    offsetStr: "UTC+2",
    titleI18nKey: "tz.Europe/Berlin"
  },
  {
    id: "Europe/Bratislava",
    offset: 72e5,
    offsetStr: "UTC+2",
    titleI18nKey: "tz.Europe/Bratislava"
  },
  {
    id: "Europe/Brussels",
    offset: 72e5,
    offsetStr: "UTC+2",
    titleI18nKey: "tz.Europe/Brussels"
  },
  {
    id: "Europe/Budapest",
    offset: 72e5,
    offsetStr: "UTC+2",
    titleI18nKey: "tz.Europe/Budapest"
  },
  {
    id: "Europe/Copenhagen",
    offset: 72e5,
    offsetStr: "UTC+2",
    titleI18nKey: "tz.Europe/Copenhagen"
  },
  {
    id: "Europe/Luxembourg",
    offset: 72e5,
    offsetStr: "UTC+2",
    titleI18nKey: "tz.Europe/Luxembourg"
  },
  {
    id: "Europe/Madrid",
    offset: 72e5,
    offsetStr: "UTC+2",
    titleI18nKey: "tz.Europe/Madrid"
  },
  {
    id: "Europe/Malta",
    offset: 72e5,
    offsetStr: "UTC+2",
    titleI18nKey: "tz.Europe/Malta"
  },
  {
    id: "Europe/Oslo",
    offset: 72e5,
    offsetStr: "UTC+2",
    titleI18nKey: "tz.Europe/Oslo"
  },
  {
    id: "Europe/Paris",
    offset: 72e5,
    offsetStr: "UTC+2",
    titleI18nKey: "tz.Europe/Paris"
  },
  {
    id: "Europe/Prague",
    offset: 72e5,
    offsetStr: "UTC+2",
    titleI18nKey: "tz.Europe/Prague"
  },
  {
    id: "Europe/Rome",
    offset: 72e5,
    offsetStr: "UTC+2",
    titleI18nKey: "tz.Europe/Rome"
  },
  {
    id: "Europe/Stockholm",
    offset: 72e5,
    offsetStr: "UTC+2",
    titleI18nKey: "tz.Europe/Stockholm"
  },
  {
    id: "Europe/Vienna",
    offset: 72e5,
    offsetStr: "UTC+2",
    titleI18nKey: "tz.Europe/Vienna"
  },
  {
    id: "Europe/Warsaw",
    offset: 72e5,
    offsetStr: "UTC+2",
    titleI18nKey: "tz.Europe/Warsaw"
  },
  {
    id: "Europe/Zurich",
    offset: 72e5,
    offsetStr: "UTC+2",
    titleI18nKey: "tz.Europe/Zurich"
  },
  {
    id: "Africa/Cairo",
    offset: 108e5,
    offsetStr: "UTC+3",
    titleI18nKey: "tz.Africa/Cairo"
  },
  {
    id: "Africa/Nairobi",
    offset: 108e5,
    offsetStr: "UTC+3",
    titleI18nKey: "tz.Africa/Nairobi"
  },
  {
    id: "Asia/Bahrain",
    offset: 108e5,
    offsetStr: "UTC+3",
    titleI18nKey: "tz.Asia/Bahrain"
  },
  {
    id: "Asia/Jerusalem",
    offset: 108e5,
    offsetStr: "UTC+3",
    titleI18nKey: "tz.Asia/Jerusalem"
  },
  {
    id: "Asia/Kuwait",
    offset: 108e5,
    offsetStr: "UTC+3",
    titleI18nKey: "tz.Asia/Kuwait"
  },
  {
    id: "Asia/Nicosia",
    offset: 108e5,
    offsetStr: "UTC+3",
    titleI18nKey: "tz.Asia/Nicosia"
  },
  {
    id: "Asia/Qatar",
    offset: 108e5,
    offsetStr: "UTC+3",
    titleI18nKey: "tz.Asia/Qatar"
  },
  {
    id: "Asia/Riyadh",
    offset: 108e5,
    offsetStr: "UTC+3",
    titleI18nKey: "tz.Asia/Riyadh"
  },
  {
    id: "Europe/Athens",
    offset: 108e5,
    offsetStr: "UTC+3",
    titleI18nKey: "tz.Europe/Athens"
  },
  {
    id: "Europe/Bucharest",
    offset: 108e5,
    offsetStr: "UTC+3",
    titleI18nKey: "tz.Europe/Bucharest"
  },
  {
    id: "Europe/Helsinki",
    offset: 108e5,
    offsetStr: "UTC+3",
    titleI18nKey: "tz.Europe/Helsinki"
  },
  {
    id: "Europe/Istanbul",
    offset: 108e5,
    offsetStr: "UTC+3",
    titleI18nKey: "tz.Europe/Istanbul"
  },
  {
    id: "Europe/Moscow",
    offset: 108e5,
    offsetStr: "UTC+3",
    titleI18nKey: "tz.Europe/Moscow"
  },
  {
    id: "Europe/Riga",
    offset: 108e5,
    offsetStr: "UTC+3",
    titleI18nKey: "tz.Europe/Riga"
  },
  {
    id: "Europe/Tallinn",
    offset: 108e5,
    offsetStr: "UTC+3",
    titleI18nKey: "tz.Europe/Tallinn"
  },
  {
    id: "Europe/Vilnius",
    offset: 108e5,
    offsetStr: "UTC+3",
    titleI18nKey: "tz.Europe/Vilnius"
  },
  {
    id: "Asia/Tehran",
    offset: 126e5,
    offsetStr: "UTC+3:30",
    titleI18nKey: "tz.Asia/Tehran"
  },
  {
    id: "Asia/Dubai",
    offset: 144e5,
    offsetStr: "UTC+4",
    titleI18nKey: "tz.Asia/Dubai"
  },
  {
    id: "Asia/Muscat",
    offset: 144e5,
    offsetStr: "UTC+4",
    titleI18nKey: "tz.Asia/Muscat"
  },
  {
    id: "Asia/Almaty",
    offset: 18e6,
    offsetStr: "UTC+5",
    titleI18nKey: "tz.Asia/Almaty"
  },
  {
    id: "Asia/Ashkhabad",
    offset: 18e6,
    offsetStr: "UTC+5",
    titleI18nKey: "tz.Asia/Ashkhabad"
  },
  {
    id: "Asia/Karachi",
    offset: 18e6,
    offsetStr: "UTC+5",
    titleI18nKey: "tz.Asia/Karachi"
  },
  {
    id: "Asia/Colombo",
    offset: 198e5,
    offsetStr: "UTC+5:30",
    titleI18nKey: "tz.Asia/Colombo"
  },
  {
    id: "Asia/Kolkata",
    offset: 198e5,
    offsetStr: "UTC+5:30",
    titleI18nKey: "tz.Asia/Kolkata"
  },
  {
    id: "Asia/Kathmandu",
    offset: 207e5,
    offsetStr: "UTC+5:45",
    titleI18nKey: "tz.Asia/Kathmandu"
  },
  {
    id: "Asia/Dhaka",
    offset: 216e5,
    offsetStr: "UTC+6",
    titleI18nKey: "tz.Asia/Dhaka"
  },
  {
    id: "Asia/Yangon",
    offset: 234e5,
    offsetStr: "UTC+6:30",
    titleI18nKey: "tz.Asia/Yangon"
  },
  {
    id: "Asia/Bangkok",
    offset: 252e5,
    offsetStr: "UTC+7",
    titleI18nKey: "tz.Asia/Bangkok"
  },
  {
    id: "Asia/Ho_Chi_Minh",
    offset: 252e5,
    offsetStr: "UTC+7",
    titleI18nKey: "tz.Asia/Ho_Chi_Minh"
  },
  {
    id: "Asia/Jakarta",
    offset: 252e5,
    offsetStr: "UTC+7",
    titleI18nKey: "tz.Asia/Jakarta"
  },
  {
    id: "Asia/Chongqing",
    offset: 288e5,
    offsetStr: "UTC+8",
    titleI18nKey: "tz.Asia/Chongqing"
  },
  {
    id: "Asia/Hong_Kong",
    offset: 288e5,
    offsetStr: "UTC+8",
    titleI18nKey: "tz.Asia/Hong_Kong"
  },
  {
    id: "Asia/Kuala_Lumpur",
    offset: 288e5,
    offsetStr: "UTC+8",
    titleI18nKey: "tz.Asia/Kuala_Lumpur"
  },
  {
    id: "Asia/Manila",
    offset: 288e5,
    offsetStr: "UTC+8",
    titleI18nKey: "tz.Asia/Manila"
  },
  {
    id: "Asia/Shanghai",
    offset: 288e5,
    offsetStr: "UTC+8",
    titleI18nKey: "tz.Asia/Shanghai"
  },
  {
    id: "Asia/Singapore",
    offset: 288e5,
    offsetStr: "UTC+8",
    titleI18nKey: "tz.Asia/Singapore"
  },
  {
    id: "Asia/Taipei",
    offset: 288e5,
    offsetStr: "UTC+8",
    titleI18nKey: "tz.Asia/Taipei"
  },
  {
    id: "Australia/Perth",
    offset: 288e5,
    offsetStr: "UTC+8",
    titleI18nKey: "tz.Australia/Perth"
  },
  {
    id: "Asia/Seoul",
    offset: 324e5,
    offsetStr: "UTC+9",
    titleI18nKey: "tz.Asia/Seoul"
  },
  {
    id: "Asia/Tokyo",
    offset: 324e5,
    offsetStr: "UTC+9",
    titleI18nKey: "tz.Asia/Tokyo"
  },
  {
    id: "Australia/Adelaide",
    offset: 342e5,
    offsetStr: "UTC+9:30",
    titleI18nKey: "tz.Australia/Adelaide"
  },
  {
    id: "Australia/Brisbane",
    offset: 36e6,
    offsetStr: "UTC+10",
    titleI18nKey: "tz.Australia/Brisbane"
  },
  {
    id: "Australia/Sydney",
    offset: 36e6,
    offsetStr: "UTC+10",
    titleI18nKey: "tz.Australia/Sydney"
  },
  {
    id: "Pacific/Norfolk",
    offset: 396e5,
    offsetStr: "UTC+11",
    titleI18nKey: "tz.Pacific/Norfolk"
  },
  {
    id: "Pacific/Auckland",
    offset: 432e5,
    offsetStr: "UTC+12",
    titleI18nKey: "tz.Pacific/Auckland"
  },
  {
    id: "Pacific/Chatham",
    offset: 459e5,
    offsetStr: "UTC+12:45",
    titleI18nKey: "tz.Pacific/Chatham"
  },
  {
    id: "Pacific/Fakaofo",
    offset: 468e5,
    offsetStr: "UTC+13",
    titleI18nKey: "tz.Pacific/Fakaofo"
  }
];
let ChartTimeZoneApi = class extends Disposable {
  constructor(chartStore, chartService) {
    super();
    __publicField(this, "_onTimezoneChanged", new Emitter());
    __publicField(this, "onTimezoneChanged", this._onTimezoneChanged.event);
    __publicField(this, "_tzId");
    this.chartStore = chartStore;
    this.chartService = chartService;
    this._tzId = this.getTimezone().id;
    this._register(
      this.onTimezoneChanged(() => {
        this._tzId = this.getTimezone().id;
      })
    );
  }
  getTimezoneId() {
    return this._tzId;
  }
  availableTimezones() {
    return AvailableTimezoneInfos;
  }
  getTimezone() {
    const tz = get(this.chartService.getStore()).chartProperties.timezone;
    if (tz === "exchange") {
      const { timezone } = this.chartService.symbolInfo();
      if (timezone) {
        return ensure(this.availableTimezones().find((t2) => t2.id === timezone));
      } else {
        const timezone2 = Intl.DateTimeFormat().resolvedOptions().timeZone;
        const exists = this.availableTimezones().find((t2) => t2.id === timezone2);
        if (exists) {
          return exists;
        } else {
          return ensure(this.availableTimezones().find((t2) => t2.id === "Etc/UTC"));
        }
      }
    } else {
      return ensure(this.availableTimezones().find((t2) => t2.id === tz));
    }
  }
  setTimezone(timezone) {
    const info = this.availableTimezones().find((t2) => t2.id === timezone);
    if (!info) return;
    this.chartStore.setChartProperty("timezone", timezone);
    this._onTimezoneChanged.fire(timezone);
  }
};
ChartTimeZoneApi = __decorateClass$c([
  __decorateParam$b(1, IChartService)
], ChartTimeZoneApi);
class ChartCommand {
  constructor(chartService) {
    __publicField(this, "resource");
    __publicField(this, "type", UndoRedoElementType.Resource);
    this.chartService = chartService;
    this.resource = chartService.id;
  }
}
class ViewportCommand extends ChartCommand {
  constructor(chartService, viewport) {
    super(chartService);
    __publicField(this, "_leftOffset", null);
    __publicField(this, "_rightOffset", null);
    __publicField(this, "_barSpacing", null);
    __publicField(this, "_priceAutoScale", null);
    this.viewport = viewport;
  }
  undo() {
    const timeScale = this.chartService.getTimeScale();
    const range = ensure(timeScale.getVisibleRange());
    timeScale.applyOptions({ barSpacing: ensure(this._barSpacing) });
    timeScale.setVisibleRange({
      from: range.from + ensure(this._leftOffset),
      to: range.to + ensure(this._rightOffset)
    });
    const priceScale = this.chartService.getPriceScale();
    const autoScale = this._priceAutoScale;
    if (!autoScale) {
      priceScale.setVisibleRange({ from: this.viewport.fromPrice, to: this.viewport.toPrice });
    } else {
      priceScale.setAutoScale(!!autoScale);
    }
  }
  redo() {
    const timeScale = this.chartService.getTimeScale();
    const visibleRange = ensure(timeScale.getVisibleRange());
    this._leftOffset = visibleRange.from - this.viewport.fromTime;
    this._rightOffset = visibleRange.to - this.viewport.toTime;
    this._barSpacing = timeScale.barSpacing();
    timeScale.setVisibleRange({ from: this.viewport.fromTime, to: this.viewport.toTime });
    const priceScale = this.chartService.getPriceScale();
    this._priceAutoScale = priceScale.options().autoScale;
    priceScale.setAutoScale(false);
    priceScale.setVisibleRange({ from: this.viewport.fromPrice, to: this.viewport.toPrice });
  }
}
var ZoomDirection = /* @__PURE__ */ ((ZoomDirection2) => {
  ZoomDirection2[ZoomDirection2["in"] = 0] = "in";
  ZoomDirection2[ZoomDirection2["out"] = 1] = "out";
  return ZoomDirection2;
})(ZoomDirection || {});
class ZoomCommand extends ChartCommand {
  constructor(chartService, _cmd, _zoomStack, _dir) {
    super(chartService);
    this._cmd = _cmd;
    this._zoomStack = _zoomStack;
    this._dir = _dir;
  }
  undo() {
    if (this._dir === 0) {
      if (this._cmd !== this._zoomStack.head()) {
        console.warn("zoom stack inconsistency");
        return;
      }
      this._cmd.undo();
      this._zoomStack.pop();
    } else {
      this._cmd.redo();
      this._zoomStack.push(this._cmd);
    }
  }
  redo() {
    if (this._dir === 0) {
      this._cmd.redo();
      this._zoomStack.push(this._cmd);
    } else {
      if (this._cmd !== this._zoomStack.head()) {
        console.warn("zoom stack inconsistency");
        return;
      }
      this._cmd.undo();
      this._zoomStack.pop();
    }
  }
}
class ZoomStack {
  constructor(_onPush, _onPop) {
    __publicField(this, "_commands", []);
    this._onPush = _onPush;
    this._onPop = _onPop;
  }
  push(cmd) {
    this._commands.push(cmd);
    this._onPush(cmd.viewport);
  }
  pop() {
    this._commands.pop();
    this._onPop();
  }
  head() {
    return this._commands[this._commands.length - 1];
  }
}
function createMouseEvent(type, e2, chart) {
  return new MouseInputEvent(type, e2, chart);
}
function createChartInputEvent(type, e2, chart) {
  return new ChartInputEvent(type, e2, chart);
}
const BrowserFeatures = {
  pointerEvents: window.PointerEvent && ("ontouchstart" in window || navigator.maxTouchPoints > 0)
};
var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc$b = Object.getOwnPropertyDescriptor;
var __decorateClass$b = (decorators, target, key2, kind) => {
  var result = __getOwnPropDesc$b(target, key2);
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(target, key2, result) || result;
  if (result) __defProp$2(target, key2, result);
  return result;
};
var EventType;
((EventType2) => {
  EventType2.Tap = "-chartles-gesturetap";
  EventType2.Change = "-chartles-gesturechange";
  EventType2.Start = "-chartles-gesturestart";
  EventType2.End = "-chartles-gesturesend";
  EventType2.Contextmenu = "-chartles-gesturecontextmenu";
})(EventType || (EventType = {}));
const _Gesture = (_d = class extends Disposable {
  // ms
  constructor() {
    super();
    __publicField(this, "dispatched", false);
    __publicField(this, "targets", new LinkedList());
    __publicField(this, "ignoreTargets", new LinkedList());
    __publicField(this, "handle");
    __publicField(this, "activeTouches");
    __publicField(this, "_lastSetTapCountTime");
    this.activeTouches = {};
    this.handle = null;
    this._lastSetTapCountTime = 0;
    this._register(
      addDisposableListener(document, "touchstart", (e2) => this.onTouchStart(e2), {
        passive: false
      })
    );
    this._register(
      addDisposableListener(document, "touchend", (e2) => this.onTouchEnd(e2))
    );
    this._register(
      addDisposableListener(document, "touchmove", (e2) => this.onTouchMove(e2), {
        passive: false
      })
    );
  }
  static addTarget(element2) {
    if (!_d.isTouchDevice()) {
      return Disposable.None;
    }
    if (!_d.INSTANCE) {
      _d.INSTANCE = new _d();
    }
    const remove = _d.INSTANCE.targets.push(element2);
    return toDisposable(remove);
  }
  static ignoreTarget(element2) {
    if (!_d.isTouchDevice()) {
      return Disposable.None;
    }
    if (!_d.INSTANCE) {
      _d.INSTANCE = new _d();
    }
    const remove = _d.INSTANCE.ignoreTargets.push(element2);
    return toDisposable(remove);
  }
  static isTouchDevice() {
    return "ontouchstart" in window || navigator.maxTouchPoints > 0;
  }
  dispose() {
    if (this.handle) {
      this.handle.dispose();
      this.handle = null;
    }
    super.dispose();
  }
  onTouchStart(e2) {
    const timestamp = Date.now();
    if (this.handle) {
      this.handle.dispose();
      this.handle = null;
    }
    for (let i2 = 0, len = e2.targetTouches.length; i2 < len; i2++) {
      const touch = e2.targetTouches.item(i2);
      this.activeTouches[touch.identifier] = {
        id: touch.identifier,
        initialTarget: touch.target,
        initialTimeStamp: timestamp,
        initialPageX: touch.pageX,
        initialPageY: touch.pageY,
        rollingTimestamps: [timestamp],
        rollingPageX: [touch.pageX],
        rollingPageY: [touch.pageY]
      };
      const evt = this.newGestureEvent(EventType.Start, touch.target);
      evt.pageX = touch.pageX;
      evt.pageY = touch.pageY;
      this.dispatchEvent(evt);
    }
    if (this.dispatched) {
      e2.preventDefault();
      e2.stopPropagation();
      this.dispatched = false;
    }
  }
  onTouchEnd(e2) {
    const timestamp = Date.now();
    const activeTouchCount = Object.keys(this.activeTouches).length;
    for (let i2 = 0, len = e2.changedTouches.length; i2 < len; i2++) {
      const touch = e2.changedTouches.item(i2);
      if (!Object.prototype.hasOwnProperty.call(this.activeTouches, String(touch.identifier))) {
        console.warn("move of an UNKNOWN touch", touch);
        continue;
      }
      const data = this.activeTouches[touch.identifier], holdTime = Date.now() - data.initialTimeStamp;
      if (holdTime < _d.HOLD_DELAY && Math.abs(data.initialPageX - data.rollingPageX.at(-1)) < 30 && Math.abs(data.initialPageY - data.rollingPageY.at(-1)) < 30) {
        const evt = this.newGestureEvent(EventType.Tap, data.initialTarget);
        evt.pageX = data.rollingPageX.at(-1);
        evt.pageY = data.rollingPageY.at(-1);
        this.dispatchEvent(evt);
      } else if (holdTime >= _d.HOLD_DELAY && Math.abs(data.initialPageX - data.rollingPageX.at(-1)) < 30 && Math.abs(data.initialPageY - data.rollingPageY.at(-1)) < 30) {
        const evt = this.newGestureEvent(EventType.Contextmenu, data.initialTarget);
        evt.pageX = data.rollingPageX.at(-1);
        evt.pageY = data.rollingPageY.at(-1);
        this.dispatchEvent(evt);
      } else if (activeTouchCount === 1) {
        const finalX = data.rollingPageX.at(-1);
        const finalY = data.rollingPageY.at(-1);
        const deltaT = data.rollingTimestamps.at(-1) - data.rollingTimestamps[0];
        const deltaX = finalX - data.rollingPageX[0];
        const deltaY = finalY - data.rollingPageY[0];
        const dispatchTo = [...this.targets].filter(
          (t2) => data.initialTarget instanceof Node && t2.contains(data.initialTarget)
        );
        this.inertia(
          dispatchTo,
          timestamp,
          // time now
          Math.abs(deltaX) / deltaT,
          // speed
          deltaX > 0 ? 1 : -1,
          // x direction
          finalX,
          // x now
          Math.abs(deltaY) / deltaT,
          // y speed
          deltaY > 0 ? 1 : -1,
          // y direction
          finalY
          // y now
        );
      }
      this.dispatchEvent(this.newGestureEvent(EventType.End, data.initialTarget));
      delete this.activeTouches[touch.identifier];
    }
    if (this.dispatched) {
      e2.preventDefault();
      e2.stopPropagation();
      this.dispatched = false;
    }
  }
  newGestureEvent(type, initialTarget) {
    const event2 = document.createEvent("CustomEvent");
    event2.initEvent(type, false, true);
    event2.initialTarget = initialTarget;
    event2.tapCount = 0;
    return event2;
  }
  dispatchEvent(event2) {
    if (event2.type === EventType.Tap) {
      const currentTime = (/* @__PURE__ */ new Date()).getTime();
      let setTapCount = 0;
      if (currentTime - this._lastSetTapCountTime > _d.CLEAR_TAP_COUNT_TIME) {
        setTapCount = 1;
      } else {
        setTapCount = 2;
      }
      this._lastSetTapCountTime = currentTime;
      event2.tapCount = setTapCount;
    } else if (event2.type === EventType.Change || event2.type === EventType.Contextmenu) {
      this._lastSetTapCountTime = 0;
    }
    if (event2.initialTarget instanceof Node) {
      for (const ignoreTarget of this.ignoreTargets) {
        if (ignoreTarget.contains(event2.initialTarget)) {
          return;
        }
      }
      const targets = [];
      for (const target of this.targets) {
        if (target.contains(event2.initialTarget)) {
          let depth = 0;
          let now2 = event2.initialTarget;
          while (now2 && now2 !== target) {
            depth++;
            now2 = now2.parentElement;
          }
          targets.push([depth, target]);
        }
      }
      targets.sort((a2, b2) => a2[0] - b2[0]);
      for (const [_2, target] of targets) {
        target.dispatchEvent(event2);
        this.dispatched = true;
      }
    }
  }
  inertia(dispatchTo, t1, vX, dirX, x2, vY, dirY, y2) {
    this.handle = scheduleAtNextAnimationFrame(() => {
      const now2 = Date.now();
      const deltaT = now2 - t1;
      let delta_pos_x = 0, delta_pos_y = 0;
      let stopped = true;
      vX += _d.SCROLL_FRICTION * deltaT;
      vY += _d.SCROLL_FRICTION * deltaT;
      if (vX > 0) {
        stopped = false;
        delta_pos_x = dirX * vX * deltaT;
      }
      if (vY > 0) {
        stopped = false;
        delta_pos_y = dirY * vY * deltaT;
      }
      const evt = this.newGestureEvent(EventType.Change);
      evt.translationX = delta_pos_x;
      evt.translationY = delta_pos_y;
      dispatchTo.forEach((d3) => d3.dispatchEvent(evt));
      if (!stopped) {
        this.inertia(dispatchTo, now2, vX, dirX, x2 + delta_pos_x, vY, dirY, y2 + delta_pos_y);
      }
    });
  }
  onTouchMove(e2) {
    const timestamp = Date.now();
    for (let i2 = 0, len = e2.changedTouches.length; i2 < len; i2++) {
      const touch = e2.changedTouches.item(i2);
      if (!Object.prototype.hasOwnProperty.call(this.activeTouches, String(touch.identifier))) {
        console.warn("end of an UNKNOWN touch", touch);
        continue;
      }
      const data = this.activeTouches[touch.identifier];
      const evt = this.newGestureEvent(EventType.Change, data.initialTarget);
      evt.translationX = touch.pageX - data.rollingPageX.at(-1);
      evt.translationY = touch.pageY - data.rollingPageY.at(-1);
      evt.pageX = touch.pageX;
      evt.pageY = touch.pageY;
      this.dispatchEvent(evt);
      if (data.rollingPageX.length > 3) {
        data.rollingPageX.shift();
        data.rollingPageY.shift();
        data.rollingTimestamps.shift();
      }
      data.rollingPageX.push(touch.pageX);
      data.rollingPageY.push(touch.pageY);
      data.rollingTimestamps.push(timestamp);
    }
    if (this.dispatched) {
      e2.preventDefault();
      e2.stopPropagation();
      this.dispatched = false;
    }
  }
}, __publicField(_d, "SCROLL_FRICTION", -5e-3), __publicField(_d, "INSTANCE"), __publicField(_d, "HOLD_DELAY", 700), __publicField(_d, "CLEAR_TAP_COUNT_TIME", 400), _d);
__decorateClass$b([
  memoize$1
], _Gesture, "isTouchDevice");
let Gesture = _Gesture;
class GlobalPointerMoveMonitor {
  constructor() {
    __publicField(this, "_hooks", new DisposableStore());
    __publicField(this, "_pointerMoveCallback", null);
    __publicField(this, "_onStopCallback", null);
  }
  dispose() {
    this.stopMonitoring(false);
    this._hooks.dispose();
  }
  stopMonitoring(invokeStopCallback, browserEvent) {
    if (!this.isMonitoring()) {
      return;
    }
    this._hooks.clear();
    this._pointerMoveCallback = null;
    const onStopCallback = this._onStopCallback;
    this._onStopCallback = null;
    if (invokeStopCallback && onStopCallback) {
      onStopCallback(browserEvent);
    }
  }
  isMonitoring() {
    return !!this._pointerMoveCallback;
  }
  startMonitoring(initialElement, pointerId, initialButtons, pointerMoveCallback, onStopCallback) {
    if (this.isMonitoring()) {
      this.stopMonitoring(false);
    }
    this._pointerMoveCallback = pointerMoveCallback;
    this._onStopCallback = onStopCallback;
    let eventSource = initialElement;
    try {
      initialElement.setPointerCapture(pointerId);
      this._hooks.add(
        toDisposable(() => {
          try {
            initialElement.releasePointerCapture(pointerId);
          } catch {
          }
        })
      );
    } catch {
      eventSource = getWindow(initialElement);
    }
    this._hooks.add(
      addDisposableListener(eventSource, EventType$1.POINTER_MOVE, (e2) => {
        if (e2.buttons !== initialButtons) {
          this.stopMonitoring(true);
          return;
        }
        e2.preventDefault();
        this._pointerMoveCallback(e2);
      })
    );
    this._hooks.add(
      addDisposableListener(eventSource, EventType$1.POINTER_UP, () => this.stopMonitoring(true))
    );
  }
}
class ChartMouseEvent extends StandardMouseEvent {
  constructor(e2, chartViewDomNode) {
    super(e2);
    __publicField(this, "localX");
    __publicField(this, "localY");
    const chartPos = getDomNodePagePosition(chartViewDomNode);
    const scaleX = chartPos.width / chartViewDomNode.offsetWidth;
    const scaleY = chartPos.height / chartViewDomNode.offsetHeight;
    this.localX = (e2.clientX - chartPos.left) / scaleX;
    this.localY = (e2.clientY - chartPos.top) / scaleY;
  }
}
class ChartMouseEventFactory {
  constructor(chartViewDomNode) {
    __publicField(this, "_chartViewDomNode");
    this._chartViewDomNode = chartViewDomNode;
  }
  _create(e2) {
    return new ChartMouseEvent(e2, this._chartViewDomNode);
  }
  onContextMenu(target, callback) {
    return addDisposableListener(target, EventType$1.CONTEXT_MENU, (e2) => {
      callback(this._create(e2));
    });
  }
  onMouseUp(target, callback) {
    return addDisposableListener(target, EventType$1.MOUSE_UP, (e2) => {
      callback(this._create(e2));
    });
  }
  onMouseDown(target, callback) {
    return addDisposableListener(target, EventType$1.MOUSE_DOWN, (e2) => {
      callback(this._create(e2));
    });
  }
  onPointerDown(target, callback) {
    return addDisposableListener(target, EventType$1.POINTER_DOWN, (e2) => {
      callback(this._create(e2), e2.pointerId);
    });
  }
  onMouseLeave(target, callback) {
    return addDisposableListener(target, EventType$1.MOUSE_LEAVE, (e2) => {
      callback(this._create(e2));
    });
  }
  onMouseMove(target, callback) {
    return addDisposableListener(target, EventType$1.MOUSE_MOVE, (e2) => callback(this._create(e2)));
  }
}
class ChartPointerEventFactory {
  constructor(editorViewDomNode) {
    __publicField(this, "_chartViewDomNode");
    this._chartViewDomNode = editorViewDomNode;
  }
  _create(e2) {
    return new ChartMouseEvent(e2, this._chartViewDomNode);
  }
  onPointerUp(target, callback) {
    return addDisposableListener(target, "pointerup", (e2) => {
      callback(this._create(e2));
    });
  }
  onPointerDown(target, callback) {
    return addDisposableListener(target, EventType$1.POINTER_DOWN, (e2) => {
      callback(this._create(e2), e2.pointerId);
    });
  }
  onPointerLeave(target, callback) {
    return addDisposableListener(target, EventType$1.POINTER_LEAVE, (e2) => {
      callback(this._create(e2));
    });
  }
  onPointerMove(target, callback) {
    return addDisposableListener(target, "pointermove", (e2) => callback(this._create(e2)));
  }
}
class GlobalChartPointerMoveMonitor extends Disposable {
  constructor(chartViewDomNode) {
    super();
    __publicField(this, "_chartViewDomNode");
    __publicField(this, "_globalPointerMoveMonitor");
    __publicField(this, "_keydownListener");
    this._chartViewDomNode = chartViewDomNode;
    this._globalPointerMoveMonitor = this._register(new GlobalPointerMoveMonitor());
    this._keydownListener = null;
  }
  startMonitoring(initialElement, pointerId, initialButtons, pointerMoveCallback, onStopCallback) {
    this._keydownListener = addStandardDisposableListener(
      initialElement.ownerDocument,
      "keydown",
      (e2) => {
        const chord = e2.toKeyCodeChord();
        if (chord.isModifierKey()) {
          return;
        }
        this._globalPointerMoveMonitor.stopMonitoring(true, e2.browserEvent);
      },
      true
    );
    this._globalPointerMoveMonitor.startMonitoring(
      initialElement,
      pointerId,
      initialButtons,
      (e2) => {
        pointerMoveCallback(new ChartMouseEvent(e2, this._chartViewDomNode));
      },
      (e2) => {
        this._keydownListener.dispose();
        onStopCallback(e2);
      }
    );
  }
  stopMonitoring() {
    this._globalPointerMoveMonitor.stopMonitoring(true);
  }
}
var PartFingerprint = /* @__PURE__ */ ((PartFingerprint2) => {
  PartFingerprint2[PartFingerprint2["None"] = 0] = "None";
  PartFingerprint2[PartFingerprint2["Chart"] = 1] = "Chart";
  PartFingerprint2[PartFingerprint2["Legend"] = 2] = "Legend";
  PartFingerprint2[PartFingerprint2["AxisSetting"] = 3] = "AxisSetting";
  PartFingerprint2[PartFingerprint2["Textarea"] = 4] = "Textarea";
  PartFingerprint2[PartFingerprint2["TimeScaleControl"] = 5] = "TimeScaleControl";
  return PartFingerprint2;
})(PartFingerprint || {});
const AttrName = "data-mprt";
function hasFingerprint(target) {
  return target.hasAttribute(AttrName);
}
class PartFingerprints {
  static write(target, partId) {
    target.setAttribute("data-mprt", String(partId));
  }
  static read(target) {
    const r2 = target.getAttribute("data-mprt");
    if (r2 === null) {
      return 0;
    }
    return parseInt(r2, 10);
  }
  static collect(child2, stopAt) {
    const result = [];
    let resultLen = 0;
    while (child2 && child2 !== child2.ownerDocument.body) {
      if (child2 === stopAt) {
        break;
      }
      if (child2.nodeType === child2.ELEMENT_NODE) {
        const code = this.read(child2);
        if (code) {
          result[resultLen++] = code;
        }
      }
      child2 = child2.parentElement;
    }
    const r2 = new Uint8Array(resultLen);
    for (let i2 = 0; i2 < resultLen; i2++) {
      r2[i2] = result[resultLen - i2 - 1];
    }
    return r2;
  }
}
class MouseTargetFactory {
  constructor(viewHelper) {
    __publicField(this, "_viewHelper");
    this._viewHelper = viewHelper;
  }
  mouseTargetIsWidget(e2) {
    const t2 = e2.target;
    const path = PartFingerprints.collect(t2, this._viewHelper.viewDomNode);
    if (isChildOf(path, PartFingerprint.Legend) || isChildOf(path, PartFingerprint.AxisSetting) || isChildOf(path, PartFingerprint.Textarea)) {
      return true;
    }
    return false;
  }
}
function isChildOf(path, fp) {
  return path.length && path[0] === fp;
}
class MouseHandler extends Disposable {
  constructor(viewController, viewHelper) {
    super();
    __publicField(this, "viewController");
    __publicField(this, "viewHelper");
    __publicField(this, "mouseTargetFactory");
    __publicField(this, "_mouseDownOperation");
    __publicField(this, "lastMouseLeaveTime");
    __publicField(this, "_mouseLeaveMonitor", null);
    this.viewController = viewController;
    this.viewHelper = viewHelper;
    this.mouseTargetFactory = new MouseTargetFactory(viewHelper);
    this._mouseDownOperation = this._register(
      new MouseDownOperation(this.viewController, this.viewHelper)
    );
    this.lastMouseLeaveTime = -1;
    const mouseEvents = new ChartMouseEventFactory(viewHelper.viewDomNode);
    this._register(
      mouseEvents.onContextMenu(this.viewHelper.viewDomNode, (e2) => this._onContextMenu(e2))
    );
    this._register(
      mouseEvents.onMouseMove(this.viewHelper.viewDomNode, (e2) => {
        this._onMouseMove(e2);
        if (!this._mouseLeaveMonitor) {
          this._mouseLeaveMonitor = addDisposableListener(
            this.viewHelper.viewDomNode.ownerDocument,
            "mousemove",
            (e22) => {
              if (!this.viewHelper.viewDomNode.contains(e22.target)) {
                this._onMouseLeave(new ChartMouseEvent(e22, this.viewHelper.viewDomNode));
              }
            }
          );
        }
      })
    );
    this._register(mouseEvents.onMouseUp(this.viewHelper.viewDomNode, (e2) => this._onMouseUp(e2)));
    this._register(
      mouseEvents.onMouseLeave(this.viewHelper.viewDomNode, (e2) => this._onMouseLeave(e2))
    );
    let capturePointerId = 0;
    this._register(
      mouseEvents.onPointerDown(this.viewHelper.viewDomNode, (e2, pointerId) => {
        capturePointerId = pointerId;
      })
    );
    this._register(
      addDisposableListener(this.viewHelper.viewDomNode, EventType$1.POINTER_UP, () => {
        this._mouseDownOperation.onPointerUp();
      })
    );
    this._register(
      mouseEvents.onMouseDown(
        this.viewHelper.viewDomNode,
        (e2) => this._onMouseDown(e2, capturePointerId)
      )
    );
    this._register(
      addStandardDisposableListener(
        this.viewHelper.viewDomNode,
        EventType$1.KEY_DOWN,
        this._onKeyDown.bind(this)
      )
    );
    this._register(
      addStandardDisposableListener(
        this.viewHelper.viewDomNode,
        EventType$1.KEY_UP,
        this._onKeyUp.bind(this)
      )
    );
  }
  isMouseDownOperating() {
    return this._mouseDownOperation.isActive();
  }
  _onContextMenu(e2) {
    e2.preventDefault();
    this.viewController.emitContextMenu(
      createMouseEvent(EventType$1.CONTEXT_MENU, e2, this.viewHelper.chartService)
    );
  }
  _onMouseMove(e2) {
    if (this._mouseDownOperation.isActive()) {
      return;
    }
    const actualMouseMoveTime = e2.timestamp;
    if (actualMouseMoveTime < this.lastMouseLeaveTime) {
      return;
    }
    this.viewController.emitMouseMove(
      createMouseEvent(EventType$1.MOUSE_MOVE, e2, this.viewHelper.chartService)
    );
  }
  _onMouseLeave(e2) {
    if (this._mouseLeaveMonitor) {
      this._mouseLeaveMonitor.dispose();
      this._mouseLeaveMonitor = null;
    }
    this.lastMouseLeaveTime = e2.timestamp;
    this.viewController.emitMouseLeave(
      createMouseEvent(EventType$1.MOUSE_LEAVE, e2, this.viewHelper.chartService)
    );
  }
  _onMouseUp(e2) {
    this.viewController.emitMouseUp(
      createMouseEvent(EventType$1.MOUSE_UP, e2, this.viewHelper.chartService)
    );
  }
  _onMouseDown(e2, pointerId) {
    if (!this.mouseTargetFactory.mouseTargetIsWidget(e2)) {
      this.viewController.emitMouseDown(
        createMouseEvent(EventType$1.MOUSE_DOWN, e2, this.viewHelper.chartService)
      );
      this._mouseDownOperation.start(e2, pointerId);
    }
  }
  _createKeyboardEvent(type, e2) {
    return new KeyboardInputEvent(type, e2, this.viewHelper.chartService);
  }
  _onKeyDown(e2) {
    this.viewController.emitKeyDown(this._createKeyboardEvent(EventType$1.KEY_DOWN, e2));
  }
  _onKeyUp(e2) {
    this.viewController.emitKeyUp(this._createKeyboardEvent(EventType$1.KEY_UP, e2));
  }
}
class MouseDownOperation extends Disposable {
  constructor(viewController, viewHelper) {
    super();
    __publicField(this, "_viewController");
    __publicField(this, "_viewHelper");
    __publicField(this, "_mouseMoveMonitor");
    __publicField(this, "_mouseState");
    __publicField(this, "_isActive");
    __publicField(this, "_lastMouseEvent");
    this._viewController = viewController;
    this._viewHelper = viewHelper;
    this._mouseMoveMonitor = this._register(
      new GlobalChartPointerMoveMonitor(viewHelper.viewDomNode)
    );
    this._mouseState = new MouseDownState();
    this._isActive = false;
    this._lastMouseEvent = null;
  }
  isActive() {
    return this._isActive;
  }
  _onMouseDownThenMove(e2) {
    this._lastMouseEvent = e2;
    this._mouseState.setModifiers(e2);
    if (this._mouseState.isDragAndDrop) {
      this._viewController.emitMouseDrag(
        createMouseEvent(EventType$1.DRAG, e2, this._viewHelper.chartService)
      );
    } else {
      NOTREACHED();
    }
  }
  start(e2, pointerId) {
    this._lastMouseEvent = e2;
    this._mouseState.setStartButtons(e2);
    this._mouseState.setModifiers(e2);
    this._mouseState.trySetCount(e2.detail, { x: e2.posx, y: e2.posy });
    e2.detail = this._mouseState.count;
    if (!this._mouseState.altKey && // we don't support multiple mouse
    e2.detail < 2 && // only single click on a selection can work
    !this._isActive) {
      this._mouseState.isDragAndDrop = true;
      this._isActive = true;
      this._viewController.emitMouseDragStart(
        createMouseEvent(EventType$1.DRAG_START, e2, this._viewHelper.chartService)
      );
      this._mouseMoveMonitor.startMonitoring(
        this._viewHelper.viewDomNode,
        pointerId,
        e2.buttons,
        (e22) => this._onMouseDownThenMove(e22),
        (browserEvent) => {
          if (isKeyboardEvent(browserEvent)) {
            this._viewController.emitMouseDropCanceled(
              createMouseEvent(
                EventType$1.DRAG_END,
                ensure(this._lastMouseEvent),
                this._viewHelper.chartService
              )
            );
          } else {
            this._viewController.emitMouseDrop(
              createMouseEvent(
                EventType$1.DROP,
                ensure(this._lastMouseEvent),
                this._viewHelper.chartService
              )
            );
          }
          this._stop();
        }
      );
    }
  }
  _stop() {
    this._isActive = false;
  }
  onPointerUp() {
    this._mouseMoveMonitor.stopMonitoring();
  }
}
const _MouseDownState = class _MouseDownState {
  constructor() {
    // ms
    __publicField(this, "_altKey");
    __publicField(this, "_ctrlKey");
    __publicField(this, "_metaKey");
    __publicField(this, "_shiftKey");
    __publicField(this, "_leftButton");
    __publicField(this, "_middleButton");
    __publicField(this, "_lastMouseDownPosition");
    __publicField(this, "_lastMouseDownPositionEqualCount");
    __publicField(this, "_lastMouseDownCount");
    __publicField(this, "_lastSetMouseDownCountTime");
    __publicField(this, "isDragAndDrop");
    this._altKey = false;
    this._ctrlKey = false;
    this._metaKey = false;
    this._shiftKey = false;
    this._leftButton = false;
    this._middleButton = false;
    this._lastMouseDownPosition = null;
    this._lastMouseDownPositionEqualCount = 0;
    this._lastMouseDownCount = 0;
    this._lastSetMouseDownCountTime = 0;
    this.isDragAndDrop = false;
  }
  get altKey() {
    return this._altKey;
  }
  get ctrlKey() {
    return this._ctrlKey;
  }
  get metaKey() {
    return this._metaKey;
  }
  get shiftKey() {
    return this._shiftKey;
  }
  get leftButton() {
    return this._leftButton;
  }
  get middleButton() {
    return this._middleButton;
  }
  get count() {
    return this._lastMouseDownCount;
  }
  setModifiers(source2) {
    this._altKey = source2.altKey;
    this._ctrlKey = source2.ctrlKey;
    this._metaKey = source2.metaKey;
    this._shiftKey = source2.shiftKey;
  }
  setStartButtons(source2) {
    this._leftButton = source2.leftButton;
    this._middleButton = source2.middleButton;
  }
  trySetCount(setMouseDownCount, newMouseDownPosition) {
    const currentTime = (/* @__PURE__ */ new Date()).getTime();
    if (currentTime - this._lastSetMouseDownCountTime > _MouseDownState.CLEAR_MOUSE_DOWN_COUNT_TIME) {
      setMouseDownCount = 1;
    }
    this._lastSetMouseDownCountTime = currentTime;
    if (setMouseDownCount > this._lastMouseDownCount + 1) {
      setMouseDownCount = this._lastMouseDownCount + 1;
    }
    if (this._lastMouseDownPosition && isEqual(this._lastMouseDownPosition.x, newMouseDownPosition)) {
      this._lastMouseDownPositionEqualCount++;
    } else {
      this._lastMouseDownPositionEqualCount = 1;
    }
    this._lastMouseDownPosition = newMouseDownPosition;
    this._lastMouseDownCount = Math.min(setMouseDownCount, this._lastMouseDownPositionEqualCount);
  }
};
__publicField(_MouseDownState, "CLEAR_MOUSE_DOWN_COUNT_TIME", 400);
let MouseDownState = _MouseDownState;
class PointerEventHandler extends MouseHandler {
  constructor(viewController, viewHelper) {
    super(viewController, viewHelper);
    __publicField(this, "_lastPointerType");
    this._register(Gesture.addTarget(this.viewHelper.viewDomNode));
    this._register(
      addDisposableListener(this.viewHelper.viewDomNode, EventType.Tap, (e2) => this.onTap(e2))
    );
    this._register(
      addDisposableListener(this.viewHelper.viewDomNode, EventType.Change, (e2) => this.onChange(e2))
    );
    this._register(
      addDisposableListener(
        this.viewHelper.viewDomNode,
        EventType.Contextmenu,
        (e2) => this._onContextMenu(new ChartMouseEvent(e2, viewHelper.viewDomNode))
      )
    );
    this._lastPointerType = "mouse";
    this._register(
      addDisposableListener(this.viewHelper.viewDomNode, "pointerdown", (e2) => {
        const pointerType = e2.pointerType;
        if (pointerType === "mouse") {
          this._lastPointerType = "mouse";
          return;
        } else if (pointerType === "touch") {
          this._lastPointerType = "touch";
        } else {
          this._lastPointerType = "pen";
        }
      })
    );
    const pointerEvents = new ChartPointerEventFactory(viewHelper.viewDomNode);
    this._register(
      pointerEvents.onPointerUp(this.viewHelper.viewDomNode, (e2) => this._onMouseUp(e2))
    );
    this._register(
      pointerEvents.onPointerLeave(this.viewHelper.viewDomNode, (e2) => this._onMouseLeave(e2))
    );
    this._register(
      pointerEvents.onPointerDown(
        this.viewHelper.viewDomNode,
        (e2, pointerId) => this._onMouseDown(e2, pointerId)
      )
    );
  }
  onTap(event2) {
    if (!event2.initialTarget || !this.viewHelper.viewDomNode.contains(event2.initialTarget)) {
      return;
    }
    event2.preventDefault();
    this._dispatchGesture(
      event2,
      /*inSelectionMode*/
      false
    );
  }
  onChange(event2) {
    if (this._lastPointerType === "pen") {
      this._dispatchGesture(
        event2,
        /*inSelectionMode*/
        true
      );
    }
  }
  _dispatchGesture(event2, inSelectionMode) {
    console.warn("gesture evnt", event2, inSelectionMode);
  }
  _onMouseDown(e2, pointerId) {
    if (e2.browserEvent.pointerType === "touch") {
      return;
    }
    super._onMouseDown(e2, pointerId);
  }
}
class TouchHandler extends MouseHandler {
  constructor(viewController, viewHelper) {
    super(viewController, viewHelper);
    this._register(Gesture.addTarget(this.viewHelper.viewDomNode));
    this._register(
      addDisposableListener(this.viewHelper.viewDomNode, EventType.Tap, (e2) => this.onTap(e2))
    );
    this._register(
      addDisposableListener(this.viewHelper.viewDomNode, EventType.Change, (e2) => this.onChange(e2))
    );
    this._register(
      addDisposableListener(
        this.viewHelper.viewDomNode,
        EventType.Contextmenu,
        (e2) => this._onContextMenu(new ChartMouseEvent(e2, this.viewHelper.viewDomNode))
      )
    );
  }
  onTap(event2) {
    event2.preventDefault();
    console.warn("tag", event2);
  }
  onChange(e2) {
    console.warn("change", e2);
  }
}
class PointerHandler extends Disposable {
  constructor(viewController, viewHelper) {
    super();
    __publicField(this, "_mouseHandler");
    const isPhone = isIOS || isAndroid && isMobile;
    if (isPhone && BrowserFeatures.pointerEvents) {
      this._register(new PointerEventHandler(viewController, viewHelper));
    } else if (window.TouchEvent) {
      this._register(this._mouseHandler = new TouchHandler(viewController, viewHelper));
    } else {
      this._register(this._mouseHandler = new MouseHandler(viewController, viewHelper));
    }
  }
  isMouseDownOperating() {
    var _a3;
    return !!((_a3 = this._mouseHandler) == null ? void 0 : _a3.isMouseDownOperating());
  }
}
class ViewController {
  constructor(userInputEvents) {
    __publicField(this, "userInputEvents");
    this.userInputEvents = userInputEvents;
  }
  emitKeyDown(e2) {
    this.userInputEvents.emitKeyDown(e2);
  }
  emitKeyUp(e2) {
    this.userInputEvents.emitKeyUp(e2);
  }
  emitContextMenu(e2) {
    this.userInputEvents.emitContextMenu(e2);
  }
  emitMouseMove(e2) {
    this.userInputEvents.emitMouseMove(e2);
  }
  emitMouseLeave(e2) {
    this.userInputEvents.emitMouseLeave(e2);
  }
  emitMouseUp(e2) {
    this.userInputEvents.emitMouseUp(e2);
  }
  emitMouseDown(e2) {
    this.userInputEvents.emitMouseDown(e2);
  }
  emitMouseDrag(e2) {
    this.userInputEvents.emitMouseDrag(e2);
  }
  emitMouseDragStart(e2) {
    this.userInputEvents.emitMouseDragStart(e2);
  }
  emitMouseDrop(e2) {
    this.userInputEvents.emitMouseDrop(e2);
  }
  emitMouseDropCanceled(e2) {
    this.userInputEvents.emitMouseDropCanceled(e2);
  }
}
class ViewUserInputEvents {
  constructor() {
    __publicField(this, "onKeyDown", null);
    __publicField(this, "onKeyUp", null);
    __publicField(this, "onContextMenu", null);
    __publicField(this, "onMouseMove", null);
    __publicField(this, "onMouseLeave", null);
    __publicField(this, "onMouseDown", null);
    __publicField(this, "onMouseUp", null);
    __publicField(this, "onMouseDrag", null);
    __publicField(this, "onMouseDragStart", null);
    __publicField(this, "onMouseDrop", null);
    __publicField(this, "onMouseDropCanceled", null);
  }
  emitKeyDown(e2) {
    var _a3;
    (_a3 = this.onKeyDown) == null ? void 0 : _a3.call(this, e2);
  }
  emitKeyUp(e2) {
    var _a3;
    (_a3 = this.onKeyUp) == null ? void 0 : _a3.call(this, e2);
  }
  emitContextMenu(e2) {
    var _a3;
    (_a3 = this.onContextMenu) == null ? void 0 : _a3.call(this, e2);
  }
  emitMouseMove(e2) {
    var _a3;
    (_a3 = this.onMouseMove) == null ? void 0 : _a3.call(this, e2);
  }
  emitMouseLeave(e2) {
    var _a3;
    (_a3 = this.onMouseLeave) == null ? void 0 : _a3.call(this, e2);
  }
  emitMouseDown(e2) {
    var _a3;
    (_a3 = this.onMouseDown) == null ? void 0 : _a3.call(this, e2);
  }
  emitMouseUp(e2) {
    var _a3;
    (_a3 = this.onMouseUp) == null ? void 0 : _a3.call(this, e2);
  }
  emitMouseDrag(e2) {
    var _a3;
    (_a3 = this.onMouseDrag) == null ? void 0 : _a3.call(this, e2);
  }
  emitMouseDragStart(e2) {
    var _a3;
    (_a3 = this.onMouseDragStart) == null ? void 0 : _a3.call(this, e2);
  }
  emitMouseDrop(e2) {
    var _a3;
    (_a3 = this.onMouseDrop) == null ? void 0 : _a3.call(this, e2);
  }
  emitMouseDropCanceled(e2) {
    var _a3;
    (_a3 = this.onMouseDropCanceled) == null ? void 0 : _a3.call(this, e2);
  }
}
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$a = Object.getOwnPropertyDescriptor;
var __decorateClass$a = (decorators, target, key2, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$a(target, key2) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
  if (kind && result) __defProp$1(target, key2, result);
  return result;
};
var __decorateParam$a = (index2, decorator) => (target, key2) => decorator(target, key2, index2);
class InteractionEmitter extends Emitter {
  constructor(deliveryQueue) {
    super({ deliveryQueue });
  }
  fire(event2) {
    super.fire(event2);
  }
}
let ChartWidget = class extends Disposable {
  constructor(index2, _container, chartStore, _cursorHandler, serialized, configurationService, chartManagementService, instantiationService, contextKeyService, i18nService, undoRedoService, themeService, chartContributionRegistry, chartResolutionRegistry, studyService) {
    super();
    __publicField(this, "_serviceBrand");
    __publicField(this, "id", generateUuid());
    __publicField(this, "_chartStore");
    __publicField(this, "_size");
    __publicField(this, "chartApi");
    __publicField(this, "_timezoneApi");
    __publicField(this, "_chartModel");
    __publicField(this, "_chartController");
    __publicField(this, "_pointerHandler");
    __publicField(this, "_paneCursorScope");
    __publicField(this, "_paneDragCursorScope");
    __publicField(this, "mainSeriesApi");
    __publicField(this, "_dataSources", /* @__PURE__ */ new Map());
    __publicField(this, "_study", /* @__PURE__ */ new Map());
    __publicField(this, "_zoomStack", new ZoomStack(
      (viewport) => {
        this._chartStore.zoomToViewport(viewport);
      },
      () => this._chartStore.zoomFromViewport()
    ));
    __publicField(this, "_instantiationService");
    __publicField(this, "_deliveryQueue", createEventDeliveryQueue());
    __publicField(this, "_contributions", this._register(new ChartContributions()));
    __publicField(this, "eventFilter");
    __publicField(this, "_onMouseUp", this._register(
      new InteractionEmitter(this._deliveryQueue)
    ));
    __publicField(this, "onMouseUp", this._onMouseUp.event);
    __publicField(this, "_onMouseDown", this._register(
      new InteractionEmitter(this._deliveryQueue)
    ));
    __publicField(this, "onMouseDown", this._onMouseDown.event);
    __publicField(this, "_onMouseDragStart", this._register(
      new InteractionEmitter(this._deliveryQueue)
    ));
    __publicField(this, "onMouseDragStart", this._onMouseDragStart.event);
    __publicField(this, "_onMouseDrag", this._register(
      new InteractionEmitter(this._deliveryQueue)
    ));
    __publicField(this, "onMouseDrag", this._onMouseDrag.event);
    __publicField(this, "_onMouseDrop", this._register(
      new InteractionEmitter(this._deliveryQueue)
    ));
    __publicField(this, "onMouseDrop", this._onMouseDrop.event);
    __publicField(this, "_onMouseDropCanceled", this._register(
      new InteractionEmitter(this._deliveryQueue)
    ));
    __publicField(this, "onMouseDropCanceled", this._onMouseDropCanceled.event);
    __publicField(this, "_onContextMenu", this._register(
      new InteractionEmitter(this._deliveryQueue)
    ));
    __publicField(this, "onContextMenu", this._onContextMenu.event);
    __publicField(this, "_onMouseMove", this._register(
      new InteractionEmitter(this._deliveryQueue)
    ));
    __publicField(this, "onMouseMove", this._onMouseMove.event);
    __publicField(this, "_onMouseLeave", this._register(
      new InteractionEmitter(this._deliveryQueue)
    ));
    __publicField(this, "onMouseLeave", this._onMouseLeave.event);
    __publicField(this, "_onKeyUp", this._register(
      new InteractionEmitter(this._deliveryQueue)
    ));
    __publicField(this, "onKeyUp", this._onKeyUp.event);
    __publicField(this, "_onKeyDown", this._register(
      new InteractionEmitter(this._deliveryQueue)
    ));
    __publicField(this, "onKeyDown", this._onKeyDown.event);
    __publicField(this, "_onClick", this._register(
      new InteractionEmitter(this._deliveryQueue)
    ));
    __publicField(this, "onClick", this._onClick.event);
    __publicField(this, "_onCrosshairMove", this._register(
      new InteractionEmitter(this._deliveryQueue)
    ));
    __publicField(this, "onCrosshairMove", this._onCrosshairMove.event);
    __publicField(this, "_onDataLoaded", this._register(new Emitter()));
    __publicField(this, "onDataLoaded", this._onDataLoaded.event);
    __publicField(this, "_onSymbolChanged", this._register(new Emitter()));
    __publicField(this, "onSymbolChanged", this._onSymbolChanged.event);
    __publicField(this, "_onChartFocus", this._register(new Emitter()));
    __publicField(this, "onChartFocus", this._onChartFocus.event);
    __publicField(this, "_onChartBlur", this._register(new Emitter()));
    __publicField(this, "onChartBlur", this._onChartBlur.event);
    __publicField(this, "_onDrawingsVisibility", this._register(new Emitter()));
    __publicField(this, "onDrawingsVisibility", this._onDrawingsVisibility.event);
    __publicField(this, "_onPositionsAndOrdersVisibility", this._register(new Emitter()));
    __publicField(this, "onPositionsAndOrdersVisibility", this._onPositionsAndOrdersVisibility.event);
    __publicField(this, "formatTickMark", (time, tickMarkType, locale) => {
      const formatOptions = {};
      switch (tickMarkType) {
        case Ni.Year:
          formatOptions.year = "numeric";
          break;
        case Ni.Month:
          formatOptions.month = "short";
          break;
        case Ni.DayOfMonth:
          formatOptions.day = "numeric";
          break;
        case Ni.Time:
          formatOptions.hour12 = false;
          formatOptions.hour = "2-digit";
          formatOptions.minute = "2-digit";
          break;
        case Ni.TimeWithSeconds:
          formatOptions.hour12 = false;
          formatOptions.hour = "2-digit";
          formatOptions.minute = "2-digit";
          formatOptions.second = "2-digit";
          break;
        default:
          NOTREACHED();
      }
      const date = Wi(time) ? new Date(time.year, time.month, time.day) : isString$1(time) ? new Date(time) : new Date(time * 1e3);
      const tz = this.getTimezoneApi().getTimezoneId();
      const localDate = toZonedTime(date, tz);
      return localDate.toLocaleString(locale, formatOptions);
    });
    __publicField(this, "mouseInsideChart", false);
    __publicField(this, "_cachedVolumeId", null);
    this.index = index2;
    this._container = _container;
    this._cursorHandler = _cursorHandler;
    this.configurationService = configurationService;
    this.chartManagementService = chartManagementService;
    this.i18nService = i18nService;
    this.undoRedoService = undoRedoService;
    this.themeService = themeService;
    this.studyService = studyService;
    this._instantiationService = instantiationService.createChild(
      new ServiceCollection(
        [IContextKeyService, this._register(contextKeyService.createScoped(this._container))],
        [IChartService, this],
        [IChartGuiService, this._register(new ChartGuiService())]
      )
    );
    this._chartStore = createChartStoreHandler(chartStore);
    this._chartModel = new ChartModel(this, themeService);
    this._chartController = this._instantiationService.createInstance(ChartController);
    this._size = { width: _container.clientWidth, height: _container.clientHeight };
    this.chartApi = qn(this._container, {
      width: this._size.width,
      height: this._size.height,
      autoSize: false,
      layout: {
        attributionLogo: false,
        panes: {
          enableResize: true
        }
      },
      crosshair: {
        mode: K.Normal
      },
      timeScale: {
        timeVisible: true,
        secondsVisible: false,
        borderVisible: false,
        barSpacing: (serialized == null ? void 0 : serialized.timeScale.barSpacing) ?? defaultBarSpacing,
        rightOffset: defaultRightOffset,
        extendedScale: {
          getExtendedTime: (baseTime, offsetCount) => {
            const resInfo = ensure(chartResolutionRegistry.value(this.resolution()));
            const tz = this.getTimezoneApi().getTimezoneId();
            return getFutureTime(
              tz,
              ensure(this.mainSeriesApi.getSessionsSpec()),
              baseTime,
              offsetCount,
              resInfo
            );
          },
          getAdvanceUnit: (fromTime, toTime) => {
            const delta = toTime - fromTime;
            const resInfo = ensure(chartResolutionRegistry.value(this.resolution()));
            return delta / (resInfo.value * getSecondsOfResolutionUnit(resInfo.unit));
          }
        },
        tickMarkFormatter: this.formatTickMark
      },
      rightPriceScale: {
        visible: true,
        borderVisible: false,
        mode: (serialized == null ? void 0 : serialized.rightPriceScale.mode) ?? vi.Normal,
        scaleMargins: {
          top: 0.1,
          bottom: 0.08
        }
      },
      localization: {
        locale: i18nService.locale,
        priceFormatter: (price) => {
          return this.mainSeriesApi.priceFormatter().format(price);
        },
        timeFormatter: (time) => this.formatDateTime(time)
      },
      preventLeave: () => {
        return this._pointerHandler.isMouseDownOperating();
      }
    });
    this._spyChartOptionsSetter();
    this._onChartStyleChanged(serialized == null ? void 0 : serialized.overrides);
    this._register(
      this.getTimezoneApi().onTimezoneChanged(() => {
        const { localization } = this.chartApi.options();
        this.chartApi.applyOptions({
          localization
        });
      })
    );
    let serializedMainSeries = void 0;
    if (serialized) {
      for (const pane of serialized.panes) {
        for (const source2 of pane.sources) {
          if (source2.type === SourceType.Main) {
            serializedMainSeries = source2;
          }
        }
      }
    }
    this._register(
      this.mainSeriesApi = this._instantiationService.createInstance(
        ChartMainSeriesApi,
        this._createDataSourceContext(),
        serializedMainSeries
      )
    );
    this._chartController.onSeriesCreated(this.mainSeriesApi.id, this.mainSeriesApi);
    this._dataSources.set(this.symbol(), this.mainSeriesApi);
    this._registerListeners();
    const viewUserInputEvents = new ViewUserInputEvents();
    viewUserInputEvents.onKeyDown = (e2) => {
      if (this._passToEventFilter(e2)) return;
      this._onKeyDown.fire(e2);
    };
    viewUserInputEvents.onKeyUp = (e2) => {
      if (this._passToEventFilter(e2)) return;
      this._onKeyUp.fire(e2);
    };
    viewUserInputEvents.onContextMenu = (e2) => {
      if (this._passToEventFilter(e2)) return;
      this._onContextMenu.fire(e2);
    };
    viewUserInputEvents.onMouseMove = (e2) => {
      if (this._passToEventFilter(e2)) return;
      this._onMouseMove.fire(e2);
    };
    viewUserInputEvents.onMouseLeave = (e2) => {
      if (this._passToEventFilter(e2)) return;
      this._onMouseLeave.fire(e2);
    };
    viewUserInputEvents.onMouseDown = (e2) => {
      if (this._passToEventFilter(e2)) return;
      this._onMouseDown.fire(e2);
    };
    viewUserInputEvents.onMouseUp = (e2) => {
      if (this._passToEventFilter(e2)) return;
      this._onMouseUp.fire(e2);
    };
    viewUserInputEvents.onMouseDragStart = (e2) => {
      this._paneDragCursorScope = new CursorScope(this._cursorHandler.getPaneCursor());
      if (this._passToEventFilter(e2)) return;
      this._onMouseDragStart.fire(e2);
    };
    viewUserInputEvents.onMouseDrag = (e2) => {
      if (this._passToEventFilter(e2)) return;
      this._onMouseDrag.fire(e2);
    };
    viewUserInputEvents.onMouseDrop = (e2) => {
      if (!this._passToEventFilter(e2)) this._onMouseDrop.fire(e2);
      this._paneDragCursorScope = void 0;
    };
    viewUserInputEvents.onMouseDropCanceled = (e2) => {
      if (!this._passToEventFilter(e2)) this._onMouseDropCanceled.fire();
      this._paneDragCursorScope = void 0;
    };
    const controller = new ViewController(viewUserInputEvents);
    this._register(
      this._pointerHandler = new PointerHandler(controller, {
        viewDomNode: this._container,
        chartService: this
      })
    );
    this._contributions.initialize(
      chartContributionRegistry.getContributions(),
      this._instantiationService
    );
    this._register(
      this.mainSeriesApi.onDataLoaded(() => {
        this._onDataLoaded.fire();
        if (serialized) {
          this._loadStudies(serialized);
        } else {
          this._createVolumeIfNeeded();
        }
      })
    );
  }
  startup() {
  }
  getModel() {
    return this._chartModel;
  }
  getController() {
    return this._chartController;
  }
  _onChartStyleChanged(serializedOverrides) {
    const all = this.configurationService.getValue("chartProperties");
    const overrides = {
      layout: all.layout ?? /* @__PURE__ */ Object.create(null),
      grid: all.grid ?? /* @__PURE__ */ Object.create(null)
    };
    const themed = this.themeService.isDark() ? chartConfigDark : chartConfigLight;
    const merged = merge(
      cloneDeep(themed),
      cloneDeep(overrides),
      serializedOverrides ? unflatten(serializedOverrides) : {}
    );
    this.chartApi.applyOptions(merged);
  }
  installEventFilter(filter2) {
    this.eventFilter = filter2;
  }
  getTimezoneApi() {
    if (!this._timezoneApi) {
      this._register(
        this._timezoneApi = this._instantiationService.createInstance(
          ChartTimeZoneApi,
          this._chartStore
        )
      );
    }
    return this._timezoneApi;
  }
  getContainerDomElement() {
    return this._container;
  }
  getChartSize() {
    return this._size;
  }
  getTimeScale() {
    return this.chartApi.timeScale();
  }
  getPriceScale() {
    return this.mainSeriesApi.getSeries().priceScale();
  }
  getStore() {
    return this._chartStore.getStore();
  }
  getPane(paneIndex) {
    return this.chartApi.panes().find((p2) => p2.paneIndex() === paneIndex) ?? null;
  }
  getPaneSeries(paneIndex, seriesIndex = 0) {
    const pane = this.getPane(paneIndex);
    if (!pane) return null;
    return pane.getSeries()[seriesIndex] ?? null;
  }
  getStoreHandler() {
    return this._chartStore;
  }
  symbolInfo() {
    return this._chartStore.get("symbolInfo");
  }
  interval() {
    return Interval$1.parse(this._chartStore.get("resolution"));
  }
  focus() {
    this._container.focus();
    this._onChartFocus.fire();
  }
  blur() {
    this._container.blur();
    this._onChartBlur.fire();
  }
  formatDateTime(time) {
    if (typeof time == "string") return time;
    const date = Wi(time) ? new Date(time.year, time.month, time.day) : new Date(time * 1e3);
    const tz = this.getTimezoneApi().getTimezoneId();
    return formatInTimeZone(date, tz, this._dateTimeFormat());
  }
  formatDate(time) {
    if (typeof time == "string") return time;
    const date = time instanceof Date ? time : Wi(time) ? new Date(time.year, time.month, time.day) : new Date(time * 1e3);
    const tz = this.getTimezoneApi().getTimezoneId();
    return formatInTimeZone(date, tz, this._dateFormat());
  }
  _dateTimeFormat() {
    return this.i18nService.dateTimeFormat(false);
  }
  _dateFormat() {
    return this.i18nService.dateFormat();
  }
  _passToEventFilter(e2) {
    if (this.eventFilter) {
      this.eventFilter.eventFilter(e2);
      return e2.isAccepted();
    }
    return false;
  }
  _registerListeners() {
    const handleCrosshairMove = (params) => {
      const evt = createChartInputEvent(InputEventType.MOUSE_MOVE, params, this);
      this._withCursorScope(() => {
        if (!this._passToEventFilter(evt)) {
          this._onCrosshairMove.fire(evt);
        }
      });
      this._updateLegend(params);
    };
    const handleClick = (params) => {
      const evt = createChartInputEvent(InputEventType.CLICK, params, this);
      this._withCursorScope(() => {
        if (!this._passToEventFilter(evt)) {
          this._onClick.fire(evt);
        }
      });
    };
    this.chartApi.subscribeCrosshairMove(handleCrosshairMove);
    this.chartApi.subscribeClick(handleClick);
    this._register(
      toDisposable(() => {
        this.chartApi.unsubscribeCrosshairMove(handleCrosshairMove);
        this.chartApi.unsubscribeClick(handleClick);
        this.chartApi.remove();
      })
    );
    this._register(
      this.onMouseDown(() => {
        if (this.chartManagementService.activeChart() !== this) {
          this.chartManagementService.setActiveChart(this);
        }
      })
    );
    this._register(
      this.themeService.onDidColorThemeChange(() => {
        this._onChartStyleChanged();
      })
    );
    this._register(
      watch(
        this.configurationService.store,
        (store) => store.chartProperties,
        () => {
          this._onChartStyleChanged();
        }
      )
    );
    this.mainSeriesApi.onDataChanged(() => {
      this._updateLegend();
    });
  }
  _withCursorScope(dispatch2) {
    this._paneCursorScope = new CursorScope(
      this._cursorHandler.getPaneCursor(),
      this._paneDragCursorScope
    );
    dispatch2();
    if (!this._paneCursorScope.touched()) {
      this._cursorHandler.setPaneCursor(this._paneCursorScope.initValue);
    }
  }
  _updateLegend(param) {
    if (param) {
      this.mouseInsideChart = !!param.point;
    } else {
      if (this.mouseInsideChart) return;
    }
    this.mainSeriesApi.updateLegend(param);
    this._study.values().forEach((study) => study.updateLegend(param));
  }
  _createDataSourceContext() {
    return {
      countBack: () => {
        return Math.ceil(this._size.width / defaultBarSpacing) + 100;
      }
    };
  }
  _getOrCreateDataSource(symbol) {
    if (symbol === this.symbol()) return this.mainSeriesApi;
    let ds2 = this._dataSources.get(symbol);
    if (!ds2) {
      ds2 = this._instantiationService.createInstance(
        StudyDataSource,
        symbol,
        this.resolution(),
        this._createDataSourceContext(),
        this.chartApi
      );
      this._dataSources.set(symbol, ds2);
    }
    return ds2;
  }
  _removeDataSource(symbol) {
    if (symbol === this.symbol()) return;
    const ds2 = this._dataSources.get(symbol);
    if (ds2) {
      ds2.dispose();
    }
    this._dataSources.delete(symbol);
  }
  _spyChartOptionsSetter() {
    const origin = this.chartApi.applyOptions;
    this.chartApi.applyOptions = (arg) => {
      origin.call(this.chartApi, arg);
      this._chartStore.set("chartOptions", this.chartApi.options());
    };
  }
  autoResize() {
    const rect = {
      width: this._container.clientWidth,
      height: this._container.clientHeight
    };
    if (isSizeEqual(rect, this._size)) return;
    this._size.width = rect.width;
    this._size.height = rect.height;
    this.chartApi.resize(rect.width, rect.height, true);
  }
  addCompareSymbol(symbol) {
    const rightPriceScale = this.chartApi.priceScale("right");
    if (rightPriceScale.options().mode !== vi.Percentage) {
      rightPriceScale.applyOptions({
        mode: vi.Percentage
      });
    }
    const ds2 = this._getOrCreateDataSource(symbol);
    ds2.loadAll(async (symbolInfo) => {
      const compare = this._instantiationService.createInstance(ChartCompare, symbolInfo, ds2);
      this._study.set(compare.id, compare);
      await compare.paneReady();
      this._chartStore.addStudy({
        id: compare.id,
        title: symbolInfo.name,
        overlap: true,
        compare: true,
        styleValues: compare.getStyleValues()
      });
    });
  }
  chartType() {
    return this.mainSeriesApi.chartType();
  }
  showPaneCursor(cursor) {
    var _a3, _b3;
    (_a3 = this._paneDragCursorScope) == null ? void 0 : _a3.touch(cursor);
    (_b3 = this._paneCursorScope) == null ? void 0 : _b3.touch(cursor);
    this._cursorHandler.setPaneCursor(cursor);
  }
  setChartType(type, cb, force) {
    return this.mainSeriesApi.setChartType(type, cb, force);
  }
  resolution() {
    return this.mainSeriesApi.resolution();
  }
  setResolution(resolution) {
    return this.mainSeriesApi.setResolution(resolution);
  }
  symbol() {
    return this.mainSeriesApi.symbol();
  }
  setSymbol(symbol) {
    this._onSymbolChanged.fire();
    return this.mainSeriesApi.setSymbol(symbol);
  }
  async createShape(point, options) {
    return this._chartController.createShape(
      {
        price: point.price,
        time: point.time / 1e3
      },
      options
    );
  }
  async createStudy(name, inputs, overrides) {
    let study;
    let studyInfo;
    if (name === "volume") {
      const vol = this._instantiationService.createInstance(ChartVolume, this.mainSeriesApi);
      study = vol;
      studyInfo = vol.studyInfo;
    } else {
      studyInfo = studyRegistry.value(name);
      if (!studyInfo) {
        console.warn(`Study ${name} not found`);
        return null;
      }
      studyInfo = merge(cloneDeep(studyInfo), {
        styleValues: { styles: unflatten(overrides) },
        inputs: studyInfo.optionInfos.reduce(
          (acc, i2) => {
            acc[i2.name] = i2.defaultValue;
            return acc;
          },
          {}
        )
      });
      study = this._instantiationService.createInstance(ChartStudy, studyInfo, this.mainSeriesApi);
    }
    should(studyInfo);
    this._study.set(study.id, study);
    await study.paneReady();
    this._chartStore.addStudy({
      id: study.id,
      title: studyInfo.abbr,
      overlap: studyInfo.overlap,
      compare: false,
      inputs: studyInfo.inputs,
      styleValues: studyInfo.styleValues
    });
    study.loadData();
    return study.id;
  }
  _loadStudies(serialized) {
    serialized.panes.forEach((pane) => {
      pane.sources.forEach((s2) => {
        if (s2.type === SourceType.Study) {
          this.createStudy(s2.name, s2.state.inputs, s2.state.styles);
        }
      });
    });
  }
  async _createVolumeIfNeeded() {
    if (!this.configurationService.featureEnabled("create_volume_indicator_by_default")) return;
    if (this._cachedVolumeId) return;
    if (!hasVolume(this.symbolInfo())) return;
    const bars = this.mainSeriesApi.data();
    const bar = bars[0];
    if (!isUndefined(bar.customValues.volume)) {
      this._cachedVolumeId = await this.createStudy("volume");
    }
  }
  toggleIndicatorsVisible(visible) {
    this._study.values().forEach((s2) => s2.toggleVisible(visible));
  }
  toggleDrawingsVisibility(visible) {
    this._onDrawingsVisibility.fire(visible);
  }
  togglePositionsAndOrdersVisibility(visible) {
    this._onPositionsAndOrdersVisibility.fire(visible);
  }
  getStudyById(entityId) {
    return ensure(this._study.get(entityId));
  }
  async removeEntity(entityId) {
    const study = this._study.get(entityId);
    if (study) {
      this._removeStudy(study, entityId);
      return;
    }
    this._chartController.removeEntity(entityId);
  }
  _removeStudy(study, entityId) {
    study.dispose();
    this._study.delete(entityId);
    this._chartStore.removeStudy(entityId);
    if (study.isChartCompare()) {
      const symbolInfo = study.symbolInfo();
      const compares = Array.from(this._study.values().filter((s2) => s2.isChartCompare()));
      const usedSameDataSource = compares.filter((s2) => s2.symbolInfo().name === symbolInfo.name);
      if (!usedSameDataSource.length) {
        const symbol = symbolInfo.name;
        this._removeDataSource(symbol);
      }
      if (!compares.length) {
        this.chartApi.priceScale("right").applyOptions({
          mode: vi.Normal
        });
      }
    }
  }
  removeAllStudy() {
    this._study.keys().forEach((id2) => {
      this.removeEntity(id2);
    });
  }
  resetData() {
    const promises = [
      this.mainSeriesApi.resetData(),
      ...this._chartStore.get("studyList").map((study) => {
        return this.getStudyById(study.id).resetData();
      })
    ];
    return Promise.all(promises);
  }
  zoomToViewport(fromTime, toTime, fromPrice, toPrice) {
    const viewport = {
      fromTime: Math.min(fromTime, toTime),
      toTime: Math.max(fromTime, toTime),
      fromPrice: Math.min(fromPrice, toPrice),
      toPrice: Math.max(fromPrice, toPrice)
    };
    const viewportCmd = new ViewportCommand(this, viewport);
    const cmd = new ZoomCommand(this, viewportCmd, this._zoomStack, ZoomDirection.in);
    cmd.redo();
    this.undoRedoService.pushElement(cmd);
  }
  zoomFromViewport() {
    const viewportCommand = this._zoomStack.head();
    const cmd = new ZoomCommand(this, viewportCommand, this._zoomStack, ZoomDirection.out);
    cmd.redo();
    this.undoRedoService.pushElement(cmd);
  }
  invokeWithinContext(fn2) {
    return this._instantiationService.invokeFunction(fn2);
  }
  save() {
    const timeScale = this.getTimeScale();
    const chartOptions = this.chartApi.options();
    const paneSources = /* @__PURE__ */ new Map();
    paneSources.set(this.mainSeriesApi.getSeries().getPane(), [this.mainSeriesApi.save()]);
    this._study.forEach((study) => {
      const pane = study.series.getPane();
      if (paneSources.has(pane)) {
        ensure(paneSources.get(pane)).push(study.save());
      } else {
        paneSources.set(pane, [study.save()]);
      }
    });
    const options = this.chartApi.options();
    const styleOptions = {
      layout: {
        background: options.layout.background
      },
      grid: options.grid
    };
    const plain = flatten(styleOptions);
    const overrides = omitBy(
      plain,
      (value, key2) => Reflect.get(chartDefaultProperties, key2) === value
    );
    return {
      version: 1,
      timezone: this.getTimezoneApi().getTimezoneId(),
      symbol: this.symbol(),
      resolution: this.resolution(),
      timeScale: {
        barSpacing: timeScale.barSpacing(),
        rightOffset: timeScale.rightOffset()
      },
      rightPriceScale: {
        mode: chartOptions.rightPriceScale.mode
      },
      panes: paneSources.entries().reduce((acc, [, values2]) => {
        acc.push({
          sources: values2
        });
        return acc;
      }, []),
      overrides
    };
  }
};
__decorateClass$a([
  memoize$1
], ChartWidget.prototype, "_dateTimeFormat", 1);
__decorateClass$a([
  memoize$1
], ChartWidget.prototype, "_dateFormat", 1);
ChartWidget = __decorateClass$a([
  __decorateParam$a(5, IConfigurationService),
  __decorateParam$a(6, IChartManagementService),
  __decorateParam$a(7, IInstantiationService),
  __decorateParam$a(8, IContextKeyService),
  __decorateParam$a(9, IIntlService),
  __decorateParam$a(10, IUndoRedoService),
  __decorateParam$a(11, IThemeService),
  __decorateParam$a(12, IChartContributionRegistry),
  __decorateParam$a(13, IChartResolutionRegistry),
  __decorateParam$a(14, IStudyService)
], ChartWidget);
class CursorScope {
  constructor(initValue, parent2 = void 0) {
    __publicField(this, "_value");
    __publicField(this, "_touched", false);
    this.initValue = initValue;
    this.parent = parent2;
    this._value = initValue;
  }
  value() {
    var _a3;
    return this._touched ? this._value : (_a3 = this.parent) == null ? void 0 : _a3.value();
  }
  touch(cursor) {
    this._value = cursor;
    this._touched = true;
  }
  touched() {
    if (this._touched) return true;
    return this.parent ? this.parent.touched() : false;
  }
}
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc$9 = Object.getOwnPropertyDescriptor;
var __decorateClass$9 = (decorators, target, key2, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$9(target, key2) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
  if (kind && result) __defProp2(target, key2, result);
  return result;
};
var __decorateParam$9 = (index2, decorator) => (target, key2) => decorator(target, key2, index2);
let ChartManagementService = class extends Disposable {
  constructor(layout, serializedData, configurationService, instantiationService) {
    super();
    __publicField(this, "_serviceBrand");
    __publicField(this, "whenRestoredPromise", new DeferredPromise$1());
    __publicField(this, "whenRestored", this.whenRestoredPromise.p);
    __publicField(this, "_charts", /* @__PURE__ */ new Map());
    __publicField(this, "store");
    __publicField(this, "_domElement");
    __publicField(this, "_defaultPaneCursor", PaneCursor.unset);
    __publicField(this, "_restoreTask");
    __publicField(this, "_onChartAdd", this._register(new Emitter()));
    __publicField(this, "_onChartRemove", this._register(new Emitter()));
    this.configurationService = configurationService;
    this.instantiationService = instantiationService;
    this.store = writable({
      hideBits: 0,
      tempMagnetMode: void 0,
      magnetMode: MagnetMode.Normal,
      cursor: PaneCursor.unset,
      activeIndex: NaN,
      layout,
      instances: /* @__PURE__ */ Object.create(null)
    });
    this._restoreTask = this._createRestoreTask(layout, serializedData == null ? void 0 : serializedData.charts);
  }
  get onChartAdd() {
    return this._onChartAdd.event;
  }
  get onChartRemove() {
    return this._onChartRemove.event;
  }
  _getValue(key2) {
    return get(this.store)[key2];
  }
  _setValue(key2, value) {
    this.store.update((store) => {
      store[key2] = value;
      return store;
    });
  }
  getDomElement() {
    return this._domElement;
  }
  getCharts() {
    return Array.from(this._charts.values());
  }
  async setLayout(layout) {
    if (this._getValue("layout") === layout) {
      return;
    }
    this._setValue("layout", layout);
    this._restoreTask = this._createRestoreTask(layout, void 0);
  }
  layout() {
    return get(this.store).layout;
  }
  _createRestoreTask(layout, charts) {
    var _a3;
    const layoutInfo = ensure(chartLayoutRegistry.value(layout));
    if (charts) {
      should(charts.length === layoutInfo.slotCount);
    }
    const onRestored = (result) => {
      if (result !== 2) {
        this.afterLayoutChange();
        setTimeout0(() => {
          this.whenRestoredPromise.complete();
        });
      }
    };
    const chartInits = (charts == null ? void 0 : charts.map((c2) => {
      return {
        symbol: c2.chart.symbol,
        resolution: c2.chart.resolution
      };
    })) ?? new Array(layoutInfo.slotCount).fill({
      symbol: this.configurationService.getValue("symbol"),
      resolution: this.configurationService.getValue("interval")
    });
    const restoreTask = new RestoreTask(chartInits);
    this._charts.entries().forEach(([index2, chart]) => {
      if (index2 >= chartInits.length) return;
      const data = chartInits[index2];
      let changed = false;
      if (chart.symbol() !== data.symbol) {
        chart.setSymbol(data.symbol);
        changed = true;
      }
      if (chart.resolution() !== data.resolution) {
        chart.setResolution(data.resolution);
        changed = true;
      }
      if (isSerializedChartData(data)) {
        NOTIMPLEMENTED();
      }
      if (!changed) {
        restoreTask.handleChartRestored(index2);
      }
    });
    restoreTask.onResult(onRestored);
    (_a3 = this._restoreTask) == null ? void 0 : _a3.dispose();
    this._restoreTask = restoreTask;
    return this._restoreTask;
  }
  _layoutDetails() {
    return chartLayoutRegistry.value(this.layout());
  }
  async afterLayoutChange() {
    if (!this._charts.size) return;
    this._charts.values().forEach((chart) => chart.autoResize());
    const currentLayout = ensure(this._layoutDetails());
    const activeIndex = this._getValue("activeIndex");
    if (!isFinite(activeIndex) || currentLayout.slotCount >= activeIndex) {
      this.setActiveChart(currentLayout.slotCount - 1);
    }
  }
  handleGridMount(div) {
    this._domElement = div;
    const resizeObserver = new ResizeObserver(() => this.autoResize());
    resizeObserver.observe(div);
    this._register(toDisposable(() => resizeObserver.disconnect()));
  }
  autoResizeNow() {
    this._charts.values().forEach((chart) => chart.autoResize());
  }
  autoResize() {
    this.autoResizeNow();
  }
  handleCellMount(div, index2) {
    const chart = this._createChart(div, this._restoreTask.getChartInit(index2));
    this._restoreTask.handleChartRestored(index2);
    this._onChartAdd.fire(chart);
    should(chart.getContainerDomElement() === div);
    should(chart.index === index2);
    return chart;
  }
  handleCellDestory(div, index2) {
    const chart = ensure(this._charts.get(index2));
    should(chart.getContainerDomElement() === div);
    chart.dispose();
    this._onChartRemove.fire(chart);
    this._charts.delete(index2);
    const currentLayout = ensure(this._layoutDetails());
    const activeIndex = this._getValue("activeIndex");
    const newCount = currentLayout.slotCount;
    if (newCount <= activeIndex) {
      this.setActiveChart(newCount - 1);
    }
    this.store.update((store) => {
      delete store.instances[index2];
      return store;
    });
  }
  _createChart(div, chartInitData) {
    const max = this.chartsCount() ? Math.max(...this._charts.keys()) : -1;
    should(max === this.chartsCount() - 1);
    const index2 = max + 1;
    const chartInit = {
      dataStatus: ChartDataStatus.idle,
      symbol: chartInitData.symbol,
      resolution: chartInitData.resolution,
      chartOptions: /* @__PURE__ */ Object.create(null),
      chartProperties: cloneDeep(this.configurationService.getValue("chartProperties")),
      symbolInfo: /* @__PURE__ */ Object.create(null),
      mainLegend: /* @__PURE__ */ Object.create(null),
      studyList: [],
      studyLegend: /* @__PURE__ */ Object.create(null),
      drawingInfos: [],
      viewports: []
    };
    this.store.update((store) => {
      store.instances[index2] = chartInit;
      return store;
    });
    const instance = this.instantiationService.createInstance(
      ChartWidget,
      index2,
      div,
      {
        getStore: () => {
          return derived(this.store, (store) => store.instances[index2]);
        },
        get: (key2) => {
          return get(this.store).instances[index2][key2];
        },
        update: (cb) => {
          this.store.update((store) => {
            const subStore = store.instances[index2];
            cb(subStore);
            return store;
          });
        }
      },
      {
        setPaneCursor: this.setPaneCursor.bind(this),
        getPaneCursor: () => this._defaultPaneCursor
      },
      isSerializedChartData(chartInitData) ? chartInitData : void 0
    );
    this._charts.set(index2, instance);
    return instance;
  }
  activeChart() {
    const activeSlot = this._getValue("activeIndex");
    return ensure(this._charts.get(activeSlot));
  }
  activeChartIndex() {
    return this._getValue("activeIndex");
  }
  chart(index2) {
    if (isUndefinedOrNull(index2)) return this.activeChart();
    return ensure(this._charts.get(index2));
  }
  chartsCount() {
    return this._charts.size;
  }
  setActiveChart(candidate) {
    const activeIndex = this._getValue("activeIndex");
    const prev = isFinite(activeIndex) && activeIndex < this.chartsCount() ? this.activeChart() : null;
    if (isFiniteNumber(candidate)) {
      const chart = ensure(this._charts.get(candidate));
      if (chart === prev) return;
      this._setValue("activeIndex", candidate);
      prev == null ? void 0 : prev.blur();
      chart.focus();
    } else {
      if (candidate === prev) return;
      const chart = ensure(this._charts.values().find((chart2) => chart2 === candidate));
      this._setValue("activeIndex", candidate.index);
      prev == null ? void 0 : prev.blur();
      chart.focus();
    }
  }
  setSymbol(symbol, interval, callback) {
    this.activeChart().setSymbol(symbol);
    this.activeChart().setResolution(interval);
    callback == null ? void 0 : callback();
  }
  setPaneCursor(cursor, asDefault) {
    if (asDefault) {
      if (this._defaultPaneCursor === PaneCursor.demonstration && cursor === PaneCursor.eraser) {
        this._defaultPaneCursor = PaneCursor.demonstration | PaneCursor.eraser;
      } else {
        this._defaultPaneCursor = cursor;
      }
    }
    if (cursor === this._getValue("cursor")) return;
    this._setValue("cursor", cursor);
  }
  getDefaultPaneCursor() {
    return this._defaultPaneCursor;
  }
  setHideBits(bits) {
    const store = get(this.store);
    if (store.hideBits === bits) return;
    const prevDrawingHidden = HideDrawingsBit & store.hideBits;
    const nextDrawingHidden = HideDrawingsBit & bits;
    const prevIndicatorHidden = HideIndicatorsBit & store.hideBits;
    const nextIndicatorHidden = HideIndicatorsBit & bits;
    const prevPositionsAndOrdersHidden = HidePositionsAndOrdersBit & store.hideBits;
    const nextPositionsAndOrdersHidden = HidePositionsAndOrdersBit & bits;
    this._setValue("hideBits", bits);
    this.getCharts().forEach((chartWidget) => {
      if (prevIndicatorHidden !== nextIndicatorHidden) {
        chartWidget.toggleIndicatorsVisible(!nextDrawingHidden);
      }
      if (prevDrawingHidden !== nextDrawingHidden) {
        chartWidget.toggleDrawingsVisibility(!nextDrawingHidden);
      }
      if (prevPositionsAndOrdersHidden !== nextPositionsAndOrdersHidden) {
        chartWidget.togglePositionsAndOrdersVisibility(!nextPositionsAndOrdersHidden);
      }
    });
  }
  save() {
    const store = get(this.store);
    return {
      version: 1,
      layout: store.layout,
      activeIndex: store.activeIndex,
      hideBits: store.hideBits,
      charts: Object.keys(store.instances).reduce(
        (acc, key2) => {
          acc.push({
            chart: this.chart(parseInt(key2)).save()
          });
          return acc;
        },
        []
      )
    };
  }
  async restore(data) {
    if (this._getValue("layout") !== data.layout) {
      this._setValue("layout", data.layout);
    }
    this._restoreTask = this._createRestoreTask(data.layout, data.charts);
  }
};
__decorateClass$9([
  debounce(8)
], ChartManagementService.prototype, "autoResize", 1);
ChartManagementService = __decorateClass$9([
  __decorateParam$9(2, IConfigurationService),
  __decorateParam$9(3, IInstantiationService)
], ChartManagementService);
function isSerializedChartData(data) {
  return "version" in data;
}
class RestoreTask {
  constructor(chartInits) {
    __publicField(this, "chartPromises", []);
    __publicField(this, "_onResult", new Emitter());
    __publicField(this, "onResult", this._onResult.event);
    this.chartInits = chartInits;
    chartInits.forEach(() => {
      this.chartPromises.push(new DeferredPromise$1());
    });
    Promise.all(this.chartPromises.map((p2) => p2.p)).then((results) => {
      const allOk = results.every(
        (r2) => r2 === 0
        /* ok */
      );
      const allCancelled = results.every(
        (r2) => r2 === 2
        /* cancelled */
      );
      this._onResult.fire(
        allOk ? 0 : allCancelled ? 2 : 1
        /* partial */
      );
    });
  }
  handleChartRestored(index2) {
    this.chartPromises[index2].complete(
      0
      /* ok */
    );
  }
  getChartInit(index2) {
    return ensure(this.chartInits[index2]);
  }
  dispose() {
    this.chartPromises.forEach((p2) => p2.complete(
      2
      /* cancelled */
    ));
    this._onResult.dispose();
  }
}
const HtmlMIME = "text/html";
const TextMIME = "text/plain";
class ClipboardService extends Disposable {
  constructor(host, shadowRoot) {
    super();
    __publicField(this, "_onPaste", new Emitter());
    __publicField(this, "onPaste", this._onPaste.event);
    __publicField(this, "_inMemoryData", null);
    this._register(addDisposableListener(document, "copy", () => this.clearInMemoryData()));
    this._register(
      addDisposableListener(document, "paste", (e2) => {
        const target = e2.target || document.activeElement;
        if (target !== host) return;
        const path = PartFingerprints.collect(shadowRoot.activeElement, host);
        if (!path.length) return;
        if (path[0] === PartFingerprint.Textarea) return;
        if (!e2.clipboardData) return;
        if (!e2.clipboardData.items) return;
        const data = /* @__PURE__ */ Object.create(null);
        const files = [];
        e2.clipboardData.getData("text");
        for (const item of e2.clipboardData.items) {
          if (item.type === HtmlMIME) {
            data.html = e2.clipboardData.getData(HtmlMIME);
          }
          if (item.type === TextMIME) {
            data.text = e2.clipboardData.getData(TextMIME);
          }
          if (item.type.startsWith("image")) {
            files.push(item.getAsFile());
          }
        }
        if (files.length) {
          data.files = files;
        }
        if (isEmpty(data)) return;
        this._onPaste.fire(data);
        this._inMemoryData = null;
      })
    );
  }
  async writeClipboard(data, copyEvent) {
    const hasFiles = data.files && data.files.length > 0;
    if (!hasFiles && copyEvent && copyEvent.eventPhase > 0) {
      writeViaLegacyCopy(copyEvent, data);
      return Promise.resolve();
    }
    if (!hasFiles) {
      let handled = false;
      const onCopy = (e2) => {
        e2.stopImmediatePropagation();
        writeViaLegacyCopy(e2, data);
        handled = true;
      };
      try {
        document.addEventListener("copy", onCopy, true);
        document.execCommand("copy");
      } finally {
        document.removeEventListener("copy", onCopy, true);
      }
      if (handled) return Promise.resolve();
    }
    try {
      await writeViaClipboardApi(data);
    } catch (e2) {
      console.warn(e2);
    }
    this._inMemoryData = isEmpty(data) ? null : data;
  }
  clearInMemoryData() {
    this._inMemoryData = null;
  }
}
function writeViaLegacyCopy(event2, data) {
  event2.preventDefault();
  const clipboardData = ensure(event2.clipboardData);
  if (data.text) clipboardData.setData("text/plain", data.text);
  if (data.html) clipboardData.setData("text/html", data.html);
}
async function writeViaClipboardApi(data) {
  const clipboard = navigator.clipboard;
  if (!clipboard || !clipboard.write || !window.ClipboardItem) {
    throw new DOMException("ClipboardApi is not supported", "NotSupportedError");
  }
  const clipboardItems = /* @__PURE__ */ Object.create(null);
  for (const file of data.files || []) {
    clipboardItems[file.type] = file;
  }
  if (data.text) clipboardItems[TextMIME] = new Blob([data.text], { type: TextMIME });
  if (data.html) clipboardItems[HtmlMIME] = new Blob([data.html], { type: HtmlMIME });
  return clipboard.write([new ClipboardItem(clipboardItems)]);
}
var __getOwnPropDesc$8 = Object.getOwnPropertyDescriptor;
var __decorateClass$8 = (decorators, target, key2, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$8(target, key2) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$8 = (index2, decorator) => (target, key2) => decorator(target, key2, index2);
let CommandService = class {
  constructor(instantiationService, commandRegistry) {
    __publicField(this, "_instantiationService");
    this.commandRegistry = commandRegistry;
    this._instantiationService = instantiationService;
  }
  executeCommand(id2, ...args) {
    const command = this.commandRegistry.getCommand(id2);
    if (!command) {
      return Promise.reject(new Error(`command '${id2}' not found`));
    }
    try {
      const result = this._instantiationService.invokeFunction.apply(this._instantiationService, [
        command.handler,
        ...args
      ]);
      return Promise.resolve(result);
    } catch (err) {
      return Promise.reject(err);
    }
  }
};
CommandService = __decorateClass$8([
  __decorateParam$8(0, IInstantiationService),
  __decorateParam$8(1, ICommandRegistry)
], CommandService);
const ChartFeaturePreset = {
  create_volume_indicator_by_default: true,
  header_resolutions: true,
  header_chart_type: true,
  header_indicators: true,
  header_layouttoggle: true,
  header_settings: false,
  header_fullscreen_button: true,
  header_screenshot: true,
  left_toolbar: true,
  left_strong_magnet: true,
  timezone_menu: true
};
class ConfigurationService extends Disposable {
  constructor(options) {
    var _a3, _b3, _c2, _d2, _e, _f, _g;
    super();
    __publicField(this, "store");
    const timezone = options.timezone ?? "exchange";
    this.store = writable({
      locale: options.locale ?? ((_b3 = (_a3 = options.savedData) == null ? void 0 : _a3.configs) == null ? void 0 : _b3.locale) ?? "en-US",
      symbol: options.symbol,
      interval: options.interval,
      theme: options.theme ?? ((_d2 = (_c2 = options.savedData) == null ? void 0 : _c2.configs) == null ? void 0 : _d2.theme) ?? "light",
      drawingsAccessType: (_e = options.drawingsAccess) == null ? void 0 : _e.type,
      drawingsAccess: parseAccessList(options.drawingsAccess),
      studiesAccessType: (_f = options.studiesAccess) == null ? void 0 : _f.type,
      studiesAccess: parseAccessList(options.studiesAccess),
      layoutAccessType: (_g = options.layoutAccess) == null ? void 0 : _g.type,
      layoutAccess: parseAccessList(options.layoutAccess),
      chartProperties: parseChartProperties(
        Object.assign({}, chartDefaultProperties, options.overrides, { timezone })
      ),
      studyProperties: parseStudyProperties(
        Object.assign({}, studyDefaultProperties, options.studiesOverrides)
      ),
      chartFeatures: parseChartFeatures(options.enabledFeatures, options.disabledFeatures)
    });
  }
  getValue(key2) {
    return get(this.store)[key2];
  }
  setValue(key2, value) {
    this.store.update((store) => {
      store[key2] = value;
      return { ...store };
    });
  }
  featureEnabled(key2) {
    return this.getValue("chartFeatures")[key2];
  }
  save() {
    const store = get(this.store);
    return {
      version: 1,
      locale: store.locale,
      theme: store.theme
    };
  }
  applyOverrides(overrides) {
    const chartProperties = this.getValue("chartProperties");
    this.setValue("chartProperties", merge(chartProperties, parseChartProperties(overrides)));
  }
  applyStudiesOverrides(overrides) {
    const studyProperties = this.getValue("studyProperties");
    this.setValue("studyProperties", merge(studyProperties, parseStudyProperties(overrides)));
  }
}
function parseAccessList(list) {
  const ret = /* @__PURE__ */ Object.create(null);
  if (!list) return ret;
  const type = list.type;
  return list.items.reduce((acc, item) => {
    acc[item.name] = item.grayed ? "gray" : type;
    return acc;
  }, ret);
}
function parseChartFeatures(enabled, disabled) {
  const features = { ...ChartFeaturePreset };
  keys(ChartFeaturePreset).forEach((k2) => {
    features[k2] = ChartFeaturePreset[k2];
    if (enabled == null ? void 0 : enabled.includes(k2)) {
      features[k2] = true;
    }
    if (disabled == null ? void 0 : disabled.includes(k2)) {
      features[k2] = false;
    }
  });
  return features;
}
const plainConfigs = ["mainSeriesProperties", "tool"];
function parseChartProperties(props) {
  const ret = /* @__PURE__ */ Object.create(null);
  keys(props).forEach((key2) => {
    const value = props[key2];
    if (isUndefinedOrNull(value)) return;
    if (isString$1(value) && !value.length) return;
    const parts = key2.split(".");
    if (parts.length === 1 || plainConfigs.includes(parts[0])) {
      Reflect.set(ret, key2, value);
      return;
    }
    let obj = ret;
    while (parts.length) {
      const path = ensure(parts.shift());
      if (parts.length) {
        if (!Reflect.has(obj, path)) {
          Reflect.set(obj, path, /* @__PURE__ */ Object.create(null));
        }
        obj = Reflect.get(obj, path);
      } else {
        Reflect.set(obj, path, value);
      }
    }
  });
  return ret;
}
function parseStudyProperties(props) {
  const ret = /* @__PURE__ */ Object.create(null);
  keys(props).forEach((key2) => {
    const value = props[key2];
    const [studyName, plotName, styleName, arrIndex] = key2.split(".");
    if (!ret[studyName]) {
      ret[studyName] = {
        plots: /* @__PURE__ */ Object.create(null)
      };
    }
    const styleValues = ret[studyName];
    if (!styleValues.plots[plotName]) {
      styleValues.plots[plotName] = /* @__PURE__ */ Object.create(null);
    }
    const plotStyles = styleValues.plots[plotName];
    if (arrIndex) {
      should(styleName === "color");
      const idx = parseInt(arrIndex);
      should(isFinite(idx));
      if (!plotStyles.color) {
        plotStyles.color = [];
      }
      should(isString$1(value));
      should(Array.isArray(plotStyles.color));
      plotStyles.color[idx] = value;
    } else {
      plotStyles[styleName] = value;
    }
  });
  return ret;
}
const KEYBINDING_CONTEXT_ATTR = "data-keybinding-context";
class Context {
  constructor(id2, parent2) {
    __publicField(this, "_parent");
    __publicField(this, "_value");
    __publicField(this, "_id");
    this._id = id2;
    this._parent = parent2;
    this._value = /* @__PURE__ */ Object.create(null);
    this._value["_contextId"] = id2;
  }
  get value() {
    return { ...this._value };
  }
}
class AbstractContextKeyService extends Disposable {
  constructor(myContextId) {
    super();
    __publicField(this, "_isDisposed");
    __publicField(this, "_myContextId");
    this._isDisposed = false;
    this._myContextId = myContextId;
  }
  get contextId() {
    return this._myContextId;
  }
  createScoped(domNode) {
    if (this._isDisposed) {
      throw new Error(`AbstractContextKeyService has been disposed`);
    }
    return new ScopedContextKeyService(this, domNode);
  }
  getContext(target) {
    if (this._isDisposed) {
      return NullContext.INSTANCE;
    }
    return this.getContextValuesContainer(findContextAttr(target));
  }
  dispose() {
    super.dispose();
    this._isDisposed = true;
  }
}
class ContextKeyService extends AbstractContextKeyService {
  constructor() {
    super(0);
    __publicField(this, "_lastContextId");
    __publicField(this, "_contexts", /* @__PURE__ */ new Map());
    this._lastContextId = 0;
    const myContext = new ConfigAwareContextValuesContainer(this._myContextId);
    this._contexts.set(this._myContextId, myContext);
  }
  getContextValuesContainer(contextId) {
    if (this._isDisposed) {
      return NullContext.INSTANCE;
    }
    return this._contexts.get(contextId) || NullContext.INSTANCE;
  }
  createChildContext(parentContextId = this._myContextId) {
    if (this._isDisposed) {
      throw new Error(`ContextKeyService has been disposed`);
    }
    const id2 = ++this._lastContextId;
    this._contexts.set(id2, new Context(id2, this.getContextValuesContainer(parentContextId)));
    return id2;
  }
  disposeContext(contextId) {
    if (!this._isDisposed) {
      this._contexts.delete(contextId);
    }
  }
}
class ScopedContextKeyService extends AbstractContextKeyService {
  constructor(parent2, domNode) {
    super(parent2.createChildContext());
    __publicField(this, "_parent");
    __publicField(this, "_domNode");
    this._parent = parent2;
    this._domNode = domNode;
    if (this._domNode.hasAttribute(KEYBINDING_CONTEXT_ATTR)) {
      let extraInfo = "";
      if (this._domNode.classList) {
        extraInfo = Array.from(this._domNode.classList.values()).join(", ");
      }
      console.error(`Element already has context attribute${extraInfo ? ": " + extraInfo : ""}`);
    }
    this._domNode.setAttribute(KEYBINDING_CONTEXT_ATTR, String(this._myContextId));
  }
  dispose() {
    if (this._isDisposed) {
      return;
    }
    this._parent.disposeContext(this._myContextId);
    this._domNode.removeAttribute(KEYBINDING_CONTEXT_ATTR);
    super.dispose();
  }
  getContextValuesContainer(contextId) {
    if (this._isDisposed) {
      return NullContext.INSTANCE;
    }
    return this._parent.getContextValuesContainer(contextId);
  }
  createChildContext(parentContextId = this._myContextId) {
    if (this._isDisposed) {
      throw new Error(`ScopedContextKeyService has been disposed`);
    }
    return this._parent.createChildContext(parentContextId);
  }
  disposeContext(contextId) {
    if (this._isDisposed) {
      return;
    }
    this._parent.disposeContext(contextId);
  }
}
const _NullContext = class _NullContext extends Context {
  constructor() {
    super(-1, null);
  }
};
__publicField(_NullContext, "INSTANCE", new _NullContext());
let NullContext = _NullContext;
class ConfigAwareContextValuesContainer extends Context {
  constructor(id2) {
    super(id2, null);
  }
}
function findContextAttr(domNode) {
  while (domNode) {
    if (domNode.hasAttribute(KEYBINDING_CONTEXT_ATTR)) {
      const attr = domNode.getAttribute(KEYBINDING_CONTEXT_ATTR);
      if (attr) {
        return parseInt(attr, 10);
      }
      return NaN;
    }
    domNode = domNode.parentElement;
  }
  return 0;
}
class DatafeedService extends Disposable {
  constructor(datafeed) {
    super();
    __publicField(this, "_serviceBrand");
    __publicField(this, "_onReady", this._register(new Emitter()));
    __publicField(this, "onReady", this._onReady.event);
    __publicField(this, "onTicks", /* @__PURE__ */ new Map());
    __publicField(this, "onResetCaches", /* @__PURE__ */ new Map());
    this.datafeed = datafeed;
    let onR = (arg) => {
      if (this._disposed) return;
      this._onReady.fire(arg);
    };
    datafeed.onReady((arg) => onR(arg));
    this._register(
      toDisposable(() => {
        onR = () => {
        };
      })
    );
  }
  getBars(symbolInfo, resolution, periodParams, onResult, onError, token) {
    if (token.isCancellationRequested) return;
    const disposable = token.onCancellationRequested(() => {
      onResult = () => {
      };
      onError = () => {
      };
      disposable.dispose();
    });
    this.datafeed.getBars(
      symbolInfo,
      resolution,
      periodParams,
      (bars, meta) => {
        onResult(
          bars.map((bar) => ({ ...bar, time: bar.time / 1e3 })),
          meta
        );
        disposable.dispose();
      },
      (...args) => {
        onError(...args);
        disposable.dispose();
      }
    );
  }
  resolveSymbol(symbolName, onResolve, onError, token, extension) {
    if (token.isCancellationRequested) return;
    const disposable = token.onCancellationRequested(() => {
      onResolve = () => {
      };
      onError = () => {
      };
      disposable.dispose();
    });
    this.datafeed.resolveSymbol(
      symbolName,
      (...args) => {
        onResolve(...args);
        disposable.dispose();
      },
      (...args) => {
        onError(...args);
        disposable.dispose();
      },
      extension
    );
  }
  subscribeBars(symbolInfo, resolution, onTick, listenerGuid, onResetCacheNeededCallback) {
    this.onTicks.set(listenerGuid, onTick);
    this.onResetCaches.set(listenerGuid, onResetCacheNeededCallback);
    const onTicks = this.onTicks;
    const onReset = this.onResetCaches;
    this.datafeed.subscribeBars(
      symbolInfo,
      resolution,
      (bar) => {
        var _a3;
        (_a3 = onTicks.get(listenerGuid)) == null ? void 0 : _a3({
          ...bar,
          time: bar.time / 1e3
        });
      },
      listenerGuid,
      () => {
        var _a3;
        (_a3 = onReset.get(listenerGuid)) == null ? void 0 : _a3();
      }
    );
  }
  unsubscribeBars(listenerGuid) {
    this.datafeed.unsubscribeBars(listenerGuid);
    this.onTicks.delete(listenerGuid);
    this.onResetCaches.delete(listenerGuid);
  }
  dispose() {
    super.dispose();
    this.onTicks.clear();
    this.onResetCaches.clear();
  }
}
class GuiService extends Disposable {
  constructor(root2) {
    super();
    __publicField(this, "_serviceBrand");
    __publicField(this, "_headerReady", new DeferredPromise$1());
    __publicField(this, "_buttonReady", this._register(new Emitter()));
    __publicField(this, "buttonReady", this._buttonReady.event);
    __publicField(this, "store");
    this.root = root2;
    this.store = writable({
      leftButtons: [],
      rightButtons: [],
      components: []
    });
  }
  headerReady() {
    return this._headerReady.p;
  }
  dispose() {
    super.dispose();
    if (!this._headerReady.isSettled) {
      this._headerReady.complete();
    }
    this.store = null;
    this._headerReady = null;
    this.buttonReady = null;
  }
  setHeaderReady() {
    if (this._disposed) return;
    this._headerReady.complete();
  }
  async createButton(options) {
    const btnOpt = /* @__PURE__ */ Object.create(null);
    btnOpt.id = generateUuid();
    const align = (options == null ? void 0 : options.align) ?? "left";
    if (options == null ? void 0 : options.useTradingViewStyle) {
      btnOpt.text = options.text;
      btnOpt.title = options.title;
      btnOpt.onClick = options.onClick;
    }
    const deferredPromise = new DeferredPromise$1();
    const listener = this.buttonReady((evt) => {
      if (evt.id === btnOpt.id) {
        listener.dispose();
        deferredPromise.complete((options == null ? void 0 : options.useTradingViewStyle) ? void 0 : evt.el);
      }
    });
    switch (align) {
      case "left":
        this.store.update((store) => {
          store.leftButtons.push(btnOpt);
          return store;
        });
        break;
      case "right":
        this.store.update((store) => {
          store.rightButtons.push(btnOpt);
          return store;
        });
        break;
      default:
        NOTREACHED();
    }
    return deferredPromise.p;
  }
  setButtonReady(id2, el) {
    this._buttonReady.fire({ id: id2, el });
  }
  showComponent(params) {
    const id2 = generateUuid();
    this.store.update((store) => {
      store.components.push({
        id: id2,
        Component: params.Component,
        props: params.props
      });
      return store;
    });
    return {
      dispose: () => {
        this.store.update((store) => {
          const idx = store.components.findIndex((c2) => c2.id === id2);
          if (idx !== -1) {
            store.components.splice(idx, 1);
          }
          return { ...store };
        });
      },
      update: (props) => {
        this.store.update((store) => {
          const info = store.components.find((c2) => c2.id === id2);
          if (info) {
            Object.assign(info.props, props);
          }
          return { ...store };
        });
      }
    };
  }
}
const IInputService = createDecorator$1("IInputManager");
const IKeybindingService = createDecorator$1("keybindingService");
var __getOwnPropDesc$7 = Object.getOwnPropertyDescriptor;
var __decorateClass$7 = (decorators, target, key2, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$7(target, key2) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$7 = (index2, decorator) => (target, key2) => decorator(target, key2, index2);
let InputService = class extends Disposable {
  constructor(toolService, keybindingService, chartManagementService) {
    super();
    this.toolService = toolService;
    this.keybindingService = keybindingService;
    this.chartManagementService = chartManagementService;
    this._register(
      chartManagementService.onChartAdd((chart) => {
        chart.installEventFilter(this);
      })
    );
  }
  eventFilter(event2) {
    switch (event2.type) {
      case InputEventType.KEY_DOWN: {
        const keyEvent = ensure(event2.asKeyboardInputEvent()).init;
        const shouldPreventDefault = this.keybindingService.dispatchEvent(
          keyEvent,
          this.chartManagementService.activeChart().getContainerDomElement()
        );
        if (shouldPreventDefault) {
          keyEvent.preventDefault();
          keyEvent.stopPropagation();
          event2.accept();
        }
        break;
      }
    }
    if (!event2.isAccepted()) {
      this.toolService.processEvent(event2);
    }
    return event2.isAccepted();
  }
};
InputService = __decorateClass$7([
  __decorateParam$7(0, IToolService),
  __decorateParam$7(1, IKeybindingService),
  __decorateParam$7(2, IChartManagementService)
], InputService);
class SyncDescriptor {
  constructor(ctor, staticArguments = [], supportsDelayedInstantiation = false) {
    __publicField(this, "ctor");
    __publicField(this, "staticArguments");
    __publicField(this, "supportsDelayedInstantiation");
    this.ctor = ctor;
    this.staticArguments = staticArguments;
    this.supportsDelayedInstantiation = supportsDelayedInstantiation;
  }
}
let Node$1 = class Node2 {
  constructor(key2, data) {
    __publicField(this, "incoming", /* @__PURE__ */ new Map());
    __publicField(this, "outgoing", /* @__PURE__ */ new Map());
    this.key = key2;
    this.data = data;
  }
};
class Graph {
  constructor(_hashFn) {
    __publicField(this, "_nodes", /* @__PURE__ */ new Map());
    this._hashFn = _hashFn;
  }
  roots() {
    const ret = [];
    for (const node of this._nodes.values()) {
      if (node.outgoing.size === 0) {
        ret.push(node);
      }
    }
    return ret;
  }
  insertEdge(from, to) {
    const fromNode = this.lookupOrInsertNode(from);
    const toNode = this.lookupOrInsertNode(to);
    fromNode.outgoing.set(toNode.key, toNode);
    toNode.incoming.set(fromNode.key, fromNode);
  }
  removeNode(data) {
    const key2 = this._hashFn(data);
    this._nodes.delete(key2);
    for (const node of this._nodes.values()) {
      node.outgoing.delete(key2);
      node.incoming.delete(key2);
    }
  }
  lookupOrInsertNode(data) {
    const key2 = this._hashFn(data);
    let node = this._nodes.get(key2);
    if (!node) {
      node = new Node$1(key2, data);
      this._nodes.set(key2, node);
    }
    return node;
  }
  lookup(data) {
    return this._nodes.get(this._hashFn(data));
  }
  isEmpty() {
    return this._nodes.size === 0;
  }
  toString() {
    const data = [];
    for (const [key2, value] of this._nodes) {
      data.push(
        `${key2}
	(-> incoming)[${[...value.incoming.keys()].join(", ")}]
	(outgoing ->)[${[...value.outgoing.keys()].join(",")}]
`
      );
    }
    return data.join("\n");
  }
  /**
   * This is brute force and slow and **only** be used
   * to trouble shoot.
   */
  findCycleSlow() {
    for (const [id2, node] of this._nodes) {
      const seen2 = /* @__PURE__ */ new Set([id2]);
      const res = this._findCycle(node, seen2);
      if (res) {
        return res;
      }
    }
    return void 0;
  }
  _findCycle(node, seen2) {
    for (const [id2, outgoing] of node.outgoing) {
      if (seen2.has(id2)) {
        return [...seen2, id2].join(" -> ");
      }
      seen2.add(id2);
      const value = this._findCycle(outgoing, seen2);
      if (value) {
        return value;
      }
      seen2.delete(id2);
    }
    return void 0;
  }
}
const _enableAllTracing = false;
class CyclicDependencyError extends Error {
  constructor(graph) {
    super("cyclic dependency between services");
    this.message = graph.findCycleSlow() ?? `UNABLE to detect cycle, dumping graph: 
${graph.toString()}`;
  }
}
class InstantiationService {
  constructor(_services = new ServiceCollection(), _strict = false, _parent, _enableTracing = _enableAllTracing) {
    __publicField(this, "_globalGraph");
    __publicField(this, "_globalGraphImplicitDependency");
    __publicField(this, "_isDisposed", false);
    __publicField(this, "_servicesToMaybeDispose", /* @__PURE__ */ new Set());
    __publicField(this, "_children", /* @__PURE__ */ new Set());
    __publicField(this, "_activeInstantiations", /* @__PURE__ */ new Set());
    this._services = _services;
    this._strict = _strict;
    this._parent = _parent;
    this._enableTracing = _enableTracing;
    this._services.set(IInstantiationService, this);
    this._globalGraph = _enableTracing ? (_parent == null ? void 0 : _parent._globalGraph) ?? new Graph((e2) => e2) : void 0;
  }
  dispose() {
    if (!this._isDisposed) {
      this._isDisposed = true;
      dispose(this._children);
      this._children.clear();
      for (const candidate of this._servicesToMaybeDispose) {
        if (isDisposable(candidate)) {
          candidate.dispose();
        }
      }
      this._servicesToMaybeDispose.clear();
    }
  }
  _throwIfDisposed() {
    if (this._isDisposed) {
      throw new Error("InstantiationService has been disposed");
    }
  }
  createChild(services, store) {
    this._throwIfDisposed();
    const that = this;
    const result = new class extends InstantiationService {
      dispose() {
        that._children.delete(result);
        super.dispose();
      }
    }(services, this._strict, this, this._enableTracing);
    this._children.add(result);
    store == null ? void 0 : store.add(result);
    return result;
  }
  invokeFunction(fn2, ...args) {
    this._throwIfDisposed();
    const _trace = Trace.traceInvocation(this._enableTracing, fn2);
    let _done = false;
    try {
      const accessor = {
        get: (id2) => {
          if (_done) {
            throw illegalState(
              "service accessor is only valid during the invocation of its target method"
            );
          }
          const result = this._getOrCreateServiceInstance(id2, _trace);
          if (!result) {
            throw new Error(`[invokeFunction] unknown service '${id2}'`);
          }
          return result;
        }
      };
      return fn2(accessor, ...args);
    } finally {
      _done = true;
      _trace.stop();
    }
  }
  createInstance(ctorOrDescriptor, ...rest) {
    this._throwIfDisposed();
    let _trace;
    let result;
    if (ctorOrDescriptor instanceof SyncDescriptor) {
      _trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor.ctor);
      result = this._createInstance(
        ctorOrDescriptor.ctor,
        ctorOrDescriptor.staticArguments.concat(rest),
        _trace
      );
    } else {
      _trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor);
      result = this._createInstance(ctorOrDescriptor, rest, _trace);
    }
    _trace.stop();
    return result;
  }
  _createInstance(ctor, args = [], _trace) {
    const serviceDependencies = _util.getServiceDependencies(ctor).sort((a2, b2) => a2.index - b2.index);
    const serviceArgs = [];
    for (const dependency of serviceDependencies) {
      const service = this._getOrCreateServiceInstance(dependency.id, _trace);
      if (!service) {
        this._throwIfStrict(
          `[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`,
          false
        );
      }
      serviceArgs.push(service);
    }
    const firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;
    if (args.length !== firstServiceArgPos) {
      console.trace(
        `[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`
      );
      const delta = firstServiceArgPos - args.length;
      if (delta > 0) {
        args = args.concat(new Array(delta));
      } else {
        args = args.slice(0, firstServiceArgPos);
      }
    }
    return Reflect.construct(ctor, args.concat(serviceArgs));
  }
  _setCreatedServiceInstance(id2, instance) {
    if (this._services.get(id2) instanceof SyncDescriptor) {
      this._services.set(id2, instance);
    } else if (this._parent) {
      this._parent._setCreatedServiceInstance(id2, instance);
    } else {
      throw new Error("illegalState - setting UNKNOWN service instance");
    }
  }
  _getServiceInstanceOrDescriptor(id2) {
    const instanceOrDesc = this._services.get(id2);
    if (!instanceOrDesc && this._parent) {
      return this._parent._getServiceInstanceOrDescriptor(id2);
    } else {
      return instanceOrDesc;
    }
  }
  _getOrCreateServiceInstance(id2, _trace) {
    if (this._globalGraph && this._globalGraphImplicitDependency) {
      this._globalGraph.insertEdge(this._globalGraphImplicitDependency, String(id2));
    }
    const thing = this._getServiceInstanceOrDescriptor(id2);
    if (thing instanceof SyncDescriptor) {
      return this._safeCreateAndCacheServiceInstance(id2, thing, _trace.branch(id2, true));
    } else {
      _trace.branch(id2, false);
      return thing;
    }
  }
  _safeCreateAndCacheServiceInstance(id2, desc, _trace) {
    if (this._activeInstantiations.has(id2)) {
      throw new Error(`illegal state - RECURSIVELY instantiating service '${id2}'`);
    }
    this._activeInstantiations.add(id2);
    try {
      return this._createAndCacheServiceInstance(id2, desc, _trace);
    } finally {
      this._activeInstantiations.delete(id2);
    }
  }
  _createAndCacheServiceInstance(id2, desc, _trace) {
    var _a3;
    const graph = new Graph((data) => data.id.toString());
    let cycleCount = 0;
    const stack = [{ id: id2, desc, _trace }];
    const seen2 = /* @__PURE__ */ new Set();
    while (stack.length) {
      const item = stack.pop();
      if (seen2.has(String(item.id))) {
        continue;
      }
      seen2.add(String(item.id));
      graph.lookupOrInsertNode(item);
      if (cycleCount++ > 1e3) {
        throw new CyclicDependencyError(graph);
      }
      for (const dependency of _util.getServiceDependencies(item.desc.ctor)) {
        const instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);
        if (!instanceOrDesc) {
          this._throwIfStrict(
            `[createInstance] ${id2} depends on ${dependency.id} which is NOT registered.`,
            true
          );
        }
        (_a3 = this._globalGraph) == null ? void 0 : _a3.insertEdge(String(item.id), String(dependency.id));
        if (instanceOrDesc instanceof SyncDescriptor) {
          const d3 = {
            id: dependency.id,
            desc: instanceOrDesc,
            _trace: item._trace.branch(dependency.id, true)
          };
          graph.insertEdge(item, d3);
          stack.push(d3);
        }
      }
    }
    while (true) {
      const roots = graph.roots();
      if (roots.length === 0) {
        if (!graph.isEmpty()) {
          throw new CyclicDependencyError(graph);
        }
        break;
      }
      for (const { data } of roots) {
        const instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);
        if (instanceOrDesc instanceof SyncDescriptor) {
          const instance = this._createServiceInstanceWithOwner(
            data.id,
            data.desc.ctor,
            data.desc.staticArguments,
            data.desc.supportsDelayedInstantiation,
            data._trace
          );
          this._setCreatedServiceInstance(data.id, instance);
        }
        graph.removeNode(data);
      }
    }
    return this._getServiceInstanceOrDescriptor(id2);
  }
  _createServiceInstanceWithOwner(id2, ctor, args = [], supportsDelayedInstantiation, _trace) {
    if (this._services.get(id2) instanceof SyncDescriptor) {
      return this._createServiceInstance(
        id2,
        ctor,
        args,
        supportsDelayedInstantiation,
        _trace,
        this._servicesToMaybeDispose
      );
    } else if (this._parent) {
      return this._parent._createServiceInstanceWithOwner(
        id2,
        ctor,
        args,
        supportsDelayedInstantiation,
        _trace
      );
    } else {
      throw new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);
    }
  }
  _createServiceInstance(id2, ctor, args = [], supportsDelayedInstantiation, _trace, disposeBucket) {
    if (!supportsDelayedInstantiation) {
      const result = this._createInstance(ctor, args, _trace);
      disposeBucket.add(result);
      return result;
    } else {
      const child2 = new InstantiationService(void 0, this._strict, this, this._enableTracing);
      child2._globalGraphImplicitDependency = String(id2);
      const earlyListeners = /* @__PURE__ */ new Map();
      const idle = new GlobalIdleValue(() => {
        const result = child2._createInstance(ctor, args, _trace);
        for (const [key2, values2] of earlyListeners) {
          const candidate = result[key2];
          if (typeof candidate === "function") {
            for (const value of values2) {
              value.disposable = candidate.apply(result, value.listener);
            }
          }
        }
        earlyListeners.clear();
        disposeBucket.add(result);
        return result;
      });
      return new Proxy(/* @__PURE__ */ Object.create(null), {
        get(target, key2) {
          if (!idle.isInitialized) {
            if (typeof key2 === "string" && (key2.startsWith("onDid") || key2.startsWith("onWill"))) {
              let list = earlyListeners.get(key2);
              if (!list) {
                list = new LinkedList();
                earlyListeners.set(key2, list);
              }
              const event2 = (callback, thisArg, disposables) => {
                if (idle.isInitialized) {
                  return idle.value[key2](callback, thisArg, disposables);
                } else {
                  const entry = {
                    listener: [callback, thisArg, disposables],
                    disposable: void 0
                  };
                  const rm = list.push(entry);
                  const result = toDisposable(() => {
                    var _a3;
                    rm();
                    (_a3 = entry.disposable) == null ? void 0 : _a3.dispose();
                  });
                  return result;
                }
              };
              return event2;
            }
          }
          if (key2 in target) {
            return target[key2];
          }
          const obj = idle.value;
          let prop2 = obj[key2];
          if (typeof prop2 !== "function") {
            return prop2;
          }
          prop2 = prop2.bind(obj);
          target[key2] = prop2;
          return prop2;
        },
        set(_target, p2, value) {
          idle.value[p2] = value;
          return true;
        },
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        getPrototypeOf(_target) {
          return ctor.prototype;
        }
      });
    }
  }
  _throwIfStrict(msg, printWarning) {
    if (printWarning) {
      console.warn(msg);
    }
    if (this._strict) {
      throw new Error(msg);
    }
  }
}
const _Trace = class _Trace {
  constructor(type, name) {
    __publicField(this, "_start", Date.now());
    __publicField(this, "_dep", []);
    this.type = type;
    this.name = name;
  }
  static traceInvocation(_enableTracing, ctor) {
    return !_enableTracing ? _Trace._None : new _Trace(
      2,
      ctor.name || new Error().stack.split("\n").slice(3, 4).join("\n")
    );
  }
  static traceCreation(_enableTracing, ctor) {
    return !_enableTracing ? _Trace._None : new _Trace(1, ctor.name);
  }
  branch(id2, first) {
    const child2 = new _Trace(3, id2.toString());
    this._dep.push([id2, first, child2]);
    return child2;
  }
  stop() {
    const dur = Date.now() - this._start;
    _Trace._totals += dur;
    let causedCreation = false;
    function printChild(n2, trace) {
      const res = [];
      const prefix = new Array(n2 + 1).join("	");
      for (const [id2, first, child2] of trace._dep) {
        if (first && child2) {
          causedCreation = true;
          res.push(`${prefix}CREATES -> ${id2}`);
          const nested = printChild(n2 + 1, child2);
          if (nested) {
            res.push(nested);
          }
        } else {
          res.push(`${prefix}uses -> ${id2}`);
        }
      }
      return res.join("\n");
    }
    const lines = [
      `${this.type === 1 ? "CREATE" : "CALL"} ${this.name}`,
      `${printChild(1, this)}`,
      `DONE, took ${dur.toFixed(2)}ms (grand total ${_Trace._totals.toFixed(2)}ms)`
    ];
    if (dur > 2 || causedCreation) {
      _Trace.all.add(lines.join("\n"));
    }
  }
};
__publicField(_Trace, "all", /* @__PURE__ */ new Set());
__publicField(_Trace, "_None", new class extends _Trace {
  constructor() {
    super(0, null);
  }
  stop() {
  }
  branch() {
    return this;
  }
}());
__publicField(_Trace, "_totals", 0);
let Trace = _Trace;
const en = {
  "tool.cursor.cross": "Cross",
  "tool.cursor.dot": "Dot",
  "tool.cursor.arrow": "Arrow",
  "tool.cursor.demo": "Demonstration",
  "tool.cursor.magic": "Magic",
  "tool.cursor.eraser": "Eraser",
  "toolGroup.line": "LINES",
  "tool.line.trendLine": "Trend Line",
  "tool.line.ray": "Ray",
  "tool.line.infoLine": "Info Line",
  "tool.line.extendedLine": "Extended Line",
  "tool.line.trendAngle": "Trend Angle",
  "tool.line.horizontalLine": "Horizontal Line",
  "tool.line.horizontalRay": "Horizontal Ray",
  "tool.line.verticalLine": "Vertical Line",
  "tool.line.crossLine": "Cross Line",
  "toolGroup.channel": "CHANNELS",
  "tool.channel.parallelChannel": "Parallel Channel",
  "tool.channel.regressionTrend": "Regression Trend",
  "tool.channel.flatTopBottom": "Flat Top/Bottom",
  "tool.channel.disjointChannel": "Disjoint Channel",
  "toolGroup.pitchfork": "PITCHFORKS",
  "tool.pitchfork.pitchfork": "Pitchfork",
  "tool.pitchfork.schiffPitchfork": "Schiff Pitchfork",
  "tool.pitchfork.modifiedSchiffPitchfork": "Modified Schiff Pitchfork",
  "tool.pitchfork.insidePitchfork": "Inside Pitchfork",
  "toolGroup.fib": "FIBONACCI",
  "tool.fib.fibRetracement": "Fib Retracement",
  "tool.fib.trendBasedFibExtension": "Trend-Based Fib Extension",
  "tool.fib.fibChannel": "Fib Channel",
  "tool.fib.fibTimeZone": "Fib Time Zone",
  "tool.fib.fibSpeedResistanceFan": "Fib Speed Resistance Fan",
  "tool.fib.trendBasedFibTime": "Trend-Based Fib Time",
  "tool.fib.fibCircles": "Fib Circles",
  "tool.fib.fibSpiral": "Fib Spiral",
  "tool.fib.fibSpeedResistanceArcs": "Fib Speed Resistance Arcs",
  "tool.fib.fibWedge": "Fib Wedge",
  "tool.fib.pitchfan": "Pitchfan",
  "toolGroup.gann": "GANN",
  "tool.gann.gannBox": "Gann Box",
  "tool.gann.gannSquareFixed": "Gann Square Fixed",
  "tool.gann.gannSquare": "Gann Square",
  "tool.gann.gannFan": "Gann Fan",
  "toolGroup.pattern": "PATTERNs",
  "tool.pattern.xabcd": "XABCD Pattern",
  "tool.pattern.cypher": "Cypher Pattern",
  "tool.pattern.headAndShoulders": "Head and Shoulders",
  "tool.pattern.abcd": "ABCD Pattern",
  "tool.pattern.triangle": "Triangle Pattern",
  "tool.pattern.threeDrives": "Three Drives Pattern",
  "toolGroup.wave": "ELLIOTT WAVE",
  "tool.wave.12345": "Elliott Impulse Wave (12345)",
  "tool.wave.abc": "Elliott Correction Wave (ABC)",
  "tool.wave.abcde": "Elliott Triangle Wave (ABCDE)",
  "tool.wave.wxy": "Elliott Double Combo Wave (WXY)",
  "tool.wave.wxyxz": "Elliott Triple Combo Wave (WXYXZ)",
  "toolGroup.cycle": "CYCLICS",
  "tool.cycle.cyclicLines": "Cyclic Lines",
  "tool.cycle.timeCycles": "Time Cycles",
  "tool.cycle.sineLine": "Sine Line",
  "toolGroup.proj": "PROJECTION",
  "tool.projection.longPosition": "Long Position",
  "tool.projection.shortPosition": "Short Position",
  "tool.projection.forecast": "Forecast",
  "tool.projection.barsPattern": "Bars Pattern",
  "tool.projection.ghostFeed": "Ghost Feed",
  "tool.projection.projection": "Projection",
  "toolGroup.volumn": "VOLUMN-BASED",
  "tool.volumnBased.anchoredVwap": "Anchored VWAP",
  "tool.volumnBased.fixedRangeVolumnProfile": "Fixed Range Volumn Profile",
  "tool.volumnBased.anchoredVolumnProfile": "Anchored Volumn Profile",
  "toolGroup.measurer": "MEASURER",
  "tool.measurer.priceRange": "Price Range",
  "tool.measurer.dateRange": "Date Range",
  "tool.measurer.dataAndPriceRange": "Date and Price Range",
  "toolGroup.brush": "BRUSHES",
  "tool.brush.brush": "Brush",
  "tool.brush.highlighter": "Highlighter",
  "toolGroup.arrow": "ARROWS",
  "tool.arrow.arrowMarker": "Arrow Marker",
  "tool.arrow.arrow": "Arrow",
  "tool.arrow.arrowMarkUp": "Arrow Mark Up",
  "tool.arrow.arrowMarkDown": "Arrow Mark Down",
  "tool.arrow.arrowMarkLeft": "Arrow Mark Left",
  "tool.arrow.arrowMarkRight": "Arrow Mark Right",
  "toolGroup.shape": "SHAPES",
  "tool.shape.rect": "Rectangle",
  "tool.shape.rotatedRect": "Rotated Rectangle",
  "tool.shape.path": "Path",
  "tool.shape.circle": "Circle",
  "tool.shape.ellipse": "Ellipse",
  "tool.shape.polyline": "Polyline",
  "tool.shape.triangle": "Triangle",
  "tool.shape.arc": "Arc",
  "tool.shape.curve": "Curve",
  "tool.shape.doubleCurve": "Double Curve",
  "toolGroup.text": "TEXT & NOTES",
  "tool.text.text": "Text",
  "tool.text.anchoredText": "Anchored Text",
  "tool.text.note": "Note",
  "tool.text.priceNote": "Price Note",
  "tool.text.pin": "Pin",
  "tool.text.pinFixed": "Anchored Pin",
  "tool.text.table": "Table",
  "tool.text.callout": "Callout",
  "tool.text.comment": "Comment",
  "tool.text.priceLabel": "Price Label",
  "tool.text.signpost": "Signpost",
  "tool.text.flagMark": "Flag Mark",
  "toolGroup.content": "CONTENT",
  "tool.content.image": "Image",
  "tool.emoji": "Emoji",
  "tool.sticker": "Sticker",
  "tool.icon": "Icons",
  "tool.emoji.group.smiles&people": "smiles & people",
  "tool.emoji.group.animals&nature": "animals & nature",
  "tool.emoji.group.food&drink": "food & drink",
  "tool.emoji.group.activity": "activity",
  "tool.emoji.group.travel&places": "travel & places",
  "tool.emoji.group.objects": "objects",
  "tool.emoji.group.symbols": "symbols",
  "tool.emoji.group.flags": "flags",
  "tool.icon.group.gestures&smileys": "GESTURES & SMILEYS",
  "tool.icon.group.symbols&flags": "SYMBOLS & FLAGS",
  "tool.icon.group.nature": "NATURE",
  "tool.icon.group.currency": "CURRENCY",
  "tool.icon.group.objects": "OBJECTS",
  "tool.icon.group.arrows": "ARROWS",
  "tool.measure": "Measure",
  "tool.measure.after": " + click on the chart",
  "tool.zoomIn": "Zoom In",
  "tool.zoomOut": "Zoom Out",
  "tool.magnet": "Magnet Mode snaps drawings placed near price bars to the closest OHLC value",
  "tool.keepDraw": "Keep drawing",
  "tool.lockDraw": "Lock All drawings",
  "tool.hide.hideAll": "Hide all drawings, indicators, positions & orders",
  "tool.hide.showAll": "Show all drawings, indicators, positions & orders",
  "tool.hide.hideDrawing": "Hide all drawings",
  "tool.hide.showDrawing": "Show all drawings",
  "tool.hide.hideIndicator": "Hide all indicators",
  "tool.hide.showIndicator": "Show all indicators",
  "tool.hide.hidePosition": "Hide all positions & orders",
  "tool.hide.showPosition": "Show all positions & orders",
  "tool.removeObjects": "Remove objects",
  "tool.more.cursor": "Cursor",
  "tool.more.trendLine": "Trend line tools",
  "tool.more.channel": "Channel tools",
  "tool.more.gannAndFib": "Gann and Fibonacci tools",
  "tool.more.pattern": "Patterns",
  "tool.more.forecastAndMeasure": "Forecasting and measurement tools",
  "tool.more.shapes": "Geometric shapes",
  "tool.more.annotation": "Annotation tools",
  "tool.more.icons": "Icons",
  "tool.more.magnet": "Magnets",
  "tool.more.hide": "Hide Options",
  "tool.more.remove": "Remove options",
  "tool.magnet.weak": "Weak Magnet",
  "tool.magnet.strong": "Strong Magnet",
  "tool.remove.drawing": "Remove {draw} drawings",
  "tool.remove.indicator": "Remove {ind} indicators",
  "tool.remove.drawingAndIndicator": "Remove {draw} indicators & {ind} indicators",
  "resolutionGroup.ticks": "TICKS",
  "resolutionGroup.seconds": "SECONDS",
  "resolutionGroup.minutes": "MINUTES",
  "resolutionGroup.hours": "HOURS",
  "resolutionGroup.days": "DAYS",
  "resolution.tick": "1 tick",
  "resolution.tick_plural": "{count} ticks",
  "resolution.second": "1 second",
  "resolution.second_plural": "{count} seconds",
  "resolution.minute": "1 minute",
  "resolution.minute_plural": "{count} minutes",
  "resolution.hour": "1 hour",
  "resolution.hour_plural": "{count} hours",
  "resolution.day": "1 day",
  "resolution.day_plural": "{count} days",
  "resolution.weak": "1 weak",
  "resolution.weak_plural": "{count} weaks",
  "resolution.month": "1 month",
  "resolution.month_plural": "{count} months",
  "resolution.year": "1 year",
  "resolution.year_plural": "{count} years",
  "resolution.timeSpan.day": "d",
  "resolution.timeSpan.hour": "h",
  "resolution.timeSpan.minute": "m",
  "resolution.timeSpan.second": "s",
  "chartStyle.bar": "Bars",
  "chartStyle.candle": "Candles",
  "chartStyle.hollowCandle": "Hollow Candles",
  "chartStyle.line": "Line",
  "chartStyle.area": "Area",
  "topToolbar.symbolSearch": "Symbol Search",
  "topToolbar.compare": "Compare or Add Symbol",
  "topToolbar.indicator": "Indicators",
  "topToolbar.indicator.tip": "Indicators",
  "topToolbar.layout": "Layout setup",
  "topToolbar.setting": "Chart settings",
  "topToolbar.fullscreen": "Fullscreen mode",
  "topToolbar.snapshot": "Take a snapshot",
  "topToolbar.snapshot.menu.title": "CHART SNAPSHOT",
  "topToolbar.snapshot.downloadImage": "Download image",
  "topToolbar.snapshot.copyImage": "Copy image",
  "topToolbar.snapshot.copyImage.success": "Chart image copied to clipboard",
  "legend.changeSymbol": "Change Symbol",
  "legend.changeInterval": "Change interval",
  "legend.more": "More",
  "legend.remove": "Remove",
  "legend.main.open": "O",
  "legend.main.high": "H",
  "legend.main.low": "L",
  "legend.main.close": "C",
  "legend.main.showLess": "Hide indicator legend",
  "legend.main.showMore": "Show indicator legend",
  "legend.error.symbol": "Symbol Error",
  "legend.error.runtime": "Runtime Error",
  "indicator.dialog.title": "Indicators",
  "indicator.dialog.script": "SCRIPT NAME",
  "setting.title": "Chart settings",
  "setting.timezone": "Timezone",
  "crosshairMenu.buyLimit": "Buy 1 {symbol} @ {ask} limit",
  "crosshairMenu.sellStop": "Sell 1 {symbol} @ {bid} stop",
  "crosshairMenu.newOrder": "Create new order…",
  "crosshairMenu.settings": "Trading settings...",
  "crosshairMenu.draw": "Draw Horizontal Line at {price}",
  "common.search": "Search",
  "common.cancel": "Cancel",
  "common.ok": "Ok",
  "trade.buy": "Buy",
  "trade.sell": "Buy",
  "tool.tradeLine.buy": "Buy",
  "tool.tradeLine.sell": "Sell",
  "tool.tradeLine.tp": "TP",
  "tool.tradeLine.sl": "SL",
  "tool.tradeLine.qty": "{qty}Lots",
  "tradePrimitive.execution.tip": "{side} {qty} @ {price}",
  "tool.line.common.bars": "{count} bars",
  "tool.line.common.distance": "distance: {distance}",
  "tool.headAndShoulders.left": "Left Shoulder",
  "tool.headAndShoulders.head": "Head",
  "tool.headAndShoulders.right": "Right Shoulder",
  "tool.position.target": "Target: {profitChange}({profitChangePercent}) {profitChangePip}, Amount: {amount}",
  "tool.position.open": "Open",
  "tool.position.close": "Close",
  "tool.position.pnl": "{status} P&L: {pnl}",
  "tool.position.qty": "Qty: {qty}",
  "tool.position.ratio": "Risk/Reward Ratio: {riskRewardRatio}",
  "tool.position.stop": "Stop: {stopChange}({stopChangePercent}) {stopChangePip}, Amount: {amount}",
  "tool.forecast.success": "SUCCESS",
  "tool.forecast.failure": "FAILURE",
  "tool.forecast.in": "in {timeSpan}",
  "tool.text.common.addText": "Add text",
  "tool.image.dialog.title": "Image",
  "tool.image.dialog.choose": "Choose Image",
  "tool.image.dialog.imageTypes": "JPG, PNG or WEBP",
  "tool.image.dialog.sizeLimit": "Max size 2MB",
  "contextMenu.clone": "Clone",
  "contextMenu.clone.kb.drag": "Drag",
  "contextMenu.copy": "Copy",
  "priceAxis.mode.regular": "Regular",
  "priceAxis.mode.log": "Logarithmic",
  "priceAxis.mode.percent": "Percent",
  "drawingBar.show": "Show Drawings Toolbar",
  "drawingBar.hide": "Hide Drawings Toolbar",
  "tz.Etc/UTC": "UTC",
  "tz.exchange": "Exchange",
  "tz.Africa/Cairo": "Cairo",
  "tz.Africa/Casablanca": "Casablanca",
  "tz.Africa/Johannesburg": "Johannesburg",
  "tz.Africa/Lagos": "Lagos",
  "tz.Africa/Nairobi": "Nairobi",
  "tz.Africa/Tunis": "Tunis",
  "tz.America/Anchorage": "Anchorage",
  "tz.America/Argentina/Buenos_Aires": "Buenos_Aires",
  "tz.America/Bogota": "Bogota",
  "tz.America/Caracas": "Caracas",
  "tz.America/Chicago": "Chicago",
  "tz.America/El_Salvador": "El_Salvador",
  "tz.America/Juneau": "Juneau",
  "tz.America/Lima": "Lima",
  "tz.America/Los_Angeles": "Los_Angeles",
  "tz.America/Mexico_City": "Mexico_City",
  "tz.America/New_York": "New_York",
  "tz.America/Phoenix": "Phoenix",
  "tz.America/Santiago": "Santiago",
  "tz.America/Sao_Paulo": "Sao_Paulo",
  "tz.America/Toronto": "Toronto",
  "tz.America/Vancouver": "Vancouver",
  "tz.US/Mountain": "Mountain",
  "tz.Asia/Almaty": "Almaty",
  "tz.Asia/Ashkhabad": "Ashkhabad",
  "tz.Asia/Bahrain": "Bahrain",
  "tz.Asia/Bangkok": "Bangkok",
  "tz.Asia/Chongqing": "Chongqing",
  "tz.Asia/Colombo": "Colombo",
  "tz.Asia/Dhaka": "Dhaka",
  "tz.Asia/Dubai": "Dubai",
  "tz.Asia/Ho_Chi_Minh": "Ho_Chi_Minh",
  "tz.Asia/Hong_Kong": "Hong_Kong",
  "tz.Asia/Jakarta": "Jakarta",
  "tz.Asia/Jerusalem": "Jerusalem",
  "tz.Asia/Karachi": "Karachi",
  "tz.Asia/Kathmandu": "Kathmandu",
  "tz.Asia/Kolkata": "Kolkata",
  "tz.Asia/Kuala_Lumpur": "Kuala_Lumpur",
  "tz.Asia/Kuwait": "Kuwait",
  "tz.Asia/Manila": "Manila",
  "tz.Asia/Muscat": "Muscat",
  "tz.Asia/Nicosia": "Nicosia",
  "tz.Asia/Qatar": "Qatar",
  "tz.Asia/Riyadh": "Riyadh",
  "tz.Asia/Seoul": "Seoul",
  "tz.Asia/Shanghai": "Shanghai",
  "tz.Asia/Singapore": "Singapore",
  "tz.Asia/Taipei": "Taipei",
  "tz.Asia/Tehran": "Tehran",
  "tz.Asia/Tokyo": "Tokyo",
  "tz.Asia/Yangon": "Yangon",
  "tz.Atlantic/Azores": "Azores",
  "tz.Atlantic/Reykjavik": "Reykjavik",
  "tz.Australia/Adelaide": "Adelaide",
  "tz.Australia/Brisbane": "Brisbane",
  "tz.Australia/Perth": "Perth",
  "tz.Australia/Sydney": "Sydney",
  "tz.Europe/Amsterdam": "Amsterdam",
  "tz.Europe/Athens": "Athens",
  "tz.Europe/Belgrade": "Belgrade",
  "tz.Europe/Berlin": "Berlin",
  "tz.Europe/Bratislava": "Bratislava",
  "tz.Europe/Brussels": "Brussels",
  "tz.Europe/Bucharest": "Bucharest",
  "tz.Europe/Budapest": "Budapest",
  "tz.Europe/Copenhagen": "Copenhagen",
  "tz.Europe/Dublin": "Dublin",
  "tz.Europe/Helsinki": "Helsinki",
  "tz.Europe/Istanbul": "Istanbul",
  "tz.Europe/Lisbon": "Lisbon",
  "tz.Europe/London": "London",
  "tz.Europe/Luxembourg": "Luxembourg",
  "tz.Europe/Madrid": "Madrid",
  "tz.Europe/Malta": "Malta",
  "tz.Europe/Moscow": "Moscow",
  "tz.Europe/Oslo": "Oslo",
  "tz.Europe/Paris": "Paris",
  "tz.Europe/Prague": "Prague",
  "tz.Europe/Riga": "Riga",
  "tz.Europe/Rome": "Rome",
  "tz.Europe/Stockholm": "Stockholm",
  "tz.Europe/Tallinn": "Tallinn",
  "tz.Europe/Vienna": "Vienna",
  "tz.Europe/Vilnius": "Vilnius",
  "tz.Europe/Warsaw": "Warsaw",
  "tz.Europe/Zurich": "Zurich",
  "tz.Pacific/Auckland": "Auckland",
  "tz.Pacific/Chatham": "Chatham",
  "tz.Pacific/Fakaofo": "Fakaofo",
  "tz.Pacific/Honolulu": "Honolulu",
  "tz.Pacific/Norfolk": "Norfolk",
  "nav.scrollToRealtime": "Scroll to the most recent bar",
  "errors.noData": "No data here",
  "tradeLineMenu.modifyOrder": "Modify order",
  "tradeLineMenu.cancelOrder": "Cancel order",
  "tradeLineMenu.modifyPosition": "Modify position",
  "tradeLineMenu.closePosition": "Close position"
};
const localeDateFormats = {
  "zh-CN": "yyyy-MM-dd",
  // 简体中文（中国）
  "en-US": `dd MMM ''yy`,
  // 英语（美国），连续的 '' 是 date-fns 所需要的转义
  "fr-FR": "dd/MM/yyyy",
  // 法语（法国）
  "de-DE": "dd.MM.yyyy",
  // 德语（德国）
  "id-ID": "dd/MM/yyyy",
  // 印尼语（印尼）
  "ja-JP": "yyyy/MM/dd",
  // 日语（日本）
  "ko-KR": "yyyy. M. d.",
  // 韩语（韩国）
  "pl-PL": "dd.MM.yyyy",
  // 波兰语（波兰）
  "pt-BR": "dd/MM/yyyy",
  // 葡萄牙语（巴西）
  "es-ES": "dd/MM/yyyy",
  // 西班牙语（西班牙）
  "th-TH": "d/M/yyyy",
  // 泰语（泰国，注意佛历）
  "vi-VN": "dd/MM/yyyy",
  // 越南语（越南）
  "ms-MY": "dd/MM/yyyy",
  // 马来语（马来西亚）
  "zh-TW": "yyyy-MM-dd"
  // 繁体中文（台湾）
};
const InvalidTranslation = [null, void 0, ""];
function translate(langDict, targetLocale, key2, params) {
  try {
    let str = langDict[targetLocale][key2];
    if (InvalidTranslation.includes(str)) return "";
    if (params && "count" in params && Number(params.count) > 1) {
      const strPlural = langDict[targetLocale][key2 + "_plural"];
      if (strPlural) str = strPlural;
    }
    if (params) {
      Reflect.ownKeys(params).forEach((item) => {
        str = str.replace(new RegExp(`{${item}}`, "g"), `${params[item]}`);
      });
    }
    return str;
  } catch {
    console.warn(`can not found [${targetLocale}] translation file`);
    return key2;
  }
}
const dicts = { en };
class IntlService {
  constructor(locale) {
    __publicField(this, "_serviceBrand");
    this.locale = locale;
  }
  dateFormat() {
    return ensure(localeDateFormats[this.locale]);
  }
  dateTimeFormat(showSecond) {
    return `${this.dateFormat()} HH:mm${showSecond ? ":ss" : ""}`;
  }
  t(key2, values2) {
    if (!key2) return "";
    return translate(dicts, "en", key2, values2);
  }
  isI18nKey(str) {
    return Reflect.has(dicts["en"], str);
  }
  formatNumber(val) {
    return val.toFixed(0);
  }
}
const ILogService = createDecorator$1("logService");
const DEFAULT_LOG_LEVEL = 3;
class AbstractLogger extends Disposable {
  constructor() {
    super(...arguments);
    __publicField(this, "level", DEFAULT_LOG_LEVEL);
    __publicField(this, "_onDidChangeLogLevel", this._register(
      new Emitter()
    ));
    __publicField(this, "onDidChangeLogLevel", this._onDidChangeLogLevel.event);
  }
  setLevel(level) {
    if (this.level !== level) {
      this.level = level;
      this._onDidChangeLogLevel.fire(this.level);
    }
  }
  getLevel() {
    return this.level;
  }
  checkLogLevel(level) {
    return this.level !== 0 && this.level <= level;
  }
  canLog(level) {
    if (this._store.isDisposed) {
      return false;
    }
    return this.checkLogLevel(level);
  }
}
class ConsoleLogger extends AbstractLogger {
  constructor(logLevel = DEFAULT_LOG_LEVEL, useColors = true) {
    super();
    this.useColors = useColors;
    this.setLevel(logLevel);
  }
  trace(message2, ...args) {
    if (this.canLog(
      1
      /* Trace */
    )) {
      if (this.useColors) {
        console.log("%cTRACE", "color: #888", message2, ...args);
      } else {
        console.log(message2, ...args);
      }
    }
  }
  debug(message2, ...args) {
    if (this.canLog(
      2
      /* Debug */
    )) {
      if (this.useColors) {
        console.log("%cDEBUG", "background: #eee; color: #888", message2, ...args);
      } else {
        console.log(message2, ...args);
      }
    }
  }
  info(message2, ...args) {
    if (this.canLog(
      3
      /* Info */
    )) {
      if (this.useColors) {
        console.log("%c INFO", "color: #33f", message2, ...args);
      } else {
        console.log(message2, ...args);
      }
    }
  }
  warn(message2, ...args) {
    if (this.canLog(
      4
      /* Warning */
    )) {
      if (this.useColors) {
        console.warn("%c WARN", "color: #993", message2, ...args);
      } else {
        console.log(message2, ...args);
      }
    }
  }
  error(message2, ...args) {
    if (this.canLog(
      5
      /* Error */
    )) {
      if (this.useColors) {
        console.error("%c  ERR", "color: #f33", message2, ...args);
      } else {
        console.error(message2, ...args);
      }
    }
  }
  flush() {
  }
}
var ResultKind = /* @__PURE__ */ ((ResultKind2) => {
  ResultKind2[ResultKind2["NoMatchingKb"] = 0] = "NoMatchingKb";
  ResultKind2[ResultKind2["MoreChordsNeeded"] = 1] = "MoreChordsNeeded";
  ResultKind2[ResultKind2["KbFound"] = 2] = "KbFound";
  return ResultKind2;
})(ResultKind || {});
const NoMatchingKb = {
  kind: 0
  /* NoMatchingKb */
};
const MoreChordsNeeded = {
  kind: 1
  /* MoreChordsNeeded */
};
function KbFound(commandId, commandArgs, isBubble) {
  return { kind: 2, commandId, commandArgs, isBubble };
}
class KeybindingResolver {
  constructor(defaultKeybindings, overrides, log, _instantiationService) {
    __publicField(this, "_log");
    __publicField(this, "_defaultKeybindings");
    __publicField(this, "_keybindings");
    __publicField(this, "_defaultBoundCommands");
    __publicField(this, "_map");
    __publicField(this, "_lookupMap");
    this._instantiationService = _instantiationService;
    this._log = log;
    this._defaultKeybindings = defaultKeybindings;
    this._defaultBoundCommands = /* @__PURE__ */ new Map();
    for (const defaultKeybinding of defaultKeybindings) {
      const command = defaultKeybinding.command;
      if (command && command.charAt(0) !== "-") {
        this._defaultBoundCommands.set(command, true);
      }
    }
    this._map = /* @__PURE__ */ new Map();
    this._lookupMap = /* @__PURE__ */ new Map();
    this._keybindings = KeybindingResolver.handleRemovals(
      [].concat(defaultKeybindings).concat(overrides)
    );
    for (let i2 = 0, len = this._keybindings.length; i2 < len; i2++) {
      const k2 = this._keybindings[i2];
      if (k2.chords.length === 0) {
        continue;
      }
      this._addKeyPress(k2.chords[0], k2);
    }
  }
  static _isTargetedForRemoval(defaultKb, keypress) {
    if (keypress) {
      for (let i2 = 0; i2 < keypress.length; i2++) {
        if (keypress[i2] !== defaultKb.chords[i2]) {
          return false;
        }
      }
    }
    return true;
  }
  /**
   * Looks for rules containing "-commandId" and removes them.
   */
  static handleRemovals(rules) {
    const removals = /* @__PURE__ */ new Map();
    for (let i2 = 0, len = rules.length; i2 < len; i2++) {
      const rule = rules[i2];
      if (rule.command && rule.command.charAt(0) === "-") {
        const command = rule.command.substring(1);
        if (!removals.has(command)) {
          removals.set(command, [rule]);
        } else {
          removals.get(command).push(rule);
        }
      }
    }
    if (removals.size === 0) {
      return rules;
    }
    const result = [];
    for (let i2 = 0, len = rules.length; i2 < len; i2++) {
      const rule = rules[i2];
      if (!rule.command || rule.command.length === 0) {
        result.push(rule);
        continue;
      }
      if (rule.command.charAt(0) === "-") {
        continue;
      }
      const commandRemovals = removals.get(rule.command);
      if (!commandRemovals || !rule.isDefault) {
        result.push(rule);
        continue;
      }
      let isRemoved = false;
      for (const commandRemoval of commandRemovals) {
        if (this._isTargetedForRemoval(
          rule,
          commandRemoval.chords
          /*, when*/
        )) {
          isRemoved = true;
          break;
        }
      }
      if (!isRemoved) {
        result.push(rule);
        continue;
      }
    }
    return result;
  }
  _addKeyPress(keypress, item) {
    const conflicts = this._map.get(keypress);
    if (typeof conflicts === "undefined") {
      this._map.set(keypress, [item]);
      this._addToLookupMap(item);
      return;
    }
    for (let i2 = conflicts.length - 1; i2 >= 0; i2--) {
      const conflict = conflicts[i2];
      if (conflict.command === item.command) {
        continue;
      }
      let isShorterKbPrefix = true;
      for (let i22 = 1; i22 < conflict.chords.length && i22 < item.chords.length; i22++) {
        if (conflict.chords[i22] !== item.chords[i22]) {
          isShorterKbPrefix = false;
          break;
        }
      }
      if (!isShorterKbPrefix) {
        continue;
      }
      this._removeFromLookupMap(conflict);
    }
    conflicts.push(item);
    this._addToLookupMap(item);
  }
  _addToLookupMap(item) {
    if (!item.command) {
      return;
    }
    let arr = this._lookupMap.get(item.command);
    if (typeof arr === "undefined") {
      arr = [item];
      this._lookupMap.set(item.command, arr);
    } else {
      arr.push(item);
    }
  }
  _removeFromLookupMap(item) {
    if (!item.command) {
      return;
    }
    const arr = this._lookupMap.get(item.command);
    if (typeof arr === "undefined") {
      return;
    }
    for (let i2 = 0, len = arr.length; i2 < len; i2++) {
      if (arr[i2] === item) {
        arr.splice(i2, 1);
        return;
      }
    }
  }
  getDefaultBoundCommands() {
    return this._defaultBoundCommands;
  }
  getDefaultKeybindings() {
    return this._defaultKeybindings;
  }
  getKeybindings() {
    return this._keybindings;
  }
  lookupKeybindings(commandId) {
    const items = this._lookupMap.get(commandId);
    if (typeof items === "undefined" || items.length === 0) {
      return [];
    }
    const result = [];
    let resultLen = 0;
    for (let i2 = items.length - 1; i2 >= 0; i2--) {
      result[resultLen++] = items[i2];
    }
    return result;
  }
  // public lookupPrimaryKeybinding(
  //   commandId: string,
  //   context: IContextKeyService,
  //   enforceContextCheck = false,
  // ): ResolvedKeybindingItem | null {
  //   const items = this._lookupMap.get(commandId);
  //
  //   if (typeof items === 'undefined' || items.length === 0) {
  //     return null;
  //   }
  //
  //   if (items.length === 1 && !enforceContextCheck) {
  //     return items[0];
  //   }
  //
  //   for (let i = items.length - 1; i >= 0; i--) {
  //     const item = items[i];
  //
  //     if (context.contextMatchesRules(item.when)) {
  //       return item;
  //     }
  //   }
  //
  //   if (enforceContextCheck) {
  //     return null;
  //   }
  //
  //   return items[items.length - 1];
  // }
  /**
   * Looks up a keybinding trigged as a result of pressing a sequence of chords - `[...currentChords, keypress]`
   *
   * Example: resolving 3 chords pressed sequentially - `cmd+k cmd+p cmd+i`:
   * 	`currentChords = [ 'cmd+k' , 'cmd+p' ]` and `keypress = `cmd+i` - last pressed chord
   */
  resolve(context, currentChords, keypress) {
    const pressedChords = [...currentChords, keypress];
    this._log(`| Resolving ${pressedChords}`);
    const kbCandidates = this._map.get(pressedChords[0]);
    if (kbCandidates === void 0) {
      this._log(`\\ No keybinding entries.`);
      return NoMatchingKb;
    }
    let lookupMap = null;
    if (pressedChords.length < 2) {
      lookupMap = kbCandidates;
    } else {
      lookupMap = [];
      for (let i2 = 0, len = kbCandidates.length; i2 < len; i2++) {
        const candidate = kbCandidates[i2];
        if (pressedChords.length > candidate.chords.length) {
          continue;
        }
        let prefixMatches = true;
        for (let i22 = 1; i22 < pressedChords.length; i22++) {
          if (candidate.chords[i22] !== pressedChords[i22]) {
            prefixMatches = false;
            break;
          }
        }
        if (prefixMatches) {
          lookupMap.push(candidate);
        }
      }
    }
    const result = this._findCommand(context, lookupMap);
    if (!result) {
      this._log(
        `\\ From ${lookupMap.length} keybinding entries, no when clauses matched the context.`
      );
      return NoMatchingKb;
    }
    if (pressedChords.length < result.chords.length) {
      this._log(
        `\\ From ${lookupMap.length} keybinding entries, awaiting ${result.chords.length - pressedChords.length} more chord(s), when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`
      );
      return MoreChordsNeeded;
    }
    this._log(
      `\\ From ${lookupMap.length} keybinding entries, matched ${result.command}, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`
    );
    return KbFound(result.command, result.commandArgs, result.bubble);
  }
  _findCommand(context, matches2) {
    for (let i2 = matches2.length - 1; i2 >= 0; i2--) {
      const k2 = matches2[i2];
      if (!this._contextMatchesRules(context, k2.when)) {
        continue;
      }
      return k2;
    }
    return null;
  }
  _contextMatchesRules(context, rules) {
    if (!rules) {
      return true;
    }
    return this._instantiationService.invokeFunction((accessor) => {
      return rules(context, accessor);
    });
  }
}
function printWhenExplanation(when) {
  if (!when) {
    return `no when condition`;
  }
  return `${when.toString()}`;
}
function printSourceExplanation(kb) {
  return kb.extensionId ? kb.isBuiltinExtension ? `built-in extension ${kb.extensionId}` : `user extension ${kb.extensionId}` : kb.isDefault ? `built-in` : `user`;
}
class ModifierLabelProvider {
  constructor(mac, windows, linux = windows) {
    __publicField(this, "modifierLabels");
    this.modifierLabels = [null];
    this.modifierLabels[OperatingSystem.Macintosh] = mac;
    this.modifierLabels[OperatingSystem.Windows] = windows;
    this.modifierLabels[OperatingSystem.Linux] = linux;
  }
  toLabel(OS2, chords, keyLabelProvider) {
    if (chords.length === 0) {
      return null;
    }
    const result = [];
    for (let i2 = 0, len = chords.length; i2 < len; i2++) {
      const chord = chords[i2];
      const keyLabel = keyLabelProvider(chord);
      if (keyLabel === null) {
        return null;
      }
      result[i2] = _simpleAsString(chord, keyLabel, this.modifierLabels[OS2]);
    }
    return result.join(" ");
  }
}
function _simpleAsString(modifiers, key2, labels) {
  if (key2 === null) {
    return "";
  }
  const result = [];
  if (modifiers.ctrlKey) {
    result.push(labels.ctrlKey);
  }
  if (modifiers.shiftKey) {
    result.push(labels.shiftKey);
  }
  if (modifiers.altKey) {
    result.push(labels.altKey);
  }
  if (modifiers.metaKey) {
    result.push(labels.metaKey);
  }
  if (key2 !== "") {
    result.push(key2);
  }
  return result.join(labels.separator);
}
const UILabelProvider = new ModifierLabelProvider(
  {
    ctrlKey: "⌃",
    shiftKey: "⇧",
    altKey: "⌥",
    metaKey: "⌘",
    separator: ""
  },
  {
    ctrlKey: "Ctrl",
    shiftKey: "Shift",
    altKey: "Alt",
    metaKey: "Windows",
    separator: "+"
  },
  {
    ctrlKey: "Ctrl",
    shiftKey: "Shift",
    altKey: "Alt",
    metaKey: "Super",
    separator: "+"
  }
);
const cache = /* @__PURE__ */ new Map();
function getKeybindingLabel(keybinding, os2 = OS) {
  if (cache.has(keybinding)) return cache.get(keybinding) ?? "";
  const kb = decodeKeybinding(keybinding, os2);
  let ret = "";
  if (kb) {
    ret = UILabelProvider.toLabel(os2, kb.chords, (chord) => keyCodeToChar[chord.keyCode]) ?? "";
  }
  cache.set(keybinding, ret);
  return ret;
}
class ResolvedKeybindingItem {
  constructor(resolvedKeybinding, command, commandArgs, when, isDefault, extensionId, isBuiltinExtension) {
    __publicField(this, "_resolvedKeybindingItemBrand");
    __publicField(this, "resolvedKeybinding");
    __publicField(this, "chords");
    __publicField(this, "bubble");
    __publicField(this, "command");
    __publicField(this, "commandArgs");
    __publicField(this, "when");
    __publicField(this, "isDefault");
    __publicField(this, "extensionId");
    __publicField(this, "isBuiltinExtension");
    this.resolvedKeybinding = resolvedKeybinding;
    this.chords = resolvedKeybinding ? toEmptyArrayIfContainsNull(resolvedKeybinding.getDispatchChords()) : [];
    if (resolvedKeybinding && this.chords.length === 0) {
      NOTREACHED();
    }
    this.bubble = command ? command.charCodeAt(0) === CharCode.Caret : false;
    this.command = this.bubble ? command.substr(1) : command;
    this.commandArgs = commandArgs;
    this.when = when;
    this.isDefault = isDefault;
    this.extensionId = extensionId;
    this.isBuiltinExtension = isBuiltinExtension;
  }
}
function toEmptyArrayIfContainsNull(arr) {
  const result = [];
  for (let i2 = 0, len = arr.length; i2 < len; i2++) {
    const element2 = arr[i2];
    if (!element2) {
      return [];
    }
    result.push(element2);
  }
  return result;
}
class ResolvedKeybinding {
  constructor(os2, chords) {
    __publicField(this, "_os");
    __publicField(this, "_chords");
    if (chords.length === 0) {
      throw illegalArgument(`chords`);
    }
    this._os = os2;
    this._chords = chords;
  }
  getLabel() {
    return UILabelProvider.toLabel(
      this._os,
      this._chords,
      (keybinding) => this._getLabel(keybinding)
    );
  }
  getDispatchChords() {
    return this._chords.map((keybinding) => this._getChordDispatch(keybinding));
  }
  _getLabel(chord) {
    if (chord.isDuplicateModifierCase()) {
      return "";
    }
    return this._keyCodeToUILabel(chord.keyCode);
  }
  _keyCodeToUILabel(keyCode) {
    return keyCodeToChar[keyCode];
  }
  _getChordDispatch(chord) {
    return getDispatchStr(chord);
  }
  static resolveKeybinding(keybinding, os2) {
    const chords = toEmptyArrayIfContainsNull(keybinding.chords);
    if (chords.length > 0) {
      return [new ResolvedKeybinding(os2, chords)];
    }
    return [];
  }
}
function getDispatchStr(chord) {
  if (chord.isModifierKey()) {
    return null;
  }
  let result = "";
  if (chord.ctrlKey) {
    result += "ctrl+";
  }
  if (chord.shiftKey) {
    result += "shift+";
  }
  if (chord.altKey) {
    result += "alt+";
  }
  if (chord.metaKey) {
    result += "meta+";
  }
  result += KeyCodeUtils.toString(chord.keyCode);
  return result;
}
var __getOwnPropDesc$6 = Object.getOwnPropertyDescriptor;
var __decorateClass$6 = (decorators, target, key2, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$6(target, key2) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$6 = (index2, decorator) => (target, key2) => decorator(target, key2, index2);
let KeybindingService = class extends Disposable {
  constructor(host, shadowRoot, _commandService, _logService, _contextKeyService, _instantiationService, keybindingsRegistry, chartManagementService) {
    super();
    __publicField(this, "_serviceBrand");
    __publicField(this, "_logging", false);
    __publicField(this, "_cachedResolver");
    __publicField(this, "_dynamicKeybindings");
    __publicField(this, "_currentlyDispatchingCommandId");
    this._commandService = _commandService;
    this._logService = _logService;
    this._contextKeyService = _contextKeyService;
    this._instantiationService = _instantiationService;
    this.keybindingsRegistry = keybindingsRegistry;
    this._cachedResolver = null;
    this._dynamicKeybindings = [];
    this._currentlyDispatchingCommandId = null;
    this._register(
      addStandardDisposableListener(host, "keydown", (e2) => {
        if (!shadowRoot.activeElement) {
          const chart = chartManagementService.activeChart();
          if (!chart) return;
          const shouldBeActive = chart.getContainerDomElement();
          shouldBeActive.focus();
          this.dispatchEvent(e2, shouldBeActive);
        }
      })
    );
    this._register(
      addDisposableListener(shadowRoot, "focusin", () => {
        const chart = chartManagementService.activeChart();
        if (!chart) return;
        const shouldBeActive = chart.getContainerDomElement();
        const activeElement = shadowRoot.activeElement;
        const win = activeElement == null ? void 0 : activeElement.ownerDocument.defaultView;
        const isInput = win && (activeElement instanceof win.HTMLInputElement || activeElement instanceof win.HTMLTextAreaElement);
        if (activeElement && !isInput && shadowRoot.contains(activeElement) && activeElement !== shouldBeActive) {
          shouldBeActive.focus();
        }
      })
    );
  }
  dispatchEvent(e2, target) {
    return this._dispatch(e2, target);
  }
  _dispatch(e2, target) {
    return this._doDispatch(this.resolveKeyboardEvent(e2), target);
  }
  _doDispatch(userKeypress, target) {
    let shouldPreventDefault = false;
    const [userPressedChord] = userKeypress.getDispatchChords();
    if (userPressedChord === null) {
      this._log(`\\ Keyboard event cannot be dispatched in keydown phase.`);
      return shouldPreventDefault;
    }
    const contextValue = this._contextKeyService.getContext(target);
    const keypressLabel = userKeypress.getLabel();
    const resolveResult = this._getResolver().resolve(contextValue, [], userPressedChord);
    switch (resolveResult.kind) {
      case ResultKind.NoMatchingKb: {
        this._logService.trace(
          "KeybindingService#dispatch",
          keypressLabel,
          `[ No matching keybinding ]`
        );
        return shouldPreventDefault;
      }
      case ResultKind.MoreChordsNeeded: {
        return NOTREACHED();
      }
      case ResultKind.KbFound: {
        this._logService.trace(
          "KeybindingService#dispatch",
          keypressLabel,
          `[ Will dispatch command ${resolveResult.commandId} ]`
        );
        if (resolveResult.commandId === null || resolveResult.commandId === "") ;
        else {
          if (!resolveResult.isBubble) {
            shouldPreventDefault = true;
          }
          this._log(`+ Invoking command ${resolveResult.commandId}.`);
          this._currentlyDispatchingCommandId = resolveResult.commandId;
          try {
            if (typeof resolveResult.commandArgs === "undefined") {
              this._commandService.executeCommand(resolveResult.commandId).then(void 0, (err) => this._logService.warn(err));
            } else {
              this._commandService.executeCommand(resolveResult.commandId, resolveResult.commandArgs).then(void 0, (err) => this._logService.warn(err));
            }
          } finally {
            this._currentlyDispatchingCommandId = null;
          }
        }
        return shouldPreventDefault;
      }
    }
  }
  _getResolver() {
    if (!this._cachedResolver) {
      const defaults = this._toNormalizedKeybindingItems(
        this.keybindingsRegistry.getDefaultKeybindings(),
        true
      );
      const overrides = this._toNormalizedKeybindingItems(this._dynamicKeybindings, false);
      this._cachedResolver = new KeybindingResolver(
        defaults,
        overrides,
        (str) => this._log(str),
        this._instantiationService
      );
    }
    return this._cachedResolver;
  }
  _toNormalizedKeybindingItems(items, isDefault) {
    const result = [];
    let resultLen = 0;
    for (const item of items) {
      const when = item.when || void 0;
      const keybinding = item.keybinding;
      if (!keybinding) {
        result[resultLen++] = new ResolvedKeybindingItem(
          void 0,
          item.command,
          item.commandArgs,
          when,
          isDefault,
          null,
          false
        );
      } else {
        const resolvedKeybindings = ResolvedKeybinding.resolveKeybinding(keybinding, OS);
        for (const resolvedKeybinding of resolvedKeybindings) {
          result[resultLen++] = new ResolvedKeybindingItem(
            resolvedKeybinding,
            item.command,
            item.commandArgs,
            when,
            isDefault,
            null,
            false
          );
        }
      }
    }
    return result;
  }
  _log(str) {
    if (this._logging) {
      this._logService.info(`[KeybindingService]: ${str}`);
    }
  }
  resolveKeyboardEvent(keyboardEvent) {
    const chord = new KeyCodeChord(
      keyboardEvent.ctrlKey,
      keyboardEvent.shiftKey,
      keyboardEvent.altKey,
      keyboardEvent.metaKey,
      keyboardEvent.keyCode
    );
    return new ResolvedKeybinding(OS, [chord]);
  }
};
KeybindingService = __decorateClass$6([
  __decorateParam$6(2, ICommandService),
  __decorateParam$6(3, ILogService),
  __decorateParam$6(4, IContextKeyService),
  __decorateParam$6(5, IInstantiationService),
  __decorateParam$6(6, IKeybindingsRegistry),
  __decorateParam$6(7, IChartManagementService)
], KeybindingService);
const ILifecycleService = createDecorator$1("lifecycleService");
var LifecyclePhase = /* @__PURE__ */ ((LifecyclePhase2) => {
  LifecyclePhase2[LifecyclePhase2["Starting"] = 1] = "Starting";
  LifecyclePhase2[LifecyclePhase2["Ready"] = 2] = "Ready";
  LifecyclePhase2[LifecyclePhase2["Restored"] = 3] = "Restored";
  LifecyclePhase2[LifecyclePhase2["Eventually"] = 4] = "Eventually";
  return LifecyclePhase2;
})(LifecyclePhase || {});
class LifecycleService extends Disposable {
  constructor() {
    super(...arguments);
    __publicField(this, "_phase", LifecyclePhase.Starting);
    __publicField(this, "_willShutdown", false);
    __publicField(this, "phaseWhen", /* @__PURE__ */ new Map());
  }
  get phase() {
    return this._phase;
  }
  get willShutdown() {
    return this._willShutdown;
  }
  set phase(value) {
    if (value < this.phase) {
      throw new Error("Lifecycle cannot go backwards");
    }
    if (this._phase === value) {
      return;
    }
    this._phase = value;
    const barrier = this.phaseWhen.get(this._phase);
    if (barrier) {
      barrier.open();
      this.phaseWhen.delete(this._phase);
    }
  }
  async when(phase) {
    if (phase <= this._phase) {
      return;
    }
    let barrier = this.phaseWhen.get(phase);
    if (!barrier) {
      barrier = new Barrier();
      this.phaseWhen.set(phase, barrier);
    }
    await barrier.wait();
  }
}
class LogService extends Disposable {
  constructor(primaryLogger) {
    super();
    __publicField(this, "logger");
    this.logger = primaryLogger;
    this._register(primaryLogger.onDidChangeLogLevel((level) => this.setLevel(level)));
  }
  get onDidChangeLogLevel() {
    return this.logger.onDidChangeLogLevel;
  }
  setLevel(level) {
    this.logger.setLevel(level);
  }
  getLevel() {
    return this.logger.getLevel();
  }
  trace(message2, ...args) {
    this.logger.trace(message2, ...args);
  }
  debug(message2, ...args) {
    this.logger.debug(message2, ...args);
  }
  info(message2, ...args) {
    this.logger.info(message2, ...args);
  }
  warn(message2, ...args) {
    this.logger.warn(message2, ...args);
  }
  error(message2, ...args) {
    this.logger.error(message2, ...args);
  }
  flush() {
    this.logger.flush();
  }
}
const INotificationService = createDecorator$1("notificationService");
class NoOpNotification {
  constructor() {
    __publicField(this, "onDidClose", NoneEvent);
  }
  close() {
  }
}
var Severity = /* @__PURE__ */ ((Severity2) => {
  Severity2[Severity2["Verbose"] = 0] = "Verbose";
  Severity2[Severity2["Info"] = 1] = "Info";
  Severity2[Severity2["Warning"] = 2] = "Warning";
  Severity2[Severity2["Error"] = 3] = "Error";
  return Severity2;
})(Severity || {});
((Severity2) => {
  const _error = "error";
  const _warning = "warning";
  const _info = "info";
  const _verbose = "verbose";
  function toString2(severity) {
    switch (severity) {
      case 3:
        return _error;
      case 2:
        return _warning;
      case 1:
        return _info;
      default:
        return _verbose;
    }
  }
  Severity2.toString = toString2;
})(Severity || (Severity = {}));
var NotificationChangeType = /* @__PURE__ */ ((NotificationChangeType2) => {
  NotificationChangeType2[NotificationChangeType2["ADD"] = 0] = "ADD";
  NotificationChangeType2[NotificationChangeType2["REMOVE"] = 1] = "REMOVE";
  return NotificationChangeType2;
})(NotificationChangeType || {});
class NotificationHandle extends Disposable {
  constructor(item, onClose) {
    super();
    __publicField(this, "_onDidClose", this._register(new Emitter()));
    __publicField(this, "onDidClose", this._onDidClose.event);
    this.item = item;
    this.onClose = onClose;
    this.registerListeners();
  }
  registerListeners() {
    once(this.item.onDidClose)(() => {
      this._onDidClose.fire();
      this.dispose();
    });
  }
  close() {
    this.onClose(this.item);
    this.dispose();
  }
}
const _NotificationsModel = class _NotificationsModel extends Disposable {
  constructor() {
    super(...arguments);
    __publicField(this, "_onDidChangeNotification", this._register(
      new Emitter()
    ));
    __publicField(this, "onDidChangeNotification", this._onDidChangeNotification.event);
    __publicField(this, "_notifications", []);
  }
  get notifications() {
    return this._notifications;
  }
  addNotification(notification) {
    const item = this.createViewItem(notification);
    if (!item) {
      return _NotificationsModel.NO_OP_NOTIFICATION;
    }
    const duplicate = this.findNotification(item);
    duplicate == null ? void 0 : duplicate.close();
    this._notifications.splice(0, 0, item);
    this._onDidChangeNotification.fire({
      item,
      index: 0,
      kind: 0
      /* ADD */
    });
    return new NotificationHandle(item, (item2) => this.onClose(item2));
  }
  onClose(item) {
    const liveItem = this.findNotification(item);
    if (liveItem && liveItem !== item) {
      liveItem.close();
    } else {
      item.close();
    }
  }
  findNotification(item) {
    return this._notifications.find((notification) => notification.equals(item));
  }
  createViewItem(notification) {
    const item = NotificationViewItem.create(notification);
    if (!item) {
      return void 0;
    }
    once(item.onDidClose)(() => {
      const index2 = this._notifications.indexOf(item);
      if (index2 >= 0) {
        this._notifications.splice(index2, 1);
        this._onDidChangeNotification.fire({
          item,
          index: index2,
          kind: 1
          /* REMOVE */
        });
      }
    });
    return item;
  }
};
__publicField(_NotificationsModel, "NO_OP_NOTIFICATION", new NoOpNotification());
let NotificationsModel = _NotificationsModel;
const _NotificationViewItem = class _NotificationViewItem extends Disposable {
  constructor(id2, _severity, _message) {
    super();
    __publicField(this, "_visible", false);
    __publicField(this, "_onDidClose", this._register(new Emitter()));
    __publicField(this, "onDidClose", this._onDidClose.event);
    this.id = id2;
    this._severity = _severity;
    this._message = _message;
  }
  static create(notification) {
    if (!notification || !notification.message || isCancellationError(notification.message)) {
      return void 0;
    }
    let severity;
    if (typeof notification.severity === "number") {
      severity = notification.severity;
    } else {
      severity = Severity.Info;
    }
    const message2 = _NotificationViewItem.parseNotificationMessage(notification.message);
    if (!message2) {
      return void 0;
    }
    return new _NotificationViewItem(notification.id, severity, message2);
  }
  static parseNotificationMessage(input) {
    let message2;
    if (input instanceof Error) {
      message2 = toErrorMessage(input, false);
    } else if (typeof input === "string") {
      message2 = input;
    }
    if (!message2) {
      return void 0;
    }
    const raw = message2;
    if (message2.length > _NotificationViewItem.MAX_MESSAGE_LENGTH) {
      message2 = `${message2.substr(0, _NotificationViewItem.MAX_MESSAGE_LENGTH)}...`;
    }
    message2 = message2.replace(/(\r\n|\n|\r)/gm, " ").trim();
    const text2 = message2;
    return { raw, text: text2, original: input };
  }
  get severity() {
    return this._severity;
  }
  get message() {
    return this._message;
  }
  get visible() {
    return this._visible;
  }
  close() {
    this._onDidClose.fire();
    this.dispose();
  }
  equals(other) {
    if (typeof this.id === "string" || typeof other.id === "string") {
      return this.id === other.id;
    }
    return this._message.raw === other.message.raw;
  }
};
__publicField(_NotificationViewItem, "MAX_MESSAGE_LENGTH", 1e3);
let NotificationViewItem = _NotificationViewItem;
class NotificationService extends Disposable {
  constructor() {
    super();
    __publicField(this, "model", this._register(new NotificationsModel()));
    __publicField(this, "_onDidAddNotification", this._register(new Emitter()));
    __publicField(this, "onDidAddNotification", this._onDidAddNotification.event);
    __publicField(this, "_onDidRemoveNotification", this._register(new Emitter()));
    __publicField(this, "onDidRemoveNotification", this._onDidRemoveNotification.event);
    this.registerListeners();
  }
  registerListeners() {
    this._register(
      this.model.onDidChangeNotification((e2) => {
        switch (e2.kind) {
          case NotificationChangeType.ADD:
          case NotificationChangeType.REMOVE: {
            const notification = {
              message: e2.item.message.original,
              severity: e2.item.severity
            };
            if (e2.kind === NotificationChangeType.ADD) {
              this._onDidAddNotification.fire(notification);
            }
            if (e2.kind === NotificationChangeType.REMOVE) {
              this._onDidRemoveNotification.fire(notification);
            }
            break;
          }
        }
      })
    );
  }
  verbose(message2) {
    if (Array.isArray(message2)) {
      for (const messageEntry of message2) {
        this.info(messageEntry);
      }
      return;
    }
    this.model.addNotification({ severity: Severity.Verbose, message: message2 });
  }
  info(message2) {
    if (Array.isArray(message2)) {
      for (const messageEntry of message2) {
        this.info(messageEntry);
      }
      return;
    }
    this.model.addNotification({ severity: Severity.Info, message: message2 });
  }
  warn(message2) {
    if (Array.isArray(message2)) {
      for (const messageEntry of message2) {
        this.warn(messageEntry);
      }
      return;
    }
    this.model.addNotification({ severity: Severity.Warning, message: message2 });
  }
  error(message2) {
    if (Array.isArray(message2)) {
      for (const messageEntry of message2) {
        this.error(messageEntry);
      }
      return;
    }
    this.model.addNotification({ severity: Severity.Error, message: message2 });
  }
  notify(notification) {
    const handle = this.model.addNotification(notification);
    return handle;
  }
}
const IStoreService = createDecorator$1("storeService");
class StoreService {
  constructor(savedState) {
    __publicField(this, "_serviceBrand");
    __publicField(this, "_stores", /* @__PURE__ */ new Map());
    if (savedState) {
      Object.keys(savedState).forEach((key2) => {
        this.defineStore(key2, savedState[key2]);
      });
    }
  }
  defineStore(key2, initialValue) {
    if (this._stores.has(key2)) {
      return ensure(this._stores.get(key2));
    }
    const store = writable(initialValue);
    this._stores.set(key2, store);
    return store;
  }
  setStore(key2, data) {
    const store = ensure(this._stores.get(key2));
    store.set(data);
  }
  save() {
    return this._stores.entries().reduce(
      (acc, [key2, store]) => {
        acc[key2] = cloneDeep(get(store));
        return acc;
      },
      /* @__PURE__ */ Object.create(null)
    );
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const proxyMarker = Symbol("Comlink.proxy");
const createEndpoint = Symbol("Comlink.endpoint");
const releaseProxy = Symbol("Comlink.releaseProxy");
const finalizer = Symbol("Comlink.finalizer");
const throwMarker = Symbol("Comlink.thrown");
const isObject = (val) => typeof val === "object" && val !== null || typeof val === "function";
const proxyTransferHandler = {
  canHandle: (val) => isObject(val) && val[proxyMarker],
  serialize(obj) {
    const { port1, port2 } = new MessageChannel();
    expose(obj, port1);
    return [port2, [port2]];
  },
  deserialize(port) {
    port.start();
    return wrap$1(port);
  }
};
const throwTransferHandler = {
  canHandle: (value) => isObject(value) && throwMarker in value,
  serialize({ value }) {
    let serialized;
    if (value instanceof Error) {
      serialized = {
        isError: true,
        value: {
          message: value.message,
          name: value.name,
          stack: value.stack
        }
      };
    } else {
      serialized = { isError: false, value };
    }
    return [serialized, []];
  },
  deserialize(serialized) {
    if (serialized.isError) {
      throw Object.assign(new Error(serialized.value.message), serialized.value);
    }
    throw serialized.value;
  }
};
const transferHandlers = /* @__PURE__ */ new Map([
  ["proxy", proxyTransferHandler],
  ["throw", throwTransferHandler]
]);
function isAllowedOrigin(allowedOrigins, origin) {
  for (const allowedOrigin of allowedOrigins) {
    if (origin === allowedOrigin || allowedOrigin === "*") {
      return true;
    }
    if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
      return true;
    }
  }
  return false;
}
function expose(obj, ep = globalThis, allowedOrigins = ["*"]) {
  ep.addEventListener("message", function callback(ev) {
    if (!ev || !ev.data) {
      return;
    }
    if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
      console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
      return;
    }
    const { id: id2, type, path } = Object.assign({ path: [] }, ev.data);
    const argumentList = (ev.data.argumentList || []).map(fromWireValue);
    let returnValue;
    try {
      const parent2 = path.slice(0, -1).reduce((obj2, prop2) => obj2[prop2], obj);
      const rawValue = path.reduce((obj2, prop2) => obj2[prop2], obj);
      switch (type) {
        case "GET":
          {
            returnValue = rawValue;
          }
          break;
        case "SET":
          {
            parent2[path.slice(-1)[0]] = fromWireValue(ev.data.value);
            returnValue = true;
          }
          break;
        case "APPLY":
          {
            returnValue = rawValue.apply(parent2, argumentList);
          }
          break;
        case "CONSTRUCT":
          {
            const value = new rawValue(...argumentList);
            returnValue = proxy(value);
          }
          break;
        case "ENDPOINT":
          {
            const { port1, port2 } = new MessageChannel();
            expose(obj, port2);
            returnValue = transfer(port1, [port1]);
          }
          break;
        case "RELEASE":
          {
            returnValue = void 0;
          }
          break;
        default:
          return;
      }
    } catch (value) {
      returnValue = { value, [throwMarker]: 0 };
    }
    Promise.resolve(returnValue).catch((value) => {
      return { value, [throwMarker]: 0 };
    }).then((returnValue2) => {
      const [wireValue, transferables] = toWireValue(returnValue2);
      ep.postMessage(Object.assign(Object.assign({}, wireValue), { id: id2 }), transferables);
      if (type === "RELEASE") {
        ep.removeEventListener("message", callback);
        closeEndPoint(ep);
        if (finalizer in obj && typeof obj[finalizer] === "function") {
          obj[finalizer]();
        }
      }
    }).catch((error) => {
      const [wireValue, transferables] = toWireValue({
        value: new TypeError("Unserializable return value"),
        [throwMarker]: 0
      });
      ep.postMessage(Object.assign(Object.assign({}, wireValue), { id: id2 }), transferables);
    });
  });
  if (ep.start) {
    ep.start();
  }
}
function isMessagePort(endpoint) {
  return endpoint.constructor.name === "MessagePort";
}
function closeEndPoint(endpoint) {
  if (isMessagePort(endpoint))
    endpoint.close();
}
function wrap$1(ep, target) {
  const pendingListeners = /* @__PURE__ */ new Map();
  ep.addEventListener("message", function handleMessage(ev) {
    const { data } = ev;
    if (!data || !data.id) {
      return;
    }
    const resolver = pendingListeners.get(data.id);
    if (!resolver) {
      return;
    }
    try {
      resolver(data);
    } finally {
      pendingListeners.delete(data.id);
    }
  });
  return createProxy(ep, pendingListeners, [], target);
}
function throwIfProxyReleased(isReleased) {
  if (isReleased) {
    throw new Error("Proxy has been released and is not useable");
  }
}
function releaseEndpoint(ep) {
  return requestResponseMessage(ep, /* @__PURE__ */ new Map(), {
    type: "RELEASE"
  }).then(() => {
    closeEndPoint(ep);
  });
}
const proxyCounter = /* @__PURE__ */ new WeakMap();
const proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep) => {
  const newCount = (proxyCounter.get(ep) || 0) - 1;
  proxyCounter.set(ep, newCount);
  if (newCount === 0) {
    releaseEndpoint(ep);
  }
});
function registerProxy(proxy2, ep) {
  const newCount = (proxyCounter.get(ep) || 0) + 1;
  proxyCounter.set(ep, newCount);
  if (proxyFinalizers) {
    proxyFinalizers.register(proxy2, ep, proxy2);
  }
}
function unregisterProxy(proxy2) {
  if (proxyFinalizers) {
    proxyFinalizers.unregister(proxy2);
  }
}
function createProxy(ep, pendingListeners, path = [], target = function() {
}) {
  let isProxyReleased = false;
  const proxy2 = new Proxy(target, {
    get(_target, prop2) {
      throwIfProxyReleased(isProxyReleased);
      if (prop2 === releaseProxy) {
        return () => {
          unregisterProxy(proxy2);
          releaseEndpoint(ep);
          pendingListeners.clear();
          isProxyReleased = true;
        };
      }
      if (prop2 === "then") {
        if (path.length === 0) {
          return { then: () => proxy2 };
        }
        const r2 = requestResponseMessage(ep, pendingListeners, {
          type: "GET",
          path: path.map((p2) => p2.toString())
        }).then(fromWireValue);
        return r2.then.bind(r2);
      }
      return createProxy(ep, pendingListeners, [...path, prop2]);
    },
    set(_target, prop2, rawValue) {
      throwIfProxyReleased(isProxyReleased);
      const [value, transferables] = toWireValue(rawValue);
      return requestResponseMessage(ep, pendingListeners, {
        type: "SET",
        path: [...path, prop2].map((p2) => p2.toString()),
        value
      }, transferables).then(fromWireValue);
    },
    apply(_target, _thisArg, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const last2 = path[path.length - 1];
      if (last2 === createEndpoint) {
        return requestResponseMessage(ep, pendingListeners, {
          type: "ENDPOINT"
        }).then(fromWireValue);
      }
      if (last2 === "bind") {
        return createProxy(ep, pendingListeners, path.slice(0, -1));
      }
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep, pendingListeners, {
        type: "APPLY",
        path: path.map((p2) => p2.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    },
    construct(_target, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep, pendingListeners, {
        type: "CONSTRUCT",
        path: path.map((p2) => p2.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    }
  });
  registerProxy(proxy2, ep);
  return proxy2;
}
function myFlat(arr) {
  return Array.prototype.concat.apply([], arr);
}
function processArguments(argumentList) {
  const processed = argumentList.map(toWireValue);
  return [processed.map((v2) => v2[0]), myFlat(processed.map((v2) => v2[1]))];
}
const transferCache = /* @__PURE__ */ new WeakMap();
function transfer(obj, transfers) {
  transferCache.set(obj, transfers);
  return obj;
}
function proxy(obj) {
  return Object.assign(obj, { [proxyMarker]: true });
}
function toWireValue(value) {
  for (const [name, handler] of transferHandlers) {
    if (handler.canHandle(value)) {
      const [serializedValue, transferables] = handler.serialize(value);
      return [
        {
          type: "HANDLER",
          name,
          value: serializedValue
        },
        transferables
      ];
    }
  }
  return [
    {
      type: "RAW",
      value
    },
    transferCache.get(value) || []
  ];
}
function fromWireValue(value) {
  switch (value.type) {
    case "HANDLER":
      return transferHandlers.get(value.name).deserialize(value.value);
    case "RAW":
      return value.value;
  }
}
function requestResponseMessage(ep, pendingListeners, msg, transfers) {
  return new Promise((resolve) => {
    const id2 = generateUUID();
    pendingListeners.set(id2, resolve);
    if (ep.start) {
      ep.start();
    }
    ep.postMessage(Object.assign({ id: id2 }, msg), transfers);
  });
}
function generateUUID() {
  return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
}
var endpointSymbol = Symbol("getEndpoint");
var wrap = (ep) => {
  const wrapped = wrap$1(ep);
  return new Proxy(wrapped, {
    get(target, prop2, receiver) {
      if (prop2 === endpointSymbol) return ep;
      return Reflect.get(target, prop2, receiver);
    }
  });
};
class StudyService {
  constructor() {
    __publicField(this, "_serviceBrand");
    __publicField(this, "worker");
    this.worker = wrap(new Worker(
      new URL(
        /* @vite-ignore */
        "" + new URL("worker-kN-yM__8.js", import.meta.url).href,
        import.meta.url
      ),
      {}
    ));
  }
  exec(func, inputs, options) {
    return func(this.worker, inputs, options);
  }
}
function toPX(val) {
  if (!isFiniteNumber(val)) return "";
  return `${val}px`;
}
const ChartFontFamily = `-apple-system, BlinkMacSystemFont, 'Trebuchet MS', Roboto, Ubuntu, sans-serif`;
function createStyleSheet(container = document.head, beforeAppend, disposableStore) {
  const style = document.createElement("style");
  style.type = "text/css";
  style.media = "screen";
  beforeAppend == null ? void 0 : beforeAppend(style);
  container.appendChild(style);
  return style;
}
class ColorRegistry {
  constructor() {
    __publicField(this, "colorsById", /* @__PURE__ */ Object.create(null));
  }
  registerColor(id2, defaults) {
    const colorContribution = {
      id: id2,
      defaults
    };
    should(!this.colorsById[id2]);
    this.colorsById[id2] = colorContribution;
    return id2;
  }
  getColors() {
    return Object.keys(this.colorsById).map((id2) => this.colorsById[id2]);
  }
  resolveDefaultColor(id2, theme) {
    const colorDesc = this.colorsById[id2];
    if (colorDesc == null ? void 0 : colorDesc.defaults) {
      const colorValue = isColorDefaults(colorDesc.defaults) ? colorDesc.defaults[theme.type] : colorDesc.defaults;
      return resolveColorValue(colorValue, theme);
    }
    return void 0;
  }
}
const colorRegistry = new ColorRegistry();
function registerColor(id2, defaults) {
  return colorRegistry.registerColor(id2, defaults);
}
function isColorDefaults(value) {
  return value !== null && typeof value === "object" && "light" in value && "dark" in value;
}
function resolveColorValue(colorValue, theme) {
  if (colorValue === null) {
    return void 0;
  } else if (typeof colorValue === "string") {
    if (colorValue[0] === "#") {
      return Color.fromHex(colorValue);
    }
    return theme.getColor(colorValue);
  } else if (colorValue instanceof Color) {
    return colorValue;
  } else {
    return NOTREACHED();
  }
}
function asCssVariableName(colorIdent) {
  return `--cl-${colorIdent.replace(/\./g, "-")}`;
}
const lighColors = {
  "global.background": "#EBEBEB",
  foreground: "#0F0F0FFF",
  background: "#fff",
  primary: "#2962ff",
  selectedForeground: "#2962ff",
  "negative.foreground": "#fff",
  "negative.background": "#2962ff",
  "negative.hoverBackground": "#1E53E5FF",
  "gutter.background": "#EBEBEBFF",
  "button.foreground": "#0F0F0FFF",
  "button.background": "#fff",
  "button.hoverBackground": "#f2f2f2",
  "button.primary.foreground": "#fff",
  "button.primary.background": "#1A1A1AFF",
  "button.secondary.foreground": "#1A1A1AFF",
  "button.secondary.background": "#fff",
  "button.secondary.border": "#1A1A1AFF",
  "button.secondary.hoverForeground": "#fff",
  "button.secondary.hoverBackground": "#1A1A1AFF",
  "tooltip.foreground": "#fff",
  "tooltip.background": "#2E2E2E",
  "scroll.foreground": "#fff",
  "scroll.background": "#1e222d99",
  "dialog.shadow": "#00000033",
  "dialog.background": "#fff",
  "scrollbarThumb.background": "#9c9c9c",
  "listTitle.foreground": "#808080FF",
  "listItem.foreground": "#0F0F0FFF",
  "listItem.background": "#fff",
  "listItem.hoverBackground": "#f2f2f2",
  "listItem.selectedForeground": "#fff",
  "listItem.selectedBackground": "#2E2E2EFF",
  "listItem.disabledForeground": "#C8C8C8FF",
  "listKeybinding.foreground": "#808080FF",
  "input.foreground": "#131722FF",
  "inputPlaceholder.foreground": "#a3a6af",
  "legendLoader.foreground": "#707070FF",
  "legend.background": "#FFFFFF7F",
  "legend.hoverBackground": "#FFFFFF",
  "legend.hoverBorder": "#dbdbdb",
  "handle.foreground": "#b8b8b8",
  "toast.verbose.foreground": "#1A1A1AFF",
  "toast.verbose.background": "#ffffff",
  "toast.verbose.border": "#089981FF",
  "toast.info.foreground": "#fff",
  "toast.info.background": "#2962ff"
};
const darkColors = {
  "global.background": "#303030",
  foreground: "#DBDBDBFF",
  background: "#1A1A1AFF",
  primary: "#2962ff",
  selectedForeground: "#2962ff",
  "negative.foreground": "#DBDBDBFF",
  "negative.background": "#2962FFFF",
  "negative.hoverBackground": "#1E53E5FF",
  "gutter.background": "#4A4A4AFF",
  "button.foreground": "#DBDBDBFF",
  "button.background": "#1A1A1AFF",
  "button.hoverBackground": "#303030FF",
  "button.primary.foreground": "#1A1A1AFF",
  "button.primary.background": "#FFFFFFFF",
  "button.secondary.foreground": "#FFFFFFFF",
  "button.secondary.background": "#00000000",
  "button.secondary.border": "#FFF",
  "button.secondary.hoverForeground": "#1A1A1AFF",
  "button.secondary.hoverBackground": "#F2F2F2FF",
  "tooltip.foreground": "#F0F0F0",
  "tooltip.background": "#3D3D3D",
  "scroll.foreground": "#fff",
  "scroll.background": "#3d3d3d",
  "dialog.shadow": "#00000066",
  "dialog.background": "#262626",
  "scrollbarThumb.background": "#9c9c9c",
  "listTitle.foreground": "#808080FF",
  "listItem.foreground": "#DBDBDBFF",
  "listItem.background": "#262626",
  "listItem.hoverBackground": "#303030FF",
  "listItem.selectedForeground": "#000000FF",
  "listItem.selectedBackground": "#F2F2F2FF",
  "listItem.disabledForeground": "#C8C8C8FF",
  "listKeybinding.foreground": "#8C8C8CFF",
  "input.foreground": "#A8A8A8FF",
  "inputPlaceholder.foreground": "#8c8c8c",
  "legendLoader.foreground": "#8c8c8c",
  "legend.background": "#1A1A1A",
  "legend.hoverBackground": "#303030",
  "legend.hoverBorder": "#3D3D3D",
  "handle.foreground": "#575757",
  "toast.verbose.foreground": "#DBDBDB",
  "toast.verbose.background": "#262626",
  "toast.verbose.border": "#089981",
  "toast.info.foreground": "#fff",
  "toast.info.background": "#2962FFFF"
};
const clLight = {
  base: "light",
  inherit: false,
  colors: lighColors
};
const clDark = {
  base: "dark",
  inherit: false,
  colors: darkColors
};
keys(clLight.colors).forEach((key2) => {
  registerColor(key2, { light: clLight.colors[key2], dark: clDark.colors[key2] });
});
var __getOwnPropDesc$5 = Object.getOwnPropertyDescriptor;
var __decorateClass$5 = (decorators, target, key2, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$5(target, key2) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$5 = (index2, decorator) => (target, key2) => decorator(target, key2, index2);
let ThemeService = class extends Disposable {
  constructor(host, _customProps, configurationService) {
    super();
    __publicField(this, "_serviceBrand");
    __publicField(this, "_knownThemes");
    __publicField(this, "_onDidColorThemeChange", this._register(new Emitter()));
    __publicField(this, "onDidColorThemeChange", this._onDidColorThemeChange.event);
    __publicField(this, "_themeCSS", "");
    __publicField(this, "_theme");
    __publicField(this, "_styleElement");
    this._customProps = _customProps;
    this.configurationService = configurationService;
    this._knownThemes = /* @__PURE__ */ new Map();
    this._knownThemes.set("light", newBuiltInTheme("light"));
    this._knownThemes.set("dark", newBuiltInTheme("dark"));
    this._styleElement = createStyleSheet(host, (style) => {
      style.className = "chartles-vars";
      style.textContent = this._themeCSS;
    });
    this._register(
      toDisposable(() => {
        this._styleElement.remove();
      })
    );
    this.setTheme(configurationService.getValue("theme"), false);
  }
  setTheme(themeName, write = true) {
    const theme = this._knownThemes.get(themeName) ?? ensure(this._knownThemes.get("light"));
    this._updateActualTheme(theme);
    if (write) {
      this.configurationService.setValue("theme", theme.themeName);
    }
  }
  defineTheme(themeName, themeData) {
    if (!/^[a-z0-9-]+$/i.test(themeName)) {
      throw new Error("Illegal theme name!");
    }
    if (!isBuiltinTheme(themeData.base) && !isBuiltinTheme(themeName)) {
      throw new Error("Illegal theme base!");
    }
    this._knownThemes.set(themeName, new ColorTheme(themeName, themeData));
    if (isBuiltinTheme(themeName)) {
      this._knownThemes.forEach((theme) => {
        if (theme.base === themeName) {
          theme.notifyBaseUpdated();
        }
      });
    }
    if (this._theme.themeName === themeName) {
      this.setTheme(themeName);
    }
  }
  getColorTheme() {
    return this._theme;
  }
  isDark() {
    return this.getColorTheme().type === ColorScheme.DARK;
  }
  _updateActualTheme(desiredTheme) {
    if (!desiredTheme || this._theme === desiredTheme) {
      return;
    }
    this._theme = desiredTheme;
    this._updateTheme();
  }
  _updateTheme() {
    const cssRules = [];
    const hasRule = {};
    const ruleCollector = {
      addRule: (rule) => {
        if (!hasRule[rule]) {
          cssRules.push(rule);
          hasRule[rule] = true;
        }
      }
    };
    const colorVariables = [];
    for (const [key2, value] of Object.entries(this._customProps)) {
      colorVariables.push(`${key2}: ${value.toString()};`);
    }
    for (const item of colorRegistry.getColors()) {
      const color = this._theme.getColor(item.id, true);
      if (color) {
        colorVariables.push(`${asCssVariableName(item.id)}: ${color.toString()};`);
      }
    }
    ruleCollector.addRule(`:host { ${colorVariables.join("\n")} }`);
    this._themeCSS = cssRules.join("\n");
    this._updateCSS();
    this._onDidColorThemeChange.fire(this._theme);
  }
  _updateCSS() {
    this._styleElement.textContent = this._themeCSS;
  }
};
ThemeService = __decorateClass$5([
  __decorateParam$5(2, IConfigurationService)
], ThemeService);
class ColorTheme {
  constructor(name, standaloneThemeData) {
    __publicField(this, "id");
    __publicField(this, "themeName");
    __publicField(this, "themeData");
    __publicField(this, "colors");
    __publicField(this, "defaultColors");
    this.themeData = standaloneThemeData;
    const base = standaloneThemeData.base;
    if (name.length > 0) {
      if (isBuiltinTheme(name)) {
        this.id = name;
      } else {
        this.id = base + " " + name;
      }
      this.themeName = name;
    } else {
      this.id = base;
      this.themeName = base;
    }
    this.colors = null;
    this.defaultColors = /* @__PURE__ */ Object.create(null);
  }
  get base() {
    return this.themeData.base;
  }
  get type() {
    return this.base === "light" ? ColorScheme.LIGHT : ColorScheme.DARK;
  }
  notifyBaseUpdated() {
    if (this.themeData.inherit) {
      this.colors = null;
    }
  }
  getColors() {
    if (!this.colors) {
      const colors = /* @__PURE__ */ new Map();
      for (const id2 in this.themeData.colors) {
        colors.set(id2, Color.fromHex(this.themeData.colors[id2]));
      }
      if (this.themeData.inherit) {
        const baseData = getBuiltinRules(this.themeData.base);
        for (const id2 in baseData.colors) {
          if (!colors.has(id2)) {
            colors.set(id2, Color.fromHex(baseData.colors[id2]));
          }
        }
      }
      this.colors = colors;
    }
    return this.colors;
  }
  getColor(colorId, useDefault) {
    const color = this.getColors().get(colorId);
    if (color) {
      return color;
    }
    if (useDefault !== false) {
      return this.getDefault(colorId);
    }
    return void 0;
  }
  getDefault(colorId) {
    let color = this.defaultColors[colorId];
    if (color) {
      return color;
    }
    color = colorRegistry.resolveDefaultColor(colorId, this);
    this.defaultColors[colorId] = color;
    return color;
  }
}
function isBuiltinTheme(themeName) {
  return themeName === "light" || themeName === "dark";
}
function getBuiltinRules(builtinTheme) {
  return builtinTheme === "light" ? clLight : clDark;
}
function newBuiltInTheme(builtinTheme) {
  const themeData = getBuiltinRules(builtinTheme);
  return new ColorTheme(builtinTheme, themeData);
}
var __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor;
var __decorateClass$4 = (decorators, target, key2, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$4(target, key2) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$4 = (index2, decorator) => (target, key2) => decorator(target, key2, index2);
let ToolRegistry = class extends GenericRegistry {
  constructor(keybindingsRegistry, commandRegistry) {
    super();
    this.keybindingsRegistry = keybindingsRegistry;
    this.commandRegistry = commandRegistry;
  }
  registerTool(rule) {
    this.add(rule);
    const handler = async (accessor, options = /* @__PURE__ */ Object.create(null)) => {
      var _a3, _b3;
      const toolService = accessor.get(IToolService);
      await toolService.switchTool(rule.id, options.source ?? TriggerSource.manual);
      should(toolService.activeTool);
      should(toolService.activeTool.type === rule.id);
      const id2 = toolService.activeTool.id;
      if (options.preset) {
        (_b3 = (_a3 = toolService.activeTool).receivePresetProps) == null ? void 0 : _b3.call(_a3, options.preset);
      }
      return id2;
    };
    if (rule.keybinding) {
      return this.keybindingsRegistry.registerCommandAndKeybindingRule({
        id: rule.id,
        primary: rule.keybinding,
        weight: KeybindingWeight.ChartContrib,
        handler
      });
    } else {
      return this.commandRegistry.registerCommand({ id: rule.id, handler });
    }
  }
};
ToolRegistry = __decorateClass$4([
  __decorateParam$4(0, IKeybindingsRegistry),
  __decorateParam$4(1, ICommandRegistry)
], ToolRegistry);
var __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;
var __decorateClass$3 = (decorators, target, key2, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$3(target, key2) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$3 = (index2, decorator) => (target, key2) => decorator(target, key2, index2);
let ToolService = class extends Disposable {
  constructor(_instantiationService, _chartManagementService, _toolRegistry) {
    super();
    __publicField(this, "_activeTool");
    __publicField(this, "_past", []);
    __publicField(this, "_onDidChangeTool", this._register(new Emitter()));
    __publicField(this, "onDidChangeTool", this._onDidChangeTool.event);
    __publicField(this, "store");
    __publicField(this, "_toolScope");
    __publicField(this, "_switchQueue", this._register(new SwitchToolQueue()));
    this._instantiationService = _instantiationService;
    this._chartManagementService = _chartManagementService;
    this._toolRegistry = _toolRegistry;
    this.store = writable({
      activeType: void 0,
      manualTriggeredActiveType: void 0,
      keepDrawingMode: false,
      magnetMode: MagnetMode.Normal,
      magnetModeOverride: void 0
    });
  }
  dispose() {
    var _a3;
    super.dispose();
    Reflect.set(this, "store", null);
    (_a3 = this._activeTool) == null ? void 0 : _a3.deactivate();
    this._activeTool = void 0;
  }
  _getValue(key2) {
    return get(this.store)[key2];
  }
  _setValue(key2, value) {
    this.store.update((store) => {
      store[key2] = value;
      return store;
    });
  }
  get activeTool() {
    return this._activeTool;
  }
  async switchTool(nextToolId, source2, cancelPendingManualSelected = false) {
    if (cancelPendingManualSelected) {
      this._switchQueue.cancelPending();
    }
    return this._switchQueue.enqueue(source2, async (task) => {
      return this._doSwitchTool(task, nextToolId, source2);
    });
  }
  async _doSwitchTool(task, nextToolId, source2) {
    var _a3, _b3, _c2, _d2, _e, _f, _g, _h;
    await this._switchQueue.waitForReady(task);
    (_a3 = this._activeTool) == null ? void 0 : _a3.deactivate();
    const prev = this._activeTool;
    this._activeTool = void 0;
    (_b3 = this._toolScope) == null ? void 0 : _b3.dispose();
    if (nextToolId) {
      const factory = ensure(this._toolRegistry.value(nextToolId));
      this._activeTool = await this._instantiationService.invokeFunction(
        (accessor) => factory.createTool(accessor)
      );
    } else {
      this._activeTool = void 0;
    }
    if (task.cancellationToken.isCancellationRequested) {
      return void 0;
    }
    task.schedule(() => {
      this.store.update((store) => {
        store.activeType = nextToolId;
        return store;
      });
    });
    if (prev) {
      if (!prev.canGoBackward) {
        this._past.length = 0;
      }
      if (prev.fallbackable) {
        this._past.push(prev.type);
      }
    }
    (_c2 = this._activeTool) == null ? void 0 : _c2.activate();
    const next = this._activeTool;
    if (this._activeTool) {
      this.acquireToolScope({
        useMagnet: Boolean((_e = (_d2 = this._activeTool) == null ? void 0 : _d2.useMagnetedPosition) == null ? void 0 : _e.call(_d2)),
        isDrawing: Boolean((_g = (_f = this._activeTool) == null ? void 0 : _f.isDrawingTool) == null ? void 0 : _g.call(_f))
      });
    }
    this._onDidChangeTool.fire({ prev, next, source: source2 });
    setTimeout0(() => {
      task.complete(true);
    });
    return (_h = this._activeTool) == null ? void 0 : _h.id;
  }
  async switchBack() {
    if (this._activeTool && !this._activeTool.canGoBackward) return;
    const lastOne = this._past.pop();
    if (lastOne) {
      await this.switchTool(lastOne, TriggerSource.manual);
      this._past.pop();
    } else {
      await this.switchTool(void 0, TriggerSource.manual);
    }
  }
  async keepDrawingOrSwitchBack() {
    if (!this._getValue("keepDrawingMode")) return this.switchBack();
    if (!this._activeTool) return;
    const factory = ensure(this._toolRegistry.value(this._activeTool.type));
    this._activeTool.deactivate();
    this._activeTool = void 0;
    this._activeTool = await this._instantiationService.invokeFunction(
      (accessor) => factory.createTool(accessor)
    );
    this._activeTool.activate();
  }
  processEvent(event2) {
    var _a3;
    if (this._toolScope && this._toolScope.useMagnet) {
      switch (event2.type) {
        case InputEventType.KEY_DOWN: {
          const e2 = ensure(event2.asKeyboardInputEvent());
          const withCtrlCmd = isMacintosh && e2.metaKey || !isMacintosh && e2.ctrlKey;
          const magnetMode = this._getComputedMagnetMode();
          if (magnetMode === MagnetMode.Normal && withCtrlCmd) {
            this._setMagnetModeOverride(MagnetMode.WeakMagnet);
          }
          if (magnetMode !== MagnetMode.Normal && withCtrlCmd) {
            this._setMagnetModeOverride(MagnetMode.Normal);
          }
          break;
        }
        case InputEventType.KEY_UP: {
          this._setMagnetModeOverride(void 0);
          break;
        }
      }
    }
    (_a3 = this._activeTool) == null ? void 0 : _a3.processEvent(event2);
    return event2.isAccepted();
  }
  acquireToolScope(init2) {
    this._toolScope = {
      ...init2,
      dispose: () => {
        ensure(this._toolScope).useMagnet = false;
        this._setMagnetModeOverride(void 0);
        this._toolScope = void 0;
      }
    };
    this._setMagnetModeOverride(void 0);
    return this._toolScope;
  }
  isDrawing() {
    var _a3;
    return !!((_a3 = this._toolScope) == null ? void 0 : _a3.isDrawing);
  }
  _getComputedMagnetMode() {
    var _a3;
    if (!((_a3 = this._toolScope) == null ? void 0 : _a3.useMagnet)) return MagnetMode.Normal;
    const store = get(this.store);
    return store.magnetModeOverride ?? store.magnetMode;
  }
  _applyMagnetMode() {
    const effectedMode = this._getComputedMagnetMode();
    let mode;
    switch (effectedMode) {
      case MagnetMode.StrongMagnet:
        mode = K.MagnetOHLC;
        break;
      case MagnetMode.WeakMagnet:
        mode = K.MagnetOHLCWeak;
        break;
      case MagnetMode.Normal:
        mode = K.Normal;
        break;
      default:
        NOTIMPLEMENTED();
    }
    for (const chartService of this._chartManagementService.getCharts()) {
      chartService.chartApi.applyOptions({
        crosshair: {
          mode
        }
      });
    }
  }
  setMagnetMode(magnetMode) {
    this._setValue("magnetMode", magnetMode);
  }
  setKeepDrawingMode(keep) {
    this._setValue("keepDrawingMode", keep);
  }
  _setMagnetModeOverride(magnetMode) {
    this.store.update((store) => {
      store.magnetModeOverride = magnetMode;
      return store;
    });
    this._applyMagnetMode();
  }
};
ToolService = __decorateClass$3([
  __decorateParam$3(0, IInstantiationService),
  __decorateParam$3(1, IChartManagementService),
  __decorateParam$3(2, IToolRegistry)
], ToolService);
class SwitchToolTask {
  constructor(source2) {
    __publicField(this, "_promise", new DeferredPromise2());
    __publicField(this, "promise", this._promise.p);
    __publicField(this, "_cancellationTokenSource", new CancellationTokenSource());
    __publicField(this, "cancellationToken", this._cancellationTokenSource.token);
    __publicField(this, "cleanupLazyUpdate", null);
    __publicField(this, "disposabled", false);
    this.source = source2;
  }
  complete(val) {
    this._promise.complete(val);
    this._cancellationTokenSource.dispose(false);
  }
  dispose() {
    var _a3;
    this.disposabled = true;
    this._cancellationTokenSource.dispose(true);
    this._promise.complete(false);
    (_a3 = this.cleanupLazyUpdate) == null ? void 0 : _a3.call(this);
  }
  schedule(cb) {
    this.cleanupLazyUpdate = scheduleTimeout0(() => {
      cb();
      this.cleanupLazyUpdate = null;
    });
  }
}
class SwitchToolQueue {
  constructor() {
    __publicField(this, "_tasks", []);
  }
  async enqueue(src, cb) {
    const task = new SwitchToolTask(src);
    this._tasks.push(task);
    try {
      return await cb(task);
    } finally {
      task.complete(true);
      this.dequeue(task);
    }
  }
  dequeue(task) {
    const idx = this._tasks.indexOf(task);
    this._tasks.splice(idx, 1);
  }
  async waitForReady(task) {
    while (this._tasks.length) {
      const t2 = this._tasks[0];
      if (t2 === task) return;
      if (t2.cancellationToken.isCancellationRequested) continue;
      if (t2.disposabled) continue;
      await t2.promise;
    }
  }
  cancelPending() {
    if (!this._tasks.length) return;
    for (let i2 = this._tasks.length - 1; i2 >= -1; i2--) {
      const task = this._tasks[i2];
      if (task.source === TriggerSource.manual) this.dequeue(task);
    }
  }
  dispose() {
    var _a3;
    while (this._tasks.length) {
      (_a3 = this._tasks.pop()) == null ? void 0 : _a3.dispose();
    }
  }
}
const ITradeService = createDecorator$1("tradeService");
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __decorateClass$2 = (decorators, target, key2, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$2(target, key2) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$2 = (index2, decorator) => (target, key2) => decorator(target, key2, index2);
let TradeApi = class extends Disposable {
  constructor(toolService, commandService) {
    super();
    __publicField(this, "preOrderPromise", null);
    this.toolService = toolService;
    this.commandService = commandService;
  }
  async preOrder(overrides) {
    if (this.preOrderPromise) {
      return this.preOrderPromise.p;
    }
    if (!this.preOrderPromise) {
      this.preOrderPromise = new DeferredPromise2();
    }
    const _onDone = new Emitter();
    const _onPriceChange = new Emitter();
    const onDoneInternal = (preOrder) => {
      this.preOrderPromise = null;
      _onDone.fire(preOrder);
    };
    const onPriceChangeInternal = (preOrder) => {
      _onPriceChange.fire(preOrder);
    };
    const id2 = await this.commandService.executeCommand(
      PreOrderToolType,
      {
        source: TriggerSource.program,
        preset: {
          paneIndex: 0,
          props: {
            ...omit(overrides, ["id", "points"]),
            onDone: onDoneInternal,
            onChange: onPriceChangeInternal
          }
        }
      }
    );
    should(id2);
    const api = {
      onDone: _onDone.event,
      onChange: _onPriceChange.event,
      updateProps: (props) => {
        var _a3, _b3, _c2;
        if (((_a3 = this.toolService.activeTool) == null ? void 0 : _a3.type) === PreOrderToolType) {
          (_c2 = (_b3 = this.toolService.activeTool).receiveProps) == null ? void 0 : _c2.call(_b3, {
            points: [{ time: 0, price: props.price }]
          });
        }
      },
      dispose: () => {
        var _a3, _b3;
        (_a3 = this.preOrderPromise) == null ? void 0 : _a3.error(new Error("Unresolved preOrder Promise"));
        this.preOrderPromise = null;
        if (((_b3 = this.toolService.activeTool) == null ? void 0 : _b3.type) === PreOrderToolType) {
          this.commandService.executeCommand(ExitDrawingCommand);
        }
        _onDone.dispose();
        _onPriceChange.dispose();
      }
    };
    this.preOrderPromise.complete(api);
    return api;
  }
};
TradeApi = __decorateClass$2([
  __decorateParam$2(0, IToolService),
  __decorateParam$2(1, ICommandService)
], TradeApi);
class TradeService extends Disposable {
  constructor(brokerFactory, brokerConfig) {
    super();
    __publicField(this, "_serviceBrand");
    __publicField(this, "_onOrderUpdated", this._register(new Emitter()));
    __publicField(this, "onOrderUpdated", this._onOrderUpdated.event);
    __publicField(this, "_onPositionUpdated", this._register(new Emitter()));
    __publicField(this, "onPositionUpdated", this._onPositionUpdated.event);
    __publicField(this, "_onExecutionUpdated", this._register(new Emitter()));
    __publicField(this, "onExecutionUpdated", this._onExecutionUpdated.event);
    __publicField(this, "_broker");
    __publicField(this, "_orders", null);
    __publicField(this, "_positions", null);
    this.brokerConfig = brokerConfig;
    if (brokerFactory) {
      this._broker = brokerFactory(this._createHost());
      this._initInMemoryData();
    }
  }
  get broker() {
    return ensure(this._broker);
  }
  isTradeEnabled() {
    return !!this._broker;
  }
  _initInMemoryData() {
    this.orders();
    this.positions();
  }
  _createHost() {
    return {
      orderUpdate: (order) => {
        const existsIndex = this.getOrdersSync().findIndex((o2) => o2.id === order.id);
        if (existsIndex > -1) {
          this.getOrdersSync()[existsIndex] = order;
        } else {
          this.getOrdersSync().push(order);
        }
        this._onOrderUpdated.fire(order);
      },
      positionUpdate: (position, isHistoryUpdate = false) => {
        const existsIndex = this.getPositionsSync().findIndex((p2) => p2.id === position.id);
        if (existsIndex > -1) {
          this.getPositionsSync()[existsIndex] = position;
        } else {
          this.getPositionsSync().push(position);
        }
        this._onPositionUpdated.fire({
          position,
          isHistoryUpdate
        });
      },
      executionUpdate: (execution) => {
        this._onExecutionUpdated.fire(execution);
      }
    };
  }
  async orders() {
    const orders = await this.broker.orders();
    this._orders = orders;
    return orders;
  }
  getOrdersSync() {
    return this._orders ?? [];
  }
  getOrderById(id2) {
    return this.getOrdersSync().find((o2) => o2.id === id2) ?? null;
  }
  async positions() {
    const positions = await this.broker.positions();
    this._positions = positions;
    return positions;
  }
  getPositionsSync() {
    return this._positions ?? [];
  }
  getPositionById(id2) {
    return this.getPositionsSync().find((p2) => p2.id === id2) ?? null;
  }
  async executions(symbol) {
    return this.broker.executions(symbol);
  }
  // async placeOrder(order: PreOrder, confirmId?: string): Promise<PlaceOrderResult> {
  //   return this.broker.placeOrder(order, confirmId);
  // }
  //
  // async modifyOrder(order: Order, confirmId?: string): Promise<void> {
  //   return this.broker.modifyOrder(order, confirmId);
  // }
  //
  // async cancelOrder(orderId: string): Promise<void> {
  //   await this.broker.cancelOrder(orderId);
  // }
  //
  // async closePosition(positionId: string, amount?: number): Promise<void> {
  //   await this.broker.closePosition(positionId, amount);
  // }
  async showOrderDialog(order, focus) {
    var _a3, _b3;
    should((_b3 = (_a3 = this.brokerConfig) == null ? void 0 : _a3.customUI) == null ? void 0 : _b3.showOrderDialog);
    await this.brokerConfig.customUI.showOrderDialog(order, focus);
    return true;
  }
  async showCancelOrderDialog(orderId) {
    var _a3, _b3;
    should((_b3 = (_a3 = this.brokerConfig) == null ? void 0 : _a3.customUI) == null ? void 0 : _b3.showCancelOrderDialog);
    const order = ensure((await this.orders()).find((o2) => o2.id === orderId));
    return await this.brokerConfig.customUI.showCancelOrderDialog(order);
  }
  showClosePositionDialog(positionId) {
    var _a3, _b3;
    should((_b3 = (_a3 = this.brokerConfig) == null ? void 0 : _a3.customUI) == null ? void 0 : _b3.showClosePositionDialog);
    return this.brokerConfig.customUI.showClosePositionDialog(positionId);
  }
  showModifyPositionDialog(positionId) {
    var _a3, _b3;
    should((_b3 = (_a3 = this.brokerConfig) == null ? void 0 : _a3.customUI) == null ? void 0 : _b3.showModifyPositionDialog);
    return this.brokerConfig.customUI.showModifyPositionDialog(positionId);
  }
  showCancelBracketsDialog(orderId) {
    return this.showCancelOrderDialog(orderId);
  }
  showPositionBracketsDialog(position, brackets, focus) {
    var _a3, _b3, _c2;
    should((_b3 = (_a3 = this.brokerConfig) == null ? void 0 : _a3.customUI) == null ? void 0 : _b3.showPositionDialog);
    return (_c2 = this.brokerConfig.customUI) == null ? void 0 : _c2.showPositionDialog(position, brackets, focus);
  }
  showReversePositionDialog(position) {
    var _a3, _b3, _c2;
    should((_b3 = (_a3 = this.brokerConfig) == null ? void 0 : _a3.customUI) == null ? void 0 : _b3.showPositionDialog);
    return (_c2 = this.brokerConfig.customUI) == null ? void 0 : _c2.showPositionDialog(position, /* @__PURE__ */ Object.create(null));
  }
}
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __decorateClass$1 = (decorators, target, key2, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key2) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$1 = (index2, decorator) => (target, key2) => decorator(target, key2, index2);
let stackElementCounter = 0;
class ResourceStackElement {
  constructor(actual, resource) {
    __publicField(this, "id", ++stackElementCounter);
    __publicField(this, "type", UndoRedoElementType.Resource);
    __publicField(this, "actual");
    __publicField(this, "resource");
    this.actual = actual;
    this.resource = resource;
  }
}
class ResourceEditStack {
  constructor(resource) {
    __publicField(this, "resource");
    __publicField(this, "_past");
    __publicField(this, "_future");
    __publicField(this, "locked");
    __publicField(this, "versionId");
    this.resource = resource;
    this._past = [];
    this._future = [];
    this.locked = false;
    this.versionId = 1;
  }
  pushElement(element2) {
    this._future = [];
    this._past.push(element2);
    this.versionId++;
  }
  getClosestPastElement() {
    if (this._past.length === 0) {
      return null;
    }
    return this._past[this._past.length - 1];
  }
  getClosestFutureElement() {
    if (this._future.length === 0) {
      return null;
    }
    return this._future[this._future.length - 1];
  }
  hasPastElements() {
    return this._past.length > 0;
  }
  hasFutureElements() {
    return this._future.length > 0;
  }
  moveForward(element2) {
    this._future.pop();
    this._past.push(element2);
    this.versionId++;
  }
  moveBackward(element2) {
    this._past.pop();
    this._future.push(element2);
    this.versionId++;
  }
}
class EditStackSnapshot {
  constructor(editStacks) {
    __publicField(this, "editStacks");
    __publicField(this, "_versionIds");
    this.editStacks = editStacks;
    this._versionIds = [];
    for (let i2 = 0, len = this.editStacks.length; i2 < len; i2++) {
      this._versionIds[i2] = this.editStacks[i2].versionId;
    }
  }
  isValid() {
    for (let i2 = 0, len = this.editStacks.length; i2 < len; i2++) {
      if (this._versionIds[i2] !== this.editStacks[i2].versionId) {
        return false;
      }
    }
    return true;
  }
}
let UndoRedoService = class {
  constructor(_notificationService) {
    __publicField(this, "_editStacks", /* @__PURE__ */ new Map());
    this._notificationService = _notificationService;
  }
  pushElement(element2) {
    if (element2.type === UndoRedoElementType.Resource) {
      this._pushElement(new ResourceStackElement(element2, element2.resource));
    } else {
      NOTIMPLEMENTED();
    }
  }
  _pushElement(element2) {
    const resource = element2.resource;
    let editStack;
    if (this._editStacks.has(resource)) {
      editStack = ensure(this._editStacks.get(resource));
    } else {
      editStack = new ResourceEditStack(resource);
      this._editStacks.set(resource, editStack);
    }
    editStack.pushElement(element2);
  }
  removeElements(resource) {
    if (this._editStacks.has(resource)) {
      this._editStacks.delete(resource);
    }
  }
  canUndo(resource) {
    var _a3;
    return ((_a3 = this._editStacks.get(resource)) == null ? void 0 : _a3.hasPastElements()) ?? false;
  }
  undo(resource) {
    return this._undo(resource);
  }
  _undo(resource) {
    if (!this._editStacks.has(resource)) {
      return;
    }
    const editStack = ensure(this._editStacks.get(resource));
    const element2 = editStack.getClosestPastElement();
    if (!element2) {
      return;
    }
    try {
      return this._resourceUndo(editStack, element2);
    } catch (e2) {
      console.error(e2);
    } finally {
    }
  }
  _resourceUndo(editStack, element2) {
    if (editStack.locked) {
      NOTREACHED();
    }
    editStack.moveBackward(element2);
    return this._safeInvokeWithLocks(
      element2,
      () => {
        element2.actual.undo();
      },
      new EditStackSnapshot([editStack])
    );
  }
  canRedo(resource) {
    var _a3;
    return ((_a3 = this._editStacks.get(resource)) == null ? void 0 : _a3.hasFutureElements()) ?? false;
  }
  redo(resource) {
    return this._redo(resource);
  }
  _redo(resource) {
    if (!this._editStacks.has(resource)) {
      return;
    }
    const editStack = ensure(this._editStacks.get(resource));
    const element2 = editStack.getClosestFutureElement();
    if (!element2) {
      return;
    }
    try {
      return this._resourceRedo(editStack, element2);
    } catch (error) {
      console.error(error);
    } finally {
    }
  }
  _resourceRedo(editStack, element2) {
    editStack.moveForward(element2);
    return this._safeInvokeWithLocks(
      element2,
      () => element2.actual.redo(),
      new EditStackSnapshot([editStack])
    );
  }
  _safeInvokeWithLocks(element2, invoke, editStackSnapshot) {
    const releaseLocks = this._acquireLocks(editStackSnapshot);
    let result;
    try {
      result = invoke();
    } catch (err) {
      releaseLocks();
      return this._onError(err, element2);
    }
    if (result) {
      return result.then(
        () => {
          releaseLocks();
        },
        (err) => {
          releaseLocks();
          return this._onError(err, element2);
        }
      );
    } else {
      releaseLocks();
    }
  }
  _acquireLocks(editStackSnapshot) {
    for (const editStack of editStackSnapshot.editStacks) {
      if (editStack.locked) {
        throw new Error("Cannot acquire edit stack lock");
      }
    }
    for (const editStack of editStackSnapshot.editStacks) {
      editStack.locked = true;
    }
    return () => {
      for (const editStack of editStackSnapshot.editStacks) {
        editStack.locked = false;
      }
    };
  }
  _onError(err, element2) {
    onUnexpectedError(err);
    this.removeElements(element2.resource);
    this._notificationService.error(err);
  }
};
UndoRedoService = __decorateClass$1([
  __decorateParam$1(0, INotificationService)
], UndoRedoService);
function getOrSet(map, key2, value) {
  let result = map.get(key2);
  if (result === void 0) {
    result = value;
    map.set(key2, result);
  }
  return result;
}
const IWorkbenchContributionsRegistry = createDecorator$1(
  "workbenchContributionsRegistry"
);
class WorkbenchContributionsRegistry extends Disposable {
  constructor() {
    super(...arguments);
    __publicField(this, "_serviceBrand");
    __publicField(this, "instantiationService");
    __publicField(this, "lifecycleService");
    __publicField(this, "logService");
    __publicField(this, "contributionsByPhase", /* @__PURE__ */ new Map());
    __publicField(this, "contributionsById", /* @__PURE__ */ new Map());
    __publicField(this, "instancesById", /* @__PURE__ */ new Map());
    __publicField(this, "instanceDisposables", this._register(new DisposableStore()));
    __publicField(this, "pendingRestoredContributions", new DeferredPromise$1());
  }
  register(id2, ctor, phase) {
    const contribution = { id: id2, ctor };
    if (this.instantiationService && this.logService && this.lifecycleService && this.lifecycleService.phase >= phase) {
      this.safeCreateContribution(this.instantiationService, this.logService, contribution);
    } else {
      getOrSet(this.contributionsByPhase, phase, []).push(contribution);
      if (!this.contributionsById.has(id2)) {
        this.contributionsById.set(id2, contribution);
      } else {
        console.error(
          `IWorkbenchContributionsRegistry#registerWorkbenchContribution(): Can't register multiple contributions with same id '${id2}'`
        );
      }
    }
  }
  start(accessor) {
    const instantiationService = this.instantiationService = accessor.get(IInstantiationService);
    const lifecycleService = this.lifecycleService = accessor.get(ILifecycleService);
    const logService = this.logService = accessor.get(ILogService);
    for (const phase of [
      LifecyclePhase.Starting,
      LifecyclePhase.Ready,
      LifecyclePhase.Restored,
      LifecyclePhase.Eventually
    ]) {
      this.instantiateByPhase(instantiationService, lifecycleService, logService, phase);
    }
  }
  dispose() {
    super.dispose();
    this.contributionsByPhase.clear();
    this.contributionsById.clear();
    this.instancesById.forEach((i2) => {
      if (isDisposable(i2)) {
        dispose(i2);
      }
    });
    this.pendingRestoredContributions = null;
  }
  // getWorkbenchContribution<T extends IWorkbenchContribution>(id: string): T {
  //   if (this.instancesById.has(id)) {
  //     return this.instancesById.get(id) as T;
  //   }
  //
  //   const instantiationService = this.instantiationService;
  //   const lifecycleService = this.lifecycleService;
  //   const logService = this.logService;
  //   if (!instantiationService || !lifecycleService || !logService) {
  //     throw new Error(
  //       `IWorkbenchContributionsRegistry#getContribution('${id}'): cannot be called before registry started`,
  //     );
  //   }
  //
  //   const contribution = this.contributionsById.get(id);
  //   if (!contribution) {
  //     throw new Error(
  //       `IWorkbenchContributionsRegistry#getContribution('${id}'): contribution with that identifier is unknown.`,
  //     );
  //   }
  //
  //   if (lifecycleService.phase < LifecyclePhase.Restored) {
  //     logService.warn(
  //       `IWorkbenchContributionsRegistry#getContribution('${id}'): contribution instantiated before LifecyclePhase.Restored!`,
  //     );
  //   }
  //
  //   this.safeCreateContribution(instantiationService, logService, contribution);
  //
  //   const instance = this.instancesById.get(id);
  //   if (!instance) {
  //     throw new Error(
  //       `IWorkbenchContributionsRegistry#getContribution('${id}'): failed to create contribution.`,
  //     );
  //   }
  //
  //   return instance as T;
  // }
  instantiateByPhase(instantiationService, lifecycleService, logService, phase) {
    if (lifecycleService.phase >= phase) {
      this.doInstantiateByPhase(instantiationService, logService, phase);
    } else {
      lifecycleService.when(phase).then(() => this.doInstantiateByPhase(instantiationService, logService, phase));
    }
  }
  async doInstantiateByPhase(instantiationService, logService, phase) {
    const contributions = this.contributionsByPhase.get(phase);
    if (contributions) {
      this.contributionsByPhase.delete(phase);
      switch (phase) {
        case LifecyclePhase.Starting:
        case LifecyclePhase.Ready: {
          for (const contribution of contributions) {
            this.safeCreateContribution(instantiationService, logService, contribution);
          }
          break;
        }
        case LifecyclePhase.Restored:
        case LifecyclePhase.Eventually: {
          if (phase === LifecyclePhase.Eventually) {
            await this.pendingRestoredContributions.p;
          }
          this.doInstantiateWhenIdle(contributions, instantiationService, logService, phase);
          break;
        }
      }
    }
  }
  doInstantiateWhenIdle(contributions, instantiationService, logService, phase) {
    let i2 = 0;
    const forcedTimeout = phase === LifecyclePhase.Eventually ? 3e3 : 500;
    const instantiateSome = (idle) => {
      while (i2 < contributions.length) {
        const contribution = contributions[i2++];
        this.safeCreateContribution(instantiationService, logService, contribution);
        if (idle.timeRemaining() < 1) {
          runWhenIdle(instantiateSome, forcedTimeout);
          break;
        }
      }
      if (i2 === contributions.length) {
        if (phase === LifecyclePhase.Restored) {
          this.pendingRestoredContributions.complete();
        }
      }
    };
    runWhenIdle(instantiateSome, forcedTimeout);
  }
  async safeCreateContribution(instantiationService, logService, contribution) {
    if (this.instancesById.has(contribution.id)) {
      return;
    }
    try {
      const ctor = await contribution.ctor();
      const instance = instantiationService.createInstance(ctor);
      this.instancesById.set(contribution.id, instance);
      this.contributionsById.delete(contribution.id);
      if (isDisposable(instance)) {
        this.instanceDisposables.add(instance);
      }
    } catch (error) {
      logService.error(
        `Unable to create workbench contribution '${contribution.id ?? contribution.ctor.name}'.`,
        error
      );
    } finally {
    }
  }
}
const smuiStyle = '@keyframes mdc-ripple-fg-radius-in {\n  from {\n    animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n    transform: translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1);\n  }\n  to {\n    transform: translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1));\n  }\n}\n@keyframes mdc-ripple-fg-opacity-in {\n  from {\n    animation-timing-function: linear;\n    opacity: 0;\n  }\n  to {\n    opacity: var(--mdc-ripple-fg-opacity, 0);\n  }\n}\n@keyframes mdc-ripple-fg-opacity-out {\n  from {\n    animation-timing-function: linear;\n    opacity: var(--mdc-ripple-fg-opacity, 0);\n  }\n  to {\n    opacity: 0;\n  }\n}\n.mdc-elevation-overlay {\n  position: absolute;\n  border-radius: inherit;\n  pointer-events: none;\n  opacity: 0;\n  /* @alternate */\n  opacity: var(--mdc-elevation-overlay-opacity, 0);\n  transition: opacity 280ms cubic-bezier(0.4, 0, 0.2, 1);\n  background-color: #fff;\n  /* @alternate */\n  background-color: var(--mdc-elevation-overlay-color, #fff);\n}\n\n.mdc-menu {\n  min-width: 112px;\n  /* @alternate */\n  min-width: var(--mdc-menu-min-width, 112px);\n}\n.mdc-menu .mdc-deprecated-list-item__meta {\n  color: rgba(0, 0, 0, 0.87);\n}\n.mdc-menu .mdc-deprecated-list-item__graphic {\n  color: rgba(0, 0, 0, 0.87);\n}\n.mdc-menu .mdc-menu-item--submenu-open .mdc-deprecated-list-item__ripple::before {\n  opacity: 0.04;\n}\n.mdc-menu .mdc-menu-item--submenu-open .mdc-list-item__ripple::before {\n  opacity: 0.04;\n}\n.mdc-menu .mdc-deprecated-list {\n  color: rgba(0, 0, 0, 0.87);\n}\n.mdc-menu .mdc-deprecated-list,\n.mdc-menu .mdc-list {\n  /* @alternate */\n  position: relative;\n  border-radius: inherit;\n}\n.mdc-menu .mdc-deprecated-list .mdc-elevation-overlay,\n.mdc-menu .mdc-list .mdc-elevation-overlay {\n  width: 100%;\n  height: 100%;\n  top: 0;\n  /* @noflip */ /*rtl:ignore*/\n  left: 0;\n}\n.mdc-menu .mdc-deprecated-list::before,\n.mdc-menu .mdc-list::before {\n  position: absolute;\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  /* @noflip */ /*rtl:ignore*/\n  left: 0;\n  border: 1px solid transparent;\n  border-radius: inherit;\n  content: "";\n  pointer-events: none;\n}\n@media screen and (forced-colors: active) {\n  .mdc-menu .mdc-deprecated-list::before,\n  .mdc-menu .mdc-list::before {\n    border-color: CanvasText;\n  }\n}\n.mdc-menu .mdc-deprecated-list-divider {\n  margin: 8px 0;\n}\n.mdc-menu .mdc-deprecated-list-item {\n  user-select: none;\n}\n.mdc-menu a.mdc-deprecated-list-item .mdc-deprecated-list-item__text,\n.mdc-menu a.mdc-deprecated-list-item .mdc-deprecated-list-item__graphic {\n  pointer-events: none;\n}\n\n.mdc-menu__selection-group {\n  padding: 0;\n  fill: currentColor;\n}\n.mdc-menu__selection-group .mdc-deprecated-list-item {\n  /* @noflip */ /*rtl:ignore*/\n  padding-left: 56px;\n  /* @noflip */ /*rtl:ignore*/\n  padding-right: 16px;\n}\n[dir=rtl] .mdc-menu__selection-group .mdc-deprecated-list-item, .mdc-menu__selection-group .mdc-deprecated-list-item[dir=rtl] {\n  /*rtl:begin:ignore*/\n  /* @noflip */ /*rtl:ignore*/\n  padding-left: 16px;\n  /* @noflip */ /*rtl:ignore*/\n  padding-right: 56px;\n  /*rtl:end:ignore*/\n}\n\n.mdc-menu__selection-group .mdc-menu__selection-group-icon {\n  /* @noflip */ /*rtl:ignore*/\n  left: 16px;\n  /* @noflip */ /*rtl:ignore*/\n  right: initial;\n  visibility: hidden;\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n  transition-property: visibility;\n  transition-delay: 0.075s;\n}\n[dir=rtl] .mdc-menu__selection-group .mdc-menu__selection-group-icon, .mdc-menu__selection-group .mdc-menu__selection-group-icon[dir=rtl] {\n  /*rtl:begin:ignore*/\n  /* @noflip */ /*rtl:ignore*/\n  left: initial;\n  /* @noflip */ /*rtl:ignore*/\n  right: 16px;\n  /*rtl:end:ignore*/\n}\n\n.mdc-menu-item--selected .mdc-menu__selection-group-icon {\n  display: inline;\n  visibility: visible;\n}\n\n.mdc-menu-surface {\n  display: none;\n  position: absolute;\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n  transform: scale(1);\n  transform-origin: top left;\n  opacity: 0;\n  visibility: hidden;\n  overflow: auto;\n  will-change: transform, opacity;\n  height: 0;\n  /* @alternate */\n  box-shadow: 0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12);\n  /* @noflip */ /*rtl:ignore*/\n  transform-origin-left: top left;\n  /* @noflip */ /*rtl:ignore*/\n  transform-origin-right: top right;\n}\n.mdc-menu-surface:focus {\n  outline: none;\n}\n.mdc-menu-surface--animating-open {\n  display: inline-block;\n  transform: scale(0.8);\n  opacity: 0;\n  visibility: visible;\n  height: fit-content;\n}\n.mdc-menu-surface--open {\n  display: inline-block;\n  transform: scale(1);\n  opacity: 1;\n  visibility: visible;\n  height: fit-content;\n}\n.mdc-menu-surface--animating-closed {\n  display: inline-block;\n  opacity: 0;\n  visibility: hidden;\n  height: 0;\n}\n[dir=rtl] .mdc-menu-surface, .mdc-menu-surface[dir=rtl] {\n  /*rtl:begin:ignore*/\n  /* @noflip */ /*rtl:ignore*/\n  transform-origin-left: top right;\n  /* @noflip */ /*rtl:ignore*/\n  transform-origin-right: top left;\n  /*rtl:end:ignore*/\n}\n\n.mdc-menu-surface--anchor {\n  position: relative;\n  overflow: visible;\n}\n\n.mdc-menu-surface--fixed {\n  position: fixed;\n}\n\n.mdc-menu-surface--fullwidth {\n  width: 100%;\n}\n\n.mdc-menu-surface {\n  max-width: calc(100vw - 32px);\n  /* @alternate */\n  max-width: var(--mdc-menu-max-width, calc(100vw - 32px));\n  max-height: calc(100vh - 32px);\n  /* @alternate */\n  max-height: var(--mdc-menu-max-height, calc(100vh - 32px));\n  z-index: 8;\n  transition: opacity 0.03s linear, transform 0.12s cubic-bezier(0, 0, 0.2, 1), height 250ms cubic-bezier(0, 0, 0.2, 1);\n  background-color: #fff;\n  /* @alternate */\n  background-color: var(--mdc-theme-surface, #fff);\n  color: #000;\n  /* @alternate */\n  color: var(--mdc-theme-on-surface, #000);\n  border-radius: 4px;\n  /* @alternate */\n  border-radius: var(--mdc-shape-medium, 4px);\n}\n.mdc-menu-surface--animating-closed {\n  transition: opacity 0.075s linear;\n}\n\n.smui-menu-surface--static {\n  position: static;\n  z-index: 0;\n  display: inline-block;\n  transform: scale(1);\n  opacity: 1;\n}\n\n.smui-menu-surface--measure {\n  display: block !important;\n  opacity: 0 !important;\n}\n\n.mdc-menu__selection-group .mdc-list-item__graphic.mdc-menu__selection-group-icon {\n  display: none;\n}\n\n.mdc-menu-item--selected .mdc-list-item__graphic.mdc-menu__selection-group-icon {\n  display: inline;\n}\n\n.mdc-tooltip__surface {\n  border-radius: 4px;\n  /* @alternate */\n  border-radius: var(--mdc-shape-small, 4px);\n}\n\n.mdc-tooltip__caret-surface-top,\n.mdc-tooltip__caret-surface-bottom {\n  border-radius: 4px;\n  /* @alternate */\n  border-radius: var(--mdc-shape-small, 4px);\n}\n\n.mdc-tooltip__surface {\n  color: white;\n  /* @alternate */\n  color: var(--mdc-theme-text-primary-on-dark, white);\n}\n\n.mdc-tooltip__surface {\n  background-color: rgba(0, 0, 0, 0.6);\n}\n\n.mdc-tooltip__title {\n  color: rgba(0, 0, 0, 0.87);\n  /* @alternate */\n  color: var(--mdc-theme-text-primary-on-light, rgba(0, 0, 0, 0.87));\n}\n\n.mdc-tooltip__content {\n  color: rgba(0, 0, 0, 0.6);\n}\n\n.mdc-tooltip__content-link {\n  color: #6200ee;\n  /* @alternate */\n  color: var(--mdc-theme-primary, #6200ee);\n}\n\n.mdc-tooltip__interactive-content {\n  overflow-x: unset;\n  overflow-y: auto;\n}\n\n.mdc-tooltip.mdc-tooltip--rich .mdc-tooltip__surface {\n  background-color: #fff;\n}\n.mdc-tooltip.mdc-tooltip--rich .mdc-tooltip__caret-surface-top,\n.mdc-tooltip.mdc-tooltip--rich .mdc-tooltip__caret-surface-bottom {\n  background-color: #fff;\n}\n\n.mdc-tooltip__surface {\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-smoothing: antialiased;\n  font-family: Roboto, sans-serif;\n  /* @alternate */\n  font-family: var(--mdc-typography-caption-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));\n  font-size: 0.75rem;\n  /* @alternate */\n  font-size: var(--mdc-typography-caption-font-size, 0.75rem);\n  font-weight: 400;\n  /* @alternate */\n  font-weight: var(--mdc-typography-caption-font-weight, 400);\n  letter-spacing: 0.0333333333em;\n  /* @alternate */\n  letter-spacing: var(--mdc-typography-caption-letter-spacing, 0.0333333333em);\n  text-decoration: inherit;\n  /* @alternate */\n  text-decoration: var(--mdc-typography-caption-text-decoration, inherit);\n  text-transform: inherit;\n  /* @alternate */\n  text-transform: var(--mdc-typography-caption-text-transform, inherit);\n}\n.mdc-tooltip--rich .mdc-tooltip__surface {\n  /* @alternate */\n  box-shadow: 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12);\n  border-radius: 4px;\n  line-height: 20px;\n}\n.mdc-tooltip--rich .mdc-tooltip__surface .mdc-elevation-overlay {\n  width: 100%;\n  height: 100%;\n  top: 0;\n  /* @noflip */ /*rtl:ignore*/\n  left: 0;\n}\n.mdc-tooltip__surface .mdc-tooltip__title {\n  display: block;\n  margin-top: 0;\n  /* @alternate */\n  line-height: 20px;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-smoothing: antialiased;\n  font-family: Roboto, sans-serif;\n  /* @alternate */\n  font-family: var(--mdc-typography-subtitle2-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));\n  font-size: 0.875rem;\n  /* @alternate */\n  font-size: var(--mdc-typography-subtitle2-font-size, 0.875rem);\n  line-height: 1.375rem;\n  /* @alternate */\n  line-height: var(--mdc-typography-subtitle2-line-height, 1.375rem);\n  font-weight: 500;\n  /* @alternate */\n  font-weight: var(--mdc-typography-subtitle2-font-weight, 500);\n  letter-spacing: 0.0071428571em;\n  /* @alternate */\n  letter-spacing: var(--mdc-typography-subtitle2-letter-spacing, 0.0071428571em);\n  text-decoration: inherit;\n  /* @alternate */\n  text-decoration: var(--mdc-typography-subtitle2-text-decoration, inherit);\n  text-transform: inherit;\n  /* @alternate */\n  text-transform: var(--mdc-typography-subtitle2-text-transform, inherit);\n}\n.mdc-tooltip__surface .mdc-tooltip__title::before {\n  display: inline-block;\n  width: 0;\n  height: 24px;\n  content: "";\n  vertical-align: 0;\n}\n.mdc-tooltip__surface .mdc-tooltip__content {\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-smoothing: antialiased;\n  font-family: Roboto, sans-serif;\n  /* @alternate */\n  font-family: var(--mdc-typography-body2-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));\n  font-size: 0.875rem;\n  /* @alternate */\n  font-size: var(--mdc-typography-body2-font-size, 0.875rem);\n  line-height: 1.25rem;\n  /* @alternate */\n  line-height: var(--mdc-typography-body2-line-height, 1.25rem);\n  font-weight: 400;\n  /* @alternate */\n  font-weight: var(--mdc-typography-body2-font-weight, 400);\n  letter-spacing: 0.0178571429em;\n  /* @alternate */\n  letter-spacing: var(--mdc-typography-body2-letter-spacing, 0.0178571429em);\n  text-decoration: inherit;\n  /* @alternate */\n  text-decoration: var(--mdc-typography-body2-text-decoration, inherit);\n  text-transform: inherit;\n  /* @alternate */\n  text-transform: var(--mdc-typography-body2-text-transform, inherit);\n}\n.mdc-tooltip--rich .mdc-tooltip__surface .mdc-tooltip__content {\n  max-width: calc(320px - 2 * 8px);\n  align-self: stretch;\n}\n\n.mdc-tooltip__surface {\n  word-break: break-all;\n  /* @alternate */\n  word-break: var(--mdc-tooltip-word-break, normal);\n  overflow-wrap: anywhere;\n}\n\n.mdc-tooltip--showing-transition .mdc-tooltip__surface-animation {\n  transition: opacity 150ms 0ms cubic-bezier(0, 0, 0.2, 1), transform 150ms 0ms cubic-bezier(0, 0, 0.2, 1);\n}\n\n.mdc-tooltip--hide-transition .mdc-tooltip__surface-animation {\n  transition: opacity 75ms 0ms cubic-bezier(0.4, 0, 1, 1);\n}\n\n.mdc-tooltip {\n  position: fixed;\n  display: none;\n  z-index: 9;\n}\n\n.mdc-tooltip-wrapper--rich {\n  position: relative;\n}\n\n.mdc-tooltip--shown,\n.mdc-tooltip--showing,\n.mdc-tooltip--hide {\n  display: inline-flex;\n}\n.mdc-tooltip--shown.mdc-tooltip--rich,\n.mdc-tooltip--showing.mdc-tooltip--rich,\n.mdc-tooltip--hide.mdc-tooltip--rich {\n  display: inline-block;\n  /* @noflip */ /*rtl:ignore*/\n  left: -320px;\n  position: absolute;\n}\n\n.mdc-tooltip__surface {\n  line-height: 16px;\n  padding: 4px 8px;\n  min-width: 40px;\n  max-width: 200px;\n  min-height: 24px;\n  max-height: 40vh;\n  box-sizing: border-box;\n  overflow: hidden;\n  text-align: center;\n}\n.mdc-tooltip__surface::before {\n  position: absolute;\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  /* @noflip */ /*rtl:ignore*/\n  left: 0;\n  border: 1px solid transparent;\n  border-radius: inherit;\n  content: "";\n  pointer-events: none;\n}\n@media screen and (forced-colors: active) {\n  .mdc-tooltip__surface::before {\n    border-color: CanvasText;\n  }\n}\n.mdc-tooltip--rich .mdc-tooltip__surface {\n  align-items: flex-start;\n  display: flex;\n  flex-direction: column;\n  min-height: 24px;\n  min-width: 40px;\n  max-width: 320px;\n  position: relative;\n  /* @noflip */ /*rtl:ignore*/\n  text-align: left;\n}\n[dir=rtl] .mdc-tooltip--rich .mdc-tooltip__surface, .mdc-tooltip--rich .mdc-tooltip__surface[dir=rtl] {\n  /*rtl:begin:ignore*/\n  /* @noflip */ /*rtl:ignore*/\n  text-align: right;\n  /*rtl:end:ignore*/\n}\n\n.mdc-tooltip--multiline .mdc-tooltip__surface {\n  /* @noflip */ /*rtl:ignore*/\n  text-align: left;\n}\n[dir=rtl] .mdc-tooltip--multiline .mdc-tooltip__surface, .mdc-tooltip--multiline .mdc-tooltip__surface[dir=rtl] {\n  /*rtl:begin:ignore*/\n  /* @noflip */ /*rtl:ignore*/\n  text-align: right;\n  /*rtl:end:ignore*/\n}\n\n.mdc-tooltip__surface .mdc-tooltip__title {\n  margin: 0 8px;\n}\n.mdc-tooltip__surface .mdc-tooltip__content {\n  max-width: calc(200px - 2 * 8px);\n  margin: 8px;\n}\n.mdc-tooltip--rich .mdc-tooltip__surface .mdc-tooltip__content {\n  max-width: calc(320px - 2 * 8px);\n  align-self: stretch;\n}\n.mdc-tooltip__surface .mdc-tooltip__content-link {\n  text-decoration: none;\n}\n\n.mdc-tooltip--rich-actions,\n.mdc-tooltip__content,\n.mdc-tooltip__title {\n  z-index: 1;\n}\n\n.mdc-tooltip__surface-animation {\n  opacity: 0;\n  transform: scale(0.8);\n  will-change: transform, opacity;\n}\n.mdc-tooltip--shown .mdc-tooltip__surface-animation {\n  transform: scale(1);\n  opacity: 1;\n}\n.mdc-tooltip--hide .mdc-tooltip__surface-animation {\n  transform: scale(1);\n}\n\n.mdc-tooltip__caret-surface-top,\n.mdc-tooltip__caret-surface-bottom {\n  position: absolute;\n  height: 24px;\n  width: 24px;\n  /* @noflip */ /*rtl:ignore*/\n  transform: rotate(35deg) skewY(20deg) scaleX(0.9396926208);\n}\n.mdc-tooltip__caret-surface-top .mdc-elevation-overlay,\n.mdc-tooltip__caret-surface-bottom .mdc-elevation-overlay {\n  width: 100%;\n  height: 100%;\n  top: 0;\n  /* @noflip */ /*rtl:ignore*/\n  left: 0;\n}\n\n.mdc-tooltip__caret-surface-bottom {\n  /* @alternate */\n  box-shadow: 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12);\n  outline: 1px solid transparent;\n  z-index: -1;\n}\n@media screen and (forced-colors: active) {\n  .mdc-tooltip__caret-surface-bottom {\n    outline-color: CanvasText;\n  }\n}\n\n.mdc-dialog .mdc-dialog__surface {\n  background-color: #fff;\n  /* @alternate */\n  background-color: var(--mdc-theme-surface, #fff);\n}\n.mdc-dialog .mdc-dialog__scrim {\n  background-color: rgba(0, 0, 0, 0.32);\n}\n.mdc-dialog .mdc-dialog__surface-scrim {\n  background-color: rgba(0, 0, 0, 0.32);\n}\n.mdc-dialog .mdc-dialog__title {\n  color: rgba(0, 0, 0, 0.87);\n}\n.mdc-dialog .mdc-dialog__content {\n  color: rgba(0, 0, 0, 0.6);\n}\n.mdc-dialog .mdc-dialog__close {\n  color: #000;\n  /* @alternate */\n  color: var(--mdc-theme-on-surface, #000);\n}\n.mdc-dialog .mdc-dialog__close .mdc-icon-button__ripple::before, .mdc-dialog .mdc-dialog__close .mdc-icon-button__ripple::after {\n  background-color: #000;\n  /* @alternate */\n  background-color: var(--mdc-ripple-color, var(--mdc-theme-on-surface, #000));\n}\n.mdc-dialog .mdc-dialog__close:hover .mdc-icon-button__ripple::before, .mdc-dialog .mdc-dialog__close.mdc-ripple-surface--hover .mdc-icon-button__ripple::before {\n  opacity: 0.04;\n  /* @alternate */\n  opacity: var(--mdc-ripple-hover-opacity, 0.04);\n}\n.mdc-dialog .mdc-dialog__close.mdc-ripple-upgraded--background-focused .mdc-icon-button__ripple::before, .mdc-dialog .mdc-dialog__close:not(.mdc-ripple-upgraded):focus .mdc-icon-button__ripple::before {\n  transition-duration: 75ms;\n  opacity: 0.12;\n  /* @alternate */\n  opacity: var(--mdc-ripple-focus-opacity, 0.12);\n}\n.mdc-dialog .mdc-dialog__close:not(.mdc-ripple-upgraded) .mdc-icon-button__ripple::after {\n  transition: opacity 150ms linear;\n}\n.mdc-dialog .mdc-dialog__close:not(.mdc-ripple-upgraded):active .mdc-icon-button__ripple::after {\n  transition-duration: 75ms;\n  opacity: 0.12;\n  /* @alternate */\n  opacity: var(--mdc-ripple-press-opacity, 0.12);\n}\n.mdc-dialog .mdc-dialog__close.mdc-ripple-upgraded {\n  --mdc-ripple-fg-opacity: var(--mdc-ripple-press-opacity, 0.12);\n}\n.mdc-dialog.mdc-dialog--scrollable .mdc-dialog__title, .mdc-dialog.mdc-dialog--scrollable .mdc-dialog__actions, .mdc-dialog.mdc-dialog--scrollable.mdc-dialog-scroll-divider-footer .mdc-dialog__actions {\n  border-color: rgba(0, 0, 0, 0.12);\n}\n.mdc-dialog.mdc-dialog--scrollable .mdc-dialog__title {\n  border-bottom: 1px solid rgba(0, 0, 0, 0.12);\n  margin-bottom: 0;\n}\n.mdc-dialog.mdc-dialog-scroll-divider-header.mdc-dialog--fullscreen .mdc-dialog__header {\n  /* @alternate */\n  box-shadow: 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12);\n}\n.mdc-dialog .mdc-dialog__surface {\n  border-radius: 4px;\n  /* @alternate */\n  border-radius: var(--mdc-shape-medium, 4px);\n}\n\n.mdc-dialog__surface {\n  /* @alternate */\n  box-shadow: 0px 11px 15px -7px rgba(0, 0, 0, 0.2), 0px 24px 38px 3px rgba(0, 0, 0, 0.14), 0px 9px 46px 8px rgba(0, 0, 0, 0.12);\n}\n\n.mdc-dialog__title {\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-smoothing: antialiased;\n  font-family: Roboto, sans-serif;\n  /* @alternate */\n  font-family: var(--mdc-typography-headline6-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));\n  font-size: 1.25rem;\n  /* @alternate */\n  font-size: var(--mdc-typography-headline6-font-size, 1.25rem);\n  line-height: 2rem;\n  /* @alternate */\n  line-height: var(--mdc-typography-headline6-line-height, 2rem);\n  font-weight: 500;\n  /* @alternate */\n  font-weight: var(--mdc-typography-headline6-font-weight, 500);\n  letter-spacing: 0.0125em;\n  /* @alternate */\n  letter-spacing: var(--mdc-typography-headline6-letter-spacing, 0.0125em);\n  text-decoration: inherit;\n  /* @alternate */\n  text-decoration: var(--mdc-typography-headline6-text-decoration, inherit);\n  text-transform: inherit;\n  /* @alternate */\n  text-transform: var(--mdc-typography-headline6-text-transform, inherit);\n}\n\n.mdc-dialog__content {\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-smoothing: antialiased;\n  font-family: Roboto, sans-serif;\n  /* @alternate */\n  font-family: var(--mdc-typography-body1-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));\n  font-size: 1rem;\n  /* @alternate */\n  font-size: var(--mdc-typography-body1-font-size, 1rem);\n  line-height: 1.5rem;\n  /* @alternate */\n  line-height: var(--mdc-typography-body1-line-height, 1.5rem);\n  font-weight: 400;\n  /* @alternate */\n  font-weight: var(--mdc-typography-body1-font-weight, 400);\n  letter-spacing: 0.03125em;\n  /* @alternate */\n  letter-spacing: var(--mdc-typography-body1-letter-spacing, 0.03125em);\n  text-decoration: inherit;\n  /* @alternate */\n  text-decoration: var(--mdc-typography-body1-text-decoration, inherit);\n  text-transform: inherit;\n  /* @alternate */\n  text-transform: var(--mdc-typography-body1-text-transform, inherit);\n}\n\n.mdc-dialog__title-icon {\n  /** Hook for theming API. */\n}\n\n.mdc-dialog,\n.mdc-dialog__scrim {\n  position: fixed;\n  top: 0;\n  left: 0;\n  align-items: center;\n  justify-content: center;\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n}\n\n.mdc-dialog {\n  display: none;\n  z-index: 7;\n  /* @alternate */\n  z-index: var(--mdc-dialog-z-index, 7);\n}\n.mdc-dialog .mdc-dialog__content {\n  padding: 20px 24px 20px 24px;\n}\n.mdc-dialog .mdc-dialog__surface {\n  min-width: 280px;\n}\n@media (max-width: 592px) {\n  .mdc-dialog .mdc-dialog__surface {\n    max-width: calc(100vw - 32px);\n  }\n}\n@media (min-width: 592px) {\n  .mdc-dialog .mdc-dialog__surface {\n    max-width: 560px;\n  }\n}\n.mdc-dialog .mdc-dialog__surface {\n  max-height: calc(100% - 32px);\n}\n.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface {\n  max-width: none;\n}\n@media (max-width: 960px) {\n  .mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface {\n    max-height: 560px;\n    width: 560px;\n  }\n  .mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close-tooltip-wrapper {\n    position: relative;\n    right: -12px;\n  }\n}\n@media (max-width: 720px) and (max-width: 672px) {\n  .mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface {\n    width: calc(100vw - 112px);\n  }\n}\n@media (max-width: 720px) and (min-width: 672px) {\n  .mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface {\n    width: 560px;\n  }\n}\n@media (max-width: 720px) and (max-height: 720px) {\n  .mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface {\n    max-height: calc(100vh - 160px);\n  }\n}\n@media (max-width: 720px) and (min-height: 720px) {\n  .mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface {\n    max-height: 560px;\n  }\n}\n@media (max-width: 720px) {\n  .mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close-tooltip-wrapper {\n    position: relative;\n    right: -12px;\n  }\n}\n@media (max-width: 720px) and (max-height: 400px), (max-width: 600px), (min-width: 720px) and (max-height: 400px) {\n  .mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface {\n    height: 100%;\n    max-height: 100vh;\n    max-width: 100vw;\n    width: 100vw;\n    border-radius: 0;\n  }\n  .mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close-tooltip-wrapper {\n    position: relative;\n    order: -1;\n    left: -12px;\n  }\n  .mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__header {\n    padding: 0 16px 9px;\n    justify-content: flex-start;\n  }\n  .mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__title {\n    margin-left: calc(16px - 2 * 12px);\n  }\n}\n@media (min-width: 960px) {\n  .mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface {\n    width: calc(100vw - 400px);\n  }\n  .mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close-tooltip-wrapper {\n    position: relative;\n    right: -12px;\n  }\n}\n.mdc-dialog.mdc-dialog__scrim--hidden .mdc-dialog__scrim {\n  opacity: 0;\n}\n\n.mdc-dialog__scrim {\n  opacity: 0;\n  z-index: -1;\n}\n\n.mdc-dialog__container {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: space-around;\n  box-sizing: border-box;\n  height: 100%;\n  opacity: 0;\n  pointer-events: none;\n}\n\n.mdc-dialog__surface {\n  /* @alternate */\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  flex-grow: 0;\n  flex-shrink: 0;\n  box-sizing: border-box;\n  max-width: 100%;\n  max-height: 100%;\n  pointer-events: auto;\n  overflow-y: auto;\n  outline: 0;\n  transform: scale(0.8);\n}\n.mdc-dialog__surface .mdc-elevation-overlay {\n  width: 100%;\n  height: 100%;\n  top: 0;\n  /* @noflip */ /*rtl:ignore*/\n  left: 0;\n}\n[dir=rtl] .mdc-dialog__surface, .mdc-dialog__surface[dir=rtl] {\n  /*rtl:begin:ignore*/\n  /* @noflip */ /*rtl:ignore*/\n  text-align: right;\n  /*rtl:end:ignore*/\n}\n\n@media screen and (forced-colors: active), (-ms-high-contrast: active) {\n  .mdc-dialog__surface {\n    outline: 2px solid windowText;\n  }\n}\n.mdc-dialog__surface::before {\n  position: absolute;\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  /* @noflip */ /*rtl:ignore*/\n  left: 0;\n  border: 2px solid transparent;\n  border-radius: inherit;\n  content: "";\n  pointer-events: none;\n}\n@media screen and (forced-colors: active) {\n  .mdc-dialog__surface::before {\n    border-color: CanvasText;\n  }\n}\n@media screen and (-ms-high-contrast: active), screen and (-ms-high-contrast: none) {\n  .mdc-dialog__surface::before {\n    content: none;\n  }\n}\n\n.mdc-dialog__title {\n  display: block;\n  margin-top: 0;\n  /* @alternate */\n  position: relative;\n  flex-shrink: 0;\n  box-sizing: border-box;\n  margin: 0 0 1px;\n  padding: 0 24px 9px;\n}\n.mdc-dialog__title::before {\n  display: inline-block;\n  width: 0;\n  height: 40px;\n  content: "";\n  vertical-align: 0;\n}\n[dir=rtl] .mdc-dialog__title, .mdc-dialog__title[dir=rtl] {\n  /*rtl:begin:ignore*/\n  /* @noflip */ /*rtl:ignore*/\n  text-align: right;\n  /*rtl:end:ignore*/\n}\n\n.mdc-dialog--scrollable .mdc-dialog__title {\n  margin-bottom: 1px;\n  padding-bottom: 15px;\n}\n\n.mdc-dialog--fullscreen .mdc-dialog__header {\n  align-items: baseline;\n  border-bottom: 1px solid transparent;\n  display: inline-flex;\n  justify-content: space-between;\n  padding: 0 24px 9px;\n  z-index: 1;\n}\n@media screen and (forced-colors: active) {\n  .mdc-dialog--fullscreen .mdc-dialog__header {\n    border-bottom-color: CanvasText;\n  }\n}\n.mdc-dialog--fullscreen .mdc-dialog__header .mdc-dialog__close-tooltip-wrapper {\n  position: relative;\n  right: -12px;\n}\n.mdc-dialog--fullscreen .mdc-dialog__title {\n  margin-bottom: 0;\n  padding: 0;\n  border-bottom: 0;\n}\n.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__title {\n  border-bottom: 0;\n  margin-bottom: 0;\n}\n.mdc-dialog--fullscreen .mdc-dialog__close-tooltip-wrapper {\n  top: 5px;\n}\n.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__actions {\n  border-top: 1px solid transparent;\n}\n@media screen and (forced-colors: active) {\n  .mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__actions {\n    border-top-color: CanvasText;\n  }\n}\n\n.mdc-dialog--fullscreen--titleless .mdc-dialog__close-tooltip-wrapper {\n  margin-top: 4px;\n}\n.mdc-dialog--fullscreen--titleless.mdc-dialog--scrollable .mdc-dialog__close-tooltip-wrapper {\n  margin-top: 0;\n}\n\n.mdc-dialog__content {\n  flex-grow: 1;\n  box-sizing: border-box;\n  margin: 0;\n  overflow: auto;\n}\n.mdc-dialog__content > :first-child {\n  margin-top: 0;\n}\n.mdc-dialog__content > :last-child {\n  margin-bottom: 0;\n}\n\n.mdc-dialog__title + .mdc-dialog__content,\n.mdc-dialog__header + .mdc-dialog__content {\n  padding-top: 0;\n}\n\n.mdc-dialog--scrollable .mdc-dialog__title + .mdc-dialog__content {\n  padding-top: 8px;\n  padding-bottom: 8px;\n}\n\n.mdc-dialog__content .mdc-deprecated-list:first-child:last-child {\n  padding: 6px 0 0;\n}\n\n.mdc-dialog--scrollable .mdc-dialog__content .mdc-deprecated-list:first-child:last-child {\n  padding: 0;\n}\n\n.mdc-dialog__actions {\n  display: flex;\n  position: relative;\n  flex-shrink: 0;\n  flex-wrap: wrap;\n  align-items: center;\n  justify-content: flex-end;\n  box-sizing: border-box;\n  min-height: 52px;\n  margin: 0;\n  padding: 8px;\n  border-top: 1px solid transparent;\n}\n@media screen and (forced-colors: active) {\n  .mdc-dialog__actions {\n    border-top-color: CanvasText;\n  }\n}\n.mdc-dialog--stacked .mdc-dialog__actions {\n  flex-direction: column;\n  align-items: flex-end;\n}\n\n.mdc-dialog__button {\n  /* @noflip */ /*rtl:ignore*/\n  margin-left: 8px;\n  /* @noflip */ /*rtl:ignore*/\n  margin-right: 0;\n  max-width: 100%;\n  /* @noflip */ /*rtl:ignore*/\n  text-align: right;\n}\n[dir=rtl] .mdc-dialog__button, .mdc-dialog__button[dir=rtl] {\n  /*rtl:begin:ignore*/\n  /* @noflip */ /*rtl:ignore*/\n  margin-left: 0;\n  /* @noflip */ /*rtl:ignore*/\n  margin-right: 8px;\n  /*rtl:end:ignore*/\n}\n\n.mdc-dialog__button:first-child {\n  /* @noflip */ /*rtl:ignore*/\n  margin-left: 0;\n  /* @noflip */ /*rtl:ignore*/\n  margin-right: 0;\n}\n[dir=rtl] .mdc-dialog__button:first-child, .mdc-dialog__button:first-child[dir=rtl] {\n  /*rtl:begin:ignore*/\n  /* @noflip */ /*rtl:ignore*/\n  margin-left: 0;\n  /* @noflip */ /*rtl:ignore*/\n  margin-right: 0;\n  /*rtl:end:ignore*/\n}\n\n[dir=rtl] .mdc-dialog__button, .mdc-dialog__button[dir=rtl] {\n  /*rtl:begin:ignore*/\n  /* @noflip */ /*rtl:ignore*/\n  text-align: left;\n  /*rtl:end:ignore*/\n}\n\n.mdc-dialog--stacked .mdc-dialog__button:not(:first-child) {\n  margin-top: 12px;\n}\n\n.mdc-dialog--open,\n.mdc-dialog--opening,\n.mdc-dialog--closing {\n  display: flex;\n}\n\n.mdc-dialog--opening .mdc-dialog__scrim {\n  transition: opacity 150ms linear;\n}\n.mdc-dialog--opening .mdc-dialog__container {\n  transition: opacity 75ms linear, transform 150ms 0ms cubic-bezier(0, 0, 0.2, 1);\n}\n\n.mdc-dialog--closing .mdc-dialog__scrim,\n.mdc-dialog--closing .mdc-dialog__container {\n  transition: opacity 75ms linear;\n}\n.mdc-dialog--closing .mdc-dialog__container {\n  transform: none;\n}\n.mdc-dialog--closing .mdc-dialog__surface {\n  transform: none;\n}\n\n.mdc-dialog--chaining .mdc-dialog__scrim {\n  transition: none;\n  opacity: 1;\n}\n\n.mdc-dialog--open .mdc-dialog__scrim {\n  opacity: 1;\n}\n.mdc-dialog--open .mdc-dialog__container {\n  opacity: 1;\n}\n.mdc-dialog--open .mdc-dialog__surface {\n  transform: none;\n}\n.mdc-dialog--open.mdc-dialog__surface-scrim--shown .mdc-dialog__surface-scrim {\n  opacity: 1;\n}\n.mdc-dialog--open.mdc-dialog__surface-scrim--hiding .mdc-dialog__surface-scrim {\n  transition: opacity 75ms linear;\n}\n.mdc-dialog--open.mdc-dialog__surface-scrim--showing .mdc-dialog__surface-scrim {\n  transition: opacity 150ms linear;\n}\n\n.mdc-dialog__surface-scrim {\n  display: none;\n  opacity: 0;\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  z-index: 1;\n}\n.mdc-dialog__surface-scrim--shown .mdc-dialog__surface-scrim, .mdc-dialog__surface-scrim--showing .mdc-dialog__surface-scrim, .mdc-dialog__surface-scrim--hiding .mdc-dialog__surface-scrim {\n  display: block;\n}\n\n.mdc-dialog-scroll-lock {\n  overflow: hidden;\n}\n\n.mdc-dialog--no-content-padding .mdc-dialog__content {\n  padding: 0;\n}\n\n.mdc-dialog--sheet .mdc-dialog__container .mdc-dialog__close-tooltip-wrapper {\n  right: 12px;\n  top: 9px;\n  position: absolute;\n  z-index: 1;\n}\n\n.mdc-dialog__scrim--removed {\n  pointer-events: none;\n}\n.mdc-dialog__scrim--removed .mdc-dialog__scrim,\n.mdc-dialog__scrim--removed .mdc-dialog__surface-scrim {\n  display: none;\n}\n\n.mdc-dialog.smui-dialog--selection .mdc-dialog__content {\n  padding: 0;\n}\n\n.mdc-dialog--stacked .mdc-dialog__actions.smui-dialog__actions--reversed {\n  flex-direction: column-reverse;\n}\n.mdc-dialog--stacked .mdc-dialog__actions.smui-dialog__actions--reversed .mdc-dialog__button:not(:last-child) {\n  margin-top: 12px;\n}\n.mdc-dialog--stacked .mdc-dialog__actions.smui-dialog__actions--reversed .mdc-dialog__button:last-child {\n  margin-top: 0;\n}\n\n.mdc-snackbar {\n  z-index: 8;\n  margin: 8px;\n  display: none;\n  position: fixed;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  align-items: center;\n  justify-content: center;\n  box-sizing: border-box;\n  pointer-events: none;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n}\n\n.mdc-snackbar__surface {\n  background-color: #333333;\n}\n\n.mdc-snackbar__label {\n  color: rgba(255, 255, 255, 0.87);\n}\n\n.mdc-snackbar__surface {\n  min-width: 344px;\n}\n@media (max-width: 480px), (max-width: 344px) {\n  .mdc-snackbar__surface {\n    min-width: 100%;\n  }\n}\n\n.mdc-snackbar__surface {\n  max-width: 672px;\n}\n\n.mdc-snackbar__surface {\n  /* @alternate */\n  box-shadow: 0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12);\n}\n\n.mdc-snackbar__surface {\n  border-radius: 4px;\n  /* @alternate */\n  border-radius: var(--mdc-shape-small, 4px);\n}\n\n.mdc-snackbar--opening,\n.mdc-snackbar--open,\n.mdc-snackbar--closing {\n  display: flex;\n}\n\n.mdc-snackbar--open .mdc-snackbar__label,\n.mdc-snackbar--open .mdc-snackbar__actions {\n  visibility: visible;\n}\n\n.mdc-snackbar--leading {\n  justify-content: flex-start;\n}\n\n.mdc-snackbar--stacked .mdc-snackbar__label {\n  /* @noflip */ /*rtl:ignore*/\n  padding-left: 16px;\n  /* @noflip */ /*rtl:ignore*/\n  padding-right: 8px;\n  padding-bottom: 12px;\n}\n[dir=rtl] .mdc-snackbar--stacked .mdc-snackbar__label, .mdc-snackbar--stacked .mdc-snackbar__label[dir=rtl] {\n  /*rtl:begin:ignore*/\n  /* @noflip */ /*rtl:ignore*/\n  padding-left: 8px;\n  /* @noflip */ /*rtl:ignore*/\n  padding-right: 16px;\n  /*rtl:end:ignore*/\n}\n\n.mdc-snackbar--stacked .mdc-snackbar__surface {\n  flex-direction: column;\n  align-items: flex-start;\n}\n.mdc-snackbar--stacked .mdc-snackbar__actions {\n  align-self: flex-end;\n  margin-bottom: 8px;\n}\n\n.mdc-snackbar__surface {\n  /* @noflip */ /*rtl:ignore*/\n  padding-left: 0;\n  /* @noflip */ /*rtl:ignore*/\n  padding-right: 8px;\n  display: flex;\n  align-items: center;\n  justify-content: flex-start;\n  box-sizing: border-box;\n  transform: scale(0.8);\n  opacity: 0;\n}\n.mdc-snackbar__surface::before {\n  position: absolute;\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  border: 1px solid transparent;\n  border-radius: inherit;\n  content: "";\n  pointer-events: none;\n}\n@media screen and (forced-colors: active) {\n  .mdc-snackbar__surface::before {\n    border-color: CanvasText;\n  }\n}\n[dir=rtl] .mdc-snackbar__surface, .mdc-snackbar__surface[dir=rtl] {\n  /*rtl:begin:ignore*/\n  /* @noflip */ /*rtl:ignore*/\n  padding-left: 8px;\n  /* @noflip */ /*rtl:ignore*/\n  padding-right: 0;\n  /*rtl:end:ignore*/\n}\n\n.mdc-snackbar--open .mdc-snackbar__surface {\n  transform: scale(1);\n  opacity: 1;\n  pointer-events: auto;\n  transition: opacity 150ms 0ms cubic-bezier(0, 0, 0.2, 1), transform 150ms 0ms cubic-bezier(0, 0, 0.2, 1);\n}\n.mdc-snackbar--closing .mdc-snackbar__surface {\n  transform: scale(1);\n  transition: opacity 75ms 0ms cubic-bezier(0.4, 0, 1, 1);\n}\n\n.mdc-snackbar__label {\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-smoothing: antialiased;\n  font-family: Roboto, sans-serif;\n  /* @alternate */\n  font-family: var(--mdc-typography-body2-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));\n  font-size: 0.875rem;\n  /* @alternate */\n  font-size: var(--mdc-typography-body2-font-size, 0.875rem);\n  line-height: 1.25rem;\n  /* @alternate */\n  line-height: var(--mdc-typography-body2-line-height, 1.25rem);\n  font-weight: 400;\n  /* @alternate */\n  font-weight: var(--mdc-typography-body2-font-weight, 400);\n  letter-spacing: 0.0178571429em;\n  /* @alternate */\n  letter-spacing: var(--mdc-typography-body2-letter-spacing, 0.0178571429em);\n  text-decoration: inherit;\n  /* @alternate */\n  text-decoration: var(--mdc-typography-body2-text-decoration, inherit);\n  text-transform: inherit;\n  /* @alternate */\n  text-transform: var(--mdc-typography-body2-text-transform, inherit);\n  /* @noflip */ /*rtl:ignore*/\n  padding-left: 16px;\n  /* @noflip */ /*rtl:ignore*/\n  padding-right: 8px;\n  width: 100%;\n  flex-grow: 1;\n  box-sizing: border-box;\n  margin: 0;\n  visibility: hidden;\n  padding-top: 14px;\n  padding-bottom: 14px;\n}\n[dir=rtl] .mdc-snackbar__label, .mdc-snackbar__label[dir=rtl] {\n  /*rtl:begin:ignore*/\n  /* @noflip */ /*rtl:ignore*/\n  padding-left: 8px;\n  /* @noflip */ /*rtl:ignore*/\n  padding-right: 16px;\n  /*rtl:end:ignore*/\n}\n\n.mdc-snackbar__label::before {\n  display: inline;\n  content: attr(data-mdc-snackbar-label-text);\n}\n\n.mdc-snackbar__actions {\n  display: flex;\n  flex-shrink: 0;\n  align-items: center;\n  box-sizing: border-box;\n  visibility: hidden;\n}\n\n.mdc-snackbar__action:not(:disabled) {\n  color: #bb86fc;\n}\n.mdc-snackbar__action .mdc-button__ripple::before, .mdc-snackbar__action .mdc-button__ripple::after {\n  background-color: #bb86fc;\n  /* @alternate */\n  background-color: var(--mdc-ripple-color, #bb86fc);\n}\n.mdc-snackbar__action:hover .mdc-button__ripple::before, .mdc-snackbar__action.mdc-ripple-surface--hover .mdc-button__ripple::before {\n  opacity: 0.08;\n  /* @alternate */\n  opacity: var(--mdc-ripple-hover-opacity, 0.08);\n}\n.mdc-snackbar__action.mdc-ripple-upgraded--background-focused .mdc-button__ripple::before, .mdc-snackbar__action:not(.mdc-ripple-upgraded):focus .mdc-button__ripple::before {\n  transition-duration: 75ms;\n  opacity: 0.24;\n  /* @alternate */\n  opacity: var(--mdc-ripple-focus-opacity, 0.24);\n}\n.mdc-snackbar__action:not(.mdc-ripple-upgraded) .mdc-button__ripple::after {\n  transition: opacity 150ms linear;\n}\n.mdc-snackbar__action:not(.mdc-ripple-upgraded):active .mdc-button__ripple::after {\n  transition-duration: 75ms;\n  opacity: 0.24;\n  /* @alternate */\n  opacity: var(--mdc-ripple-press-opacity, 0.24);\n}\n.mdc-snackbar__action.mdc-ripple-upgraded {\n  --mdc-ripple-fg-opacity: var(--mdc-ripple-press-opacity, 0.24);\n}\n\n.mdc-snackbar__dismiss {\n  color: rgba(255, 255, 255, 0.87);\n}\n.mdc-snackbar__dismiss .mdc-icon-button__ripple::before, .mdc-snackbar__dismiss .mdc-icon-button__ripple::after {\n  background-color: rgba(255, 255, 255, 0.87);\n  /* @alternate */\n  background-color: var(--mdc-ripple-color, rgba(255, 255, 255, 0.87));\n}\n.mdc-snackbar__dismiss:hover .mdc-icon-button__ripple::before, .mdc-snackbar__dismiss.mdc-ripple-surface--hover .mdc-icon-button__ripple::before {\n  opacity: 0.08;\n  /* @alternate */\n  opacity: var(--mdc-ripple-hover-opacity, 0.08);\n}\n.mdc-snackbar__dismiss.mdc-ripple-upgraded--background-focused .mdc-icon-button__ripple::before, .mdc-snackbar__dismiss:not(.mdc-ripple-upgraded):focus .mdc-icon-button__ripple::before {\n  transition-duration: 75ms;\n  opacity: 0.24;\n  /* @alternate */\n  opacity: var(--mdc-ripple-focus-opacity, 0.24);\n}\n.mdc-snackbar__dismiss:not(.mdc-ripple-upgraded) .mdc-icon-button__ripple::after {\n  transition: opacity 150ms linear;\n}\n.mdc-snackbar__dismiss:not(.mdc-ripple-upgraded):active .mdc-icon-button__ripple::after {\n  transition-duration: 75ms;\n  opacity: 0.24;\n  /* @alternate */\n  opacity: var(--mdc-ripple-press-opacity, 0.24);\n}\n.mdc-snackbar__dismiss.mdc-ripple-upgraded {\n  --mdc-ripple-fg-opacity: var(--mdc-ripple-press-opacity, 0.24);\n}\n\n.mdc-snackbar__dismiss.mdc-snackbar__dismiss {\n  width: 36px;\n  height: 36px;\n  padding: 6px;\n  font-size: 18px;\n}\n.mdc-snackbar__dismiss.mdc-snackbar__dismiss .mdc-icon-button__focus-ring {\n  display: none;\n}\n.mdc-snackbar__dismiss.mdc-snackbar__dismiss.mdc-ripple-upgraded--background-focused .mdc-icon-button__focus-ring, .mdc-snackbar__dismiss.mdc-snackbar__dismiss:not(.mdc-ripple-upgraded):focus .mdc-icon-button__focus-ring {\n  display: block;\n  max-height: 36px;\n  max-width: 36px;\n}\n@media screen and (forced-colors: active) {\n  .mdc-snackbar__dismiss.mdc-snackbar__dismiss.mdc-ripple-upgraded--background-focused .mdc-icon-button__focus-ring, .mdc-snackbar__dismiss.mdc-snackbar__dismiss:not(.mdc-ripple-upgraded):focus .mdc-icon-button__focus-ring {\n    pointer-events: none;\n    border: 2px solid transparent;\n    border-radius: 6px;\n    box-sizing: content-box;\n    position: absolute;\n    top: 50%;\n    /* @noflip */ /*rtl:ignore*/\n    left: 50%;\n    /* @noflip */ /*rtl:ignore*/\n    transform: translate(-50%, -50%);\n    height: 100%;\n    width: 100%;\n  }\n}\n@media screen and (forced-colors: active) and (forced-colors: active) {\n  .mdc-snackbar__dismiss.mdc-snackbar__dismiss.mdc-ripple-upgraded--background-focused .mdc-icon-button__focus-ring, .mdc-snackbar__dismiss.mdc-snackbar__dismiss:not(.mdc-ripple-upgraded):focus .mdc-icon-button__focus-ring {\n    border-color: CanvasText;\n  }\n}\n@media screen and (forced-colors: active) {\n  .mdc-snackbar__dismiss.mdc-snackbar__dismiss.mdc-ripple-upgraded--background-focused .mdc-icon-button__focus-ring::after, .mdc-snackbar__dismiss.mdc-snackbar__dismiss:not(.mdc-ripple-upgraded):focus .mdc-icon-button__focus-ring::after {\n    content: "";\n    border: 2px solid transparent;\n    border-radius: 8px;\n    display: block;\n    position: absolute;\n    top: 50%;\n    /* @noflip */ /*rtl:ignore*/\n    left: 50%;\n    /* @noflip */ /*rtl:ignore*/\n    transform: translate(-50%, -50%);\n    height: calc(100% + 4px);\n    width: calc(100% + 4px);\n  }\n}\n@media screen and (forced-colors: active) and (forced-colors: active) {\n  .mdc-snackbar__dismiss.mdc-snackbar__dismiss.mdc-ripple-upgraded--background-focused .mdc-icon-button__focus-ring::after, .mdc-snackbar__dismiss.mdc-snackbar__dismiss:not(.mdc-ripple-upgraded):focus .mdc-icon-button__focus-ring::after {\n    border-color: CanvasText;\n  }\n}\n.mdc-snackbar__dismiss.mdc-snackbar__dismiss.mdc-icon-button--reduced-size .mdc-icon-button__ripple {\n  width: 36px;\n  height: 36px;\n  margin-top: 0px;\n  margin-bottom: 0px;\n  margin-right: 0px;\n  margin-left: 0px;\n}\n.mdc-snackbar__dismiss.mdc-snackbar__dismiss.mdc-icon-button--reduced-size.mdc-ripple-upgraded--background-focused .mdc-icon-button__focus-ring, .mdc-snackbar__dismiss.mdc-snackbar__dismiss.mdc-icon-button--reduced-size:not(.mdc-ripple-upgraded):focus .mdc-icon-button__focus-ring {\n  max-height: 36px;\n  max-width: 36px;\n}\n.mdc-snackbar__dismiss.mdc-snackbar__dismiss .mdc-icon-button__touch {\n  position: absolute;\n  top: 50%;\n  height: 36px;\n  /* @noflip */ /*rtl:ignore*/\n  left: 50%;\n  width: 36px;\n  transform: translate(-50%, -50%);\n}\n\n.mdc-snackbar__action + .mdc-snackbar__dismiss {\n  /* @noflip */ /*rtl:ignore*/\n  margin-left: 8px;\n  /* @noflip */ /*rtl:ignore*/\n  margin-right: 0;\n}\n[dir=rtl] .mdc-snackbar__action + .mdc-snackbar__dismiss, .mdc-snackbar__action + .mdc-snackbar__dismiss[dir=rtl] {\n  /*rtl:begin:ignore*/\n  /* @noflip */ /*rtl:ignore*/\n  margin-left: 0;\n  /* @noflip */ /*rtl:ignore*/\n  margin-right: 8px;\n  /*rtl:end:ignore*/\n}\n\n.smui-banner--force-show {\n  display: flex !important;\n}';
enable_legacy_mode_flag();
function useScheduleCallback(priorityLevel, callback, options) {
  onMount(() => {
    const task = schedulerExports.unstable_scheduleCallback(priorityLevel, callback, options);
    return () => {
      schedulerExports.unstable_cancelCallback(task);
    };
  });
}
function useNormalPriority(callback, options) {
  return useScheduleCallback(schedulerExports.unstable_NormalPriority, callback, options);
}
function useIdlePriority(callback, options) {
  return useScheduleCallback(schedulerExports.unstable_IdlePriority, callback, options);
}
function useIdleTask(callback) {
  const promise = new DeferredPromise$1();
  onMount(() => {
    return scheduleIdle(() => {
      promise.complete(callback());
    });
  });
  return promise.p;
}
function useMacroTask(callback) {
  const promise = new DeferredPromise$1();
  onMount(() => {
    return scheduleTimeout0(() => {
      promise.complete(callback());
    });
  });
  return promise.p;
}
function useWaitedSchedule(priorityLevel, callback, options) {
  const promise = new DeferredPromise$1();
  useScheduleCallback(
    priorityLevel,
    () => {
      const ret = callback();
      if (isThenable(ret)) {
        ret.then((result) => {
          promise.complete(result);
        });
      } else {
        promise.complete(ret);
      }
    },
    options
  );
  return promise.p;
}
function useLazyComponent(Com, priorityLevel = schedulerExports.unstable_NormalPriority) {
  return useWaitedSchedule(priorityLevel, () => Com);
}
function Scheduler($$anchor, $$props) {
  push($$props, true);
  const props = /* @__PURE__ */ rest_props($$props, ["$$slots", "$$events", "$$legacy", "children"]);
  const deferredPromise = new DeferredPromise2();
  const cleanups = [];
  onDestroy(() => {
    cleanups.forEach((c2) => c2());
  });
  if ("waitFor" in props) {
    user_effect(() => {
      if ($$props.waitFor && !deferredPromise.isSettled) {
        if (isFunction$1($$props.waitFor)) {
          once($$props.waitFor)(() => {
            if ($$props.idle) {
              const cleanup = scheduleIdle(() => {
                deferredPromise.complete($$props.children);
              });
              cleanups.push(cleanup);
            } else {
              deferredPromise.complete($$props.children);
            }
          });
        } else if ($$props.waitFor instanceof DeferredPromise2) {
          $$props.waitFor.p.then(() => {
            deferredPromise.complete($$props.children);
          });
        } else if (isThenable($$props.waitFor)) {
          $$props.waitFor.then(() => {
            deferredPromise.complete($$props.children);
          });
        } else {
          deferredPromise.complete($$props.children);
        }
      }
    });
  } else if ($$props.macro) {
    useMacroTask(() => $$props.children).then((children) => deferredPromise.complete(children));
  } else if ($$props.idle) {
    useIdleTask(() => $$props.children).then((children) => deferredPromise.complete(children));
  } else if ($$props.low) {
    useWaitedSchedule(schedulerExports.unstable_LowPriority, () => $$props.children).then((children) => deferredPromise.complete(children));
  } else {
    useWaitedSchedule(schedulerExports.unstable_NormalPriority, () => $$props.children).then((children) => deferredPromise.complete(children));
  }
  var fragment = comment();
  var node = first_child(fragment);
  await_block(node, () => deferredPromise.p, null, ($$anchor2, children) => {
    var fragment_1 = comment();
    var node_1 = first_child(fragment_1);
    snippet(node_1, () => get$1(children) ?? noop$1);
    append($$anchor2, fragment_1);
  });
  append($$anchor, fragment);
  pop();
}
var Codepoint = /* @__PURE__ */ ((Codepoint2) => {
  Codepoint2[Codepoint2["a"] = 97] = "a";
  return Codepoint2;
})(Codepoint || {});
function isLowerAsciiLetter(code) {
  return code >= CharCode.a && code <= CharCode.z;
}
function compareSubstring(a2, b2, aStart = 0, aEnd = a2.length, bStart = 0, bEnd = b2.length) {
  for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {
    const codeA = a2.charCodeAt(aStart);
    const codeB = b2.charCodeAt(bStart);
    if (codeA < codeB) {
      return -1;
    } else if (codeA > codeB) {
      return 1;
    }
  }
  const aLen = aEnd - aStart;
  const bLen = bEnd - bStart;
  if (aLen < bLen) {
    return -1;
  } else if (aLen > bLen) {
    return 1;
  }
  return 0;
}
function compareSubstringIgnoreCase(a2, b2, aStart = 0, aEnd = a2.length, bStart = 0, bEnd = b2.length) {
  for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {
    let codeA = a2.charCodeAt(aStart);
    let codeB = b2.charCodeAt(bStart);
    if (codeA === codeB) {
      continue;
    }
    if (codeA >= 128 || codeB >= 128) {
      return compareSubstring(a2.toLowerCase(), b2.toLowerCase(), aStart, aEnd, bStart, bEnd);
    }
    if (isLowerAsciiLetter(codeA)) {
      codeA -= 32;
    }
    if (isLowerAsciiLetter(codeB)) {
      codeB -= 32;
    }
    const diff = codeA - codeB;
    if (diff === 0) {
      continue;
    }
    return diff;
  }
  const aLen = aEnd - aStart;
  const bLen = bEnd - bStart;
  if (aLen < bLen) {
    return -1;
  } else if (aLen > bLen) {
    return 1;
  }
  return 0;
}
function startsWithIgnoreCase(str, candidate) {
  const candidateLength = candidate.length;
  if (candidate.length > str.length) {
    return false;
  }
  return compareSubstringIgnoreCase(str, candidate, 0, candidateLength) === 0;
}
function stripWildcards(pattern) {
  return pattern.replace(/\*/g, "");
}
function CustomComponents$1($$anchor, $$props) {
  push($$props, false);
  const [$$stores, $$cleanup] = setup_stores();
  const $components = () => store_get(components, "$components", $$stores);
  const chartGuiService = useService(IChartGuiService);
  const components = derived(chartGuiService.store, (store) => store.components);
  const registerComponent = (id2, com) => {
    chartGuiService.onComponentMounted(id2, com);
  };
  init();
  var fragment = comment();
  var node = first_child(fragment);
  each(node, 1, $components, (Entry) => Entry.id, ($$anchor2, Entry) => {
    {
      let $0 = /* @__PURE__ */ derived_safe_equal(() => registerComponent.bind(null, get$1(Entry).id));
      get$1(Entry).Component($$anchor2, spread_props(() => get$1(Entry).props, {
        get __registerComponent() {
          return get$1($0);
        }
      }));
    }
  });
  append($$anchor, fragment);
  pop();
  $$cleanup();
}
var root_1$u = /* @__PURE__ */ from_html(`<div class="errorCard svelte-3gl5ku"><div class="errorMsg svelte-3gl5ku"> </div></div>`);
const $$css$y = {
  hash: "svelte-3gl5ku",
  code: ".errorCard.svelte-3gl5ku {position:absolute;top:0;left:0;width:100%;height:100%;z-index:1;display:flex;flex-direction:column;align-items:center;justify-content:center;background:var(--cl-background);color:var(--cl-foreground);}.errorMsg.svelte-3gl5ku {max-width:350px;font-size:18px;line-height:28px;text-align:center;}"
};
function ErrorCard($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$y);
  const [$$stores, $$cleanup] = setup_stores();
  const $error = () => store_get(error, "$error", $$stores);
  const chartManagementService = useService(IChartManagementService);
  const error = derived(chartManagementService.store, (store) => {
    return store.instances[$$props.chartIndex].error;
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var div = root_1$u();
      var div_1 = child(div);
      var text2 = child(div_1);
      template_effect(() => set_text(text2, $error().message));
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($error()) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  pop();
  $$cleanup();
}
function portal(el, target = "body") {
  let targetEl;
  async function update(newTarget) {
    target = newTarget;
    if (typeof target === "string") {
      targetEl = document.querySelector(target);
      if (targetEl === null) {
        await tick();
        targetEl = document.querySelector(target);
      }
      if (targetEl === null) {
        throw new Error(`No element found matching css selector: "${target}"`);
      }
    } else if (target instanceof HTMLElement || target instanceof ShadowRoot) {
      targetEl = target;
    } else {
      throw new TypeError(`Unknown portal target type: ${target === null ? "null" : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);
    }
    targetEl.appendChild(el);
    el.hidden = false;
  }
  function destroy() {
    if (el.parentNode) {
      el.parentNode.removeChild(el);
    }
  }
  update(target);
  return { update, destroy };
}
var root$r = /* @__PURE__ */ from_html(`<div hidden><!></div>`);
function Portal($$anchor, $$props) {
  push($$props, false);
  let target = prop($$props, "target", 8, "body");
  let style = prop($$props, "style", 8, "");
  init();
  var div = root$r();
  var node = child(div);
  slot(node, $$props, "default", {});
  action(div, ($$node, $$action_arg) => portal == null ? void 0 : portal($$node, $$action_arg), target);
  template_effect(() => set_style(div, style()));
  append($$anchor, div);
  pop();
}
function getContainingShadowRootOrBody(element2) {
  const rootNode = element2.getRootNode();
  if (rootNode instanceof ShadowRoot) {
    return rootNode;
  }
  return document.body;
}
function findHost(element2) {
  const root2 = element2.getRootNode();
  if (root2 instanceof ShadowRoot) {
    return root2.host;
  }
  return document.body;
}
function findDocumentOrShadowRoot(element2) {
  const root2 = element2.getRootNode();
  if (root2 instanceof ShadowRoot) {
    return root2;
  }
  return document;
}
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCFoundation = (
  /** @class */
  function() {
    function MDCFoundation2(adapter) {
      if (adapter === void 0) {
        adapter = {};
      }
      this.adapter = adapter;
    }
    Object.defineProperty(MDCFoundation2, "cssClasses", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFoundation2, "strings", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFoundation2, "numbers", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFoundation2, "defaultAdapter", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    MDCFoundation2.prototype.init = function() {
    };
    MDCFoundation2.prototype.destroy = function() {
    };
    return MDCFoundation2;
  }()
);
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var CssClasses = /* @__PURE__ */ ((CssClasses2) => {
  CssClasses2["RICH"] = "mdc-tooltip--rich";
  CssClasses2["SHOWN"] = "mdc-tooltip--shown";
  CssClasses2["SHOWING"] = "mdc-tooltip--showing";
  CssClasses2["SHOWING_TRANSITION"] = "mdc-tooltip--showing-transition";
  CssClasses2["HIDE"] = "mdc-tooltip--hide";
  CssClasses2["HIDE_TRANSITION"] = "mdc-tooltip--hide-transition";
  CssClasses2["MULTILINE_TOOLTIP"] = "mdc-tooltip--multiline";
  CssClasses2["SURFACE"] = "mdc-tooltip__surface";
  CssClasses2["SURFACE_ANIMATION"] = "mdc-tooltip__surface-animation";
  CssClasses2["TOOLTIP_CARET_TOP"] = "mdc-tooltip__caret-surface-top";
  CssClasses2["TOOLTIP_CARET_BOTTOM"] = "mdc-tooltip__caret-surface-bottom";
  return CssClasses2;
})(CssClasses || {});
const numbers$5 = {
  BOUNDED_ANCHOR_GAP: 4,
  UNBOUNDED_ANCHOR_GAP: 8,
  MIN_VIEWPORT_TOOLTIP_THRESHOLD: 8,
  HIDE_DELAY_MS: 100,
  SHOW_DELAY_MS: 100,
  // LINT.IfChange(tooltip-dimensions)
  MIN_WIDTH: 40,
  MIN_HEIGHT: 24,
  MAX_WIDTH: 200,
  // LINT.ThenChange(_tooltip.scss:tooltip-dimensions)
  CARET_INDENTATION: 24,
  // LINT.IfChange(tooltip-anim-scale)
  ANIMATION_SCALE: 0.8,
  // LINT.ThenChange(_tooltip.scss:tooltip-anim-scale)
  // LINT.IfChange(rich-tooltip-dimensions)
  RICH_MAX_WIDTH: 320
  // LINT.ThenChange(_tooltip.scss:rich-tooltip-dimensions)
};
const attributes = {
  ARIA_EXPANDED: "aria-expanded",
  ARIA_HASPOPUP: "aria-haspopup",
  PERSISTENT: "data-mdc-tooltip-persistent",
  HAS_CARET: "data-mdc-tooltip-has-caret"
};
var XPosition = /* @__PURE__ */ ((XPosition2) => {
  XPosition2[XPosition2["DETECTED"] = 0] = "DETECTED";
  XPosition2[XPosition2["START"] = 1] = "START";
  XPosition2[XPosition2["CENTER"] = 2] = "CENTER";
  XPosition2[XPosition2["END"] = 3] = "END";
  XPosition2[XPosition2["SIDE_START"] = 4] = "SIDE_START";
  XPosition2[XPosition2["SIDE_END"] = 5] = "SIDE_END";
  return XPosition2;
})(XPosition || {});
var YPosition = /* @__PURE__ */ ((YPosition2) => {
  YPosition2[YPosition2["DETECTED"] = 0] = "DETECTED";
  YPosition2[YPosition2["ABOVE"] = 1] = "ABOVE";
  YPosition2[YPosition2["BELOW"] = 2] = "BELOW";
  YPosition2[YPosition2["SIDE"] = 3] = "SIDE";
  return YPosition2;
})(YPosition || {});
var AnchorBoundaryType = /* @__PURE__ */ ((AnchorBoundaryType2) => {
  AnchorBoundaryType2[AnchorBoundaryType2["BOUNDED"] = 0] = "BOUNDED";
  AnchorBoundaryType2[AnchorBoundaryType2["UNBOUNDED"] = 1] = "UNBOUNDED";
  return AnchorBoundaryType2;
})(AnchorBoundaryType || {});
const strings$5 = {
  LEFT: "left",
  RIGHT: "right",
  CENTER: "center",
  TOP: "top",
  BOTTOM: "bottom"
};
var PositionWithCaret = /* @__PURE__ */ ((PositionWithCaret2) => {
  PositionWithCaret2[PositionWithCaret2["DETECTED"] = 0] = "DETECTED";
  PositionWithCaret2[PositionWithCaret2["ABOVE_START"] = 1] = "ABOVE_START";
  PositionWithCaret2[PositionWithCaret2["ABOVE_CENTER"] = 2] = "ABOVE_CENTER";
  PositionWithCaret2[PositionWithCaret2["ABOVE_END"] = 3] = "ABOVE_END";
  PositionWithCaret2[PositionWithCaret2["TOP_SIDE_START"] = 4] = "TOP_SIDE_START";
  PositionWithCaret2[PositionWithCaret2["CENTER_SIDE_START"] = 5] = "CENTER_SIDE_START";
  PositionWithCaret2[PositionWithCaret2["BOTTOM_SIDE_START"] = 6] = "BOTTOM_SIDE_START";
  PositionWithCaret2[PositionWithCaret2["TOP_SIDE_END"] = 7] = "TOP_SIDE_END";
  PositionWithCaret2[PositionWithCaret2["CENTER_SIDE_END"] = 8] = "CENTER_SIDE_END";
  PositionWithCaret2[PositionWithCaret2["BOTTOM_SIDE_END"] = 9] = "BOTTOM_SIDE_END";
  PositionWithCaret2[PositionWithCaret2["BELOW_START"] = 10] = "BELOW_START";
  PositionWithCaret2[PositionWithCaret2["BELOW_CENTER"] = 11] = "BELOW_CENTER";
  PositionWithCaret2[PositionWithCaret2["BELOW_END"] = 12] = "BELOW_END";
  return PositionWithCaret2;
})(PositionWithCaret || {});
var YPositionWithCaret = /* @__PURE__ */ ((YPositionWithCaret2) => {
  YPositionWithCaret2[YPositionWithCaret2["ABOVE"] = 1] = "ABOVE";
  YPositionWithCaret2[YPositionWithCaret2["BELOW"] = 2] = "BELOW";
  YPositionWithCaret2[YPositionWithCaret2["SIDE_TOP"] = 3] = "SIDE_TOP";
  YPositionWithCaret2[YPositionWithCaret2["SIDE_CENTER"] = 4] = "SIDE_CENTER";
  YPositionWithCaret2[YPositionWithCaret2["SIDE_BOTTOM"] = 5] = "SIDE_BOTTOM";
  return YPositionWithCaret2;
})(YPositionWithCaret || {});
var XPositionWithCaret = /* @__PURE__ */ ((XPositionWithCaret2) => {
  XPositionWithCaret2[XPositionWithCaret2["START"] = 1] = "START";
  XPositionWithCaret2[XPositionWithCaret2["CENTER"] = 2] = "CENTER";
  XPositionWithCaret2[XPositionWithCaret2["END"] = 3] = "END";
  XPositionWithCaret2[XPositionWithCaret2["SIDE_START"] = 4] = "SIDE_START";
  XPositionWithCaret2[XPositionWithCaret2["SIDE_END"] = 5] = "SIDE_END";
  return XPositionWithCaret2;
})(XPositionWithCaret || {});
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var AnimationFrame = (
  /** @class */
  function() {
    function AnimationFrame2() {
      this.rafIDs = /* @__PURE__ */ new Map();
    }
    AnimationFrame2.prototype.request = function(key2, callback) {
      var _this = this;
      this.cancel(key2);
      var frameID = requestAnimationFrame(function(frame) {
        _this.rafIDs.delete(key2);
        callback(frame);
      });
      this.rafIDs.set(key2, frameID);
    };
    AnimationFrame2.prototype.cancel = function(key2) {
      var rafID = this.rafIDs.get(key2);
      if (rafID) {
        cancelAnimationFrame(rafID);
        this.rafIDs.delete(key2);
      }
    };
    AnimationFrame2.prototype.cancelAll = function() {
      var _this = this;
      this.rafIDs.forEach(function(_2, key2) {
        _this.cancel(key2);
      });
    };
    AnimationFrame2.prototype.getQueue = function() {
      var queue = [];
      this.rafIDs.forEach(function(_2, key2) {
        queue.push(key2);
      });
      return queue;
    };
    return AnimationFrame2;
  }()
);
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssPropertyNameMap = {
  animation: {
    prefixed: "-webkit-animation",
    standard: "animation"
  },
  transform: {
    prefixed: "-webkit-transform",
    standard: "transform"
  },
  transition: {
    prefixed: "-webkit-transition",
    standard: "transition"
  }
};
function isWindow(windowObj) {
  return Boolean(windowObj.document) && typeof windowObj.document.createElement === "function";
}
function getCorrectPropertyName(windowObj, cssProperty) {
  if (isWindow(windowObj) && cssProperty in cssPropertyNameMap) {
    var el = windowObj.document.createElement("div");
    var _a3 = cssPropertyNameMap[cssProperty], standard = _a3.standard, prefixed = _a3.prefixed;
    var isStandard = standard in el.style;
    return isStandard ? standard : prefixed;
  }
  return cssProperty;
}
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
const KEY$1 = {
  UNKNOWN: "Unknown",
  BACKSPACE: "Backspace",
  ENTER: "Enter",
  SPACEBAR: "Spacebar",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown",
  END: "End",
  HOME: "Home",
  ARROW_LEFT: "ArrowLeft",
  ARROW_UP: "ArrowUp",
  ARROW_RIGHT: "ArrowRight",
  ARROW_DOWN: "ArrowDown",
  DELETE: "Delete",
  ESCAPE: "Escape",
  TAB: "Tab"
};
const normalizedKeys$1 = /* @__PURE__ */ new Set();
normalizedKeys$1.add(KEY$1.BACKSPACE);
normalizedKeys$1.add(KEY$1.ENTER);
normalizedKeys$1.add(KEY$1.SPACEBAR);
normalizedKeys$1.add(KEY$1.PAGE_UP);
normalizedKeys$1.add(KEY$1.PAGE_DOWN);
normalizedKeys$1.add(KEY$1.END);
normalizedKeys$1.add(KEY$1.HOME);
normalizedKeys$1.add(KEY$1.ARROW_LEFT);
normalizedKeys$1.add(KEY$1.ARROW_UP);
normalizedKeys$1.add(KEY$1.ARROW_RIGHT);
normalizedKeys$1.add(KEY$1.ARROW_DOWN);
normalizedKeys$1.add(KEY$1.DELETE);
normalizedKeys$1.add(KEY$1.ESCAPE);
normalizedKeys$1.add(KEY$1.TAB);
const KEY_CODE$1 = {
  BACKSPACE: 8,
  ENTER: 13,
  SPACEBAR: 32,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  END: 35,
  HOME: 36,
  ARROW_LEFT: 37,
  ARROW_UP: 38,
  ARROW_RIGHT: 39,
  ARROW_DOWN: 40,
  DELETE: 46,
  ESCAPE: 27,
  TAB: 9
};
const mappedKeyCodes$1 = /* @__PURE__ */ new Map();
mappedKeyCodes$1.set(KEY_CODE$1.BACKSPACE, KEY$1.BACKSPACE);
mappedKeyCodes$1.set(KEY_CODE$1.ENTER, KEY$1.ENTER);
mappedKeyCodes$1.set(KEY_CODE$1.SPACEBAR, KEY$1.SPACEBAR);
mappedKeyCodes$1.set(KEY_CODE$1.PAGE_UP, KEY$1.PAGE_UP);
mappedKeyCodes$1.set(KEY_CODE$1.PAGE_DOWN, KEY$1.PAGE_DOWN);
mappedKeyCodes$1.set(KEY_CODE$1.END, KEY$1.END);
mappedKeyCodes$1.set(KEY_CODE$1.HOME, KEY$1.HOME);
mappedKeyCodes$1.set(KEY_CODE$1.ARROW_LEFT, KEY$1.ARROW_LEFT);
mappedKeyCodes$1.set(KEY_CODE$1.ARROW_UP, KEY$1.ARROW_UP);
mappedKeyCodes$1.set(KEY_CODE$1.ARROW_RIGHT, KEY$1.ARROW_RIGHT);
mappedKeyCodes$1.set(KEY_CODE$1.ARROW_DOWN, KEY$1.ARROW_DOWN);
mappedKeyCodes$1.set(KEY_CODE$1.DELETE, KEY$1.DELETE);
mappedKeyCodes$1.set(KEY_CODE$1.ESCAPE, KEY$1.ESCAPE);
mappedKeyCodes$1.set(KEY_CODE$1.TAB, KEY$1.TAB);
const navigationKeys$1 = /* @__PURE__ */ new Set();
navigationKeys$1.add(KEY$1.PAGE_UP);
navigationKeys$1.add(KEY$1.PAGE_DOWN);
navigationKeys$1.add(KEY$1.END);
navigationKeys$1.add(KEY$1.HOME);
navigationKeys$1.add(KEY$1.ARROW_LEFT);
navigationKeys$1.add(KEY$1.ARROW_UP);
navigationKeys$1.add(KEY$1.ARROW_RIGHT);
navigationKeys$1.add(KEY$1.ARROW_DOWN);
function normalizeKey$1(evt) {
  const { key: key2 } = evt;
  if (normalizedKeys$1.has(key2)) {
    return key2;
  }
  const mappedKey = mappedKeyCodes$1.get(evt.keyCode);
  if (mappedKey) {
    return mappedKey;
  }
  return KEY$1.UNKNOWN;
}
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
const {
  RICH,
  SHOWN,
  SHOWING,
  SHOWING_TRANSITION,
  HIDE,
  HIDE_TRANSITION,
  MULTILINE_TOOLTIP
} = CssClasses;
const HAS_WINDOW = typeof window !== "undefined";
class MDCTooltipFoundation extends MDCFoundation {
  constructor(adapter) {
    super({ ...MDCTooltipFoundation.defaultAdapter, ...adapter });
    this.tooltipShown = false;
    this.anchorGap = numbers$5.BOUNDED_ANCHOR_GAP;
    this.xTooltipPos = XPosition.DETECTED;
    this.yTooltipPos = YPosition.DETECTED;
    this.tooltipPositionWithCaret = PositionWithCaret.DETECTED;
    this.minViewportTooltipThreshold = numbers$5.MIN_VIEWPORT_TOOLTIP_THRESHOLD;
    this.hideDelayMs = numbers$5.HIDE_DELAY_MS;
    this.showDelayMs = numbers$5.SHOW_DELAY_MS;
    this.anchorRect = null;
    this.parentRect = null;
    this.frameId = null;
    this.hideTimeout = null;
    this.showTimeout = null;
    this.addAncestorScrollEventListeners = new Array();
    this.removeAncestorScrollEventListeners = new Array();
    this.animFrame = new AnimationFrame();
    this.anchorBlurHandler = (event2) => {
      this.handleAnchorBlur(event2);
    };
    this.documentClickHandler = (event2) => {
      this.handleDocumentClick(event2);
    };
    this.documentKeydownHandler = (event2) => {
      this.handleKeydown(event2);
    };
    this.tooltipMouseEnterHandler = () => {
      this.handleTooltipMouseEnter();
    };
    this.tooltipMouseLeaveHandler = () => {
      this.handleTooltipMouseLeave();
    };
    this.richTooltipFocusOutHandler = (event2) => {
      this.handleRichTooltipFocusOut(event2);
    };
    this.windowScrollHandler = () => {
      this.handleWindowScrollEvent();
    };
    this.windowResizeHandler = () => {
      this.handleWindowChangeEvent();
    };
  }
  static get defaultAdapter() {
    return {
      getAttribute: () => null,
      setAttribute: () => void 0,
      removeAttribute: () => void 0,
      addClass: () => void 0,
      hasClass: () => false,
      removeClass: () => void 0,
      getComputedStyleProperty: () => "",
      setStyleProperty: () => void 0,
      setSurfaceAnimationStyleProperty: () => void 0,
      getViewportWidth: () => 0,
      getViewportHeight: () => 0,
      getTooltipSize: () => ({ width: 0, height: 0 }),
      getAnchorBoundingRect: () => ({ top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 }),
      getParentBoundingRect: () => ({ top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 }),
      getAnchorAttribute: () => null,
      setAnchorAttribute: () => null,
      isRTL: () => false,
      anchorContainsElement: () => false,
      tooltipContainsElement: () => false,
      focusAnchorElement: () => void 0,
      registerEventHandler: () => void 0,
      deregisterEventHandler: () => void 0,
      registerAnchorEventHandler: () => void 0,
      deregisterAnchorEventHandler: () => void 0,
      registerDocumentEventHandler: () => void 0,
      deregisterDocumentEventHandler: () => void 0,
      registerWindowEventHandler: () => void 0,
      deregisterWindowEventHandler: () => void 0,
      notifyHidden: () => void 0,
      notifyShown: () => void 0,
      getTooltipCaretBoundingRect: () => ({ top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 }),
      setTooltipCaretStyle: () => void 0,
      clearTooltipCaretStyles: () => void 0,
      getActiveElement: () => null,
      isInstanceOfElement: () => false
    };
  }
  init() {
    this.richTooltip = this.adapter.hasClass(RICH);
    this.persistentTooltip = this.adapter.getAttribute(attributes.PERSISTENT) === "true";
    this.interactiveTooltip = !!this.adapter.getAnchorAttribute(attributes.ARIA_EXPANDED) && this.adapter.getAnchorAttribute(attributes.ARIA_HASPOPUP) === "dialog";
    this.hasCaret = this.richTooltip && this.adapter.getAttribute(attributes.HAS_CARET) === "true";
  }
  isShown() {
    return this.tooltipShown;
  }
  isRich() {
    return this.richTooltip;
  }
  isPersistent() {
    return this.persistentTooltip;
  }
  handleAnchorMouseEnter() {
    if (this.tooltipShown) {
      this.show();
    } else {
      this.clearHideTimeout();
      this.showTimeout = setTimeout(() => {
        this.show();
      }, this.showDelayMs);
    }
  }
  handleAnchorTouchstart() {
    this.showTimeout = setTimeout(() => {
      this.show();
    }, this.showDelayMs);
    this.adapter.registerWindowEventHandler(
      "contextmenu",
      this.preventContextMenuOnLongTouch
    );
  }
  preventContextMenuOnLongTouch(event2) {
    event2.preventDefault();
  }
  /**
   * Helper methods for determining if the event target or related target
   * is contained inside the tooltip or the anchor. These methods are used to
   * determing when a tooltip should be closed of left open on blur and click
   * events.
   */
  tooltipContainsRelatedTargetElement(target) {
    return this.adapter.isInstanceOfElement(target) && this.adapter.tooltipContainsElement(target);
  }
  anchorOrTooltipContainsTargetElement(target) {
    return this.adapter.isInstanceOfElement(target) && (this.adapter.tooltipContainsElement(target) || this.adapter.anchorContainsElement(target));
  }
  handleAnchorTouchend() {
    this.clearShowTimeout();
    if (!this.isShown()) {
      this.adapter.deregisterWindowEventHandler(
        "contextmenu",
        this.preventContextMenuOnLongTouch
      );
    }
  }
  handleAnchorFocus(event2) {
    if (this.tooltipContainsRelatedTargetElement(event2.relatedTarget)) {
      return;
    }
    this.showTimeout = setTimeout(() => {
      this.show();
    }, this.showDelayMs);
  }
  handleAnchorMouseLeave() {
    this.clearShowTimeout();
    this.hideTimeout = setTimeout(() => {
      this.hide();
    }, this.hideDelayMs);
  }
  handleAnchorClick() {
    if (this.tooltipShown) {
      this.hide();
    } else {
      this.show();
    }
  }
  handleDocumentClick(event2) {
    if (this.richTooltip && this.persistentTooltip && this.anchorOrTooltipContainsTargetElement(event2.target)) {
      return;
    }
    this.hide();
  }
  handleKeydown(event2) {
    const key2 = normalizeKey$1(event2);
    if (key2 === KEY$1.ESCAPE) {
      const activeElement = this.adapter.getActiveElement();
      let tooltipContainsActiveElement = false;
      if (this.adapter.isInstanceOfElement(activeElement)) {
        tooltipContainsActiveElement = this.adapter.tooltipContainsElement(activeElement);
      }
      if (tooltipContainsActiveElement) {
        this.adapter.focusAnchorElement();
      }
      this.hide();
      event2.stopPropagation();
      return false;
    }
    return true;
  }
  handleAnchorBlur(event2) {
    if (this.richTooltip) {
      if (event2.relatedTarget === null || this.tooltipContainsRelatedTargetElement(event2.relatedTarget)) {
        return;
      }
    }
    this.hide();
  }
  handleTooltipMouseEnter() {
    this.show();
  }
  handleTooltipMouseLeave() {
    this.clearShowTimeout();
    this.hideTimeout = setTimeout(() => {
      this.hide();
    }, this.hideDelayMs);
  }
  handleRichTooltipFocusOut(event2) {
    if (this.anchorOrTooltipContainsTargetElement(event2.relatedTarget)) {
      return;
    }
    if (event2.relatedTarget === null && this.interactiveTooltip) {
      return;
    }
    this.hide();
  }
  handleWindowScrollEvent() {
    if (!this.persistentTooltip) {
      this.hide();
    }
  }
  /**
   * On window resize or scroll, check the anchor position and size and
   * repostion tooltip if necessary.
   */
  handleWindowChangeEvent() {
    this.animFrame.request("poll_anchor", () => {
      this.repositionTooltipOnAnchorMove();
    });
  }
  show() {
    this.clearHideTimeout();
    this.clearShowTimeout();
    if (this.tooltipShown) {
      return;
    }
    this.tooltipShown = true;
    this.adapter.removeAttribute("aria-hidden");
    if (this.richTooltip) {
      if (this.interactiveTooltip) {
        this.adapter.setAnchorAttribute("aria-expanded", "true");
      }
      this.adapter.registerEventHandler(
        "focusout",
        this.richTooltipFocusOutHandler
      );
    }
    if (!this.persistentTooltip) {
      this.adapter.registerEventHandler(
        "mouseenter",
        this.tooltipMouseEnterHandler
      );
      this.adapter.registerEventHandler(
        "mouseleave",
        this.tooltipMouseLeaveHandler
      );
    }
    this.adapter.removeClass(HIDE);
    this.adapter.addClass(SHOWING);
    if (this.isTooltipMultiline() && !this.richTooltip) {
      this.adapter.addClass(MULTILINE_TOOLTIP);
    }
    this.anchorRect = this.adapter.getAnchorBoundingRect();
    this.parentRect = this.adapter.getParentBoundingRect();
    this.richTooltip ? this.positionRichTooltip() : this.positionPlainTooltip();
    this.adapter.registerAnchorEventHandler("blur", this.anchorBlurHandler);
    this.adapter.registerDocumentEventHandler(
      "click",
      this.documentClickHandler
    );
    this.adapter.registerDocumentEventHandler(
      "keydown",
      this.documentKeydownHandler
    );
    this.adapter.registerWindowEventHandler("scroll", this.windowScrollHandler);
    this.adapter.registerWindowEventHandler("resize", this.windowResizeHandler);
    for (const fn2 of this.addAncestorScrollEventListeners) {
      fn2();
    }
    this.frameId = requestAnimationFrame(() => {
      this.clearAllAnimationClasses();
      this.adapter.addClass(SHOWN);
      this.adapter.addClass(SHOWING_TRANSITION);
    });
  }
  hide() {
    this.clearHideTimeout();
    this.clearShowTimeout();
    if (!this.tooltipShown) {
      return;
    }
    if (this.frameId) {
      cancelAnimationFrame(this.frameId);
    }
    this.tooltipShown = false;
    this.adapter.setAttribute("aria-hidden", "true");
    this.adapter.deregisterEventHandler(
      "focusout",
      this.richTooltipFocusOutHandler
    );
    if (this.richTooltip) {
      if (this.interactiveTooltip) {
        this.adapter.setAnchorAttribute("aria-expanded", "false");
      }
    }
    if (!this.persistentTooltip) {
      this.adapter.deregisterEventHandler(
        "mouseenter",
        this.tooltipMouseEnterHandler
      );
      this.adapter.deregisterEventHandler(
        "mouseleave",
        this.tooltipMouseLeaveHandler
      );
    }
    this.clearAllAnimationClasses();
    this.adapter.addClass(HIDE);
    this.adapter.addClass(HIDE_TRANSITION);
    this.adapter.removeClass(SHOWN);
    this.adapter.deregisterAnchorEventHandler("blur", this.anchorBlurHandler);
    this.adapter.deregisterDocumentEventHandler(
      "click",
      this.documentClickHandler
    );
    this.adapter.deregisterDocumentEventHandler(
      "keydown",
      this.documentKeydownHandler
    );
    this.adapter.deregisterWindowEventHandler(
      "scroll",
      this.windowScrollHandler
    );
    this.adapter.deregisterWindowEventHandler(
      "resize",
      this.windowResizeHandler
    );
    this.adapter.deregisterWindowEventHandler(
      "contextmenu",
      this.preventContextMenuOnLongTouch
    );
    for (const fn2 of this.removeAncestorScrollEventListeners) {
      fn2();
    }
  }
  handleTransitionEnd() {
    const isHidingTooltip = this.adapter.hasClass(HIDE);
    this.adapter.removeClass(SHOWING);
    this.adapter.removeClass(SHOWING_TRANSITION);
    this.adapter.removeClass(HIDE);
    this.adapter.removeClass(HIDE_TRANSITION);
    if (isHidingTooltip && this.showTimeout === null) {
      this.adapter.notifyHidden();
    } else if (!isHidingTooltip) {
      this.adapter.notifyShown();
    }
  }
  clearAllAnimationClasses() {
    this.adapter.removeClass(SHOWING_TRANSITION);
    this.adapter.removeClass(HIDE_TRANSITION);
  }
  setTooltipPosition(position) {
    const { xPos, yPos, withCaretPos } = position;
    if (this.hasCaret && withCaretPos) {
      this.tooltipPositionWithCaret = withCaretPos;
      return;
    }
    if (xPos) {
      this.xTooltipPos = xPos;
    }
    if (yPos) {
      this.yTooltipPos = yPos;
    }
  }
  setAnchorBoundaryType(type) {
    if (type === AnchorBoundaryType.UNBOUNDED) {
      this.anchorGap = numbers$5.UNBOUNDED_ANCHOR_GAP;
    } else {
      this.anchorGap = numbers$5.BOUNDED_ANCHOR_GAP;
    }
  }
  setShowDelay(delayMs) {
    this.showDelayMs = delayMs;
  }
  setHideDelay(delayMs) {
    this.hideDelayMs = delayMs;
  }
  isTooltipMultiline() {
    const tooltipSize = this.adapter.getTooltipSize();
    return tooltipSize.height > numbers$5.MIN_HEIGHT && tooltipSize.width >= numbers$5.MAX_WIDTH;
  }
  positionPlainTooltip() {
    const { top: top2, yTransformOrigin, left, xTransformOrigin } = this.calculateTooltipStyles(this.anchorRect);
    const transformProperty = HAS_WINDOW ? getCorrectPropertyName(window, "transform") : "transform";
    this.adapter.setSurfaceAnimationStyleProperty(
      `${transformProperty}-origin`,
      `${xTransformOrigin} ${yTransformOrigin}`
    );
    this.adapter.setStyleProperty("top", `${top2}px`);
    this.adapter.setStyleProperty("left", `${left}px`);
  }
  positionRichTooltip() {
    var _a3, _b3;
    this.adapter.setStyleProperty("width", "");
    this.adapter.setStyleProperty("left", `-${numbers$5.RICH_MAX_WIDTH}px`);
    const computedWidth = Number(this.adapter.getComputedStyleProperty("width").slice(0, -2));
    const widthNum = isFinite(computedWidth) ? computedWidth : numbers$5.RICH_MAX_WIDTH;
    const viewportWidth = Math.max(
      this.adapter.getViewportWidth() - 2 * numbers$5.MIN_VIEWPORT_TOOLTIP_THRESHOLD,
      numbers$5.MIN_WIDTH
    );
    const tooltipWidth = Math.min(viewportWidth, widthNum);
    this.adapter.setStyleProperty("width", `${tooltipWidth}px`);
    const { top: top2, yTransformOrigin, left, xTransformOrigin } = this.hasCaret ? this.calculateTooltipWithCaretStyles(this.anchorRect) : this.calculateTooltipStyles(this.anchorRect);
    const transformProperty = HAS_WINDOW ? getCorrectPropertyName(window, "transform") : "transform";
    this.adapter.setSurfaceAnimationStyleProperty(
      `${transformProperty}-origin`,
      `${xTransformOrigin} ${yTransformOrigin}`
    );
    const leftAdjustment = left - (((_a3 = this.parentRect) == null ? void 0 : _a3.left) ?? 0);
    const topAdjustment = top2 - (((_b3 = this.parentRect) == null ? void 0 : _b3.top) ?? 0);
    this.adapter.setStyleProperty("top", `${topAdjustment}px`);
    this.adapter.setStyleProperty("left", `${leftAdjustment}px`);
  }
  /**
   * Calculates the position of the tooltip. A tooltip will be placed
   * beneath the anchor element and aligned either with the 'start'/'end'
   * edge of the anchor element or the 'center'.
   *
   * Tooltip alignment is selected such that the tooltip maintains a
   * threshold distance away from the viewport (defaulting to 'center'
   * alignment). If the placement of the anchor prevents this threshold
   * distance from being maintained, the tooltip is positioned so that it
   * does not collide with the viewport.
   *
   * Users can specify an alignment, however, if this alignment results in
   * the tooltip colliding with the viewport, this specification is
   * overwritten.
   */
  calculateTooltipStyles(anchorRect) {
    if (!anchorRect) {
      return { top: 0, left: 0 };
    }
    const tooltipSize = this.adapter.getTooltipSize();
    const top2 = this.calculateYTooltipDistance(anchorRect, tooltipSize.height);
    const left = this.calculateXTooltipDistance(anchorRect, tooltipSize.width);
    return {
      top: top2.distance,
      yTransformOrigin: top2.yTransformOrigin,
      left: left.distance,
      xTransformOrigin: left.xTransformOrigin
    };
  }
  /**
   * Calculates the `left` distance for the tooltip.
   * Returns the distance value and a string indicating the x-axis transform-
   * origin that should be used when animating the tooltip.
   */
  calculateXTooltipDistance(anchorRect, tooltipWidth) {
    const isLTR = !this.adapter.isRTL();
    let startPos, endPos, centerPos, sideStartPos, sideEndPos;
    let startTransformOrigin, endTransformOrigin;
    if (this.richTooltip) {
      startPos = isLTR ? anchorRect.left - tooltipWidth : anchorRect.right;
      endPos = isLTR ? anchorRect.right : anchorRect.left - tooltipWidth;
      startTransformOrigin = isLTR ? strings$5.RIGHT : strings$5.LEFT;
      endTransformOrigin = isLTR ? strings$5.LEFT : strings$5.RIGHT;
    } else {
      startPos = isLTR ? anchorRect.left : anchorRect.right - tooltipWidth;
      endPos = isLTR ? anchorRect.right - tooltipWidth : anchorRect.left;
      centerPos = anchorRect.left + (anchorRect.width - tooltipWidth) / 2;
      const sideLeftAligned = anchorRect.left - (tooltipWidth + this.anchorGap);
      const sideRightAligned = anchorRect.right + this.anchorGap;
      sideStartPos = isLTR ? sideLeftAligned : sideRightAligned;
      sideEndPos = isLTR ? sideRightAligned : sideLeftAligned;
      startTransformOrigin = isLTR ? strings$5.LEFT : strings$5.RIGHT;
      endTransformOrigin = isLTR ? strings$5.RIGHT : strings$5.LEFT;
    }
    const plainTooltipPosOptions = [startPos, centerPos, endPos];
    if (this.xTooltipPos === XPosition.SIDE_START) {
      plainTooltipPosOptions.push(sideStartPos);
    } else if (this.xTooltipPos === XPosition.SIDE_END) {
      plainTooltipPosOptions.push(sideEndPos);
    }
    const positionOptions = this.richTooltip ? this.determineValidPositionOptions(startPos, endPos) : this.determineValidPositionOptions(...plainTooltipPosOptions);
    if (this.xTooltipPos === XPosition.START && positionOptions.has(startPos)) {
      return { distance: startPos, xTransformOrigin: startTransformOrigin };
    } else if (this.xTooltipPos === XPosition.END && positionOptions.has(endPos)) {
      return { distance: endPos, xTransformOrigin: endTransformOrigin };
    } else if (this.xTooltipPos === XPosition.CENTER && positionOptions.has(centerPos)) {
      return { distance: centerPos, xTransformOrigin: strings$5.CENTER };
    } else if (this.xTooltipPos === XPosition.SIDE_START && positionOptions.has(sideStartPos)) {
      return { distance: sideStartPos, xTransformOrigin: endTransformOrigin };
    } else if (this.xTooltipPos === XPosition.SIDE_END && positionOptions.has(sideEndPos)) {
      return { distance: sideEndPos, xTransformOrigin: startTransformOrigin };
    }
    const possiblePositions = this.richTooltip ? [
      { distance: endPos, xTransformOrigin: endTransformOrigin },
      { distance: startPos, xTransformOrigin: startTransformOrigin }
    ] : [
      { distance: centerPos, xTransformOrigin: strings$5.CENTER },
      { distance: startPos, xTransformOrigin: startTransformOrigin },
      { distance: endPos, xTransformOrigin: endTransformOrigin }
    ];
    const validPosition = possiblePositions.find(({ distance }) => positionOptions.has(distance));
    if (validPosition) {
      return validPosition;
    }
    if (anchorRect.left < 0) {
      return {
        distance: this.minViewportTooltipThreshold,
        xTransformOrigin: strings$5.LEFT
      };
    } else {
      const viewportWidth = this.adapter.getViewportWidth();
      const distance = viewportWidth - (tooltipWidth + this.minViewportTooltipThreshold);
      return { distance, xTransformOrigin: strings$5.RIGHT };
    }
  }
  /**
   * Given the values for the horizontal alignments of the tooltip, calculates
   * which of these options would result in the tooltip maintaining the required
   * threshold distance vs which would result in the tooltip staying within the
   * viewport.
   *
   * A Set of values is returned holding the distances that would honor the
   * above requirements. Following the logic for determining the tooltip
   * position, if all alignments violate the threshold, then the returned Set
   * contains values that keep the tooltip within the viewport.
   */
  determineValidPositionOptions(...positions) {
    const posWithinThreshold = /* @__PURE__ */ new Set();
    const posWithinViewport = /* @__PURE__ */ new Set();
    for (const position of positions) {
      if (this.positionHonorsViewportThreshold(position)) {
        posWithinThreshold.add(position);
      } else if (this.positionDoesntCollideWithViewport(position)) {
        posWithinViewport.add(position);
      }
    }
    return posWithinThreshold.size ? posWithinThreshold : posWithinViewport;
  }
  positionHonorsViewportThreshold(leftPos) {
    const viewportWidth = this.adapter.getViewportWidth();
    const tooltipWidth = this.adapter.getTooltipSize().width;
    return leftPos + tooltipWidth <= viewportWidth - this.minViewportTooltipThreshold && leftPos >= this.minViewportTooltipThreshold;
  }
  positionDoesntCollideWithViewport(leftPos) {
    const viewportWidth = this.adapter.getViewportWidth();
    const tooltipWidth = this.adapter.getTooltipSize().width;
    return leftPos + tooltipWidth <= viewportWidth && leftPos >= 0;
  }
  /**
   * Calculates the `top` distance for the tooltip.
   * Returns the distance value and a string indicating the y-axis transform-
   * origin that should be used when animating the tooltip.
   */
  calculateYTooltipDistance(anchorRect, tooltipHeight) {
    const belowYPos = anchorRect.bottom + this.anchorGap;
    const aboveYPos = anchorRect.top - (this.anchorGap + tooltipHeight);
    const anchorMidpoint = anchorRect.top + anchorRect.height / 2;
    const sideYPos = anchorMidpoint - tooltipHeight / 2;
    const posOptions = [aboveYPos, belowYPos];
    if (this.yTooltipPos === YPosition.SIDE) {
      posOptions.push(sideYPos);
    }
    const yPositionOptions = this.determineValidYPositionOptions(...posOptions);
    if (this.yTooltipPos === YPosition.ABOVE && yPositionOptions.has(aboveYPos)) {
      return { distance: aboveYPos, yTransformOrigin: strings$5.BOTTOM };
    } else if (this.yTooltipPos === YPosition.BELOW && yPositionOptions.has(belowYPos)) {
      return { distance: belowYPos, yTransformOrigin: strings$5.TOP };
    } else if (this.yTooltipPos === YPosition.SIDE && yPositionOptions.has(sideYPos)) {
      return { distance: sideYPos, yTransformOrigin: strings$5.CENTER };
    }
    if (yPositionOptions.has(belowYPos)) {
      return { distance: belowYPos, yTransformOrigin: strings$5.TOP };
    }
    if (yPositionOptions.has(aboveYPos)) {
      return { distance: aboveYPos, yTransformOrigin: strings$5.BOTTOM };
    }
    return { distance: belowYPos, yTransformOrigin: strings$5.TOP };
  }
  /**
   * Given the values for above/below alignment of the tooltip, calculates
   * which of these options would result in the tooltip maintaining the required
   * threshold distance vs which would result in the tooltip staying within the
   * viewport.
   *
   * A Set of values is returned holding the distances that would honor the
   * above requirements. Following the logic for determining the tooltip
   * position, if all possible alignments violate the threshold, then the
   * returned Set contains values that keep the tooltip within the viewport.
   */
  determineValidYPositionOptions(...positions) {
    const posWithinThreshold = /* @__PURE__ */ new Set();
    const posWithinViewport = /* @__PURE__ */ new Set();
    for (const position of positions) {
      if (this.yPositionHonorsViewportThreshold(position)) {
        posWithinThreshold.add(position);
      } else if (this.yPositionDoesntCollideWithViewport(position)) {
        posWithinViewport.add(position);
      }
    }
    return posWithinThreshold.size ? posWithinThreshold : posWithinViewport;
  }
  yPositionHonorsViewportThreshold(yPos) {
    const viewportHeight = this.adapter.getViewportHeight();
    const tooltipHeight = this.adapter.getTooltipSize().height;
    return yPos + tooltipHeight + this.minViewportTooltipThreshold <= viewportHeight && yPos >= this.minViewportTooltipThreshold;
  }
  yPositionDoesntCollideWithViewport(yPos) {
    const viewportHeight = this.adapter.getViewportHeight();
    const tooltipHeight = this.adapter.getTooltipSize().height;
    return yPos + tooltipHeight <= viewportHeight && yPos >= 0;
  }
  calculateTooltipWithCaretStyles(anchorRect) {
    this.adapter.clearTooltipCaretStyles();
    const caretSize = this.adapter.getTooltipCaretBoundingRect();
    if (!anchorRect || !caretSize) {
      return { position: PositionWithCaret.DETECTED, top: 0, left: 0 };
    }
    const caretWidth = caretSize.width / numbers$5.ANIMATION_SCALE;
    const caretHeight = caretSize.height / numbers$5.ANIMATION_SCALE / 2;
    const tooltipSize = this.adapter.getTooltipSize();
    const yOptions = this.calculateYWithCaretDistanceOptions(
      anchorRect,
      tooltipSize.height,
      { caretWidth, caretHeight }
    );
    const xOptions = this.calculateXWithCaretDistanceOptions(
      anchorRect,
      tooltipSize.width,
      { caretWidth, caretHeight }
    );
    let positionOptions = this.validateTooltipWithCaretDistances(yOptions, xOptions);
    if (positionOptions.size < 1) {
      positionOptions = this.generateBackupPositionOption(
        anchorRect,
        tooltipSize,
        { caretWidth, caretHeight }
      );
    }
    const { position, xDistance, yDistance } = this.determineTooltipWithCaretDistance(positionOptions);
    const { yTransformOrigin, xTransformOrigin } = this.setCaretPositionStyles(position, { caretWidth, caretHeight });
    return {
      yTransformOrigin,
      xTransformOrigin,
      top: yDistance,
      left: xDistance
    };
  }
  calculateXWithCaretDistanceOptions(anchorRect, tooltipWidth, caretSize) {
    const { caretWidth, caretHeight } = caretSize;
    const isLTR = !this.adapter.isRTL();
    const anchorMidpoint = anchorRect.left + anchorRect.width / 2;
    const sideLeftAligned = anchorRect.left - (tooltipWidth + this.anchorGap + caretHeight);
    const sideRightAligned = anchorRect.right + this.anchorGap + caretHeight;
    const sideStartPos = isLTR ? sideLeftAligned : sideRightAligned;
    const sideEndPos = isLTR ? sideRightAligned : sideLeftAligned;
    const verticalLeftAligned = anchorMidpoint - (numbers$5.CARET_INDENTATION + caretWidth / 2);
    const verticalRightAligned = anchorMidpoint - (tooltipWidth - numbers$5.CARET_INDENTATION - caretWidth / 2);
    const verticalStartPos = isLTR ? verticalLeftAligned : verticalRightAligned;
    const verticalEndPos = isLTR ? verticalRightAligned : verticalLeftAligned;
    const verticalCenterPos = anchorMidpoint - tooltipWidth / 2;
    const possiblePositionsMap = /* @__PURE__ */ new Map([
      [XPositionWithCaret.START, verticalStartPos],
      [XPositionWithCaret.CENTER, verticalCenterPos],
      [XPositionWithCaret.END, verticalEndPos],
      [XPositionWithCaret.SIDE_END, sideEndPos],
      [XPositionWithCaret.SIDE_START, sideStartPos]
    ]);
    return possiblePositionsMap;
  }
  calculateYWithCaretDistanceOptions(anchorRect, tooltipHeight, caretSize) {
    const { caretWidth, caretHeight } = caretSize;
    const anchorMidpoint = anchorRect.top + anchorRect.height / 2;
    const belowYPos = anchorRect.bottom + this.anchorGap + caretHeight;
    const aboveYPos = anchorRect.top - (this.anchorGap + tooltipHeight + caretHeight);
    const sideTopYPos = anchorMidpoint - (numbers$5.CARET_INDENTATION + caretWidth / 2);
    const sideCenterYPos = anchorMidpoint - tooltipHeight / 2;
    const sideBottomYPos = anchorMidpoint - (tooltipHeight - numbers$5.CARET_INDENTATION - caretWidth / 2);
    const possiblePositionsMap = /* @__PURE__ */ new Map([
      [YPositionWithCaret.ABOVE, aboveYPos],
      [YPositionWithCaret.BELOW, belowYPos],
      [YPositionWithCaret.SIDE_TOP, sideTopYPos],
      [YPositionWithCaret.SIDE_CENTER, sideCenterYPos],
      [YPositionWithCaret.SIDE_BOTTOM, sideBottomYPos]
    ]);
    return possiblePositionsMap;
  }
  repositionTooltipOnAnchorMove() {
    const newAnchorRect = this.adapter.getAnchorBoundingRect();
    if (!newAnchorRect || !this.anchorRect) return;
    const windowHeight = this.adapter.getViewportHeight();
    if (newAnchorRect.top + newAnchorRect.height < 0 || newAnchorRect.bottom - newAnchorRect.height >= windowHeight) {
      return;
    }
    if (newAnchorRect.top !== this.anchorRect.top || newAnchorRect.left !== this.anchorRect.left || newAnchorRect.height !== this.anchorRect.height || newAnchorRect.width !== this.anchorRect.width) {
      this.anchorRect = newAnchorRect;
      this.parentRect = this.adapter.getParentBoundingRect();
      this.richTooltip ? this.positionRichTooltip() : this.positionPlainTooltip();
    }
  }
  /**
   * Given a list of x/y position options for a rich tooltip with caret, checks
   * if valid x/y combinations of these position options are either within the
   * viewport threshold, or simply within the viewport. Returns a map with the
   * valid x/y position combinations that all either honor the viewport
   * threshold or are simply inside within the viewport.
   */
  validateTooltipWithCaretDistances(yOptions, xOptions) {
    const posWithinThreshold = /* @__PURE__ */ new Map();
    const posWithinViewport = /* @__PURE__ */ new Map();
    const validMappings = /* @__PURE__ */ new Map([
      [
        YPositionWithCaret.ABOVE,
        [
          XPositionWithCaret.START,
          XPositionWithCaret.CENTER,
          XPositionWithCaret.END
        ]
      ],
      [
        YPositionWithCaret.BELOW,
        [
          XPositionWithCaret.START,
          XPositionWithCaret.CENTER,
          XPositionWithCaret.END
        ]
      ],
      [
        YPositionWithCaret.SIDE_TOP,
        [XPositionWithCaret.SIDE_START, XPositionWithCaret.SIDE_END]
      ],
      [
        YPositionWithCaret.SIDE_CENTER,
        [XPositionWithCaret.SIDE_START, XPositionWithCaret.SIDE_END]
      ],
      [
        YPositionWithCaret.SIDE_BOTTOM,
        [XPositionWithCaret.SIDE_START, XPositionWithCaret.SIDE_END]
      ]
    ]);
    for (const y2 of validMappings.keys()) {
      const yDistance = yOptions.get(y2);
      if (this.yPositionHonorsViewportThreshold(yDistance)) {
        for (const x2 of validMappings.get(y2)) {
          const xDistance = xOptions.get(x2);
          if (this.positionHonorsViewportThreshold(xDistance)) {
            const caretPositionName = this.caretPositionOptionsMapping(x2, y2);
            posWithinThreshold.set(caretPositionName, { xDistance, yDistance });
          }
        }
      }
      if (this.yPositionDoesntCollideWithViewport(yDistance)) {
        for (const x2 of validMappings.get(y2)) {
          const xDistance = xOptions.get(x2);
          if (this.positionDoesntCollideWithViewport(xDistance)) {
            const caretPositionName = this.caretPositionOptionsMapping(x2, y2);
            posWithinViewport.set(caretPositionName, { xDistance, yDistance });
          }
        }
      }
    }
    return posWithinThreshold.size ? posWithinThreshold : posWithinViewport;
  }
  /**
   * Method for generating a horizontal and vertical position for the tooltip if
   * all other calculated values are considered invalid. This would only happen
   * in situations of very small viewports/large tooltips.
   */
  generateBackupPositionOption(anchorRect, tooltipSize, caretSize) {
    const isLTR = !this.adapter.isRTL();
    let xDistance;
    let xPos;
    if (anchorRect.left < 0) {
      xDistance = this.minViewportTooltipThreshold + caretSize.caretHeight;
      xPos = isLTR ? XPositionWithCaret.END : XPositionWithCaret.START;
    } else {
      const viewportWidth = this.adapter.getViewportWidth();
      xDistance = viewportWidth - (tooltipSize.width + this.minViewportTooltipThreshold + caretSize.caretHeight);
      xPos = isLTR ? XPositionWithCaret.START : XPositionWithCaret.END;
    }
    let yDistance;
    let yPos;
    if (anchorRect.top < 0) {
      yDistance = this.minViewportTooltipThreshold + caretSize.caretHeight;
      yPos = YPositionWithCaret.BELOW;
    } else {
      const viewportHeight = this.adapter.getViewportHeight();
      yDistance = viewportHeight - (tooltipSize.height + this.minViewportTooltipThreshold + caretSize.caretHeight);
      yPos = YPositionWithCaret.ABOVE;
    }
    const caretPositionName = this.caretPositionOptionsMapping(xPos, yPos);
    return /* @__PURE__ */ new Map(
      [[caretPositionName, { xDistance, yDistance }]]
    );
  }
  /**
   * Given a list of valid position options for a rich tooltip with caret,
   * returns the option that should be used.
   */
  determineTooltipWithCaretDistance(options) {
    if (options.has(this.tooltipPositionWithCaret)) {
      const tooltipPos = options.get(this.tooltipPositionWithCaret);
      return {
        position: this.tooltipPositionWithCaret,
        xDistance: tooltipPos.xDistance,
        yDistance: tooltipPos.yDistance
      };
    }
    const orderPref = [
      PositionWithCaret.ABOVE_START,
      PositionWithCaret.ABOVE_CENTER,
      PositionWithCaret.ABOVE_END,
      PositionWithCaret.TOP_SIDE_START,
      PositionWithCaret.CENTER_SIDE_START,
      PositionWithCaret.BOTTOM_SIDE_START,
      PositionWithCaret.TOP_SIDE_END,
      PositionWithCaret.CENTER_SIDE_END,
      PositionWithCaret.BOTTOM_SIDE_END,
      PositionWithCaret.BELOW_START,
      PositionWithCaret.BELOW_CENTER,
      PositionWithCaret.BELOW_END
    ];
    const validPosition = orderPref.find((pos2) => options.has(pos2));
    const pos = options.get(validPosition);
    return {
      position: validPosition,
      xDistance: pos.xDistance,
      yDistance: pos.yDistance
    };
  }
  /**
   * Returns the corresponding PositionWithCaret enum for the provided
   * XPositionWithCaret and YPositionWithCaret enums. This mapping exists so our
   * public API accepts only PositionWithCaret enums (as all combinations of
   * XPositionWithCaret and YPositionWithCaret are not valid), but internally we
   * can calculate the X and Y positions of a rich tooltip with caret
   * separately.
   */
  caretPositionOptionsMapping(xPos, yPos) {
    switch (yPos) {
      case YPositionWithCaret.ABOVE:
        if (xPos === XPositionWithCaret.START) {
          return PositionWithCaret.ABOVE_START;
        } else if (xPos === XPositionWithCaret.CENTER) {
          return PositionWithCaret.ABOVE_CENTER;
        } else if (xPos === XPositionWithCaret.END) {
          return PositionWithCaret.ABOVE_END;
        }
        break;
      case YPositionWithCaret.BELOW:
        if (xPos === XPositionWithCaret.START) {
          return PositionWithCaret.BELOW_START;
        } else if (xPos === XPositionWithCaret.CENTER) {
          return PositionWithCaret.BELOW_CENTER;
        } else if (xPos === XPositionWithCaret.END) {
          return PositionWithCaret.BELOW_END;
        }
        break;
      case YPositionWithCaret.SIDE_TOP:
        if (xPos === XPositionWithCaret.SIDE_START) {
          return PositionWithCaret.TOP_SIDE_START;
        } else if (xPos === XPositionWithCaret.SIDE_END) {
          return PositionWithCaret.TOP_SIDE_END;
        }
        break;
      case YPositionWithCaret.SIDE_CENTER:
        if (xPos === XPositionWithCaret.SIDE_START) {
          return PositionWithCaret.CENTER_SIDE_START;
        } else if (xPos === XPositionWithCaret.SIDE_END) {
          return PositionWithCaret.CENTER_SIDE_END;
        }
        break;
      case YPositionWithCaret.SIDE_BOTTOM:
        if (xPos === XPositionWithCaret.SIDE_START) {
          return PositionWithCaret.BOTTOM_SIDE_START;
        } else if (xPos === XPositionWithCaret.SIDE_END) {
          return PositionWithCaret.BOTTOM_SIDE_END;
        }
        break;
    }
    throw new Error(
      `MDCTooltipFoundation: Invalid caret position of ${xPos}, ${yPos}`
    );
  }
  /**
   * Given a PositionWithCaret, applies the correct styles to the caret element
   * so that it is positioned properly on the rich tooltip.
   * Returns the x and y positions of the caret, to be used as the
   * transform-origin on the tooltip itself for entrance animations.
   */
  setCaretPositionStyles(position, caretSize) {
    const values2 = this.calculateCaretPositionOnTooltip(position, caretSize);
    if (!values2) {
      return { yTransformOrigin: 0, xTransformOrigin: 0 };
    }
    this.adapter.clearTooltipCaretStyles();
    this.adapter.setTooltipCaretStyle(values2.yAlignment, values2.yAxisPx);
    this.adapter.setTooltipCaretStyle(values2.xAlignment, values2.xAxisPx);
    const skewRadians = values2.skew * (Math.PI / 180);
    const scaleX = Math.cos(skewRadians);
    this.adapter.setTooltipCaretStyle(
      "transform",
      `rotate(${values2.rotation}deg) skewY(${values2.skew}deg) scaleX(${scaleX})`
    );
    this.adapter.setTooltipCaretStyle(
      "transform-origin",
      `${values2.xAlignment} ${values2.yAlignment}`
    );
    for (const corner of values2.caretCorners) {
      this.adapter.setTooltipCaretStyle(corner, "0");
    }
    return {
      yTransformOrigin: values2.yTransformOrigin,
      xTransformOrigin: values2.xTransformOrigin
    };
  }
  /**
   * Given a PositionWithCaret, determines the correct styles to position the
   * caret properly on the rich tooltip.
   */
  calculateCaretPositionOnTooltip(tooltipPos, caretSize) {
    const isLTR = !this.adapter.isRTL();
    const tooltipWidth = this.adapter.getComputedStyleProperty("width");
    const tooltipHeight = this.adapter.getComputedStyleProperty("height");
    if (!tooltipWidth || !tooltipHeight || !caretSize) {
      return;
    }
    const midpointWidth = `calc((${tooltipWidth} - ${caretSize.caretWidth}px) / 2)`;
    const midpointHeight = `calc((${tooltipHeight} - ${caretSize.caretWidth}px) / 2)`;
    const flushWithEdge = "0";
    const indentedFromEdge = `${numbers$5.CARET_INDENTATION}px`;
    const indentedFromWidth = `calc(${tooltipWidth} - ${indentedFromEdge})`;
    const indentedFromHeight = `calc(${tooltipHeight} - ${indentedFromEdge})`;
    const verticalRotation = 35;
    const horizontalRotation = Math.abs(90 - verticalRotation);
    const bottomRightTopLeftBorderRadius = ["border-bottom-right-radius", "border-top-left-radius"];
    const bottomLeftTopRightBorderRadius = ["border-bottom-left-radius", "border-top-right-radius"];
    const skewDeg = 20;
    switch (tooltipPos) {
      case PositionWithCaret.BELOW_CENTER:
        return {
          yAlignment: strings$5.TOP,
          xAlignment: strings$5.LEFT,
          yAxisPx: flushWithEdge,
          xAxisPx: midpointWidth,
          rotation: -1 * verticalRotation,
          skew: -1 * skewDeg,
          xTransformOrigin: midpointWidth,
          yTransformOrigin: flushWithEdge,
          caretCorners: bottomRightTopLeftBorderRadius
        };
      case PositionWithCaret.BELOW_END:
        return {
          yAlignment: strings$5.TOP,
          xAlignment: isLTR ? strings$5.RIGHT : strings$5.LEFT,
          yAxisPx: flushWithEdge,
          xAxisPx: indentedFromEdge,
          rotation: isLTR ? verticalRotation : -1 * verticalRotation,
          skew: isLTR ? skewDeg : -1 * skewDeg,
          xTransformOrigin: isLTR ? indentedFromWidth : indentedFromEdge,
          yTransformOrigin: flushWithEdge,
          caretCorners: isLTR ? bottomLeftTopRightBorderRadius : bottomRightTopLeftBorderRadius
        };
      case PositionWithCaret.BELOW_START:
        return {
          yAlignment: strings$5.TOP,
          xAlignment: isLTR ? strings$5.LEFT : strings$5.RIGHT,
          yAxisPx: flushWithEdge,
          xAxisPx: indentedFromEdge,
          rotation: isLTR ? -1 * verticalRotation : verticalRotation,
          skew: isLTR ? -1 * skewDeg : skewDeg,
          xTransformOrigin: isLTR ? indentedFromEdge : indentedFromWidth,
          yTransformOrigin: flushWithEdge,
          caretCorners: isLTR ? bottomRightTopLeftBorderRadius : bottomLeftTopRightBorderRadius
        };
      case PositionWithCaret.TOP_SIDE_END:
        return {
          yAlignment: strings$5.TOP,
          xAlignment: isLTR ? strings$5.LEFT : strings$5.RIGHT,
          yAxisPx: indentedFromEdge,
          xAxisPx: flushWithEdge,
          rotation: isLTR ? horizontalRotation : -1 * horizontalRotation,
          skew: isLTR ? -1 * skewDeg : skewDeg,
          xTransformOrigin: isLTR ? flushWithEdge : tooltipWidth,
          yTransformOrigin: indentedFromEdge,
          caretCorners: isLTR ? bottomRightTopLeftBorderRadius : bottomLeftTopRightBorderRadius
        };
      case PositionWithCaret.CENTER_SIDE_END:
        return {
          yAlignment: strings$5.TOP,
          xAlignment: isLTR ? strings$5.LEFT : strings$5.RIGHT,
          yAxisPx: midpointHeight,
          xAxisPx: flushWithEdge,
          rotation: isLTR ? horizontalRotation : -1 * horizontalRotation,
          skew: isLTR ? -1 * skewDeg : skewDeg,
          xTransformOrigin: isLTR ? flushWithEdge : tooltipWidth,
          yTransformOrigin: midpointHeight,
          caretCorners: isLTR ? bottomRightTopLeftBorderRadius : bottomLeftTopRightBorderRadius
        };
      case PositionWithCaret.BOTTOM_SIDE_END:
        return {
          yAlignment: strings$5.BOTTOM,
          xAlignment: isLTR ? strings$5.LEFT : strings$5.RIGHT,
          yAxisPx: indentedFromEdge,
          xAxisPx: flushWithEdge,
          rotation: isLTR ? -1 * horizontalRotation : horizontalRotation,
          skew: isLTR ? skewDeg : -1 * skewDeg,
          xTransformOrigin: isLTR ? flushWithEdge : tooltipWidth,
          yTransformOrigin: indentedFromHeight,
          caretCorners: isLTR ? bottomLeftTopRightBorderRadius : bottomRightTopLeftBorderRadius
        };
      case PositionWithCaret.TOP_SIDE_START:
        return {
          yAlignment: strings$5.TOP,
          xAlignment: isLTR ? strings$5.RIGHT : strings$5.LEFT,
          yAxisPx: indentedFromEdge,
          xAxisPx: flushWithEdge,
          rotation: isLTR ? -1 * horizontalRotation : horizontalRotation,
          skew: isLTR ? skewDeg : -1 * skewDeg,
          xTransformOrigin: isLTR ? tooltipWidth : flushWithEdge,
          yTransformOrigin: indentedFromEdge,
          caretCorners: isLTR ? bottomLeftTopRightBorderRadius : bottomRightTopLeftBorderRadius
        };
      case PositionWithCaret.CENTER_SIDE_START:
        return {
          yAlignment: strings$5.TOP,
          xAlignment: isLTR ? strings$5.RIGHT : strings$5.LEFT,
          yAxisPx: midpointHeight,
          xAxisPx: flushWithEdge,
          rotation: isLTR ? -1 * horizontalRotation : horizontalRotation,
          skew: isLTR ? skewDeg : -1 * skewDeg,
          xTransformOrigin: isLTR ? tooltipWidth : flushWithEdge,
          yTransformOrigin: midpointHeight,
          caretCorners: isLTR ? bottomLeftTopRightBorderRadius : bottomRightTopLeftBorderRadius
        };
      case PositionWithCaret.BOTTOM_SIDE_START:
        return {
          yAlignment: strings$5.BOTTOM,
          xAlignment: isLTR ? strings$5.RIGHT : strings$5.LEFT,
          yAxisPx: indentedFromEdge,
          xAxisPx: flushWithEdge,
          rotation: isLTR ? horizontalRotation : -1 * horizontalRotation,
          skew: isLTR ? -1 * skewDeg : skewDeg,
          xTransformOrigin: isLTR ? tooltipWidth : flushWithEdge,
          yTransformOrigin: indentedFromHeight,
          caretCorners: isLTR ? bottomRightTopLeftBorderRadius : bottomLeftTopRightBorderRadius
        };
      case PositionWithCaret.ABOVE_CENTER:
        return {
          yAlignment: strings$5.BOTTOM,
          xAlignment: strings$5.LEFT,
          yAxisPx: flushWithEdge,
          xAxisPx: midpointWidth,
          rotation: verticalRotation,
          skew: skewDeg,
          xTransformOrigin: midpointWidth,
          yTransformOrigin: tooltipHeight,
          caretCorners: bottomLeftTopRightBorderRadius
        };
      case PositionWithCaret.ABOVE_END:
        return {
          yAlignment: strings$5.BOTTOM,
          xAlignment: isLTR ? strings$5.RIGHT : strings$5.LEFT,
          yAxisPx: flushWithEdge,
          xAxisPx: indentedFromEdge,
          rotation: isLTR ? -1 * verticalRotation : verticalRotation,
          skew: isLTR ? -1 * skewDeg : skewDeg,
          xTransformOrigin: isLTR ? indentedFromWidth : indentedFromEdge,
          yTransformOrigin: tooltipHeight,
          caretCorners: isLTR ? bottomRightTopLeftBorderRadius : bottomLeftTopRightBorderRadius
        };
      default:
      case PositionWithCaret.ABOVE_START:
        return {
          yAlignment: strings$5.BOTTOM,
          xAlignment: isLTR ? strings$5.LEFT : strings$5.RIGHT,
          yAxisPx: flushWithEdge,
          xAxisPx: indentedFromEdge,
          rotation: isLTR ? verticalRotation : -1 * verticalRotation,
          skew: isLTR ? skewDeg : -1 * skewDeg,
          xTransformOrigin: isLTR ? indentedFromEdge : indentedFromWidth,
          yTransformOrigin: tooltipHeight,
          caretCorners: isLTR ? bottomLeftTopRightBorderRadius : bottomRightTopLeftBorderRadius
        };
    }
  }
  clearShowTimeout() {
    if (this.showTimeout) {
      clearTimeout(this.showTimeout);
      this.showTimeout = null;
    }
  }
  clearHideTimeout() {
    if (this.hideTimeout) {
      clearTimeout(this.hideTimeout);
      this.hideTimeout = null;
    }
  }
  /**
   * Method that allows user to specify additional elements that should have a
   * scroll event listener attached to it. This should be used in instances
   * where the anchor element is placed inside a scrollable container, and will
   * ensure that the tooltip will stay attached to the anchor on scroll.
   */
  attachScrollHandler(addEventListenerFn) {
    this.addAncestorScrollEventListeners.push(() => {
      addEventListenerFn("scroll", this.windowScrollHandler);
    });
  }
  /**
   * Must be used in conjunction with #attachScrollHandler. Removes the scroll
   * event handler from elements on the page.
   */
  removeScrollHandler(removeEventHandlerFn) {
    this.removeAncestorScrollEventListeners.push(() => {
      removeEventHandlerFn("scroll", this.windowScrollHandler);
    });
  }
  destroy() {
    if (this.frameId) {
      cancelAnimationFrame(this.frameId);
      this.frameId = null;
    }
    this.clearHideTimeout();
    this.clearShowTimeout();
    this.adapter.removeClass(SHOWN);
    this.adapter.removeClass(SHOWING_TRANSITION);
    this.adapter.removeClass(SHOWING);
    this.adapter.removeClass(HIDE);
    this.adapter.removeClass(HIDE_TRANSITION);
    if (this.richTooltip) {
      this.adapter.deregisterEventHandler(
        "focusout",
        this.richTooltipFocusOutHandler
      );
    }
    if (!this.persistentTooltip) {
      this.adapter.deregisterEventHandler(
        "mouseenter",
        this.tooltipMouseEnterHandler
      );
      this.adapter.deregisterEventHandler(
        "mouseleave",
        this.tooltipMouseLeaveHandler
      );
    }
    this.adapter.deregisterAnchorEventHandler("blur", this.anchorBlurHandler);
    this.adapter.deregisterDocumentEventHandler(
      "click",
      this.documentClickHandler
    );
    this.adapter.deregisterDocumentEventHandler(
      "keydown",
      this.documentKeydownHandler
    );
    this.adapter.deregisterWindowEventHandler(
      "scroll",
      this.windowScrollHandler
    );
    this.adapter.deregisterWindowEventHandler(
      "resize",
      this.windowResizeHandler
    );
    for (const fn2 of this.removeAncestorScrollEventListeners) {
      fn2();
    }
    this.animFrame.cancelAll();
  }
}
function classMap(classObj) {
  return Object.entries(classObj).filter(([name, value]) => name !== "" && value).map(([name]) => name).join(" ");
}
function dispatch(element2, eventType, detail, eventInit = { bubbles: true }) {
  if (typeof Event === "undefined") {
    throw new Error("Event not defined.");
  }
  if (!element2) {
    throw new Error("Tried to dispatch event without element.");
  }
  const event2 = new CustomEvent(eventType, Object.assign(Object.assign({}, eventInit), { detail }));
  element2 === null || element2 === void 0 ? void 0 : element2.dispatchEvent(event2);
  return event2;
}
function exclude(obj, keys2) {
  let names = Object.getOwnPropertyNames(obj);
  const newObj = {};
  for (let i2 = 0; i2 < names.length; i2++) {
    const name = names[i2];
    const cashIndex = name.indexOf("$");
    if (cashIndex !== -1 && keys2.indexOf(name.substring(0, cashIndex + 1)) !== -1) {
      continue;
    }
    if (keys2.indexOf(name) !== -1) {
      continue;
    }
    newObj[name] = obj[name];
  }
  return newObj;
}
function prefixFilter(obj, prefix) {
  let names = Object.getOwnPropertyNames(obj);
  const newObj = {};
  for (let i2 = 0; i2 < names.length; i2++) {
    const name = names[i2];
    if (name.substring(0, prefix.length) === prefix) {
      newObj[name.substring(prefix.length)] = obj[name];
    }
  }
  return newObj;
}
class SvelteEventManager {
  constructor() {
    this.elementMap = /* @__PURE__ */ new Map();
  }
  /**
   * Listen to an event on an element.
   */
  on(element2, event2, handler, options) {
    if (!this.elementMap.has(element2)) {
      this.elementMap.set(element2, {});
    }
    const eventMap = this.elementMap.get(element2);
    if (eventMap == null) {
      throw new Error("Event map couldn't be created.");
    }
    if (!(event2 in eventMap)) {
      eventMap[event2] = /* @__PURE__ */ new Map();
    }
    const handlerMap = eventMap[event2];
    handlerMap.set(handler, on(element2, event2, handler, options));
  }
  /**
   * Unlisten to an event on an element.
   */
  off(element2, event2, handler) {
    const eventMap = this.elementMap.get(element2);
    if (eventMap == null || !(event2 in eventMap)) {
      return;
    }
    const handlerMap = eventMap[event2];
    const unlisten = handlerMap.get(handler);
    if (unlisten != null) {
      unlisten();
      handlerMap.delete(handler);
      if (handlerMap.size === 0) {
        delete eventMap[event2];
        if (Object.keys(eventMap).length === 0) {
          this.elementMap.delete(element2);
        }
      }
    }
  }
  /**
   * Unlisten to all events managed by this instance.
   */
  clear() {
    this.elementMap.forEach((eventMaps, _element) => {
      for (let [_event, eventMap] of Object.entries(eventMaps)) {
        eventMap.forEach((unlisten, _handler) => {
          unlisten();
        });
      }
    });
    this.elementMap.clear();
  }
}
function useActions(node, actions) {
  let actionReturns = [];
  if (actions) {
    for (let i2 = 0; i2 < actions.length; i2++) {
      const actionEntry = actions[i2];
      const action2 = Array.isArray(actionEntry) ? actionEntry[0] : actionEntry;
      if (Array.isArray(actionEntry) && actionEntry.length > 1) {
        actionReturns.push(action2(node, actionEntry[1]));
      } else {
        actionReturns.push(action2(node));
      }
    }
  }
  return {
    update(actions2) {
      if ((actions2 && actions2.length || 0) != actionReturns.length) {
        throw new Error("You must not change the length of an actions array.");
      }
      if (actions2) {
        for (let i2 = 0; i2 < actions2.length; i2++) {
          const returnEntry = actionReturns[i2];
          if (returnEntry && returnEntry.update) {
            const actionEntry = actions2[i2];
            if (Array.isArray(actionEntry) && actionEntry.length > 1) {
              returnEntry.update(actionEntry[1]);
            } else {
              returnEntry.update();
            }
          }
        }
      }
    },
    destroy() {
      for (let i2 = 0; i2 < actionReturns.length; i2++) {
        const returnEntry = actionReturns[i2];
        if (returnEntry && returnEntry.destroy) {
          returnEntry.destroy();
        }
      }
    }
  };
}
let counter$1 = 0;
const isTouchDevice = "ontouchstart" in window || navigator.maxTouchPoints > 0;
var root_1$t = /* @__PURE__ */ from_html(`<div><div><!></div></div>`);
function Tooltip($$anchor, $$props) {
  push($$props, true);
  const [$$stores, $$cleanup] = setup_stores();
  const $anchor = () => store_get(anchor, "$anchor", $$stores);
  let use = prop($$props, "use", 19, () => []), className = prop($$props, "class", 3, ""), style = prop($$props, "style", 3, ""), id2 = prop($$props, "id", 19, () => "SMUI-tooltip-" + counter$1++), unbounded = prop($$props, "unbounded", 3, false), xPos = prop($$props, "xPos", 3, "detected"), yPos = prop($$props, "yPos", 3, "detected"), persistent = prop($$props, "persistent", 3, false), interactive = prop($$props, "interactive", 19, persistent), hideFromScreenreader = prop($$props, "hideFromScreenreader", 3, false), showDelay = prop($$props, "showDelay", 3, void 0), hideDelay = prop($$props, "hideDelay", 3, void 0), surface$class = prop($$props, "surface$class", 3, ""), surface$style = prop($$props, "surface$style", 3, ""), triggerByAnchorFocus = prop($$props, "triggerByAnchorFocus", 3, false), supportTouchDevice = prop($$props, "supportTouchDevice", 3, false), restProps = /* @__PURE__ */ rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "use",
    "class",
    "style",
    "id",
    "unbounded",
    "xPos",
    "yPos",
    "persistent",
    "interactive",
    "hideFromScreenreader",
    "showDelay",
    "hideDelay",
    "surface$class",
    "surface$style",
    "children",
    "triggerByAnchorFocus",
    "supportTouchDevice"
  ]);
  let element2;
  let instance = /* @__PURE__ */ state(void 0);
  let eventManager = new SvelteEventManager();
  let nonReactiveLocationStore = {};
  let internalClasses = proxy$1({});
  let internalStyles = proxy$1({});
  let internalAttrs = proxy$1({});
  let surfaceAnimationStyles = proxy$1({});
  let anchor = getContext("SMUI:tooltip:wrapper:anchor");
  let tooltip = getContext("SMUI:tooltip:wrapper:tooltip");
  const rich = getContext("SMUI:tooltip:rich");
  const enabled = isTouchDevice ? supportTouchDevice() : true;
  const roleProps = /* @__PURE__ */ user_derived(() => ({
    role: rich && interactive() ? "dialog" : "tooltip",
    tabindex: rich && persistent() ? -1 : void 0
  }));
  let previousAnchor = void 0;
  user_effect(() => {
    if (get$1(instance) && previousAnchor !== $anchor()) {
      if (previousAnchor) {
        destroy(previousAnchor);
      }
      if ($anchor()) {
        init2($anchor());
      }
      previousAnchor = $anchor();
    }
  });
  user_effect(() => {
    if (get$1(instance)) {
      get$1(instance).setAnchorBoundaryType(AnchorBoundaryType[unbounded() ? "UNBOUNDED" : "BOUNDED"]);
    }
  });
  user_effect(() => {
    if (get$1(instance)) {
      get$1(instance).setTooltipPosition({
        xPos: XPosition[xPos().toUpperCase()],
        yPos: YPosition[yPos().toUpperCase()]
      });
    }
  });
  user_effect(() => {
    if (get$1(instance) && showDelay() != null) {
      get$1(instance).setShowDelay(showDelay());
    }
  });
  user_effect(() => {
    if (get$1(instance) && hideDelay() != null) {
      get$1(instance).setHideDelay(hideDelay());
    }
  });
  onMount(() => {
    set(
      instance,
      new MDCTooltipFoundation({
        getAttribute: getAttr,
        setAttribute: addAttr,
        removeAttribute: removeAttr,
        addClass,
        hasClass,
        removeClass,
        getComputedStyleProperty: (propertyName) => {
          const element3 = getElement();
          let style2 = getComputedStyle(element3).getPropertyValue(propertyName);
          if (style2 === "auto") {
            element3.classList.add("smui-banner--force-show");
            style2 = getComputedStyle(element3).getPropertyValue(propertyName);
            element3.classList.remove("smui-banner--force-show");
          }
          return style2;
        },
        setStyleProperty: addStyle,
        setSurfaceAnimationStyleProperty: addSurfaceAnimationStyle,
        getViewportWidth: () => window.innerWidth,
        getViewportHeight: () => window.innerHeight,
        getTooltipSize: () => {
          const element3 = getElement();
          let size2 = { width: element3.offsetWidth, height: element3.offsetHeight };
          if (size2.width === 0 || size2.height === 0) {
            element3.classList.add("smui-banner--force-show");
            size2 = { width: element3.offsetWidth, height: element3.offsetHeight };
            element3.classList.remove("smui-banner--force-show");
          }
          return size2;
        },
        getAnchorBoundingRect: () => {
          return $anchor() ? $anchor().getBoundingClientRect() : null;
        },
        getParentBoundingRect: () => {
          let parent2 = getElement().parentElement;
          if (!rich) {
            parent2 = findHost(getElement());
          }
          return (parent2 == null ? void 0 : parent2.getBoundingClientRect()) || null;
        },
        getAnchorAttribute: (attr) => {
          return $anchor() ? $anchor().getAttribute(attr) : null;
        },
        setAnchorAttribute: (attr, value) => {
          $anchor() && $anchor().setAttribute(attr, value);
        },
        isRTL: () => getComputedStyle(getElement()).direction === "rtl",
        anchorContainsElement: (element3) => {
          return !!($anchor() && $anchor().contains(element3));
        },
        tooltipContainsElement: (element3) => {
          return getElement().contains(element3);
        },
        focusAnchorElement: () => {
          $anchor() && $anchor().focus();
        },
        registerEventHandler: (evt, handler) => eventManager.on(getElement(), evt, handler),
        deregisterEventHandler: (evt, handler) => eventManager.off(getElement(), evt, handler),
        registerAnchorEventHandler: (evt, handler) => $anchor() && eventManager.on($anchor(), evt, handler),
        deregisterAnchorEventHandler: (evt, handler) => $anchor() && eventManager.off($anchor(), evt, handler),
        registerDocumentEventHandler: (evt, handler) => eventManager.on(document.body, evt, handler),
        deregisterDocumentEventHandler: (evt, handler) => eventManager.off(document.body, evt, handler),
        registerWindowEventHandler: (evt, handler) => eventManager.on(window, evt, handler, evt === "scroll" && { capture: true, passive: true } || void 0),
        deregisterWindowEventHandler: (evt, handler) => eventManager.off(window, evt, handler),
        notifyHidden: () => {
          dispatch(getElement(), "SMUITooltipHidden");
        },
        // TODO: figure out why MDC-Web included these caret functions, because they're entirely undocumented.
        getTooltipCaretBoundingRect: () => {
          const caret = getElement().querySelector(`.${CssClasses.TOOLTIP_CARET_TOP}`);
          if (!caret) {
            return null;
          }
          return caret.getBoundingClientRect();
        },
        setTooltipCaretStyle: (propertyName, value) => {
          const topCaret = getElement().querySelector(`.${CssClasses.TOOLTIP_CARET_TOP}`);
          const bottomCaret = getElement().querySelector(`.${CssClasses.TOOLTIP_CARET_BOTTOM}`);
          if (!topCaret || !bottomCaret) {
            return;
          }
          topCaret.style.setProperty(propertyName, value);
          bottomCaret.style.setProperty(propertyName, value);
        },
        clearTooltipCaretStyles: () => {
          const topCaret = getElement().querySelector(`.${CssClasses.TOOLTIP_CARET_TOP}`);
          const bottomCaret = getElement().querySelector(`.${CssClasses.TOOLTIP_CARET_BOTTOM}`);
          if (!topCaret || !bottomCaret) {
            return;
          }
          topCaret.removeAttribute("style");
          bottomCaret.removeAttribute("style");
        },
        getActiveElement: () => document.activeElement
      }),
      true
    );
    store_set(tooltip, element2);
    return () => {
      if ($anchor()) {
        destroy($anchor());
      }
      eventManager.clear();
    };
  });
  onDestroy(() => {
    var _a3, _b3, _c2, _d2, _e, _f;
    const root2 = getElement() ? getContainingShadowRootOrBody(getElement()) : void 0;
    if (!rich && typeof document !== "undefined" && root2 === ((_a3 = getElement()) == null ? void 0 : _a3.parentNode) && nonReactiveLocationStore.parent !== ((_b3 = getElement()) == null ? void 0 : _b3.parentNode) && ((_c2 = nonReactiveLocationStore.parent) == null ? void 0 : _c2.isConnected) && ((_d2 = nonReactiveLocationStore.parent) == null ? void 0 : _d2.insertBefore) && nonReactiveLocationStore.nextSibling) {
      (_e = nonReactiveLocationStore.parent) == null ? void 0 : _e.insertBefore(getElement(), nonReactiveLocationStore.nextSibling);
    }
    if (root2 === ((_f = getElement()) == null ? void 0 : _f.parentNode)) {
      getElement().remove();
    }
    element2 = null;
    set(instance, null);
  });
  function destroy(anchor2) {
    var _a3;
    if (!enabled) return;
    eventManager.off(anchor2, "focusout", handleAnchorFocusOut);
    if (rich && persistent()) {
      eventManager.off(anchor2, "click", handleAnchorActivate);
      eventManager.off(anchor2, "keydown", handleAnchorActivate);
    } else {
      eventManager.off(anchor2, "mouseenter", handleAnchorMouseEnter);
      eventManager.off(anchor2, "focusin", handleAnchorFocus);
      eventManager.off(anchor2, "mouseleave", handleAnchorMouseLeave);
      eventManager.off(anchor2, "touchstart", handleAnchorTouchStart);
      eventManager.off(anchor2, "touchend", handleAnchorTouchEnd);
    }
    if (rich && interactive()) {
      anchor2.removeAttribute("aria-haspopup");
      anchor2.removeAttribute("aria-expanded");
      anchor2.removeAttribute("data-tooltip-id");
    } else {
      anchor2.removeAttribute("aria-describedby");
    }
    (_a3 = get$1(instance)) == null ? void 0 : _a3.destroy();
  }
  function init2(anchor2) {
    var _a3;
    if (!enabled) return;
    if (triggerByAnchorFocus()) eventManager.on(anchor2, "focusout", handleAnchorFocusOut);
    if (rich && persistent()) {
      eventManager.on(anchor2, "click", handleAnchorActivate);
      eventManager.on(anchor2, "keydown", handleAnchorActivate);
    } else {
      eventManager.on(anchor2, "mouseenter", handleAnchorMouseEnter);
      if (triggerByAnchorFocus()) eventManager.on(anchor2, "focusin", handleAnchorFocus);
      eventManager.on(anchor2, "mouseleave", handleAnchorMouseLeave);
      eventManager.on(anchor2, "touchstart", handleAnchorTouchStart);
      eventManager.on(anchor2, "touchend", handleAnchorTouchEnd);
    }
    if (rich && interactive()) {
      anchor2.setAttribute("aria-haspopup", "dialog");
      anchor2.setAttribute("aria-expanded", "false");
      anchor2.setAttribute("data-tooltip-id", id2());
    } else {
      anchor2.setAttribute("aria-describedby", id2());
    }
    if (!rich) {
      hoist();
    }
    (_a3 = get$1(instance)) == null ? void 0 : _a3.init();
  }
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      internalClasses[className2] = true;
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      internalClasses[className2] = false;
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
      } else {
        internalStyles[name] = value;
      }
    }
  }
  function addSurfaceAnimationStyle(name, value) {
    if (surfaceAnimationStyles[name] != value) {
      if (value === "" || value == null) {
        delete surfaceAnimationStyles[name];
      } else {
        surfaceAnimationStyles[name] = value;
      }
    }
  }
  function getAttr(name) {
    return name in internalAttrs ? internalAttrs[name] ?? null : getElement().getAttribute(name);
  }
  function addAttr(name, value) {
    if (internalAttrs[name] !== value) {
      internalAttrs[name] = value;
    }
  }
  function removeAttr(name) {
    if (!(name in internalAttrs) || internalAttrs[name] != null) {
      internalAttrs[name] = void 0;
    }
  }
  function handleAnchorFocusOut(event2) {
    if (getElement().contains(event2.relatedTarget)) {
      return;
    }
    get$1(instance) && get$1(instance).hide();
  }
  function handleAnchorActivate(event2) {
    if (event2.type === "keydown" && event2.key !== "Enter" && event2.key !== " ") {
      return;
    }
    get$1(instance) && get$1(instance).handleAnchorClick();
  }
  function handleAnchorMouseEnter() {
    get$1(instance) && get$1(instance).handleAnchorMouseEnter();
  }
  function handleAnchorFocus(event2) {
    get$1(instance) && get$1(instance).handleAnchorFocus(event2);
  }
  function handleAnchorMouseLeave() {
    get$1(instance) && get$1(instance).handleAnchorMouseLeave();
  }
  function handleAnchorTouchStart() {
    get$1(instance) && get$1(instance).handleAnchorTouchstart();
  }
  function handleAnchorTouchEnd() {
    get$1(instance) && get$1(instance).handleAnchorTouchend();
  }
  function hoist() {
    if (!$anchor()) return;
    const root2 = getContainingShadowRootOrBody(getElement());
    if (root2 !== getElement().parentNode) {
      nonReactiveLocationStore.parent = getElement().parentNode ?? void 0;
      nonReactiveLocationStore.nextSibling = getElement().nextElementSibling ?? void 0;
      root2.appendChild(getElement());
    }
  }
  function attachScrollHandler(addEventListenerFn) {
    get$1(instance) && get$1(instance).attachScrollHandler(addEventListenerFn);
  }
  function removeScrollHandler(removeEventHandlerFn) {
    get$1(instance) && get$1(instance).removeScrollHandler(removeEventHandlerFn);
  }
  function getElement() {
    return element2;
  }
  function getInstance() {
    return get$1(instance);
  }
  var div = root_1$t();
  var event_handler = (e2) => {
    var _a3;
    if (get$1(instance)) {
      get$1(instance).handleTransitionEnd();
    }
    (_a3 = $$props.ontransitionend) == null ? void 0 : _a3.call($$props, e2);
  };
  attribute_effect(
    div,
    ($0, $1, $2) => ({
      class: $0,
      style: $1,
      "aria-hidden": "true",
      id: id2(),
      "data-mdc-tooltip-persistent": persistent() ? "true" : void 0,
      "data-mdc-tooltip-has-caret": void 0,
      "data-hide-tooltip-from-screenreader": hideFromScreenreader() ? "true" : void 0,
      ...get$1(roleProps),
      ...internalAttrs,
      ...$2,
      ontransitionend: event_handler
    }),
    [
      () => classMap({
        [className()]: true,
        "cl-tooltip": true,
        "mdc-tooltip": true,
        "mdc-tooltip--rich": rich,
        ...internalClasses
      }),
      () => Object.entries(internalStyles).map(([name, value]) => `${name}: ${value};`).concat([style()]).join(" "),
      () => exclude(restProps, ["surface$"])
    ]
  );
  var div_1 = child(div);
  attribute_effect(div_1, ($0, $1, $2) => ({ class: $0, style: $1, ...$2 }), [
    () => classMap({
      [surface$class()]: true,
      "mdc-tooltip__surface": true,
      "mdc-tooltip__surface-animation": true
    }),
    () => Object.entries(surfaceAnimationStyles).map(([name, value]) => `${name}: ${value};`).concat([surface$style()]).join(" "),
    () => prefixFilter(restProps, "surface$")
  ]);
  var node = child(div_1);
  snippet(node, () => $$props.children ?? noop$1);
  bind_this(div, ($$value) => element2 = $$value, () => element2);
  action(div, ($$node, $$action_arg) => useActions == null ? void 0 : useActions($$node, $$action_arg), use);
  append($$anchor, div);
  var $$pop = pop({
    attachScrollHandler,
    removeScrollHandler,
    getElement,
    getInstance
  });
  $$cleanup();
  return $$pop;
}
var root_1$s = /* @__PURE__ */ from_html(`<div><!></div>`);
function Wrapper($$anchor, $$props) {
  push($$props, true);
  const [$$stores, $$cleanup] = setup_stores();
  const $tooltip = () => store_get(tooltip, "$tooltip", $$stores);
  const $anchor = () => store_get(anchor, "$anchor", $$stores);
  let use = prop($$props, "use", 19, () => []), className = prop($$props, "class", 3, ""), rich = prop($$props, "rich", 3, false), restProps = /* @__PURE__ */ rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "use",
    "class",
    "rich",
    "children"
  ]);
  let element2;
  const anchor = writable(void 0);
  const tooltip = writable(void 0);
  setContext("SMUI:tooltip:wrapper:anchor", anchor);
  setContext("SMUI:tooltip:wrapper:tooltip", tooltip);
  setContext("SMUI:tooltip:rich", rich());
  user_effect(() => {
    if ($tooltip() && !$anchor()) {
      store_set(anchor, $tooltip().previousElementSibling);
    }
  });
  function getElement() {
    return element2;
  }
  onDestroy(() => {
    element2 = null;
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var div = root_1$s();
      attribute_effect(div, ($0) => ({ class: $0, ...restProps }), [
        () => classMap({ [className()]: true, "mdc-tooltip-wrapper--rich": true })
      ]);
      var node_1 = child(div);
      snippet(node_1, () => $$props.children ?? noop$1);
      bind_this(div, ($$value) => element2 = $$value, () => element2);
      action(div, ($$node, $$action_arg) => useActions == null ? void 0 : useActions($$node, $$action_arg), use);
      append($$anchor2, div);
    };
    var alternate = ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      snippet(node_2, () => $$props.children ?? noop$1);
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (rich()) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  var $$pop = pop({ getElement });
  $$cleanup();
  return $$pop;
}
function useTranslation() {
  const i18nService = getContext(IIntlService);
  return i18nService;
}
var root$q = /* @__PURE__ */ from_html(`<div class="loader svelte-nbyf0j"><span class="item svelte-nbyf0j"></span> <span class="item svelte-nbyf0j"></span> <span class="item svelte-nbyf0j"></span></div>`);
const $$css$x = {
  hash: "svelte-nbyf0j",
  code: ".loader.svelte-nbyf0j {margin-left:4px;display:flex;flex-direction:row;align-items:center;justify-content:flex-start;flex-wrap:nowrap;}.item.svelte-nbyf0j {width:4px;height:4px;border-radius:100%;background-color:var(--cl-legendLoader-foreground);\n  animation: svelte-nbyf0j-cl-button-loader 1s infinite;}.item.svelte-nbyf0j:not(:last-child) {margin-right:3px;}.item.svelte-nbyf0j:nth-child(1) {animation-delay:0.1s;}.item.svelte-nbyf0j:nth-child(2) {animation-delay:0.3s;}.item.svelte-nbyf0j:nth-child(3) {animation-delay:0.45s;}\n\n@keyframes svelte-nbyf0j-cl-button-loader {\n  0%, 100% {\n    opacity: 1;\n  }\n  60% {\n    opacity: 0.4;\n  }\n  30% {\n    opacity: 0.2;\n  }\n}"
};
function Loader($$anchor) {
  append_styles$1($$anchor, $$css$x);
  var div = root$q();
  append($$anchor, div);
}
var root_1$r = /* @__PURE__ */ from_html(`<div class="item error svelte-1aqdr0d"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M9 4c-.79 0-1.38.7-1.25 1.48l.67 4.03a.59.59 0 0 0 1.16 0l.67-4.03A1.27 1.27 0 0 0 9 4zm0 8a1 1 0 1 0 0 2 1 1 0 0 0 0-2z"></path></svg></div> <!>`, 1);
var root$p = /* @__PURE__ */ from_html(`<div class="container svelte-1aqdr0d"><!></div>`);
const $$css$w = {
  hash: "svelte-1aqdr0d",
  code: '.container.svelte-1aqdr0d {margin:0 4px;}.item.svelte-1aqdr0d {width:18px;height:18px;border-radius:50%;overflow:hidden;pointer-events:auto;}.error.svelte-1aqdr0d {position:relative;color:#cc2f3c;}\n@media (hover: hover) and (pointer: fine) {.error.svelte-1aqdr0d:hover {color:#b22833;}.error.svelte-1aqdr0d:hover:after {opacity:0.25;}\n}.error.svelte-1aqdr0d:after {content:" ";display:block;position:absolute;height:100%;width:100%;left:0;top:0;opacity:0.15;z-index:-1;background:#f7525f;}'
};
function Status($$anchor, $$props) {
  push($$props, false);
  append_styles$1($$anchor, $$css$w);
  const { t: t2 } = useTranslation();
  init();
  var div = root$p();
  var node = child(div);
  Wrapper(node, {
    children: ($$anchor2, $$slotProps) => {
      var fragment = root_1$r();
      var node_1 = sibling(first_child(fragment), 2);
      Tooltip(node_1, {
        children: ($$anchor3, $$slotProps2) => {
          var text$1 = text();
          template_effect(($0) => set_text(text$1, $0), [() => t2("legend.error.symbol")]);
          append($$anchor3, text$1);
        },
        $$slots: { default: true }
      });
      append($$anchor2, fragment);
    },
    $$slots: { default: true }
  });
  append($$anchor, div);
  pop();
}
var root_3$5 = /* @__PURE__ */ from_html(`<span> </span>`);
var root_2$d = /* @__PURE__ */ from_html(`<div class="valueItem svelte-1jf9nq0"><!> <span> </span></div>`);
var root_1$q = /* @__PURE__ */ from_html(`<div class="values svelte-1jf9nq0"></div>`);
const $$css$v = {
  hash: "svelte-1jf9nq0",
  code: ".values.svelte-1jf9nq0 {display:flex;flex-direction:row;flex-wrap:nowrap;align-items:center;font-size:13px;}.valueItem.svelte-1jf9nq0 {display:flex;padding-right:6px;}"
};
function StudySeriesValues($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$v);
  const [$$stores, $$cleanup] = setup_stores();
  const $values = () => store_get(values2, "$values", $$stores);
  const chartManagementService = useService(IChartManagementService);
  const values2 = derived(chartManagementService.store, (store) => {
    var _a3, _b3;
    return (_b3 = (_a3 = store.instances[$$props.chartIndex]) == null ? void 0 : _a3.studyLegend[$$props.studyId]) == null ? void 0 : _b3.values;
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var div = root_1$q();
      each(div, 5, $values, (entry) => entry.key, ($$anchor3, entry) => {
        var div_1 = root_2$d();
        var node_1 = child(div_1);
        {
          var consequent = ($$anchor4) => {
            var span = root_3$5();
            var text2 = child(span);
            template_effect(() => set_text(text2, get$1(entry).title));
            append($$anchor4, span);
          };
          if_block(node_1, ($$render) => {
            if (get$1(entry).title) $$render(consequent);
          });
        }
        var span_1 = sibling(node_1, 2);
        let styles;
        var text_1 = child(span_1);
        template_effect(
          ($0) => {
            styles = set_style(span_1, "", styles, $0);
            set_text(text_1, get$1(entry).value);
          },
          [() => ({ color: get$1(entry).color })]
        );
        append($$anchor3, div_1);
      });
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($values()) $$render(consequent_1);
    });
  }
  append($$anchor, fragment);
  pop();
  $$cleanup();
}
var root_1$p = /* @__PURE__ */ from_html(`<button aria-label="Remove" class="button svelte-1hy348m"><span class="svelte-1hy348m"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18"><path fill="currentColor" d="M7.5 4a.5.5 0 0 0-.5.5V5h4v-.5a.5.5 0 0 0-.5-.5h-3ZM12 5h3v1h-1.05l-.85 7.67A1.5 1.5 0 0 1 11.6 15H6.4a1.5 1.5 0 0 1-1.5-1.33L4.05 6H3V5h3v-.5C6 3.67 6.67 3 7.5 3h3c.83 0 1.5.67 1.5 1.5V5ZM5.06 6l.84 7.56a.5.5 0 0 0 .5.44h5.2a.5.5 0 0 0 .5-.44L12.94 6H5.06Z"></path></svg></span></button> <!>`, 1);
var root_3$4 = /* @__PURE__ */ from_html(`<button class="button svelte-1hy348m" aria-label="More"><span class="svelte-1hy348m"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18"><path fill="currentColor" fill-rule="evenodd" d="M3 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Zm0 1a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm6-1a1 1 0 1 0 0-2 1 1 0 0 0 0 2Zm0 1a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm7-2a1 1 0 1 1-2 0 1 1 0 0 1 2 0Zm1 0a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z"></path></svg></span></button> <!>`, 1);
var root$o = /* @__PURE__ */ from_html(`<div class="legendWrapper svelte-1hy348m"><div class="series svelte-1hy348m"><div role="button" tabindex="-1"><div class="texts svelte-1hy348m"> </div> <div class="inputs svelte-1hy348m"> </div> <div><!> <!></div></div> <div class="valueWrapper svelte-1hy348m"><!></div></div></div>`);
const $$css$u = {
  hash: "svelte-1hy348m",
  code: '.legendWrapper.svelte-1hy348m {display:flex;flex-direction:column;justify-content:flex-start;align-items:flex-start;}.series.svelte-1hy348m {display:flex;max-height:100%;flex-wrap:wrap;}.display.svelte-1hy348m {position:relative;display:flex;flex-wrap:nowrap;height:24px;padding:1px 4px;background-color:var(--cl-legend-background);border:1px solid transparent;border-right-width:0;border-radius:4px 0 0 4px;box-sizing:border-box;pointer-events:auto;}.display.display--hover.svelte-1hy348m {background-color:var(--cl-legend-hoverBackground);border-color:var(--cl-legend-hoverBorder);}.display.display--active.svelte-1hy348m {background-color:var(--cl-legend-hoverBackground);border-color:var(--cl-selectedForeground);}.texts.svelte-1hy348m {display:flex;align-items:center;font-size:13px;color:var(--cl-foreground);overflow:hidden;cursor:default;}.inputs.svelte-1hy348m {padding-left:4px;display:flex;align-items:center;font-size:13px;color:var(--cl-foreground);overflow:hidden;cursor:default;}.buttons.svelte-1hy348m {display:none;position:absolute;top:-1px;bottom:-1px;right:0;transform:translateX(100%);flex-direction:row;align-items:center;justify-content:flex-start;padding:1px 4px 1px 0;border:1px solid transparent;border-left-width:0;border-radius:0 4px 4px 0;box-sizing:border-box;background-color:var(--cl-background);}.buttons.buttons--hover.svelte-1hy348m {display:flex;border-color:var(--cl-legend-hoverBorder);}.buttons.buttons--active.svelte-1hy348m {display:flex;border-color:var(--cl-selectedForeground);}.button.svelte-1hy348m {outline:none;border:none;background:none;padding-block:initial;padding-inline:initial;font-family:inherit;color:inherit;display:flex;align-items:center;justify-content:center;font:inherit;position:relative;height:100%;flex:0;margin:0 4px;}.button.svelte-1hy348m > :where(.svelte-1hy348m) {isolation:isolate;}\n@media (hover: hover) and (pointer: fine) {.button.svelte-1hy348m:hover:before {position:absolute;top:0;right:-4px;bottom:0;left:-4px;border-radius:4px;content:"";background-color:var(--cl-button-hoverBackground);}\n}.button.svelte-1hy348m > span:where(.svelte-1hy348m) {display:block;width:18px;height:18px;}.valueWrapper.svelte-1hy348m {align-self:stretch;display:flex;align-items:center;flex-wrap:nowrap;cursor:default;overflow:hidden;border-top:1px solid transparent;border-bottom:1px solid transparent;}'
};
function StudySeriesLegend($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$u);
  const [$$stores, $$cleanup] = setup_stores();
  const $isSelected = () => store_get(isSelected, "$isSelected", $$stores);
  const $title = () => store_get(title, "$title", $$stores);
  const $inputs = () => store_get(inputs, "$inputs", $$stores);
  const $isWaitingData = () => store_get(isWaitingData, "$isWaitingData", $$stores);
  const $isError = () => store_get(isError, "$isError", $$stores);
  const { t: t2 } = useTranslation();
  const chartManagementService = useService(IChartManagementService);
  const chart = chartManagementService.chart($$props.chartIndex);
  const title = derived(chartManagementService.store, (store) => {
    const study = store.instances[chart.index].studyList.find((s2) => s2.id === $$props.studyId);
    if (!study) return "";
    return study.title;
  });
  const inputs = derived(chartManagementService.store, (store) => {
    const study = store.instances[chart.index].studyList.find((s2) => s2.id === $$props.studyId);
    if (!study) return "";
    if (!study.inputs) return "";
    if (isEmpty(study.inputs)) return "";
    return `(${Object.values(study.inputs).join(",")})`;
  });
  const isWaitingData = derived(chartManagementService.store, (store) => {
    var _a3;
    const status = (_a3 = store.instances[$$props.chartIndex]) == null ? void 0 : _a3.dataStatus;
    return status !== ChartDataStatus.dataLoaded && status !== ChartDataStatus.error;
  });
  const isError = derived(chartManagementService.store, (store) => {
    var _a3;
    const status = (_a3 = store.instances[$$props.chartIndex]) == null ? void 0 : _a3.dataStatus;
    return status === ChartDataStatus.error;
  });
  const isSelected = derived(chartManagementService.store, (store) => {
    var _a3, _b3;
    return (_b3 = (_a3 = store.instances[$$props.chartIndex]) == null ? void 0 : _a3.studyLegend[$$props.studyId]) == null ? void 0 : _b3.selected;
  });
  let isHover = /* @__PURE__ */ state(false);
  let unhoverTimer = 0;
  async function removeStudy() {
    chart.removeEntity($$props.studyId);
  }
  var div = root$o();
  var div_1 = child(div);
  var div_2 = child(div_1);
  var div_3 = child(div_2);
  var text$1 = child(div_3);
  var div_4 = sibling(div_3, 2);
  var text_1 = child(div_4);
  var div_5 = sibling(div_4, 2);
  var node = child(div_5);
  Wrapper(node, {
    children: ($$anchor2, $$slotProps) => {
      var fragment = root_1$p();
      var button = first_child(fragment);
      var event_handler = /* @__PURE__ */ user_derived(() => ifLeftClick(removeStudy));
      button.__pointerup = function(...$$args) {
        var _a3;
        (_a3 = get$1(event_handler)) == null ? void 0 : _a3.apply(this, $$args);
      };
      var node_1 = sibling(button, 2);
      Tooltip(node_1, {
        showDelay: 600,
        children: ($$anchor3, $$slotProps2) => {
          var text_2 = text();
          template_effect(($0) => set_text(text_2, $0), [() => t2("legend.remove")]);
          append($$anchor3, text_2);
        },
        $$slots: { default: true }
      });
      append($$anchor2, fragment);
    },
    $$slots: { default: true }
  });
  var node_2 = sibling(node, 2);
  Wrapper(node_2, {
    children: ($$anchor2, $$slotProps) => {
      var fragment_2 = root_3$4();
      var node_3 = sibling(first_child(fragment_2), 2);
      Tooltip(node_3, {
        showDelay: 600,
        children: ($$anchor3, $$slotProps2) => {
          var text_3 = text();
          template_effect(($0) => set_text(text_3, $0), [() => t2("legend.more")]);
          append($$anchor3, text_3);
        },
        $$slots: { default: true }
      });
      append($$anchor2, fragment_2);
    },
    $$slots: { default: true }
  });
  var div_6 = sibling(div_2, 2);
  var node_4 = child(div_6);
  {
    var consequent = ($$anchor2) => {
      Loader($$anchor2);
    };
    var alternate_1 = ($$anchor2) => {
      var fragment_5 = comment();
      var node_5 = first_child(fragment_5);
      {
        var consequent_1 = ($$anchor3) => {
          Status($$anchor3, {});
        };
        var alternate = ($$anchor3) => {
          StudySeriesValues($$anchor3, {
            get chartIndex() {
              return $$props.chartIndex;
            },
            get studyId() {
              return $$props.studyId;
            }
          });
        };
        if_block(
          node_5,
          ($$render) => {
            if ($isError()) $$render(consequent_1);
            else $$render(alternate, false);
          },
          true
        );
      }
      append($$anchor2, fragment_5);
    };
    if_block(node_4, ($$render) => {
      if ($isWaitingData()) $$render(consequent);
      else $$render(alternate_1, false);
    });
  }
  template_effect(
    ($0, $1) => {
      set_class(div_2, 1, $0, "svelte-1hy348m");
      set_text(text$1, $title());
      set_text(text_1, $inputs());
      set_class(div_5, 1, $1, "svelte-1hy348m");
    },
    [
      () => clsx(clsx$1("display", get$1(isHover) && "display--hover", $isSelected() && "display--active")),
      () => clsx(clsx$1("buttons", get$1(isHover) && "buttons--hover", $isSelected() && "buttons--active"))
    ]
  );
  event("mouseenter", div_2, () => {
    set(isHover, true);
    if (unhoverTimer) {
      clearTimeout(unhoverTimer);
      unhoverTimer = 0;
    }
  });
  event("mouseleave", div_2, () => {
    unhoverTimer = setTimeout(
      () => {
        set(isHover, false);
        unhoverTimer = 0;
      },
      150
    );
  });
  append($$anchor, div);
  pop();
  $$cleanup();
}
delegate(["pointerup"]);
var root_1$o = /* @__PURE__ */ from_html(`<div class="auxPanePortal svelte-17pfq9"><!></div>`);
const $$css$t = {
  hash: "svelte-17pfq9",
  code: ".auxPanePortal.svelte-17pfq9 {position:absolute;top:4px;left:4px;z-index:2;user-select:none;pointer-events:none;}"
};
function AuxPanePortal($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$t);
  const props = /* @__PURE__ */ rest_props($$props, ["$$slots", "$$events", "$$legacy"]);
  const chartManagementService = useService(IChartManagementService);
  let target;
  const chartWidget = chartManagementService.chart($$props.chartIndex);
  const study = chartWidget.getStudyById($$props.studyId);
  const container = study.paneHTMLElement();
  container.style.position = "relative";
  const div = document.createElement("div");
  container.appendChild(div);
  target = div;
  target.id = props.studyId;
  onMount(() => {
    PartFingerprints.write(target, PartFingerprint.Legend);
  });
  onDestroy(() => {
    target.remove();
  });
  Portal($$anchor, {
    get target() {
      return target;
    },
    children: ($$anchor2, $$slotProps) => {
      var div_1 = root_1$o();
      var node = child(div_1);
      StudySeriesLegend(node, {
        get chartIndex() {
          return $$props.chartIndex;
        },
        get studyId() {
          return $$props.studyId;
        }
      });
      append($$anchor2, div_1);
    },
    $$slots: { default: true }
  });
  pop();
}
var root_2$c = /* @__PURE__ */ from_html(`<div class="valueItem svelte-ir8sbd"><span class="key svelte-ir8sbd"> </span> <span> </span></div> <div class="valueItem svelte-ir8sbd"><span class="key svelte-ir8sbd"> </span> <span> </span></div> <div class="valueItem svelte-ir8sbd"><span class="key svelte-ir8sbd"> </span> <span> </span></div> <div class="valueItem svelte-ir8sbd"><span class="key svelte-ir8sbd"> </span> <span> </span></div>`, 1);
var root_4$a = /* @__PURE__ */ from_html(`<div class="valueItem svelte-ir8sbd"><span> </span></div>`);
var root_5$4 = /* @__PURE__ */ from_html(`<span> </span>`);
var root_1$n = /* @__PURE__ */ from_html(`<div class="values svelte-ir8sbd"><!> <!></div>`);
const $$css$s = {
  hash: "svelte-ir8sbd",
  code: ".values.svelte-ir8sbd {display:flex;flex-direction:row;flex-wrap:wrap;align-items:center;font-size:13px;}.valueItem.svelte-ir8sbd {display:flex;padding-right:6px;}.key.svelte-ir8sbd {color:var(--cl-foreground);padding-right:1px;}"
};
function MainSeriesValues($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$s);
  const [$$stores, $$cleanup] = setup_stores();
  const $values = () => store_get(values2, "$values", $$stores);
  const $isOhlc = () => store_get(isOhlc, "$isOhlc", $$stores);
  const $legendProps = () => store_get(legendProps, "$legendProps", $$stores);
  const { t: t2 } = useTranslation();
  const configurationService = useService(IConfigurationService);
  const chartManagementService = useService(IChartManagementService);
  const legendProps = derivedWithCache(configurationService.store, (store) => {
    return store.chartProperties.legend;
  });
  const values2 = derivedWithCache(chartManagementService.store, (store) => {
    var _a3;
    return (_a3 = store.instances[$$props.chartIndex]) == null ? void 0 : _a3.mainLegend;
  });
  const isOhlc = derivedWithCache(chartManagementService.store, (store) => {
    var _a3;
    const style = (_a3 = store.instances[$$props.chartIndex]) == null ? void 0 : _a3.chartProperties["mainSeriesProperties.style"];
    return !!style && isOhlcSeries(style);
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_3 = ($$anchor2) => {
      var div = root_1$n();
      var node_1 = child(div);
      {
        var consequent = ($$anchor3) => {
          var fragment_1 = root_2$c();
          var div_1 = first_child(fragment_1);
          var span = child(div_1);
          var text2 = child(span);
          var span_1 = sibling(span, 2);
          let styles;
          var text_1 = child(span_1);
          var div_2 = sibling(div_1, 2);
          var span_2 = child(div_2);
          var text_2 = child(span_2);
          var span_3 = sibling(span_2, 2);
          let styles_1;
          var text_3 = child(span_3);
          var div_3 = sibling(div_2, 2);
          var span_4 = child(div_3);
          var text_4 = child(span_4);
          var span_5 = sibling(span_4, 2);
          let styles_2;
          var text_5 = child(span_5);
          var div_4 = sibling(div_3, 2);
          var span_6 = child(div_4);
          var text_6 = child(span_6);
          var span_7 = sibling(span_6, 2);
          let styles_3;
          var text_7 = child(span_7);
          template_effect(
            ($0, $1, $2, $3, $4, $5, $6, $7) => {
              var _a3, _b3, _c2, _d2;
              set_text(text2, $0);
              styles = set_style(span_1, "", styles, $1);
              set_text(text_1, (_a3 = $values()) == null ? void 0 : _a3.open);
              set_text(text_2, $2);
              styles_1 = set_style(span_3, "", styles_1, $3);
              set_text(text_3, (_b3 = $values()) == null ? void 0 : _b3.high);
              set_text(text_4, $4);
              styles_2 = set_style(span_5, "", styles_2, $5);
              set_text(text_5, (_c2 = $values()) == null ? void 0 : _c2.low);
              set_text(text_6, $6);
              styles_3 = set_style(span_7, "", styles_3, $7);
              set_text(text_7, (_d2 = $values()) == null ? void 0 : _d2.close);
            },
            [
              () => t2("legend.main.open"),
              () => {
                var _a3;
                return { color: (_a3 = $values()) == null ? void 0 : _a3.color };
              },
              () => t2("legend.main.high"),
              () => {
                var _a3;
                return { color: (_a3 = $values()) == null ? void 0 : _a3.color };
              },
              () => t2("legend.main.low"),
              () => {
                var _a3;
                return { color: (_a3 = $values()) == null ? void 0 : _a3.color };
              },
              () => t2("legend.main.close"),
              () => {
                var _a3;
                return { color: (_a3 = $values()) == null ? void 0 : _a3.color };
              }
            ]
          );
          append($$anchor3, fragment_1);
        };
        var alternate = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          {
            var consequent_1 = ($$anchor4) => {
              var div_5 = root_4$a();
              var span_8 = child(div_5);
              let styles_4;
              var text_8 = child(span_8);
              template_effect(
                ($0) => {
                  var _a3;
                  styles_4 = set_style(span_8, "", styles_4, $0);
                  set_text(text_8, (_a3 = $values()) == null ? void 0 : _a3.value);
                },
                [() => {
                  var _a3;
                  return { color: (_a3 = $values()) == null ? void 0 : _a3.color };
                }]
              );
              append($$anchor4, div_5);
            };
            if_block(
              node_2,
              ($$render) => {
                if ($values().value) $$render(consequent_1);
              },
              true
            );
          }
          append($$anchor3, fragment_2);
        };
        if_block(node_1, ($$render) => {
          if ($isOhlc() && $values().open) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      var node_3 = sibling(node_1, 2);
      {
        var consequent_2 = ($$anchor3) => {
          var span_9 = root_5$4();
          let styles_5;
          var text_9 = child(span_9);
          template_effect(
            ($0) => {
              var _a3;
              styles_5 = set_style(span_9, "", styles_5, $0);
              set_text(text_9, (_a3 = $values()) == null ? void 0 : _a3.change);
            },
            [() => {
              var _a3;
              return { color: (_a3 = $values()) == null ? void 0 : _a3.color };
            }]
          );
          append($$anchor3, span_9);
        };
        if_block(node_3, ($$render) => {
          if ($legendProps().showBarChange) $$render(consequent_2);
        });
      }
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($values()) $$render(consequent_3);
    });
  }
  append($$anchor, fragment);
  pop();
  $$cleanup();
}
var root_2$b = /* @__PURE__ */ from_html(`<button class="symbolBtn svelte-17lzdls"><span class="svelte-17lzdls"> </span></button> <!>`, 1);
var root_4$9 = /* @__PURE__ */ from_html(`<button class="resolutionBtn svelte-17lzdls"><span class="svelte-17lzdls"> </span></button> <!>`, 1);
var root_6$5 = /* @__PURE__ */ from_html(`<button aria-label="More" class="more svelte-17lzdls"><span class="svelte-17lzdls"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18"><path fill="currentColor" fill-rule="evenodd" d="M3 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Zm0 1a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm6-1a1 1 0 1 0 0-2 1 1 0 0 0 0 2Zm0 1a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm7-2a1 1 0 1 1-2 0 1 1 0 0 1 2 0Zm1 0a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z"></path></svg></span></button> <!>`, 1);
var root_1$m = /* @__PURE__ */ from_html(`<div role="button" tabindex="-1"><div class="texts svelte-17lzdls"><div class="titleWrapper"><!></div> <div class="interval svelte-17lzdls"><!></div></div> <div><!></div></div>`);
var root$n = /* @__PURE__ */ from_html(`<div class="legendWrapper svelte-17lzdls"><div class="series svelte-17lzdls"><!> <div class="valueWrapper svelte-17lzdls"><!></div></div></div>`);
const $$css$r = {
  hash: "svelte-17lzdls",
  code: '@charset "UTF-8";.legendWrapper.svelte-17lzdls {display:flex;flex-direction:column;justify-content:flex-start;align-items:flex-start;}.series.svelte-17lzdls {display:flex;max-height:100%;flex-wrap:wrap;}.display.svelte-17lzdls {position:relative;display:flex;flex-wrap:nowrap;padding:1px 4px;background-color:var(--cl-legend-background);border:1px solid transparent;border-right-width:0;border-radius:4px 0 0 4px;box-sizing:border-box;pointer-events:auto;}.display.display--hover.svelte-17lzdls {background-color:var(--cl-legend-hoverBackground);border-color:var(--cl-legend-hoverBorder);}.display.display--active.svelte-17lzdls {background-color:var(--cl-legend-hoverBackground);border-color:var(--cl-selectedForeground);}.texts.svelte-17lzdls {display:flex;align-items:center;font-size:16px;line-height:18px;color:var(--cl-foreground);overflow:hidden;cursor:default;}.symbolBtn.svelte-17lzdls,\n.resolutionBtn.svelte-17lzdls {outline:none;border:none;background:none;padding-block:initial;padding-inline:initial;font-family:inherit;color:inherit;display:flex;align-items:center;justify-content:center;font:inherit;position:relative;}.symbolBtn.svelte-17lzdls > :where(.svelte-17lzdls),\n.resolutionBtn.svelte-17lzdls > :where(.svelte-17lzdls) {isolation:isolate;}\n@media (hover: hover) and (pointer: fine) {.symbolBtn.svelte-17lzdls:hover:before,\n  .resolutionBtn.svelte-17lzdls:hover:before {position:absolute;top:0;right:-5px;bottom:0;left:-5px;border-radius:4px;content:"";background-color:var(--cl-button-hoverBackground);}\n}.interval.svelte-17lzdls {position:relative;padding-left:12px;}.interval.svelte-17lzdls::before {color:var(--cl-foreground);content:"·";font-size:16px;height:100%;left:0;line-height:inherit;position:absolute;text-align:center;width:12px;}.buttons.svelte-17lzdls {display:none;position:absolute;top:-1px;bottom:-1px;right:0;transform:translateX(100%);flex-direction:row;align-items:center;justify-content:flex-start;padding:1px 6px 1px 6px;border:1px solid transparent;border-left-width:0;border-radius:0 4px 4px 0;box-sizing:border-box;background-color:var(--cl-background);}.buttons.buttons--hover.svelte-17lzdls {display:flex;border-color:var(--cl-legend-hoverBorder);}.buttons.buttons--active.svelte-17lzdls {display:flex;border-color:var(--cl-selectedForeground);}.more.svelte-17lzdls {outline:none;border:none;background:none;padding-block:initial;padding-inline:initial;font-family:inherit;color:inherit;display:flex;align-items:center;justify-content:center;font:inherit;position:relative;height:100%;flex:0;}.more.svelte-17lzdls > :where(.svelte-17lzdls) {isolation:isolate;}\n@media (hover: hover) and (pointer: fine) {.more.svelte-17lzdls:hover:before {position:absolute;top:0;right:-6px;bottom:0;left:-6px;border-radius:4px;content:"";background-color:var(--cl-button-hoverBackground);}\n}.more.svelte-17lzdls > span:where(.svelte-17lzdls) {display:block;width:18px;height:18px;}.valueWrapper.svelte-17lzdls {align-self:stretch;display:flex;align-items:center;flex-wrap:nowrap;cursor:default;overflow:hidden;border-top:1px solid transparent;border-bottom:1px solid transparent;}'
};
function MainSeriesLegend($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$r);
  const [$$stores, $$cleanup] = setup_stores();
  const $legendProps = () => store_get(legendProps, "$legendProps", $$stores);
  const $selected = () => store_get(selected, "$selected", $$stores);
  const $isWaitingData = () => store_get(isWaitingData, "$isWaitingData", $$stores);
  const $symbolInfo = () => store_get(symbolInfo, "$symbolInfo", $$stores);
  const $resolution = () => store_get(resolution, "$resolution", $$stores);
  const $isError = () => store_get(isError, "$isError", $$stores);
  const { t: t2 } = useTranslation();
  const configurationService = useService(IConfigurationService);
  const chartManagementService = useService(IChartManagementService);
  const chartIndex = $$props.chartIndex;
  const legendProps = derivedWithCache(configurationService.store, (store) => {
    return store.chartProperties.legend;
  });
  const symbolInfo = derivedWithCache(chartManagementService.store, (store) => {
    var _a3;
    return (_a3 = store.instances[chartIndex]) == null ? void 0 : _a3.symbolInfo;
  });
  const isWaitingData = derivedWithCache(chartManagementService.store, (store) => {
    var _a3;
    const status = (_a3 = store.instances[chartIndex]) == null ? void 0 : _a3.dataStatus;
    return status !== ChartDataStatus.dataLoaded && status !== ChartDataStatus.error;
  });
  const isError = derivedWithCache(chartManagementService.store, (store) => {
    var _a3;
    const status = (_a3 = store.instances[chartIndex]) == null ? void 0 : _a3.dataStatus;
    return status === ChartDataStatus.error;
  });
  const resolution = derivedWithCache(chartManagementService.store, (store) => {
    var _a3;
    return (_a3 = store.instances[chartIndex]) == null ? void 0 : _a3.resolution;
  });
  const selected = derivedWithCache(chartManagementService.store, (store) => {
    var _a3, _b3;
    return (_b3 = (_a3 = store.instances[chartIndex]) == null ? void 0 : _a3.mainLegend) == null ? void 0 : _b3.selected;
  });
  let isHover = /* @__PURE__ */ state(false);
  let unhoverTimer = 0;
  var div = root$n();
  var div_1 = child(div);
  var node = child(div_1);
  {
    var consequent = ($$anchor2) => {
      var div_2 = root_1$m();
      var div_3 = child(div_2);
      var div_4 = child(div_3);
      var node_1 = child(div_4);
      Wrapper(node_1, {
        children: ($$anchor3, $$slotProps) => {
          var fragment = root_2$b();
          var button = first_child(fragment);
          var span = child(button);
          var text$1 = child(span);
          var node_2 = sibling(button, 2);
          Tooltip(node_2, {
            children: ($$anchor4, $$slotProps2) => {
              var text_1 = text();
              template_effect(($0) => set_text(text_1, $0), [() => t2("legend.changeSymbol")]);
              append($$anchor4, text_1);
            },
            $$slots: { default: true }
          });
          template_effect(() => {
            var _a3;
            return set_text(text$1, (_a3 = $symbolInfo()) == null ? void 0 : _a3.description);
          });
          append($$anchor3, fragment);
        },
        $$slots: { default: true }
      });
      var div_5 = sibling(div_4, 2);
      var node_3 = child(div_5);
      Wrapper(node_3, {
        children: ($$anchor3, $$slotProps) => {
          var fragment_2 = root_4$9();
          var button_1 = first_child(fragment_2);
          var span_1 = child(button_1);
          var text_2 = child(span_1);
          var node_4 = sibling(button_1, 2);
          Tooltip(node_4, {
            children: ($$anchor4, $$slotProps2) => {
              var text_3 = text();
              template_effect(($0) => set_text(text_3, $0), [() => t2("legend.changeInterval")]);
              append($$anchor4, text_3);
            },
            $$slots: { default: true }
          });
          template_effect(() => set_text(text_2, $resolution()));
          append($$anchor3, fragment_2);
        },
        $$slots: { default: true }
      });
      var div_6 = sibling(div_3, 2);
      var node_5 = child(div_6);
      Wrapper(node_5, {
        children: ($$anchor3, $$slotProps) => {
          var fragment_4 = root_6$5();
          var node_6 = sibling(first_child(fragment_4), 2);
          Tooltip(node_6, {
            children: ($$anchor4, $$slotProps2) => {
              var text_4 = text();
              template_effect(($0) => set_text(text_4, $0), [() => t2("legend.more")]);
              append($$anchor4, text_4);
            },
            $$slots: { default: true }
          });
          append($$anchor3, fragment_4);
        },
        $$slots: { default: true }
      });
      template_effect(
        ($0, $1) => {
          set_class(div_2, 1, $0, "svelte-17lzdls");
          set_class(div_6, 1, $1, "svelte-17lzdls");
        },
        [
          () => clsx(clsx$1("display", get$1(isHover) && "display--hover", $selected() && "display--active")),
          () => clsx(clsx$1("buttons", get$1(isHover) && "buttons--hover", $selected() && "buttons--active"))
        ]
      );
      event("mouseenter", div_2, () => {
        if ($isWaitingData()) return;
        set(isHover, true);
        if (unhoverTimer) {
          clearTimeout(unhoverTimer);
          unhoverTimer = 0;
        }
      });
      event("mouseleave", div_2, () => {
        unhoverTimer = setTimeout(
          () => {
            set(isHover, false);
            unhoverTimer = 0;
          },
          200
        );
      });
      append($$anchor2, div_2);
    };
    if_block(node, ($$render) => {
      if ($legendProps().showSeriesTitle) $$render(consequent);
    });
  }
  var div_7 = sibling(node, 2);
  var node_7 = child(div_7);
  {
    var consequent_1 = ($$anchor2) => {
      Loader($$anchor2);
    };
    var alternate_1 = ($$anchor2) => {
      var fragment_7 = comment();
      var node_8 = first_child(fragment_7);
      {
        var consequent_2 = ($$anchor3) => {
          Status($$anchor3, {});
        };
        var alternate = ($$anchor3) => {
          MainSeriesValues($$anchor3, {
            get chartIndex() {
              return chartIndex;
            }
          });
        };
        if_block(
          node_8,
          ($$render) => {
            if ($isError()) $$render(consequent_2);
            else $$render(alternate, false);
          },
          true
        );
      }
      append($$anchor2, fragment_7);
    };
    if_block(node_7, ($$render) => {
      if ($isWaitingData()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, div);
  pop();
  $$cleanup();
}
var root_8 = /* @__PURE__ */ from_html(`<span class="studyCount svelte-iowc5s"> </span>`);
var root_7$5 = /* @__PURE__ */ from_html(`<button class="toggleLegend svelte-iowc5s"><span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15 15" width="15" height="15"><path fill="currentColor" d="M3.5 5.58c.24-.28.65-.3.92-.07L7.5 8.14l3.08-2.63a.65.65 0 1 1 .84.98L7.5 9.86 3.58 6.49a.65.65 0 0 1-.07-.91z"></path></svg></span> <!></button> <!>`, 1);
var root_1$l = /* @__PURE__ */ from_html(`<div class="mainPanePortal svelte-iowc5s"><!> <!> <!></div>`);
const $$css$q = {
  hash: "svelte-iowc5s",
  code: '.mainPanePortal.svelte-iowc5s {position:absolute;top:4px;left:4px;right:4px;padding-top:4px;z-index:3;pointer-events:none;user-select:none;overflow:hidden;}.toggleLegend.svelte-iowc5s {outline:none;border:none;background:none;padding-block:initial;padding-inline:initial;font-family:inherit;color:inherit;display:flex;align-items:center;justify-content:center;font:inherit;position:relative;display:flex;flex-direction:row;margin:2px 0 0 5px;border:1px solid var(--cl-legend-hoverBorder);background-color:var(--cl-legend-hoverBackground);border-radius:3px;cursor:default;pointer-events:all;}.toggleLegend.svelte-iowc5s > :where(.svelte-iowc5s) {isolation:isolate;}\n@media (hover: hover) and (pointer: fine) {.toggleLegend.svelte-iowc5s:hover:before {position:absolute;top:0;right:-0px;bottom:0;left:-0px;border-radius:4px;content:"";background-color:var(--cl-button-hoverBackground);}\n}.iconWrap.svelte-iowc5s {width:27px;height:19px;display:flex;align-items:center;justify-content:center;transition:transform 0.1s cubic-bezier(0.06, 0.52, 1, 0.54);transform:rotate(-180deg);color:var(--cl-foreground);}.iconWrap.collapsed.multi.svelte-iowc5s {width:19px;}.iconWrap.collapsed.svelte-iowc5s {transform:rotate(0);}.studyCount.svelte-iowc5s {font-size:13px;padding-right:4px;color:var(--cl-foreground);}'
};
function MainPanePortal($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$q);
  const [$$stores, $$cleanup] = setup_stores();
  const $overlapStudyIdList = () => store_get(overlapStudyIdList, "$overlapStudyIdList", $$stores);
  const { t: t2 } = useTranslation();
  const chartManagementService = useService(IChartManagementService);
  const overlapStudyIdList = derivedWithCache(chartManagementService.store, (store) => {
    var _a3;
    return (((_a3 = store.instances[$$props.chartIndex]) == null ? void 0 : _a3.studyList) ?? []).filter((s2) => !!s2.overlap).map((s2) => s2.id);
  });
  let target;
  const chartWidget = chartManagementService.chart($$props.chartIndex);
  const container = ensure(chartWidget.mainSeriesApi.getSeries().getPane().getHTMLElement());
  const div = document.createElement("div");
  container.appendChild(div);
  target = div;
  onMount(() => {
    PartFingerprints.write(target, PartFingerprint.Legend);
  });
  onDestroy(() => {
    target.remove();
  });
  let collapsed = /* @__PURE__ */ state(false);
  const toggleIndicatorLegend = () => {
    set(collapsed, !get$1(collapsed));
  };
  Portal($$anchor, {
    get target() {
      return target;
    },
    children: ($$anchor2, $$slotProps) => {
      var div_1 = root_1$l();
      var node = child(div_1);
      MainSeriesLegend(node, {
        get chartIndex() {
          return $$props.chartIndex;
        }
      });
      var node_1 = sibling(node, 2);
      Scheduler(node_1, {
        idle: true,
        children: ($$anchor3, $$slotProps2) => {
          var fragment_1 = comment();
          var node_2 = first_child(fragment_1);
          {
            var consequent = ($$anchor4) => {
              var fragment_2 = comment();
              var node_3 = first_child(fragment_2);
              each(node_3, 1, $overlapStudyIdList, (studyId) => studyId, ($$anchor5, studyId) => {
                StudySeriesLegend($$anchor5, {
                  get chartIndex() {
                    return $$props.chartIndex;
                  },
                  get studyId() {
                    return get$1(studyId);
                  }
                });
              });
              append($$anchor4, fragment_2);
            };
            if_block(node_2, ($$render) => {
              if (!get$1(collapsed)) $$render(consequent);
            });
          }
          append($$anchor3, fragment_1);
        },
        $$slots: { default: true }
      });
      var node_4 = sibling(node_1, 2);
      Scheduler(node_4, {
        idle: true,
        children: ($$anchor3, $$slotProps2) => {
          var fragment_4 = comment();
          var node_5 = first_child(fragment_4);
          {
            var consequent_2 = ($$anchor4) => {
              Wrapper($$anchor4, {
                children: ($$anchor5, $$slotProps3) => {
                  var fragment_6 = root_7$5();
                  var button = first_child(fragment_6);
                  var event_handler = /* @__PURE__ */ user_derived(() => ifLeftClick(toggleIndicatorLegend));
                  button.__pointerup = function(...$$args) {
                    var _a3;
                    (_a3 = get$1(event_handler)) == null ? void 0 : _a3.apply(this, $$args);
                  };
                  var span = child(button);
                  var node_6 = sibling(span, 2);
                  {
                    var consequent_1 = ($$anchor6) => {
                      var span_1 = root_8();
                      var text2 = child(span_1);
                      template_effect(() => set_text(text2, $overlapStudyIdList().length));
                      append($$anchor6, span_1);
                    };
                    if_block(node_6, ($$render) => {
                      if (get$1(collapsed) && $overlapStudyIdList().length) $$render(consequent_1);
                    });
                  }
                  var node_7 = sibling(button, 2);
                  Tooltip(node_7, {
                    children: ($$anchor6, $$slotProps4) => {
                      var text_1 = text();
                      template_effect(($0) => set_text(text_1, $0), [
                        () => t2(get$1(collapsed) ? "legend.main.showMore" : "legend.main.showLess")
                      ]);
                      append($$anchor6, text_1);
                    },
                    $$slots: { default: true }
                  });
                  template_effect(() => set_class(
                    span,
                    1,
                    clsx([
                      "iconWrap",
                      get$1(collapsed) && "collapsed",
                      $overlapStudyIdList().length && "multi"
                    ]),
                    "svelte-iowc5s"
                  ));
                  append($$anchor5, fragment_6);
                },
                $$slots: { default: true }
              });
            };
            if_block(node_5, ($$render) => {
              if ($overlapStudyIdList().length) $$render(consequent_2);
            });
          }
          append($$anchor3, fragment_4);
        },
        $$slots: { default: true }
      });
      append($$anchor2, div_1);
    },
    $$slots: { default: true }
  });
  pop();
  $$cleanup();
}
delegate(["pointerup"]);
function useDisposable(d3) {
  onDestroy(() => d3.dispose());
}
var root_2$a = /* @__PURE__ */ from_html(`<div class="tipContent svelte-f2r7jm"> </div>`);
var root_1$k = /* @__PURE__ */ from_html(`<div class="anchor svelte-f2r7jm"></div> <!>`, 1);
var root_4$8 = /* @__PURE__ */ from_html(`<div class="tipContent svelte-f2r7jm"> </div>`);
var root_3$3 = /* @__PURE__ */ from_html(`<div class="anchor svelte-f2r7jm"></div> <!>`, 1);
var root$m = /* @__PURE__ */ from_html(`<!> <!>`, 1);
const $$css$p = {
  hash: "svelte-f2r7jm",
  code: ".anchor.svelte-f2r7jm {position:absolute;pointer-events:none;}.tipContent.svelte-f2r7jm {user-select:none;pointer-events:none;}"
};
function PaneTooltip($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$p);
  const chartGuiService = useService(IChartGuiService);
  let div1;
  let div2;
  let tooltip1;
  let tooltip2;
  let tooltips = proxy$1({
    1: {
      content: "",
      yPos: void 0,
      showDelay: 100,
      hideDelay: 100,
      show: false
    },
    2: {
      content: "",
      yPos: void 0,
      showDelay: 100,
      hideDelay: 100,
      show: false
    }
  });
  let counter2 = 0;
  let using = { value: 2, id: -1 };
  function getDiv() {
    return using.value === 2 ? div2 : div1;
  }
  function hideCurrent(now2 = false) {
    var _a3;
    if (now2) (_a3 = getTooltip().getInstance()) == null ? void 0 : _a3.setHideDelay(0);
    getDiv().dispatchEvent(new MouseEvent("mouseleave"));
    getState().show = false;
  }
  function getTooltip() {
    return using.value === 2 ? tooltip2 : tooltip1;
  }
  function getState() {
    return using.value === 2 ? tooltips["2"] : tooltips["1"];
  }
  function changeCurrent() {
    using.value = using.value === 2 ? 1 : 2;
    return using.id = counter2++;
  }
  useDisposable(chartGuiService.onPaneTooltipRequested(async (e2) => {
    const immediate = !!getState().show;
    hideCurrent(true);
    const current = changeCurrent();
    const { anchor, content } = e2;
    Object.assign(getDiv().style, {
      left: toPX(anchor.x),
      top: toPX(anchor.y),
      width: toPX(anchor.width),
      height: toPX(anchor.height)
    });
    Object.assign(getState(), {
      content,
      showDelay: immediate ? 0 : 100,
      hideDelay: 100,
      yPos: e2.yPos
    });
    getState().content = content;
    await tick();
    if (using.id !== current) return;
    getDiv().dispatchEvent(new MouseEvent("mouseenter"));
    getState().show = true;
  }));
  useDisposable(chartGuiService.onPaneTooltipCancelled(async () => {
    hideCurrent();
    changeCurrent();
  }));
  onDestroy(() => {
    div1 = null;
    tooltip1 = null;
    div2 = null;
    tooltip2 = null;
  });
  var fragment = root$m();
  var node = first_child(fragment);
  Wrapper(node, {
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = root_1$k();
      var div = first_child(fragment_1);
      bind_this(div, ($$value) => div1 = $$value, () => div1);
      var node_1 = sibling(div, 2);
      bind_this(
        Tooltip(node_1, {
          persistent: true,
          get showDelay() {
            return tooltips["1"].showDelay;
          },
          get hideDelay() {
            return tooltips["1"].hideDelay;
          },
          get yPos() {
            return tooltips["1"].yPos;
          },
          children: ($$anchor3, $$slotProps2) => {
            var div_1 = root_2$a();
            var text2 = child(div_1);
            template_effect(() => set_text(text2, tooltips["1"].content));
            append($$anchor3, div_1);
          },
          $$slots: { default: true }
        }),
        ($$value) => tooltip1 = $$value,
        () => tooltip1
      );
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  });
  var node_2 = sibling(node, 2);
  Wrapper(node_2, {
    children: ($$anchor2, $$slotProps) => {
      var fragment_2 = root_3$3();
      var div_2 = first_child(fragment_2);
      bind_this(div_2, ($$value) => div2 = $$value, () => div2);
      var node_3 = sibling(div_2, 2);
      bind_this(
        Tooltip(node_3, {
          persistent: true,
          get showDelay() {
            return tooltips["2"].showDelay;
          },
          get hideDelay() {
            return tooltips["2"].hideDelay;
          },
          get yPos() {
            return tooltips["2"].yPos;
          },
          children: ($$anchor3, $$slotProps2) => {
            var div_3 = root_4$8();
            var text_1 = child(div_3);
            template_effect(() => set_text(text_1, tooltips["2"].content));
            append($$anchor3, div_3);
          },
          $$slots: { default: true }
        }),
        ($$value) => tooltip2 = $$value,
        () => tooltip2
      );
      append($$anchor2, fragment_2);
    },
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  pop();
}
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
const FOCUS_SENTINEL_CLASS = "mdc-dom-focus-sentinel";
class FocusTrap {
  constructor(root2, options = {}) {
    // Previously focused element before trapping focus.
    __publicField(this, "elFocusedBeforeTrapFocus", null);
    this.root = root2;
    this.options = options;
  }
  /**
   * Traps focus in `root`. Also focuses on either `initialFocusEl` if set;
   * otherwises sets initial focus to the first focusable child element.
   */
  trapFocus() {
    const focusableEls = this.getFocusableElements(this.root);
    if (focusableEls.length === 0) {
      throw new Error("FocusTrap: Element must have at least one focusable child.");
    }
    const host = findDocumentOrShadowRoot(this.root);
    this.elFocusedBeforeTrapFocus = host.activeElement instanceof HTMLElement ? host.activeElement : null;
    this.wrapTabFocus(this.root);
    if (!this.options.skipInitialFocus) {
      this.focusInitialElement(focusableEls, this.options.initialFocusEl);
    }
  }
  /**
   * Releases focus from `root`. Also restores focus to the previously focused
   * element.
   */
  releaseFocus() {
    [].slice.call(this.root.querySelectorAll(`.${FOCUS_SENTINEL_CLASS}`)).forEach((sentinelEl) => {
      sentinelEl.parentElement.removeChild(sentinelEl);
    });
    if (!this.options.skipRestoreFocus && this.elFocusedBeforeTrapFocus) {
      this.elFocusedBeforeTrapFocus.focus();
    }
  }
  /**
   * Wraps tab focus within `el` by adding two hidden sentinel divs which are
   * used to mark the beginning and the end of the tabbable region. When
   * focused, these sentinel elements redirect focus to the first/last
   * children elements of the tabbable region, ensuring that focus is trapped
   * within that region.
   */
  wrapTabFocus(el) {
    const sentinelStart = this.createSentinel();
    const sentinelEnd = this.createSentinel();
    sentinelStart.addEventListener("focus", () => {
      const focusableEls = this.getFocusableElements(el);
      if (focusableEls.length > 0) {
        focusableEls[focusableEls.length - 1].focus();
      }
    });
    sentinelEnd.addEventListener("focus", () => {
      const focusableEls = this.getFocusableElements(el);
      if (focusableEls.length > 0) {
        focusableEls[0].focus();
      }
    });
    el.insertBefore(sentinelStart, el.children[0]);
    el.appendChild(sentinelEnd);
  }
  /**
   * Focuses on `initialFocusEl` if defined and a child of the root element.
   * Otherwise, focuses on the first focusable child element of the root.
   */
  focusInitialElement(focusableEls, initialFocusEl) {
    let focusIndex = 0;
    if (initialFocusEl) {
      focusIndex = Math.max(focusableEls.indexOf(initialFocusEl), 0);
    }
    focusableEls[focusIndex].focus();
  }
  getFocusableElements(root2) {
    const focusableEls = [].slice.call(
      root2.querySelectorAll("[autofocus], [tabindex], a, input, textarea, select, button")
    );
    return focusableEls.filter((el) => {
      const isDisabledOrHidden = el.getAttribute("aria-disabled") === "true" || el.getAttribute("disabled") != null || el.getAttribute("hidden") != null || el.getAttribute("aria-hidden") === "true";
      const isTabbableAndVisible = el.tabIndex >= 0 && el.getBoundingClientRect().width > 0 && !el.classList.contains(FOCUS_SENTINEL_CLASS) && !isDisabledOrHidden;
      let isProgrammaticallyHidden = false;
      if (isTabbableAndVisible) {
        const style = getComputedStyle(el);
        isProgrammaticallyHidden = style.display === "none" || style.visibility === "hidden";
      }
      return isTabbableAndVisible && !isProgrammaticallyHidden;
    });
  }
  createSentinel() {
    const sentinel = document.createElement("div");
    sentinel.setAttribute("tabindex", "0");
    sentinel.setAttribute("aria-hidden", "true");
    sentinel.classList.add(FOCUS_SENTINEL_CLASS);
    return sentinel;
  }
}
const domFocusTrap = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  FocusTrap
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
function closest(element2, selector) {
  if (element2.closest) {
    return element2.closest(selector);
  }
  let el = element2;
  while (el) {
    if (matches(el, selector)) {
      return el;
    }
    el = el.parentElement;
  }
  return null;
}
function matches(element2, selector) {
  const nativeMatches = element2.matches || element2.webkitMatchesSelector || element2.msMatchesSelector;
  return nativeMatches.call(element2, selector);
}
function estimateScrollWidth(element2) {
  const htmlEl = element2;
  if (htmlEl.offsetParent !== null) {
    return htmlEl.scrollWidth;
  }
  const clone = htmlEl.cloneNode(true);
  clone.style.setProperty("position", "absolute");
  clone.style.setProperty("transform", "translate(-9999px, -9999px)");
  document.documentElement.appendChild(clone);
  const scrollWidth = clone.scrollWidth;
  document.documentElement.removeChild(clone);
  return scrollWidth;
}
const ponyfill = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  closest,
  estimateScrollWidth,
  matches
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var _a, _b2;
var cssClasses$4 = {
  LIST_ITEM_ACTIVATED_CLASS: "mdc-list-item--activated",
  LIST_ITEM_CLASS: "mdc-list-item",
  LIST_ITEM_DISABLED_CLASS: "mdc-list-item--disabled",
  LIST_ITEM_SELECTED_CLASS: "mdc-list-item--selected",
  LIST_ITEM_TEXT_CLASS: "mdc-list-item__text",
  LIST_ITEM_PRIMARY_TEXT_CLASS: "mdc-list-item__primary-text",
  ROOT: "mdc-list"
};
_a = {}, _a["" + cssClasses$4.LIST_ITEM_ACTIVATED_CLASS] = "mdc-list-item--activated", _a["" + cssClasses$4.LIST_ITEM_CLASS] = "mdc-list-item", _a["" + cssClasses$4.LIST_ITEM_DISABLED_CLASS] = "mdc-list-item--disabled", _a["" + cssClasses$4.LIST_ITEM_SELECTED_CLASS] = "mdc-list-item--selected", _a["" + cssClasses$4.LIST_ITEM_PRIMARY_TEXT_CLASS] = "mdc-list-item__primary-text", _a["" + cssClasses$4.ROOT] = "mdc-list", _a;
var deprecatedClassNameMap = (_b2 = {}, _b2["" + cssClasses$4.LIST_ITEM_ACTIVATED_CLASS] = "mdc-deprecated-list-item--activated", _b2["" + cssClasses$4.LIST_ITEM_CLASS] = "mdc-deprecated-list-item", _b2["" + cssClasses$4.LIST_ITEM_DISABLED_CLASS] = "mdc-deprecated-list-item--disabled", _b2["" + cssClasses$4.LIST_ITEM_SELECTED_CLASS] = "mdc-deprecated-list-item--selected", _b2["" + cssClasses$4.LIST_ITEM_TEXT_CLASS] = "mdc-deprecated-list-item__text", _b2["" + cssClasses$4.LIST_ITEM_PRIMARY_TEXT_CLASS] = "mdc-deprecated-list-item__primary-text", _b2["" + cssClasses$4.ROOT] = "mdc-deprecated-list", _b2);
var strings$4 = {
  ACTION_EVENT: "MDCList:action",
  SELECTION_CHANGE_EVENT: "MDCList:selectionChange",
  ARIA_CHECKED: "aria-checked",
  ARIA_CHECKED_CHECKBOX_SELECTOR: '[role="checkbox"][aria-checked="true"]',
  ARIA_CHECKED_RADIO_SELECTOR: '[role="radio"][aria-checked="true"]',
  ARIA_CURRENT: "aria-current",
  ARIA_DISABLED: "aria-disabled",
  ARIA_ORIENTATION: "aria-orientation",
  ARIA_ORIENTATION_HORIZONTAL: "horizontal",
  ARIA_ROLE_CHECKBOX_SELECTOR: '[role="checkbox"]',
  ARIA_SELECTED: "aria-selected",
  ARIA_INTERACTIVE_ROLES_SELECTOR: '[role="listbox"], [role="menu"]',
  ARIA_MULTI_SELECTABLE_SELECTOR: '[aria-multiselectable="true"]',
  CHECKBOX_RADIO_SELECTOR: 'input[type="checkbox"], input[type="radio"]',
  CHECKBOX_SELECTOR: 'input[type="checkbox"]',
  CHILD_ELEMENTS_TO_TOGGLE_TABINDEX: "\n    ." + cssClasses$4.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + cssClasses$4.LIST_ITEM_CLASS + " a,\n    ." + deprecatedClassNameMap[cssClasses$4.LIST_ITEM_CLASS] + " button:not(:disabled),\n    ." + deprecatedClassNameMap[cssClasses$4.LIST_ITEM_CLASS] + " a\n  ",
  DEPRECATED_SELECTOR: ".mdc-deprecated-list",
  FOCUSABLE_CHILD_ELEMENTS: "\n    ." + cssClasses$4.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + cssClasses$4.LIST_ITEM_CLASS + " a,\n    ." + cssClasses$4.LIST_ITEM_CLASS + ' input[type="radio"]:not(:disabled),\n    .' + cssClasses$4.LIST_ITEM_CLASS + ' input[type="checkbox"]:not(:disabled),\n    .' + deprecatedClassNameMap[cssClasses$4.LIST_ITEM_CLASS] + " button:not(:disabled),\n    ." + deprecatedClassNameMap[cssClasses$4.LIST_ITEM_CLASS] + " a,\n    ." + deprecatedClassNameMap[cssClasses$4.LIST_ITEM_CLASS] + ' input[type="radio"]:not(:disabled),\n    .' + deprecatedClassNameMap[cssClasses$4.LIST_ITEM_CLASS] + ' input[type="checkbox"]:not(:disabled)\n  ',
  RADIO_SELECTOR: 'input[type="radio"]',
  SELECTED_ITEM_SELECTOR: '[aria-selected="true"], [aria-current="true"]'
};
var numbers$4 = {
  UNSET_INDEX: -1,
  TYPEAHEAD_BUFFER_CLEAR_TIMEOUT_MS: 300
};
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var KEY = {
  UNKNOWN: "Unknown",
  BACKSPACE: "Backspace",
  ENTER: "Enter",
  SPACEBAR: "Spacebar",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown",
  END: "End",
  HOME: "Home",
  ARROW_LEFT: "ArrowLeft",
  ARROW_UP: "ArrowUp",
  ARROW_RIGHT: "ArrowRight",
  ARROW_DOWN: "ArrowDown",
  DELETE: "Delete",
  ESCAPE: "Escape",
  TAB: "Tab"
};
var normalizedKeys = /* @__PURE__ */ new Set();
normalizedKeys.add(KEY.BACKSPACE);
normalizedKeys.add(KEY.ENTER);
normalizedKeys.add(KEY.SPACEBAR);
normalizedKeys.add(KEY.PAGE_UP);
normalizedKeys.add(KEY.PAGE_DOWN);
normalizedKeys.add(KEY.END);
normalizedKeys.add(KEY.HOME);
normalizedKeys.add(KEY.ARROW_LEFT);
normalizedKeys.add(KEY.ARROW_UP);
normalizedKeys.add(KEY.ARROW_RIGHT);
normalizedKeys.add(KEY.ARROW_DOWN);
normalizedKeys.add(KEY.DELETE);
normalizedKeys.add(KEY.ESCAPE);
normalizedKeys.add(KEY.TAB);
var KEY_CODE = {
  BACKSPACE: 8,
  ENTER: 13,
  SPACEBAR: 32,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  END: 35,
  HOME: 36,
  ARROW_LEFT: 37,
  ARROW_UP: 38,
  ARROW_RIGHT: 39,
  ARROW_DOWN: 40,
  DELETE: 46,
  ESCAPE: 27,
  TAB: 9
};
var mappedKeyCodes = /* @__PURE__ */ new Map();
mappedKeyCodes.set(KEY_CODE.BACKSPACE, KEY.BACKSPACE);
mappedKeyCodes.set(KEY_CODE.ENTER, KEY.ENTER);
mappedKeyCodes.set(KEY_CODE.SPACEBAR, KEY.SPACEBAR);
mappedKeyCodes.set(KEY_CODE.PAGE_UP, KEY.PAGE_UP);
mappedKeyCodes.set(KEY_CODE.PAGE_DOWN, KEY.PAGE_DOWN);
mappedKeyCodes.set(KEY_CODE.END, KEY.END);
mappedKeyCodes.set(KEY_CODE.HOME, KEY.HOME);
mappedKeyCodes.set(KEY_CODE.ARROW_LEFT, KEY.ARROW_LEFT);
mappedKeyCodes.set(KEY_CODE.ARROW_UP, KEY.ARROW_UP);
mappedKeyCodes.set(KEY_CODE.ARROW_RIGHT, KEY.ARROW_RIGHT);
mappedKeyCodes.set(KEY_CODE.ARROW_DOWN, KEY.ARROW_DOWN);
mappedKeyCodes.set(KEY_CODE.DELETE, KEY.DELETE);
mappedKeyCodes.set(KEY_CODE.ESCAPE, KEY.ESCAPE);
mappedKeyCodes.set(KEY_CODE.TAB, KEY.TAB);
var navigationKeys = /* @__PURE__ */ new Set();
navigationKeys.add(KEY.PAGE_UP);
navigationKeys.add(KEY.PAGE_DOWN);
navigationKeys.add(KEY.END);
navigationKeys.add(KEY.HOME);
navigationKeys.add(KEY.ARROW_LEFT);
navigationKeys.add(KEY.ARROW_UP);
navigationKeys.add(KEY.ARROW_RIGHT);
navigationKeys.add(KEY.ARROW_DOWN);
function normalizeKey(evt) {
  var key2 = evt.key;
  if (normalizedKeys.has(key2)) {
    return key2;
  }
  var mappedKey = mappedKeyCodes.get(evt.keyCode);
  if (mappedKey) {
    return mappedKey;
  }
  return KEY.UNKNOWN;
}
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var ELEMENTS_KEY_ALLOWED_IN = ["input", "button", "textarea", "select"];
var preventDefaultEvent = function(evt) {
  var target = evt.target;
  if (!target) {
    return;
  }
  var tagName = ("" + target.tagName).toLowerCase();
  if (ELEMENTS_KEY_ALLOWED_IN.indexOf(tagName) === -1) {
    evt.preventDefault();
  }
};
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
function initState() {
  var state2 = {
    bufferClearTimeout: 0,
    currentFirstChar: "",
    sortedIndexCursor: 0,
    typeaheadBuffer: ""
  };
  return state2;
}
function initSortedIndex(listItemCount, getPrimaryTextByItemIndex) {
  var sortedIndexByFirstChar = /* @__PURE__ */ new Map();
  for (var i2 = 0; i2 < listItemCount; i2++) {
    var primaryText = getPrimaryTextByItemIndex(i2).trim();
    if (!primaryText) {
      continue;
    }
    var firstChar = primaryText[0].toLowerCase();
    if (!sortedIndexByFirstChar.has(firstChar)) {
      sortedIndexByFirstChar.set(firstChar, []);
    }
    sortedIndexByFirstChar.get(firstChar).push({ text: primaryText.toLowerCase(), index: i2 });
  }
  sortedIndexByFirstChar.forEach(function(values2) {
    values2.sort(function(first, second) {
      return first.index - second.index;
    });
  });
  return sortedIndexByFirstChar;
}
function matchItem(opts, state2) {
  var nextChar = opts.nextChar, focusItemAtIndex = opts.focusItemAtIndex, sortedIndexByFirstChar = opts.sortedIndexByFirstChar, focusedItemIndex = opts.focusedItemIndex, skipFocus = opts.skipFocus, isItemAtIndexDisabled = opts.isItemAtIndexDisabled;
  clearTimeout(state2.bufferClearTimeout);
  state2.bufferClearTimeout = setTimeout(function() {
    clearBuffer(state2);
  }, numbers$4.TYPEAHEAD_BUFFER_CLEAR_TIMEOUT_MS);
  state2.typeaheadBuffer = state2.typeaheadBuffer + nextChar;
  var index2;
  if (state2.typeaheadBuffer.length === 1) {
    index2 = matchFirstChar(sortedIndexByFirstChar, focusedItemIndex, isItemAtIndexDisabled, state2);
  } else {
    index2 = matchAllChars(sortedIndexByFirstChar, isItemAtIndexDisabled, state2);
  }
  if (index2 !== -1 && !skipFocus) {
    focusItemAtIndex(index2);
  }
  return index2;
}
function matchFirstChar(sortedIndexByFirstChar, focusedItemIndex, isItemAtIndexDisabled, state2) {
  var firstChar = state2.typeaheadBuffer[0];
  var itemsMatchingFirstChar = sortedIndexByFirstChar.get(firstChar);
  if (!itemsMatchingFirstChar) {
    return -1;
  }
  if (firstChar === state2.currentFirstChar && itemsMatchingFirstChar[state2.sortedIndexCursor].index === focusedItemIndex) {
    state2.sortedIndexCursor = (state2.sortedIndexCursor + 1) % itemsMatchingFirstChar.length;
    var newIndex = itemsMatchingFirstChar[state2.sortedIndexCursor].index;
    if (!isItemAtIndexDisabled(newIndex)) {
      return newIndex;
    }
  }
  state2.currentFirstChar = firstChar;
  var newCursorPosition = -1;
  var cursorPosition;
  for (cursorPosition = 0; cursorPosition < itemsMatchingFirstChar.length; cursorPosition++) {
    if (!isItemAtIndexDisabled(itemsMatchingFirstChar[cursorPosition].index)) {
      newCursorPosition = cursorPosition;
      break;
    }
  }
  for (; cursorPosition < itemsMatchingFirstChar.length; cursorPosition++) {
    if (itemsMatchingFirstChar[cursorPosition].index > focusedItemIndex && !isItemAtIndexDisabled(itemsMatchingFirstChar[cursorPosition].index)) {
      newCursorPosition = cursorPosition;
      break;
    }
  }
  if (newCursorPosition !== -1) {
    state2.sortedIndexCursor = newCursorPosition;
    return itemsMatchingFirstChar[state2.sortedIndexCursor].index;
  }
  return -1;
}
function matchAllChars(sortedIndexByFirstChar, isItemAtIndexDisabled, state2) {
  var firstChar = state2.typeaheadBuffer[0];
  var itemsMatchingFirstChar = sortedIndexByFirstChar.get(firstChar);
  if (!itemsMatchingFirstChar) {
    return -1;
  }
  var startingItem = itemsMatchingFirstChar[state2.sortedIndexCursor];
  if (startingItem.text.lastIndexOf(state2.typeaheadBuffer, 0) === 0 && !isItemAtIndexDisabled(startingItem.index)) {
    return startingItem.index;
  }
  var cursorPosition = (state2.sortedIndexCursor + 1) % itemsMatchingFirstChar.length;
  var nextCursorPosition = -1;
  while (cursorPosition !== state2.sortedIndexCursor) {
    var currentItem = itemsMatchingFirstChar[cursorPosition];
    var matches2 = currentItem.text.lastIndexOf(state2.typeaheadBuffer, 0) === 0;
    var isEnabled = !isItemAtIndexDisabled(currentItem.index);
    if (matches2 && isEnabled) {
      nextCursorPosition = cursorPosition;
      break;
    }
    cursorPosition = (cursorPosition + 1) % itemsMatchingFirstChar.length;
  }
  if (nextCursorPosition !== -1) {
    state2.sortedIndexCursor = nextCursorPosition;
    return itemsMatchingFirstChar[state2.sortedIndexCursor].index;
  }
  return -1;
}
function isTypingInProgress(state2) {
  return state2.typeaheadBuffer.length > 0;
}
function clearBuffer(state2) {
  state2.typeaheadBuffer = "";
}
function handleKeydown(opts, state2) {
  var event2 = opts.event, isTargetListItem = opts.isTargetListItem, focusedItemIndex = opts.focusedItemIndex, focusItemAtIndex = opts.focusItemAtIndex, sortedIndexByFirstChar = opts.sortedIndexByFirstChar, isItemAtIndexDisabled = opts.isItemAtIndexDisabled;
  var isArrowLeft = normalizeKey(event2) === "ArrowLeft";
  var isArrowUp = normalizeKey(event2) === "ArrowUp";
  var isArrowRight = normalizeKey(event2) === "ArrowRight";
  var isArrowDown = normalizeKey(event2) === "ArrowDown";
  var isHome = normalizeKey(event2) === "Home";
  var isEnd = normalizeKey(event2) === "End";
  var isEnter = normalizeKey(event2) === "Enter";
  var isSpace = normalizeKey(event2) === "Spacebar";
  if (event2.altKey || event2.ctrlKey || event2.metaKey || isArrowLeft || isArrowUp || isArrowRight || isArrowDown || isHome || isEnd || isEnter) {
    return -1;
  }
  var isCharacterKey = !isSpace && event2.key.length === 1;
  if (isCharacterKey) {
    preventDefaultEvent(event2);
    var matchItemOpts = {
      focusItemAtIndex,
      focusedItemIndex,
      nextChar: event2.key.toLowerCase(),
      sortedIndexByFirstChar,
      skipFocus: false,
      isItemAtIndexDisabled
    };
    return matchItem(matchItemOpts, state2);
  }
  if (!isSpace) {
    return -1;
  }
  if (isTargetListItem) {
    preventDefaultEvent(event2);
  }
  var typeaheadOnListItem = isTargetListItem && isTypingInProgress(state2);
  if (typeaheadOnListItem) {
    var matchItemOpts = {
      focusItemAtIndex,
      focusedItemIndex,
      nextChar: " ",
      sortedIndexByFirstChar,
      skipFocus: false,
      isItemAtIndexDisabled
    };
    return matchItem(matchItemOpts, state2);
  }
  return -1;
}
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
function isNumberArray(selectedIndex) {
  return selectedIndex instanceof Array;
}
var handledModifierKeys = ["Alt", "Control", "Meta", "Shift"];
function createModifierChecker(event2) {
  var eventModifiers = new Set(event2 ? handledModifierKeys.filter(function(m2) {
    return event2.getModifierState(m2);
  }) : []);
  return function(modifiers) {
    return modifiers.every(function(m2) {
      return eventModifiers.has(m2);
    }) && modifiers.length === eventModifiers.size;
  };
}
var MDCListFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCListFoundation2, _super);
    function MDCListFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCListFoundation2.defaultAdapter), adapter)) || this;
      _this.wrapFocus = false;
      _this.isVertical = true;
      _this.isSingleSelectionList = false;
      _this.areDisabledItemsFocusable = true;
      _this.selectedIndex = numbers$4.UNSET_INDEX;
      _this.focusedItemIndex = numbers$4.UNSET_INDEX;
      _this.useActivatedClass = false;
      _this.useSelectedAttr = false;
      _this.ariaCurrentAttrValue = null;
      _this.isCheckboxList = false;
      _this.isRadioList = false;
      _this.lastSelectedIndex = null;
      _this.hasTypeahead = false;
      _this.typeaheadState = initState();
      _this.sortedIndexByFirstChar = /* @__PURE__ */ new Map();
      return _this;
    }
    Object.defineProperty(MDCListFoundation2, "strings", {
      get: function() {
        return strings$4;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCListFoundation2, "cssClasses", {
      get: function() {
        return cssClasses$4;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCListFoundation2, "numbers", {
      get: function() {
        return numbers$4;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCListFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addClassForElementIndex: function() {
            return void 0;
          },
          focusItemAtIndex: function() {
            return void 0;
          },
          getAttributeForElementIndex: function() {
            return null;
          },
          getFocusedElementIndex: function() {
            return 0;
          },
          getListItemCount: function() {
            return 0;
          },
          hasCheckboxAtIndex: function() {
            return false;
          },
          hasRadioAtIndex: function() {
            return false;
          },
          isCheckboxCheckedAtIndex: function() {
            return false;
          },
          isFocusInsideList: function() {
            return false;
          },
          isRootFocused: function() {
            return false;
          },
          listItemAtIndexHasClass: function() {
            return false;
          },
          notifyAction: function() {
            return void 0;
          },
          notifySelectionChange: function() {
          },
          removeClassForElementIndex: function() {
            return void 0;
          },
          setAttributeForElementIndex: function() {
            return void 0;
          },
          setCheckedCheckboxOrRadioAtIndex: function() {
            return void 0;
          },
          setTabIndexForListItemChildren: function() {
            return void 0;
          },
          getPrimaryTextAtIndex: function() {
            return "";
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCListFoundation2.prototype.layout = function() {
      if (this.adapter.getListItemCount() === 0) {
        return;
      }
      if (this.adapter.hasCheckboxAtIndex(0)) {
        this.isCheckboxList = true;
      } else if (this.adapter.hasRadioAtIndex(0)) {
        this.isRadioList = true;
      } else {
        this.maybeInitializeSingleSelection();
      }
      if (this.hasTypeahead) {
        this.sortedIndexByFirstChar = this.typeaheadInitSortedIndex();
      }
    };
    MDCListFoundation2.prototype.getFocusedItemIndex = function() {
      return this.focusedItemIndex;
    };
    MDCListFoundation2.prototype.setWrapFocus = function(value) {
      this.wrapFocus = value;
    };
    MDCListFoundation2.prototype.setVerticalOrientation = function(value) {
      this.isVertical = value;
    };
    MDCListFoundation2.prototype.setSingleSelection = function(value) {
      this.isSingleSelectionList = value;
      if (value) {
        this.maybeInitializeSingleSelection();
        this.selectedIndex = this.getSelectedIndexFromDOM();
      }
    };
    MDCListFoundation2.prototype.setDisabledItemsFocusable = function(value) {
      this.areDisabledItemsFocusable = value;
    };
    MDCListFoundation2.prototype.maybeInitializeSingleSelection = function() {
      var selectedItemIndex = this.getSelectedIndexFromDOM();
      if (selectedItemIndex === numbers$4.UNSET_INDEX)
        return;
      var hasActivatedClass = this.adapter.listItemAtIndexHasClass(selectedItemIndex, cssClasses$4.LIST_ITEM_ACTIVATED_CLASS);
      if (hasActivatedClass) {
        this.setUseActivatedClass(true);
      }
      this.isSingleSelectionList = true;
      this.selectedIndex = selectedItemIndex;
    };
    MDCListFoundation2.prototype.getSelectedIndexFromDOM = function() {
      var selectedIndex = numbers$4.UNSET_INDEX;
      var listItemsCount = this.adapter.getListItemCount();
      for (var i2 = 0; i2 < listItemsCount; i2++) {
        var hasSelectedClass = this.adapter.listItemAtIndexHasClass(i2, cssClasses$4.LIST_ITEM_SELECTED_CLASS);
        var hasActivatedClass = this.adapter.listItemAtIndexHasClass(i2, cssClasses$4.LIST_ITEM_ACTIVATED_CLASS);
        if (!(hasSelectedClass || hasActivatedClass)) {
          continue;
        }
        selectedIndex = i2;
        break;
      }
      return selectedIndex;
    };
    MDCListFoundation2.prototype.setHasTypeahead = function(hasTypeahead) {
      this.hasTypeahead = hasTypeahead;
      if (hasTypeahead) {
        this.sortedIndexByFirstChar = this.typeaheadInitSortedIndex();
      }
    };
    MDCListFoundation2.prototype.isTypeaheadInProgress = function() {
      return this.hasTypeahead && isTypingInProgress(this.typeaheadState);
    };
    MDCListFoundation2.prototype.setUseActivatedClass = function(useActivated) {
      this.useActivatedClass = useActivated;
    };
    MDCListFoundation2.prototype.setUseSelectedAttribute = function(useSelected) {
      this.useSelectedAttr = useSelected;
    };
    MDCListFoundation2.prototype.getSelectedIndex = function() {
      return this.selectedIndex;
    };
    MDCListFoundation2.prototype.setSelectedIndex = function(index2, options) {
      if (options === void 0) {
        options = {};
      }
      if (!this.isIndexValid(index2)) {
        return;
      }
      if (this.isCheckboxList) {
        this.setCheckboxAtIndex(index2, options);
      } else if (this.isRadioList) {
        this.setRadioAtIndex(index2, options);
      } else {
        this.setSingleSelectionAtIndex(index2, options);
      }
    };
    MDCListFoundation2.prototype.handleFocusIn = function(listItemIndex) {
      if (listItemIndex >= 0) {
        this.focusedItemIndex = listItemIndex;
        this.adapter.setAttributeForElementIndex(listItemIndex, "tabindex", "0");
        this.adapter.setTabIndexForListItemChildren(listItemIndex, "0");
      }
    };
    MDCListFoundation2.prototype.handleFocusOut = function(listItemIndex) {
      var _this = this;
      if (listItemIndex >= 0) {
        this.adapter.setAttributeForElementIndex(listItemIndex, "tabindex", "-1");
        this.adapter.setTabIndexForListItemChildren(listItemIndex, "-1");
      }
      setTimeout(function() {
        if (!_this.adapter.isFocusInsideList()) {
          _this.setTabindexToFirstSelectedOrFocusedItem();
        }
      }, 0);
    };
    MDCListFoundation2.prototype.isIndexDisabled = function(index2) {
      return this.adapter.listItemAtIndexHasClass(index2, cssClasses$4.LIST_ITEM_DISABLED_CLASS);
    };
    MDCListFoundation2.prototype.handleKeydown = function(event2, isRootListItem, listItemIndex) {
      var _this = this;
      var _a3;
      var isArrowLeft = normalizeKey(event2) === "ArrowLeft";
      var isArrowUp = normalizeKey(event2) === "ArrowUp";
      var isArrowRight = normalizeKey(event2) === "ArrowRight";
      var isArrowDown = normalizeKey(event2) === "ArrowDown";
      var isHome = normalizeKey(event2) === "Home";
      var isEnd = normalizeKey(event2) === "End";
      var isEnter = normalizeKey(event2) === "Enter";
      var isSpace = normalizeKey(event2) === "Spacebar";
      var isForward = this.isVertical && isArrowDown || !this.isVertical && isArrowRight;
      var isBack = this.isVertical && isArrowUp || !this.isVertical && isArrowLeft;
      var isLetterA = event2.key === "A" || event2.key === "a";
      var eventHasModifiers = createModifierChecker(event2);
      if (this.adapter.isRootFocused()) {
        if ((isBack || isEnd) && eventHasModifiers([])) {
          event2.preventDefault();
          this.focusLastElement();
        } else if ((isForward || isHome) && eventHasModifiers([])) {
          event2.preventDefault();
          this.focusFirstElement();
        } else if (isBack && eventHasModifiers(["Shift"]) && this.isCheckboxList) {
          event2.preventDefault();
          var focusedIndex = this.focusLastElement();
          if (focusedIndex !== -1) {
            this.setSelectedIndexOnAction(focusedIndex, false);
          }
        } else if (isForward && eventHasModifiers(["Shift"]) && this.isCheckboxList) {
          event2.preventDefault();
          var focusedIndex = this.focusFirstElement();
          if (focusedIndex !== -1) {
            this.setSelectedIndexOnAction(focusedIndex, false);
          }
        }
        if (this.hasTypeahead) {
          var handleKeydownOpts = {
            event: event2,
            focusItemAtIndex: function(index2) {
              _this.focusItemAtIndex(index2);
            },
            focusedItemIndex: -1,
            isTargetListItem: isRootListItem,
            sortedIndexByFirstChar: this.sortedIndexByFirstChar,
            isItemAtIndexDisabled: function(index2) {
              return _this.isIndexDisabled(index2);
            }
          };
          handleKeydown(handleKeydownOpts, this.typeaheadState);
        }
        return;
      }
      var currentIndex = this.adapter.getFocusedElementIndex();
      if (currentIndex === -1) {
        currentIndex = listItemIndex;
        if (currentIndex < 0) {
          return;
        }
      }
      if (isForward && eventHasModifiers([])) {
        preventDefaultEvent(event2);
        this.focusNextElement(currentIndex);
      } else if (isBack && eventHasModifiers([])) {
        preventDefaultEvent(event2);
        this.focusPrevElement(currentIndex);
      } else if (isForward && eventHasModifiers(["Shift"]) && this.isCheckboxList) {
        preventDefaultEvent(event2);
        var focusedIndex = this.focusNextElement(currentIndex);
        if (focusedIndex !== -1) {
          this.setSelectedIndexOnAction(focusedIndex, false);
        }
      } else if (isBack && eventHasModifiers(["Shift"]) && this.isCheckboxList) {
        preventDefaultEvent(event2);
        var focusedIndex = this.focusPrevElement(currentIndex);
        if (focusedIndex !== -1) {
          this.setSelectedIndexOnAction(focusedIndex, false);
        }
      } else if (isHome && eventHasModifiers([])) {
        preventDefaultEvent(event2);
        this.focusFirstElement();
      } else if (isEnd && eventHasModifiers([])) {
        preventDefaultEvent(event2);
        this.focusLastElement();
      } else if (isHome && eventHasModifiers(["Control", "Shift"]) && this.isCheckboxList) {
        preventDefaultEvent(event2);
        if (this.isIndexDisabled(currentIndex)) {
          return;
        }
        this.focusFirstElement();
        this.toggleCheckboxRange(0, currentIndex, currentIndex);
      } else if (isEnd && eventHasModifiers(["Control", "Shift"]) && this.isCheckboxList) {
        preventDefaultEvent(event2);
        if (this.isIndexDisabled(currentIndex)) {
          return;
        }
        this.focusLastElement();
        this.toggleCheckboxRange(currentIndex, this.adapter.getListItemCount() - 1, currentIndex);
      } else if (isLetterA && eventHasModifiers(["Control"]) && this.isCheckboxList) {
        event2.preventDefault();
        this.checkboxListToggleAll(this.selectedIndex === numbers$4.UNSET_INDEX ? [] : this.selectedIndex, true);
      } else if ((isEnter || isSpace) && eventHasModifiers([])) {
        if (isRootListItem) {
          var target = event2.target;
          if (target && target.tagName === "A" && isEnter) {
            return;
          }
          preventDefaultEvent(event2);
          if (this.isIndexDisabled(currentIndex)) {
            return;
          }
          if (!this.isTypeaheadInProgress()) {
            if (this.isSelectableList()) {
              this.setSelectedIndexOnAction(currentIndex, false);
            }
            this.adapter.notifyAction(currentIndex);
          }
        }
      } else if ((isEnter || isSpace) && eventHasModifiers(["Shift"]) && this.isCheckboxList) {
        var target = event2.target;
        if (target && target.tagName === "A" && isEnter) {
          return;
        }
        preventDefaultEvent(event2);
        if (this.isIndexDisabled(currentIndex)) {
          return;
        }
        if (!this.isTypeaheadInProgress()) {
          this.toggleCheckboxRange((_a3 = this.lastSelectedIndex) !== null && _a3 !== void 0 ? _a3 : currentIndex, currentIndex, currentIndex);
          this.adapter.notifyAction(currentIndex);
        }
      }
      if (this.hasTypeahead) {
        var handleKeydownOpts = {
          event: event2,
          focusItemAtIndex: function(index2) {
            _this.focusItemAtIndex(index2);
          },
          focusedItemIndex: this.focusedItemIndex,
          isTargetListItem: isRootListItem,
          sortedIndexByFirstChar: this.sortedIndexByFirstChar,
          isItemAtIndexDisabled: function(index2) {
            return _this.isIndexDisabled(index2);
          }
        };
        handleKeydown(handleKeydownOpts, this.typeaheadState);
      }
    };
    MDCListFoundation2.prototype.handleClick = function(index2, isCheckboxAlreadyUpdatedInAdapter, event2) {
      var _a3;
      var eventHasModifiers = createModifierChecker(event2);
      if (index2 === numbers$4.UNSET_INDEX) {
        return;
      }
      if (this.isIndexDisabled(index2)) {
        return;
      }
      if (eventHasModifiers([])) {
        if (this.isSelectableList()) {
          this.setSelectedIndexOnAction(index2, isCheckboxAlreadyUpdatedInAdapter);
        }
        this.adapter.notifyAction(index2);
      } else if (this.isCheckboxList && eventHasModifiers(["Shift"])) {
        this.toggleCheckboxRange((_a3 = this.lastSelectedIndex) !== null && _a3 !== void 0 ? _a3 : index2, index2, index2);
        this.adapter.notifyAction(index2);
      }
    };
    MDCListFoundation2.prototype.focusNextElement = function(index2) {
      var count = this.adapter.getListItemCount();
      var nextIndex = index2;
      var firstChecked = null;
      do {
        nextIndex++;
        if (nextIndex >= count) {
          if (this.wrapFocus) {
            nextIndex = 0;
          } else {
            return index2;
          }
        }
        if (nextIndex === firstChecked) {
          return -1;
        }
        firstChecked = firstChecked !== null && firstChecked !== void 0 ? firstChecked : nextIndex;
      } while (!this.areDisabledItemsFocusable && this.isIndexDisabled(nextIndex));
      this.focusItemAtIndex(nextIndex);
      return nextIndex;
    };
    MDCListFoundation2.prototype.focusPrevElement = function(index2) {
      var count = this.adapter.getListItemCount();
      var prevIndex = index2;
      var firstChecked = null;
      do {
        prevIndex--;
        if (prevIndex < 0) {
          if (this.wrapFocus) {
            prevIndex = count - 1;
          } else {
            return index2;
          }
        }
        if (prevIndex === firstChecked) {
          return -1;
        }
        firstChecked = firstChecked !== null && firstChecked !== void 0 ? firstChecked : prevIndex;
      } while (!this.areDisabledItemsFocusable && this.isIndexDisabled(prevIndex));
      this.focusItemAtIndex(prevIndex);
      return prevIndex;
    };
    MDCListFoundation2.prototype.focusFirstElement = function() {
      return this.focusNextElement(-1);
    };
    MDCListFoundation2.prototype.focusLastElement = function() {
      return this.focusPrevElement(this.adapter.getListItemCount());
    };
    MDCListFoundation2.prototype.focusInitialElement = function() {
      var initialIndex = this.getFirstSelectedOrFocusedItemIndex();
      this.focusItemAtIndex(initialIndex);
      return initialIndex;
    };
    MDCListFoundation2.prototype.setEnabled = function(itemIndex, isEnabled) {
      if (!this.isIndexValid(itemIndex, false)) {
        return;
      }
      if (isEnabled) {
        this.adapter.removeClassForElementIndex(itemIndex, cssClasses$4.LIST_ITEM_DISABLED_CLASS);
        this.adapter.setAttributeForElementIndex(itemIndex, strings$4.ARIA_DISABLED, "false");
      } else {
        this.adapter.addClassForElementIndex(itemIndex, cssClasses$4.LIST_ITEM_DISABLED_CLASS);
        this.adapter.setAttributeForElementIndex(itemIndex, strings$4.ARIA_DISABLED, "true");
      }
    };
    MDCListFoundation2.prototype.setSingleSelectionAtIndex = function(index2, options) {
      if (options === void 0) {
        options = {};
      }
      if (this.selectedIndex === index2 && !options.forceUpdate) {
        return;
      }
      var selectedClassName = cssClasses$4.LIST_ITEM_SELECTED_CLASS;
      if (this.useActivatedClass) {
        selectedClassName = cssClasses$4.LIST_ITEM_ACTIVATED_CLASS;
      }
      if (this.selectedIndex !== numbers$4.UNSET_INDEX) {
        this.adapter.removeClassForElementIndex(this.selectedIndex, selectedClassName);
      }
      this.setAriaForSingleSelectionAtIndex(index2);
      this.setTabindexAtIndex(index2);
      if (index2 !== numbers$4.UNSET_INDEX) {
        this.adapter.addClassForElementIndex(index2, selectedClassName);
      }
      this.selectedIndex = index2;
      if (options.isUserInteraction && !options.forceUpdate) {
        this.adapter.notifySelectionChange([index2]);
      }
    };
    MDCListFoundation2.prototype.setAriaForSingleSelectionAtIndex = function(index2) {
      if (this.selectedIndex === numbers$4.UNSET_INDEX) {
        this.ariaCurrentAttrValue = this.adapter.getAttributeForElementIndex(index2, strings$4.ARIA_CURRENT);
      }
      var isAriaCurrent = this.ariaCurrentAttrValue !== null;
      var ariaAttribute = isAriaCurrent ? strings$4.ARIA_CURRENT : strings$4.ARIA_SELECTED;
      if (this.selectedIndex !== numbers$4.UNSET_INDEX) {
        this.adapter.setAttributeForElementIndex(this.selectedIndex, ariaAttribute, "false");
      }
      if (index2 !== numbers$4.UNSET_INDEX) {
        var ariaAttributeValue = isAriaCurrent ? this.ariaCurrentAttrValue : "true";
        this.adapter.setAttributeForElementIndex(index2, ariaAttribute, ariaAttributeValue);
      }
    };
    MDCListFoundation2.prototype.getSelectionAttribute = function() {
      return this.useSelectedAttr ? strings$4.ARIA_SELECTED : strings$4.ARIA_CHECKED;
    };
    MDCListFoundation2.prototype.setRadioAtIndex = function(index2, options) {
      if (options === void 0) {
        options = {};
      }
      var selectionAttribute = this.getSelectionAttribute();
      this.adapter.setCheckedCheckboxOrRadioAtIndex(index2, true);
      if (this.selectedIndex === index2 && !options.forceUpdate) {
        return;
      }
      if (this.selectedIndex !== numbers$4.UNSET_INDEX) {
        this.adapter.setAttributeForElementIndex(this.selectedIndex, selectionAttribute, "false");
      }
      this.adapter.setAttributeForElementIndex(index2, selectionAttribute, "true");
      this.selectedIndex = index2;
      if (options.isUserInteraction && !options.forceUpdate) {
        this.adapter.notifySelectionChange([index2]);
      }
    };
    MDCListFoundation2.prototype.setCheckboxAtIndex = function(index2, options) {
      if (options === void 0) {
        options = {};
      }
      var currentIndex = this.selectedIndex;
      var currentlySelected = options.isUserInteraction ? new Set(currentIndex === numbers$4.UNSET_INDEX ? [] : currentIndex) : null;
      var selectionAttribute = this.getSelectionAttribute();
      var changedIndices = [];
      for (var i2 = 0; i2 < this.adapter.getListItemCount(); i2++) {
        var previousIsChecked = currentlySelected === null || currentlySelected === void 0 ? void 0 : currentlySelected.has(i2);
        var newIsChecked = index2.indexOf(i2) >= 0;
        if (newIsChecked !== previousIsChecked) {
          changedIndices.push(i2);
        }
        this.adapter.setCheckedCheckboxOrRadioAtIndex(i2, newIsChecked);
        this.adapter.setAttributeForElementIndex(i2, selectionAttribute, newIsChecked ? "true" : "false");
      }
      this.selectedIndex = index2;
      if (options.isUserInteraction && changedIndices.length) {
        this.adapter.notifySelectionChange(changedIndices);
      }
    };
    MDCListFoundation2.prototype.toggleCheckboxRange = function(fromIndex, toIndex, toggleIndex) {
      this.lastSelectedIndex = toggleIndex;
      var currentlySelected = new Set(this.selectedIndex === numbers$4.UNSET_INDEX ? [] : this.selectedIndex);
      var newIsChecked = !(currentlySelected === null || currentlySelected === void 0 ? void 0 : currentlySelected.has(toggleIndex));
      var _a3 = __read([fromIndex, toIndex].sort(), 2), startIndex = _a3[0], endIndex = _a3[1];
      var selectionAttribute = this.getSelectionAttribute();
      var changedIndices = [];
      for (var i2 = startIndex; i2 <= endIndex; i2++) {
        if (this.isIndexDisabled(i2)) {
          continue;
        }
        var previousIsChecked = currentlySelected.has(i2);
        if (newIsChecked !== previousIsChecked) {
          changedIndices.push(i2);
          this.adapter.setCheckedCheckboxOrRadioAtIndex(i2, newIsChecked);
          this.adapter.setAttributeForElementIndex(i2, selectionAttribute, "" + newIsChecked);
          if (newIsChecked) {
            currentlySelected.add(i2);
          } else {
            currentlySelected.delete(i2);
          }
        }
      }
      if (changedIndices.length) {
        this.selectedIndex = __spreadArray([], __read(currentlySelected));
        this.adapter.notifySelectionChange(changedIndices);
      }
    };
    MDCListFoundation2.prototype.setTabindexAtIndex = function(index2) {
      if (this.focusedItemIndex === numbers$4.UNSET_INDEX && index2 !== 0) {
        this.adapter.setAttributeForElementIndex(0, "tabindex", "-1");
      } else if (this.focusedItemIndex >= 0 && this.focusedItemIndex !== index2) {
        this.adapter.setAttributeForElementIndex(this.focusedItemIndex, "tabindex", "-1");
      }
      if (!(this.selectedIndex instanceof Array) && this.selectedIndex !== index2) {
        this.adapter.setAttributeForElementIndex(this.selectedIndex, "tabindex", "-1");
      }
      if (index2 !== numbers$4.UNSET_INDEX) {
        this.adapter.setAttributeForElementIndex(index2, "tabindex", "0");
      }
    };
    MDCListFoundation2.prototype.isSelectableList = function() {
      return this.isSingleSelectionList || this.isCheckboxList || this.isRadioList;
    };
    MDCListFoundation2.prototype.setTabindexToFirstSelectedOrFocusedItem = function() {
      var targetIndex = this.getFirstSelectedOrFocusedItemIndex();
      this.setTabindexAtIndex(targetIndex);
    };
    MDCListFoundation2.prototype.getFirstSelectedOrFocusedItemIndex = function() {
      if (!this.isSelectableList()) {
        return Math.max(this.focusedItemIndex, 0);
      }
      if (typeof this.selectedIndex === "number" && this.selectedIndex !== numbers$4.UNSET_INDEX) {
        return this.selectedIndex;
      }
      if (isNumberArray(this.selectedIndex) && this.selectedIndex.length > 0) {
        return this.selectedIndex.reduce(function(minIndex, currentIndex) {
          return Math.min(minIndex, currentIndex);
        });
      }
      return 0;
    };
    MDCListFoundation2.prototype.isIndexValid = function(index2, validateListType) {
      var _this = this;
      if (validateListType === void 0) {
        validateListType = true;
      }
      if (index2 instanceof Array) {
        if (!this.isCheckboxList && validateListType) {
          throw new Error("MDCListFoundation: Array of index is only supported for checkbox based list");
        }
        if (index2.length === 0) {
          return true;
        } else {
          return index2.some(function(i2) {
            return _this.isIndexInRange(i2);
          });
        }
      } else if (typeof index2 === "number") {
        if (this.isCheckboxList && validateListType) {
          throw new Error("MDCListFoundation: Expected array of index for checkbox based list but got number: " + index2);
        }
        return this.isIndexInRange(index2) || this.isSingleSelectionList && index2 === numbers$4.UNSET_INDEX;
      } else {
        return false;
      }
    };
    MDCListFoundation2.prototype.isIndexInRange = function(index2) {
      var listSize = this.adapter.getListItemCount();
      return index2 >= 0 && index2 < listSize;
    };
    MDCListFoundation2.prototype.setSelectedIndexOnAction = function(index2, isCheckboxAlreadyUpdatedInAdapter) {
      this.lastSelectedIndex = index2;
      if (this.isCheckboxList) {
        this.toggleCheckboxAtIndex(index2, isCheckboxAlreadyUpdatedInAdapter);
        this.adapter.notifySelectionChange([index2]);
      } else {
        this.setSelectedIndex(index2, { isUserInteraction: true });
      }
    };
    MDCListFoundation2.prototype.toggleCheckboxAtIndex = function(index2, isCheckboxAlreadyUpdatedInAdapter) {
      var selectionAttribute = this.getSelectionAttribute();
      var adapterIsChecked = this.adapter.isCheckboxCheckedAtIndex(index2);
      var newCheckedValue;
      if (isCheckboxAlreadyUpdatedInAdapter) {
        newCheckedValue = adapterIsChecked;
      } else {
        newCheckedValue = !adapterIsChecked;
        this.adapter.setCheckedCheckboxOrRadioAtIndex(index2, newCheckedValue);
      }
      this.adapter.setAttributeForElementIndex(index2, selectionAttribute, newCheckedValue ? "true" : "false");
      var selectedIndexes = this.selectedIndex === numbers$4.UNSET_INDEX ? [] : this.selectedIndex.slice();
      if (newCheckedValue) {
        selectedIndexes.push(index2);
      } else {
        selectedIndexes = selectedIndexes.filter(function(i2) {
          return i2 !== index2;
        });
      }
      this.selectedIndex = selectedIndexes;
    };
    MDCListFoundation2.prototype.focusItemAtIndex = function(index2) {
      this.adapter.focusItemAtIndex(index2);
      this.focusedItemIndex = index2;
    };
    MDCListFoundation2.prototype.checkboxListToggleAll = function(currentlySelectedIndexes, isUserInteraction) {
      var count = this.adapter.getListItemCount();
      if (currentlySelectedIndexes.length === count) {
        this.setCheckboxAtIndex([], { isUserInteraction });
      } else {
        var allIndexes = [];
        for (var i2 = 0; i2 < count; i2++) {
          if (!this.isIndexDisabled(i2) || currentlySelectedIndexes.indexOf(i2) > -1) {
            allIndexes.push(i2);
          }
        }
        this.setCheckboxAtIndex(allIndexes, { isUserInteraction });
      }
    };
    MDCListFoundation2.prototype.typeaheadMatchItem = function(nextChar, startingIndex, skipFocus) {
      var _this = this;
      if (skipFocus === void 0) {
        skipFocus = false;
      }
      var opts = {
        focusItemAtIndex: function(index2) {
          _this.focusItemAtIndex(index2);
        },
        focusedItemIndex: startingIndex ? startingIndex : this.focusedItemIndex,
        nextChar,
        sortedIndexByFirstChar: this.sortedIndexByFirstChar,
        skipFocus,
        isItemAtIndexDisabled: function(index2) {
          return _this.isIndexDisabled(index2);
        }
      };
      return matchItem(opts, this.typeaheadState);
    };
    MDCListFoundation2.prototype.typeaheadInitSortedIndex = function() {
      return initSortedIndex(this.adapter.getListItemCount(), this.adapter.getPrimaryTextAtIndex);
    };
    MDCListFoundation2.prototype.clearTypeaheadBuffer = function() {
      clearBuffer(this.typeaheadState);
    };
    return MDCListFoundation2;
  }(MDCFoundation)
);
var root_1$j = /* @__PURE__ */ from_svg(`<svg><!></svg>`);
function SmuiElement($$anchor, $$props) {
  push($$props, true);
  let use = prop($$props, "use", 19, () => []), tag = prop($$props, "tag", 3, "div"), restProps = /* @__PURE__ */ rest_props($$props, ["$$slots", "$$events", "$$legacy", "use", "tag", "children"]);
  const selfClosing = /* @__PURE__ */ user_derived(() => [
    "area",
    "base",
    "br",
    "col",
    "embed",
    "hr",
    "img",
    "input",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ].indexOf(tag()) > -1);
  let element$1;
  function getElement() {
    return element$1;
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var svg = root_1$j();
      attribute_effect(svg, () => ({ ...restProps }));
      var node_1 = child(svg);
      snippet(node_1, () => $$props.children ?? noop$1);
      bind_this(svg, ($$value) => element$1 = $$value, () => element$1);
      action(svg, ($$node, $$action_arg) => useActions == null ? void 0 : useActions($$node, $$action_arg), use);
      append($$anchor2, svg);
    };
    var alternate_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          element(node_3, tag, false, ($$element, $$anchor4) => {
            bind_this($$element, ($$value) => element$1 = $$value, () => element$1);
            action($$element, ($$node, $$action_arg) => useActions == null ? void 0 : useActions($$node, $$action_arg), use);
            attribute_effect($$element, () => ({ ...restProps }));
          });
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          element(node_4, tag, false, ($$element_1, $$anchor4) => {
            bind_this($$element_1, ($$value) => element$1 = $$value, () => element$1);
            action($$element_1, ($$node, $$action_arg) => useActions == null ? void 0 : useActions($$node, $$action_arg), use);
            attribute_effect($$element_1, () => ({ ...restProps }));
            var fragment_4 = comment();
            var node_5 = first_child(fragment_4);
            snippet(node_5, () => $$props.children ?? noop$1);
            append($$anchor4, fragment_4);
          });
          append($$anchor3, fragment_3);
        };
        if_block(
          node_2,
          ($$render) => {
            if (get$1(selfClosing)) $$render(consequent_1);
            else $$render(alternate, false);
          },
          true
        );
      }
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (tag() === "svg") $$render(consequent);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  return pop({ getElement });
}
function List($$anchor, $$props) {
  push($$props, true);
  const { closest: closest2, matches: matches2 } = ponyfill;
  let nav = getContext("SMUI:list:nav");
  let use = prop($$props, "use", 19, () => []), className = prop($$props, "class", 3, ""), nonInteractive = prop($$props, "nonInteractive", 3, false), dense = prop($$props, "dense", 3, false), textualList = prop($$props, "textualList", 3, false), avatarList = prop($$props, "avatarList", 3, false), iconList = prop($$props, "iconList", 3, false), imageList = prop($$props, "imageList", 3, false), thumbnailList = prop($$props, "thumbnailList", 3, false), videoList = prop($$props, "videoList", 3, false), twoLine = prop($$props, "twoLine", 3, false), threeLine = prop($$props, "threeLine", 3, false), vertical = prop($$props, "vertical", 3, true), wrapFocus = prop($$props, "wrapFocus", 19, () => getContext("SMUI:list:wrapFocus") ?? false), singleSelection = prop($$props, "singleSelection", 3, false), disabledItemsFocusable = prop($$props, "disabledItemsFocusable", 3, false), selectedIndex = prop($$props, "selectedIndex", 31, () => -1), radioList = prop($$props, "radioList", 3, false), checkList = prop($$props, "checkList", 3, false), hasTypeahead = prop($$props, "hasTypeahead", 3, false), MyComponent = prop($$props, "component", 3, SmuiElement), tag = prop($$props, "tag", 3, nav ? "nav" : "ul"), restProps = /* @__PURE__ */ rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "use",
    "class",
    "nonInteractive",
    "dense",
    "textualList",
    "avatarList",
    "iconList",
    "imageList",
    "thumbnailList",
    "videoList",
    "twoLine",
    "threeLine",
    "vertical",
    "wrapFocus",
    "singleSelection",
    "disabledItemsFocusable",
    "selectedIndex",
    "radioList",
    "checkList",
    "hasTypeahead",
    "component",
    "tag",
    "children"
  ]);
  let element2;
  let instance = /* @__PURE__ */ state(void 0);
  let items = [];
  let role = getContext("SMUI:list:role");
  const itemAccessorMap = /* @__PURE__ */ new WeakMap();
  let selectionDialog = getContext("SMUI:dialog:selection");
  let addLayoutListener = getContext("SMUI:addLayoutListener");
  let removeLayoutListener;
  setContext("SMUI:list:nonInteractive", nonInteractive());
  setContext("SMUI:separator:context", "list");
  if (!role) {
    if (singleSelection()) {
      role = "listbox";
      setContext("SMUI:list:item:role", "option");
    } else if (radioList()) {
      role = "radiogroup";
      setContext("SMUI:list:item:role", "radio");
    } else if (checkList()) {
      role = "group";
      setContext("SMUI:list:item:role", "checkbox");
    } else {
      role = "list";
      setContext("SMUI:list:item:role", void 0);
    }
  }
  user_effect(() => {
    if (get$1(instance)) {
      get$1(instance).setVerticalOrientation(vertical());
    }
  });
  user_effect(() => {
    if (get$1(instance)) {
      get$1(instance).setWrapFocus(wrapFocus());
    }
  });
  user_effect(() => {
    if (get$1(instance)) {
      get$1(instance).setHasTypeahead(hasTypeahead());
    }
  });
  user_effect(() => {
    if (get$1(instance)) {
      get$1(instance).setSingleSelection(singleSelection());
    }
  });
  user_effect(() => {
    if (get$1(instance)) {
      get$1(instance).setDisabledItemsFocusable(disabledItemsFocusable());
    }
  });
  user_effect(() => {
    if (get$1(instance) && singleSelection() && getSelectedIndex() !== selectedIndex()) {
      get$1(instance).setSelectedIndex(selectedIndex());
    }
  });
  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }
  setContext("SMUI:list:item:mount", (accessor) => {
    items.push(accessor);
    itemAccessorMap.set(accessor.element, accessor);
    if (singleSelection() && accessor.selected) {
      selectedIndex(getListItemIndex(accessor.element));
    }
  });
  setContext("SMUI:list:item:unmount", (accessor) => {
    const idx = (accessor && items.findIndex((a2) => a2 === accessor)) ?? -1;
    if (idx !== -1) {
      items.splice(idx, 1);
      itemAccessorMap.delete(accessor.element);
    }
  });
  const SMUIListMount = getContext("SMUI:list:mount");
  const SMUIListUnmount = getContext("SMUI:list:unmount");
  onMount(() => {
    set(
      instance,
      new MDCListFoundation({
        addClassForElementIndex,
        focusItemAtIndex,
        getAttributeForElementIndex: (index2, name) => {
          var _a3;
          return ((_a3 = getOrderedList()[index2]) == null ? void 0 : _a3.getAttr(name)) ?? null;
        },
        getFocusedElementIndex: () => document.activeElement ? getOrderedList().map((accessor2) => accessor2.element).indexOf(document.activeElement) : -1,
        getListItemCount: () => items.length,
        getPrimaryTextAtIndex,
        hasCheckboxAtIndex: (index2) => {
          var _a3;
          return ((_a3 = getOrderedList()[index2]) == null ? void 0 : _a3.hasCheckbox) ?? false;
        },
        hasRadioAtIndex: (index2) => {
          var _a3;
          return ((_a3 = getOrderedList()[index2]) == null ? void 0 : _a3.hasRadio) ?? false;
        },
        isCheckboxCheckedAtIndex: (index2) => {
          const listItem = getOrderedList()[index2];
          return ((listItem == null ? void 0 : listItem.hasCheckbox) && listItem.checked) ?? false;
        },
        isFocusInsideList: () => element2 != null && getElement() !== document.activeElement && getElement().contains(document.activeElement),
        isRootFocused: () => element2 != null && document.activeElement === getElement(),
        listItemAtIndexHasClass,
        notifyAction: (index2) => {
          selectedIndex(index2);
          if (element2 != null) {
            dispatch(getElement(), "SMUIListAction", { index: index2 });
          }
        },
        notifySelectionChange: (changedIndices) => {
          if (element2 != null) {
            dispatch(getElement(), "SMUIListSelectionChange", { changedIndices });
          }
        },
        removeClassForElementIndex,
        setAttributeForElementIndex,
        setCheckedCheckboxOrRadioAtIndex: (index2, isChecked) => {
          getOrderedList()[index2].checked = isChecked;
        },
        setTabIndexForListItemChildren: (listItemIndex, tabIndexValue) => {
          const listItem = getOrderedList()[listItemIndex];
          const selector = "button:not(:disabled), a";
          Array.prototype.forEach.call(listItem.element.querySelectorAll(selector), (el) => {
            el.setAttribute("tabindex", tabIndexValue);
          });
        }
      }),
      true
    );
    const accessor = {
      get element() {
        return getElement();
      },
      get items() {
        return items;
      },
      get typeaheadInProgress() {
        if (!get$1(instance)) {
          throw new Error("Instance is undefined.");
        }
        return get$1(instance).isTypeaheadInProgress();
      },
      typeaheadMatchItem(nextChar, startingIndex) {
        if (!get$1(instance)) {
          throw new Error("Instance is undefined.");
        }
        return get$1(
          instance
          /** skipFocus */
        ).typeaheadMatchItem(nextChar, startingIndex, true);
      },
      getOrderedList,
      focusItemAtIndex,
      addClassForElementIndex,
      removeClassForElementIndex,
      setAttributeForElementIndex,
      removeAttributeForElementIndex,
      getAttributeFromElementIndex,
      getPrimaryTextAtIndex
    };
    SMUIListMount == null ? void 0 : SMUIListMount(accessor);
    get$1(instance).init();
    get$1(instance).layout();
    return () => {
      var _a3;
      SMUIListUnmount == null ? void 0 : SMUIListUnmount(accessor);
      (_a3 = get$1(instance)) == null ? void 0 : _a3.destroy();
    };
  });
  onDestroy(() => {
    if (removeLayoutListener) {
      removeLayoutListener();
    }
  });
  function handleKeydown2(event2) {
    if (get$1(instance) && event2.target) {
      get$1(instance).handleKeydown(event2, event2.target.classList.contains("mdc-deprecated-list-item"), getListItemIndex(event2.target));
    }
  }
  function handleFocusin(event2) {
    if (get$1(instance) && event2.target) {
      get$1(instance).handleFocusIn(getListItemIndex(event2.target));
    }
  }
  function handleFocusout(event2) {
    if (get$1(instance) && event2.target) {
      get$1(instance).handleFocusOut(getListItemIndex(event2.target));
    }
  }
  function handleClick(event2) {
    if (get$1(instance) && event2.target) {
      get$1(instance).handleClick(getListItemIndex(event2.target), !matches2(event2.target, 'input[type="checkbox"], input[type="radio"]'), event2);
    }
  }
  function handleAction(event2) {
    if (radioList() || checkList()) {
      const index2 = getListItemIndex(event2.target);
      if (index2 !== -1) {
        const item = getOrderedList()[index2];
        if (item && (radioList() && !item.checked || checkList())) {
          if (!matches2(event2.detail.target, 'input[type="checkbox"], input[type="radio"]')) {
            item.checked = !item.checked;
          }
          item.activateRipple();
          window.requestAnimationFrame(() => {
            item.deactivateRipple();
          });
        }
      }
    }
  }
  function getOrderedList() {
    if (element2 == null) {
      return [];
    }
    return [
      ...getElement().querySelectorAll(".mdc-deprecated-list-item")
    ].map((element3) => itemAccessorMap.get(element3)).filter((accessor) => accessor && accessor._smui_list_item_accessor);
  }
  function listItemAtIndexHasClass(index2, className2) {
    const accessor = getOrderedList()[index2];
    return (accessor && accessor.hasClass(className2)) ?? false;
  }
  function addClassForElementIndex(index2, className2) {
    const accessor = getOrderedList()[index2];
    accessor == null ? void 0 : accessor.addClass(className2);
  }
  function removeClassForElementIndex(index2, className2) {
    const accessor = getOrderedList()[index2];
    accessor == null ? void 0 : accessor.removeClass(className2);
  }
  function setAttributeForElementIndex(index2, name, value) {
    const accessor = getOrderedList()[index2];
    accessor == null ? void 0 : accessor.addAttr(name, value);
  }
  function removeAttributeForElementIndex(index2, name) {
    const accessor = getOrderedList()[index2];
    accessor == null ? void 0 : accessor.removeAttr(name);
  }
  function getAttributeFromElementIndex(index2, name) {
    const accessor = getOrderedList()[index2];
    if (accessor) {
      return accessor.getAttr(name);
    } else {
      return null;
    }
  }
  function getPrimaryTextAtIndex(index2) {
    const accessor = getOrderedList()[index2];
    return (accessor && accessor.getPrimaryText()) ?? "";
  }
  function getListItemIndex(element3) {
    const nearestParent = closest2(element3, ".mdc-deprecated-list-item, .mdc-deprecated-list");
    if (nearestParent && matches2(nearestParent, ".mdc-deprecated-list-item")) {
      return getOrderedList().map((item) => item == null ? void 0 : item.element).indexOf(nearestParent);
    }
    return -1;
  }
  function layout() {
    if (!get$1(instance)) {
      throw new Error("Instance is undefined.");
    }
    return get$1(instance).layout();
  }
  function setEnabled(itemIndex, isEnabled) {
    if (!get$1(instance)) {
      throw new Error("Instance is undefined.");
    }
    return get$1(instance).setEnabled(itemIndex, isEnabled);
  }
  function getTypeaheadInProgress() {
    if (!get$1(instance)) {
      throw new Error("Instance is undefined.");
    }
    return get$1(instance).isTypeaheadInProgress();
  }
  function getSelectedIndex() {
    if (!get$1(instance)) {
      throw new Error("Instance is undefined.");
    }
    return get$1(instance).getSelectedIndex();
  }
  function getFocusedItemIndex() {
    if (!get$1(instance)) {
      throw new Error("Instance is undefined.");
    }
    return get$1(instance).getFocusedItemIndex();
  }
  function focusItemAtIndex(index2) {
    const accessor = getOrderedList()[index2];
    if (accessor && "focus" in accessor.element) {
      accessor.element.focus();
    }
  }
  function getElement() {
    return element2.getElement();
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = /* @__PURE__ */ user_derived(() => classMap({
      [className()]: true,
      "mdc-deprecated-list": true,
      "mdc-deprecated-list--non-interactive": nonInteractive(),
      "mdc-deprecated-list--dense": dense(),
      "mdc-deprecated-list--textual-list": textualList(),
      "mdc-deprecated-list--avatar-list": avatarList() || selectionDialog,
      "mdc-deprecated-list--icon-list": iconList(),
      "mdc-deprecated-list--image-list": imageList(),
      "mdc-deprecated-list--thumbnail-list": thumbnailList(),
      "mdc-deprecated-list--video-list": videoList(),
      "mdc-deprecated-list--two-line": twoLine(),
      "smui-list--three-line": threeLine() && !twoLine()
    }));
    component(node, MyComponent, ($$anchor2, MyComponent_1) => {
      bind_this(
        MyComponent_1($$anchor2, spread_props(
          {
            get tag() {
              return tag();
            },
            get use() {
              return use();
            },
            get class() {
              return get$1($0);
            },
            get role() {
              return role;
            }
          },
          () => restProps,
          {
            onkeydown: (e2) => {
              var _a3;
              handleKeydown2(e2);
              (_a3 = $$props.onkeydown) == null ? void 0 : _a3.call($$props, e2);
            },
            onfocusin: (e2) => {
              var _a3;
              handleFocusin(e2);
              (_a3 = $$props.onfocusin) == null ? void 0 : _a3.call($$props, e2);
            },
            onfocusout: (e2) => {
              var _a3;
              handleFocusout(e2);
              (_a3 = $$props.onfocusout) == null ? void 0 : _a3.call($$props, e2);
            },
            onclick: (e2) => {
              var _a3;
              handleClick(e2);
              (_a3 = $$props.onclick) == null ? void 0 : _a3.call($$props, e2);
            },
            onSMUIAction: (e2) => {
              var _a3;
              handleAction(e2);
              (_a3 = $$props.onSMUIAction) == null ? void 0 : _a3.call($$props, e2);
            },
            children: ($$anchor3, $$slotProps) => {
              var fragment_1 = comment();
              var node_1 = first_child(fragment_1);
              snippet(node_1, () => $$props.children ?? noop$1);
              append($$anchor3, fragment_1);
            },
            $$slots: { default: true }
          }
        )),
        ($$value) => element2 = $$value,
        () => element2
      );
    });
  }
  append($$anchor, fragment);
  return pop({
    layout,
    setEnabled,
    getTypeaheadInProgress,
    getSelectedIndex,
    getFocusedItemIndex,
    focusItemAtIndex,
    getElement
  });
}
let counter = 0;
function Item($$anchor, $$props) {
  push($$props, true);
  let uninitializedValue = () => {
  };
  function isUninitializedValue(value) {
    return value === uninitializedValue;
  }
  let nav = getContext("SMUI:list:item:nav");
  let className = prop($$props, "class", 3, ""), style = prop($$props, "style", 3, ""), nonInteractive = prop($$props, "nonInteractive", 19, () => getContext("SMUI:list:nonInteractive") ?? false), wrapper = prop($$props, "wrapper", 3, false), activated = prop($$props, "activated", 15, false), role = prop($$props, "role", 19, () => wrapper() ? "presentation" : getContext("SMUI:list:item:role")), selected = prop($$props, "selected", 15, false), disabled = prop($$props, "disabled", 3, false), skipRestoreFocus = prop($$props, "skipRestoreFocus", 3, false), tabindexProp = prop($$props, "tabindex", 15, uninitializedValue), inputId = prop($$props, "inputId", 19, () => "SMUI-form-field-list-" + counter++), MyComponent = prop($$props, "component", 3, SmuiElement), tag = prop($$props, "tag", 19, () => nav ? $$props.href ? "a" : "span" : "li"), restProps = /* @__PURE__ */ rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "class",
    "style",
    "nonInteractive",
    "wrapper",
    "activated",
    "role",
    "selected",
    "disabled",
    "skipRestoreFocus",
    "tabindex",
    "inputId",
    "href",
    "component",
    "tag",
    "children"
  ]);
  setContext("SMUI:list:nonInteractive", void 0);
  setContext("SMUI:list:item:role", void 0);
  let element2;
  let internalClasses = proxy$1({});
  let internalStyles = proxy$1({});
  let internalAttrs = proxy$1({});
  let input = /* @__PURE__ */ state(void 0);
  let addTabindexIfNoItemsSelectedRaf = /* @__PURE__ */ state(void 0);
  const tabindex = /* @__PURE__ */ user_derived(() => isUninitializedValue(tabindexProp()) ? !nonInteractive() && !disabled() && (selected() || get$1(input) && get$1(input).checked) ? 0 : -1 : tabindexProp());
  setContext("SMUI:generic:input:props", { id: inputId() });
  setContext("SMUI:separator:context", void 0);
  setContext("SMUI:generic:input:mount", (accessor) => {
    if ("_smui_checkbox_accessor" in accessor || "_smui_radio_accessor" in accessor) {
      set(input, accessor, true);
    }
  });
  setContext("SMUI:generic:input:unmount", () => {
    set(input, void 0);
  });
  const SMUIListItemMount = getContext("SMUI:list:item:mount");
  const SMUIListItemUnmount = getContext("SMUI:list:item:unmount");
  onMount(() => {
    if (!selected() && !nonInteractive()) {
      let first = true;
      let el = element2.getElement();
      while (el.previousElementSibling) {
        el = el.previousElementSibling;
        if (el.nodeType === 1 && el.classList.contains("mdc-deprecated-list-item") && !el.classList.contains("mdc-deprecated-list-item--disabled")) {
          first = false;
          break;
        }
      }
      if (first) {
        set(addTabindexIfNoItemsSelectedRaf, window.requestAnimationFrame(() => addTabindexIfNoItemsSelected(el)), true);
      }
    }
    const accessor = {
      _smui_list_item_accessor: true,
      get element() {
        return getElement();
      },
      get selected() {
        return selected();
      },
      set selected(value) {
        selected(value);
      },
      hasClass,
      addClass,
      removeClass,
      getAttr,
      addAttr,
      removeAttr,
      getPrimaryText,
      // For inputs within item.
      get checked() {
        return (get$1(input) && get$1(input).checked) ?? false;
      },
      set checked(value) {
        if (get$1(input)) {
          get$1(input).checked = !!value;
        }
      },
      get hasCheckbox() {
        return !!(get$1(input) && "_smui_checkbox_accessor" in get$1(input));
      },
      get hasRadio() {
        return !!(get$1(input) && "_smui_radio_accessor" in get$1(input));
      },
      activateRipple() {
      },
      deactivateRipple() {
      },
      // For select options.
      getValue() {
        return $$props.value;
      },
      // For autocomplete
      action: action2,
      get tabindex() {
        return get$1(tabindex);
      },
      set tabindex(value) {
        tabindexProp(value);
      },
      get disabled() {
        return disabled();
      },
      get activated() {
        return activated();
      },
      set activated(value) {
        activated(value);
      }
    };
    SMUIListItemMount == null ? void 0 : SMUIListItemMount(accessor);
    return () => {
      SMUIListItemUnmount == null ? void 0 : SMUIListItemUnmount(accessor);
    };
  });
  onDestroy(() => {
    if (get$1(addTabindexIfNoItemsSelectedRaf)) {
      window.cancelAnimationFrame(get$1(addTabindexIfNoItemsSelectedRaf));
    }
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      internalClasses[className2] = true;
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      internalClasses[className2] = false;
    }
  }
  function getAttr(name) {
    return name in internalAttrs ? internalAttrs[name] ?? null : getElement().getAttribute(name);
  }
  function addAttr(name, value) {
    if (internalAttrs[name] !== value) {
      internalAttrs[name] = value;
    }
  }
  function removeAttr(name) {
    if (!(name in internalAttrs) || internalAttrs[name] != null) {
      internalAttrs[name] = void 0;
    }
  }
  function addTabindexIfNoItemsSelected(el) {
    let noneSelected = true;
    while (el.nextElementSibling) {
      el = el.nextElementSibling;
      if (el.nodeType === 1 && el.classList.contains("mdc-deprecated-list-item")) {
        const tabindexAttr = el.attributes.getNamedItem("tabindex");
        if (tabindexAttr && tabindexAttr.value === "0") {
          noneSelected = false;
          break;
        }
      }
    }
    if (noneSelected) {
      tabindexProp(0);
    }
  }
  function handleKeydown2(e2) {
    const isEnter = e2.key === "Enter";
    const isSpace = e2.key === "Space";
    if (isEnter || isSpace) {
      action2(e2);
    }
  }
  function action2(e2) {
    if (!disabled()) {
      dispatch(getElement(), "SMUIAction", e2);
    }
  }
  function getPrimaryText() {
    const element3 = getElement();
    const primaryText = element3.querySelector(".mdc-deprecated-list-item__primary-text");
    if (primaryText) {
      return primaryText.textContent ?? "";
    }
    const text2 = element3.querySelector(".mdc-deprecated-list-item__text");
    if (text2) {
      return text2.textContent ?? "";
    }
    return element3.textContent ?? "";
  }
  function getElement() {
    return element2.getElement();
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = /* @__PURE__ */ user_derived(() => classMap({
      [className()]: true,
      "mdc-deprecated-list-item": !wrapper(),
      "mdc-deprecated-list-item__wrapper": wrapper(),
      "mdc-deprecated-list-item--activated": activated(),
      "mdc-deprecated-list-item--selected": selected(),
      "mdc-deprecated-list-item--disabled": disabled(),
      "mdc-menu-item--selected": !nav && role() === "menuitem" && selected(),
      "smui-menu-item--non-interactive": nonInteractive(),
      ...internalClasses
    }));
    let $1 = /* @__PURE__ */ user_derived(() => Object.entries(internalStyles).map(([name, value]) => `${name}: ${value};`).concat([style()]).join(" "));
    let $2 = /* @__PURE__ */ user_derived(() => skipRestoreFocus() || void 0);
    component(node, MyComponent, ($$anchor2, MyComponent_1) => {
      bind_this(
        MyComponent_1($$anchor2, spread_props(
          {
            get tag() {
              return tag();
            },
            get class() {
              return get$1($0);
            },
            get style() {
              return get$1($1);
            }
          },
          () => nav && activated() ? { "aria-current": "page" } : {},
          () => !nav || wrapper() ? { role: role() } : {},
          () => !nav && role() === "option" ? { "aria-selected": selected() ? "true" : "false" } : {},
          () => !nav && (role() === "radio" || role() === "checkbox") ? {
            "aria-checked": get$1(input) && get$1(input).checked ? "true" : "false"
          } : {},
          () => !nav ? { "aria-disabled": disabled() ? "true" : "false" } : {},
          {
            get "data-menu-item-skip-restore-focus"() {
              return get$1($2);
            },
            get tabindex() {
              return get$1(tabindex);
            },
            get href() {
              return $$props.href;
            }
          },
          () => internalAttrs,
          () => restProps,
          {
            onclick: (e2) => {
              var _a3;
              if (nonInteractive()) {
                e2.preventDefault();
                e2.stopImmediatePropagation();
              } else {
                action2(e2);
              }
              (_a3 = $$props.onclick) == null ? void 0 : _a3.call($$props, e2);
            },
            onkeydown: (e2) => {
              var _a3;
              if (nonInteractive()) {
                e2.preventDefault();
                e2.stopImmediatePropagation();
              } else {
                handleKeydown2(e2);
              }
              (_a3 = $$props.onkeydown) == null ? void 0 : _a3.call($$props, e2);
            },
            children: ($$anchor3, $$slotProps) => {
              var fragment_1 = comment();
              var node_1 = first_child(fragment_1);
              snippet(node_1, () => $$props.children ?? noop$1);
              append($$anchor3, fragment_1);
            },
            $$slots: { default: true }
          }
        )),
        ($$value) => element2 = $$value,
        () => element2
      );
    });
  }
  append($$anchor, fragment);
  return pop({ action: action2, getPrimaryText, getElement });
}
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
const cssClasses$3 = {
  ANCHOR: "mdc-menu-surface--anchor",
  ANIMATING_CLOSED: "mdc-menu-surface--animating-closed",
  ANIMATING_OPEN: "mdc-menu-surface--animating-open",
  FIXED: "mdc-menu-surface--fixed",
  IS_OPEN_BELOW: "mdc-menu-surface--is-open-below",
  OPEN: "mdc-menu-surface--open",
  ROOT: "mdc-menu-surface"
};
const strings$3 = {
  CLOSED_EVENT: "MDCMenuSurface:closed",
  CLOSING_EVENT: "MDCMenuSurface:closing",
  OPENED_EVENT: "MDCMenuSurface:opened",
  OPENING_EVENT: "MDCMenuSurface:opening",
  FOCUSABLE_ELEMENTS: [
    "button:not(:disabled)",
    '[href]:not([aria-disabled="true"])',
    "input:not(:disabled)",
    "select:not(:disabled)",
    "textarea:not(:disabled)",
    '[tabindex]:not([tabindex="-1"]):not([aria-disabled="true"])'
  ].join(", ")
};
const numbers$3 = {
  /** Total duration of menu-surface open animation. */
  TRANSITION_OPEN_DURATION: 120,
  /** Total duration of menu-surface close animation. */
  TRANSITION_CLOSE_DURATION: 75,
  /**
   * Margin left to the edge of the viewport when menu-surface is at maximum
   * possible height. Also used as a viewport margin.
   */
  MARGIN_TO_EDGE: 32,
  /**
   * Ratio of anchor width to menu-surface width for switching from corner
   * positioning to center positioning.
   */
  ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO: 0.67,
  /**
   * Amount of time to wait before restoring focus when closing the menu
   * surface. This is important because if a touch event triggered the menu
   * close, and the subsequent mouse event occurs after focus is restored, then
   * the restored focus would be lost.
   */
  TOUCH_EVENT_WAIT_MS: 30
};
var CornerBit = /* @__PURE__ */ ((CornerBit2) => {
  CornerBit2[CornerBit2["BOTTOM"] = 1] = "BOTTOM";
  CornerBit2[CornerBit2["CENTER"] = 2] = "CENTER";
  CornerBit2[CornerBit2["RIGHT"] = 4] = "RIGHT";
  CornerBit2[CornerBit2["FLIP_RTL"] = 8] = "FLIP_RTL";
  return CornerBit2;
})(CornerBit || {});
var Corner = /* @__PURE__ */ ((Corner2) => {
  Corner2[Corner2["TOP_LEFT"] = 0] = "TOP_LEFT";
  Corner2[
    Corner2["TOP_RIGHT"] = 4
    /* RIGHT */
  ] = "TOP_RIGHT";
  Corner2[
    Corner2["BOTTOM_LEFT"] = 1
    /* BOTTOM */
  ] = "BOTTOM_LEFT";
  Corner2[Corner2["BOTTOM_RIGHT"] = 5] = "BOTTOM_RIGHT";
  Corner2[
    Corner2["TOP_START"] = 8
    /* FLIP_RTL */
  ] = "TOP_START";
  Corner2[Corner2["TOP_END"] = 12] = "TOP_END";
  Corner2[Corner2["BOTTOM_START"] = 9] = "BOTTOM_START";
  Corner2[Corner2["BOTTOM_END"] = 13] = "BOTTOM_END";
  return Corner2;
})(Corner || {});
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
class MDCMenuSurfaceFoundation extends MDCFoundation {
  // assigned in open()
  constructor(adapter) {
    super({ ...MDCMenuSurfaceFoundation.defaultAdapter, ...adapter });
    this.isSurfaceOpen = false;
    this.isQuickOpen = false;
    this.isHoistedElement = false;
    this.isFixedPosition = false;
    this.isHorizontallyCenteredOnViewport = false;
    this.maxHeight = 0;
    this.openBottomBias = 0;
    this.openAnimationEndTimerId = 0;
    this.closeAnimationEndTimerId = 0;
    this.animationRequestId = 0;
    this.anchorCorner = Corner.TOP_START;
    this.originCorner = Corner.TOP_START;
    this.anchorMargin = { top: 0, right: 0, bottom: 0, left: 0 };
    this.position = { x: 0, y: 0 };
  }
  static get cssClasses() {
    return cssClasses$3;
  }
  static get strings() {
    return strings$3;
  }
  static get numbers() {
    return numbers$3;
  }
  static get Corner() {
    return Corner;
  }
  /**
   * @see {@link MDCMenuSurfaceAdapter} for typing information on parameters and return types.
   */
  static get defaultAdapter() {
    return {
      addClass: () => void 0,
      removeClass: () => void 0,
      hasClass: () => false,
      hasAnchor: () => false,
      isElementInContainer: () => false,
      isFocused: () => false,
      isRtl: () => false,
      getInnerDimensions: () => ({ height: 0, width: 0 }),
      getAnchorDimensions: () => null,
      getViewportDimensions: () => ({ height: 0, width: 0 }),
      getBodyDimensions: () => ({ height: 0, width: 0 }),
      getWindowScroll: () => ({ x: 0, y: 0 }),
      setPosition: () => void 0,
      setMaxHeight: () => void 0,
      setTransformOrigin: () => void 0,
      saveFocus: () => void 0,
      restoreFocus: () => void 0,
      notifyClose: () => void 0,
      notifyClosing: () => void 0,
      notifyOpen: () => void 0,
      notifyOpening: () => void 0,
      registerWindowEventHandler: () => void 0,
      deregisterWindowEventHandler: () => void 0
    };
  }
  init() {
    const { ROOT, OPEN: OPEN2 } = MDCMenuSurfaceFoundation.cssClasses;
    if (!this.adapter.hasClass(ROOT)) {
      throw new Error(`${ROOT} class required in root element.`);
    }
    if (this.adapter.hasClass(OPEN2)) {
      this.isSurfaceOpen = true;
    }
    this.resizeListener = this.handleResize.bind(this);
    this.adapter.registerWindowEventHandler("resize", this.resizeListener);
  }
  destroy() {
    clearTimeout(this.openAnimationEndTimerId);
    clearTimeout(this.closeAnimationEndTimerId);
    cancelAnimationFrame(this.animationRequestId);
    this.adapter.deregisterWindowEventHandler("resize", this.resizeListener);
  }
  /**
   * @param corner Default anchor corner alignment of top-left menu surface
   *     corner.
   */
  setAnchorCorner(corner) {
    this.anchorCorner = corner;
  }
  /**
   * Flip menu corner horizontally.
   */
  flipCornerHorizontally() {
    this.originCorner = this.originCorner ^ CornerBit.RIGHT;
  }
  /**
   * @param margin Set of margin values from anchor.
   */
  setAnchorMargin(margin) {
    this.anchorMargin.top = margin.top || 0;
    this.anchorMargin.right = margin.right || 0;
    this.anchorMargin.bottom = margin.bottom || 0;
    this.anchorMargin.left = margin.left || 0;
  }
  /** Used to indicate if the menu-surface is hoisted to the body. */
  setIsHoisted(isHoisted) {
    this.isHoistedElement = isHoisted;
  }
  /**
   * Used to set the menu-surface calculations based on a fixed position menu.
   */
  setFixedPosition(isFixedPosition) {
    this.isFixedPosition = isFixedPosition;
  }
  /**
   * @return Returns true if menu is in fixed (`position: fixed`) position.
   */
  isFixed() {
    return this.isFixedPosition;
  }
  /** Sets the menu-surface position on the page. */
  setAbsolutePosition(x2, y2) {
    this.position.x = this.isFinite(x2) ? x2 : 0;
    this.position.y = this.isFinite(y2) ? y2 : 0;
  }
  /** Sets whether menu-surface should be horizontally centered to viewport. */
  setIsHorizontallyCenteredOnViewport(isCentered) {
    this.isHorizontallyCenteredOnViewport = isCentered;
  }
  setQuickOpen(quickOpen) {
    this.isQuickOpen = quickOpen;
  }
  /**
   * Sets maximum menu-surface height on open.
   * @param maxHeight The desired max-height. Set to 0 (default) to
   *     automatically calculate max height based on available viewport space.
   */
  setMaxHeight(maxHeight) {
    this.maxHeight = maxHeight;
  }
  /**
   * Set to a positive integer to influence the menu to preferentially open
   * below the anchor instead of above.
   * @param bias A value of `x` simulates an extra `x` pixels of available space
   *     below the menu during positioning calculations.
   */
  setOpenBottomBias(bias2) {
    this.openBottomBias = bias2;
  }
  isOpen() {
    return this.isSurfaceOpen;
  }
  /**
   * Open the menu surface.
   */
  open() {
    if (this.isSurfaceOpen) {
      return;
    }
    this.adapter.notifyOpening();
    this.adapter.saveFocus();
    if (this.isQuickOpen) {
      this.isSurfaceOpen = true;
      this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);
      this.dimensions = this.adapter.getInnerDimensions();
      this.autoposition();
      this.adapter.notifyOpen();
    } else {
      this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);
      this.animationRequestId = requestAnimationFrame(() => {
        this.dimensions = this.adapter.getInnerDimensions();
        this.autoposition();
        this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);
        this.openAnimationEndTimerId = setTimeout(() => {
          this.openAnimationEndTimerId = 0;
          this.adapter.removeClass(
            MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN
          );
          this.adapter.notifyOpen();
        }, numbers$3.TRANSITION_OPEN_DURATION);
      });
      this.isSurfaceOpen = true;
    }
    this.adapter.registerWindowEventHandler("resize", this.resizeListener);
  }
  /**
   * Closes the menu surface.
   */
  close(skipRestoreFocus = false) {
    if (!this.isSurfaceOpen) {
      return;
    }
    this.adapter.notifyClosing();
    this.adapter.deregisterWindowEventHandler("resize", this.resizeListener);
    if (this.isQuickOpen) {
      this.isSurfaceOpen = false;
      if (!skipRestoreFocus) {
        this.maybeRestoreFocus();
      }
      this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);
      this.adapter.removeClass(
        MDCMenuSurfaceFoundation.cssClasses.IS_OPEN_BELOW
      );
      this.adapter.notifyClose();
      return;
    }
    this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);
    requestAnimationFrame(() => {
      this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);
      this.adapter.removeClass(
        MDCMenuSurfaceFoundation.cssClasses.IS_OPEN_BELOW
      );
      this.closeAnimationEndTimerId = setTimeout(() => {
        this.closeAnimationEndTimerId = 0;
        this.adapter.removeClass(
          MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED
        );
        this.adapter.notifyClose();
      }, numbers$3.TRANSITION_CLOSE_DURATION);
    });
    this.isSurfaceOpen = false;
    if (!skipRestoreFocus) {
      this.maybeRestoreFocus();
    }
  }
  /** Handle clicks and close if not within menu-surface element. */
  handleBodyClick(event2) {
    const el = event2.target;
    if (this.adapter.isElementInContainer(el)) {
      return;
    }
    this.close();
  }
  /** Handle keys that close the surface. */
  handleKeydown(event2) {
    const { keyCode, key: key2 } = event2;
    const isEscape = key2 === "Escape" || keyCode === 27;
    if (isEscape) {
      this.close();
    }
  }
  /** Handles resize events on the window. */
  handleResize() {
    this.dimensions = this.adapter.getInnerDimensions();
    this.autoposition();
  }
  autoposition() {
    this.measurements = this.getAutoLayoutmeasurements();
    const corner = this.getoriginCorner();
    const maxMenuSurfaceHeight = this.getMenuSurfaceMaxHeight(corner);
    const verticalAlignment = this.hasBit(corner, CornerBit.BOTTOM) ? "bottom" : "top";
    let horizontalAlignment = this.hasBit(corner, CornerBit.RIGHT) ? "right" : "left";
    const horizontalOffset = this.getHorizontalOriginOffset(corner);
    const verticalOffset = this.getVerticalOriginOffset(corner);
    const { anchorSize, surfaceSize } = this.measurements;
    const position = {
      [horizontalAlignment]: horizontalOffset,
      [verticalAlignment]: verticalOffset
    };
    if (anchorSize.width / surfaceSize.width > numbers$3.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO) {
      horizontalAlignment = "center";
    }
    if (this.isHoistedElement || this.isFixedPosition) {
      this.adjustPositionForHoistedElement(position);
    }
    this.adapter.setTransformOrigin(
      `${horizontalAlignment} ${verticalAlignment}`
    );
    this.adapter.setPosition(position);
    this.adapter.setMaxHeight(
      maxMenuSurfaceHeight ? maxMenuSurfaceHeight + "px" : ""
    );
    if (!this.hasBit(corner, CornerBit.BOTTOM)) {
      this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.IS_OPEN_BELOW);
    }
  }
  /**
   * @return Measurements used to position menu surface popup.
   */
  getAutoLayoutmeasurements() {
    let anchorRect = this.adapter.getAnchorDimensions();
    const bodySize = this.adapter.getBodyDimensions();
    const viewportSize = this.adapter.getViewportDimensions();
    const windowScroll = this.adapter.getWindowScroll();
    if (!anchorRect) {
      anchorRect = {
        top: this.position.y,
        right: this.position.x,
        bottom: this.position.y,
        left: this.position.x,
        width: 0,
        height: 0
      };
    }
    return {
      anchorSize: anchorRect,
      bodySize,
      surfaceSize: this.dimensions,
      viewportDistance: {
        // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together
        top: anchorRect.top,
        right: viewportSize.width - anchorRect.right,
        bottom: viewportSize.height - anchorRect.bottom,
        left: anchorRect.left
        // tslint:enable:object-literal-sort-keys
      },
      viewportSize,
      windowScroll
    };
  }
  /**
   * Computes the corner of the anchor from which to animate and position the
   * menu surface.
   *
   * Only LEFT or RIGHT bit is used to position the menu surface ignoring RTL
   * context. E.g., menu surface will be positioned from right side on TOP_END.
   */
  getoriginCorner() {
    let corner = this.originCorner;
    const { viewportDistance, anchorSize, surfaceSize } = this.measurements;
    const { MARGIN_TO_EDGE } = MDCMenuSurfaceFoundation.numbers;
    const isAnchoredToBottom = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);
    let availableTop;
    let availableBottom;
    if (isAnchoredToBottom) {
      availableTop = viewportDistance.top - MARGIN_TO_EDGE + this.anchorMargin.bottom;
      availableBottom = viewportDistance.bottom - MARGIN_TO_EDGE - this.anchorMargin.bottom;
    } else {
      availableTop = viewportDistance.top - MARGIN_TO_EDGE + this.anchorMargin.top;
      availableBottom = viewportDistance.bottom - MARGIN_TO_EDGE + anchorSize.height - this.anchorMargin.top;
    }
    const isAvailableBottom = availableBottom - surfaceSize.height > 0;
    if (!isAvailableBottom && availableTop > availableBottom + this.openBottomBias) {
      corner = this.setBit(corner, CornerBit.BOTTOM);
    }
    const isRtl = this.adapter.isRtl();
    const isFlipRtl = this.hasBit(this.anchorCorner, CornerBit.FLIP_RTL);
    const hasRightBit = this.hasBit(this.anchorCorner, CornerBit.RIGHT) || this.hasBit(corner, CornerBit.RIGHT);
    let isAnchoredToRight = false;
    if (isRtl && isFlipRtl) {
      isAnchoredToRight = !hasRightBit;
    } else {
      isAnchoredToRight = hasRightBit;
    }
    let availableLeft;
    let availableRight;
    if (isAnchoredToRight) {
      availableLeft = viewportDistance.left + anchorSize.width + this.anchorMargin.left;
      availableRight = viewportDistance.right - this.anchorMargin.left;
    } else {
      availableLeft = viewportDistance.left + this.anchorMargin.left;
      availableRight = viewportDistance.right + anchorSize.width - this.anchorMargin.left;
    }
    const isAvailableLeft = availableLeft - surfaceSize.width > 0;
    const isAvailableRight = availableRight - surfaceSize.width > 0;
    const isOriginCornerAlignedToEnd = this.hasBit(corner, CornerBit.FLIP_RTL) && this.hasBit(corner, CornerBit.RIGHT);
    if (isAvailableRight && isOriginCornerAlignedToEnd && isRtl || !isAvailableLeft && isOriginCornerAlignedToEnd) {
      corner = this.unsetBit(corner, CornerBit.RIGHT);
    } else if (isAvailableLeft && isAnchoredToRight && isRtl || isAvailableLeft && !isAnchoredToRight && hasRightBit || !isAvailableRight && availableLeft >= availableRight) {
      corner = this.setBit(corner, CornerBit.RIGHT);
    }
    return corner;
  }
  /**
   * @param corner Origin corner of the menu surface.
   * @return Maximum height of the menu surface, based on available space. 0
   *     indicates should not be set.
   */
  getMenuSurfaceMaxHeight(corner) {
    if (this.maxHeight > 0) {
      return this.maxHeight;
    }
    const { viewportDistance } = this.measurements;
    let maxHeight = 0;
    const isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);
    const isBottomAnchored = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);
    const { MARGIN_TO_EDGE } = MDCMenuSurfaceFoundation.numbers;
    if (isBottomAligned) {
      maxHeight = viewportDistance.top + this.anchorMargin.top - MARGIN_TO_EDGE;
      if (!isBottomAnchored) {
        maxHeight += this.measurements.anchorSize.height;
      }
    } else {
      maxHeight = viewportDistance.bottom - this.anchorMargin.bottom + this.measurements.anchorSize.height - MARGIN_TO_EDGE;
      if (isBottomAnchored) {
        maxHeight -= this.measurements.anchorSize.height;
      }
    }
    return maxHeight;
  }
  /**
   * @param corner Origin corner of the menu surface.
   * @return Horizontal offset of menu surface origin corner from corresponding
   *     anchor corner.
   */
  getHorizontalOriginOffset(corner) {
    const { anchorSize } = this.measurements;
    const isRightAligned = this.hasBit(corner, CornerBit.RIGHT);
    const avoidHorizontalOverlap = this.hasBit(this.anchorCorner, CornerBit.RIGHT);
    if (isRightAligned) {
      const rightOffset = avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin.left : this.anchorMargin.right;
      if (this.isHoistedElement || this.isFixedPosition) {
        return rightOffset - (this.measurements.viewportSize.width - this.measurements.bodySize.width);
      }
      return rightOffset;
    }
    return avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin.right : this.anchorMargin.left;
  }
  /**
   * @param corner Origin corner of the menu surface.
   * @return Vertical offset of menu surface origin corner from corresponding
   *     anchor corner.
   */
  getVerticalOriginOffset(corner) {
    const { anchorSize } = this.measurements;
    const isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);
    const avoidVerticalOverlap = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);
    let y2 = 0;
    if (isBottomAligned) {
      y2 = avoidVerticalOverlap ? anchorSize.height - this.anchorMargin.top : -this.anchorMargin.bottom;
    } else {
      y2 = avoidVerticalOverlap ? anchorSize.height + this.anchorMargin.bottom : this.anchorMargin.top;
    }
    return y2;
  }
  /**
   * Calculates the offsets for positioning the menu-surface when the
   * menu-surface has been hoisted to the body.
   */
  adjustPositionForHoistedElement(position) {
    const { windowScroll, viewportDistance, surfaceSize, viewportSize } = this.measurements;
    const props = Object.keys(position);
    for (const prop2 of props) {
      let value = position[prop2] || 0;
      if (this.isHorizontallyCenteredOnViewport && (prop2 === "left" || prop2 === "right")) {
        position[prop2] = (viewportSize.width - surfaceSize.width) / 2;
        continue;
      }
      value += viewportDistance[prop2];
      if (!this.isFixedPosition) {
        if (prop2 === "top") {
          value += windowScroll.y;
        } else if (prop2 === "bottom") {
          value -= windowScroll.y;
        } else if (prop2 === "left") {
          value += windowScroll.x;
        } else {
          value -= windowScroll.x;
        }
      }
      position[prop2] = value;
    }
  }
  /**
   * The last focused element when the menu surface was opened should regain
   * focus, if the user is focused on or within the menu surface when it is
   * closed.
   */
  maybeRestoreFocus() {
    const isRootFocused = this.adapter.isFocused();
    const ownerDocument = this.adapter.getOwnerDocument ? this.adapter.getOwnerDocument() : document;
    const childHasFocus = ownerDocument.activeElement && this.adapter.isElementInContainer(ownerDocument.activeElement);
    if (isRootFocused || childHasFocus) {
      setTimeout(() => {
        this.adapter.restoreFocus();
      }, numbers$3.TOUCH_EVENT_WAIT_MS);
    }
  }
  hasBit(corner, bit) {
    return Boolean(corner & bit);
  }
  setBit(corner, bit) {
    return corner | bit;
  }
  unsetBit(corner, bit) {
    return corner ^ bit;
  }
  /**
   * isFinite that doesn't force conversion to number type.
   * Equivalent to Number.isFinite in ES2015, which is not supported in IE.
   */
  isFinite(num) {
    return typeof num === "number" && isFinite(num);
  }
}
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
const cssClasses$2 = {
  MENU_SELECTED_LIST_ITEM: "mdc-menu-item--selected",
  MENU_SELECTION_GROUP: "mdc-menu__selection-group",
  ROOT: "mdc-menu"
};
const strings$2 = {
  ARIA_CHECKED_ATTR: "aria-checked",
  ARIA_DISABLED_ATTR: "aria-disabled",
  CHECKBOX_SELECTOR: 'input[type="checkbox"]',
  LIST_SELECTOR: ".mdc-list,.mdc-deprecated-list",
  SELECTED_EVENT: "MDCMenu:selected",
  SKIP_RESTORE_FOCUS: "data-menu-item-skip-restore-focus"
};
const numbers$2 = {
  FOCUS_ROOT_INDEX: -1
};
var DefaultFocusState = /* @__PURE__ */ ((DefaultFocusState2) => {
  DefaultFocusState2[DefaultFocusState2["NONE"] = 0] = "NONE";
  DefaultFocusState2[DefaultFocusState2["LIST_ROOT"] = 1] = "LIST_ROOT";
  DefaultFocusState2[DefaultFocusState2["FIRST_ITEM"] = 2] = "FIRST_ITEM";
  DefaultFocusState2[DefaultFocusState2["LAST_ITEM"] = 3] = "LAST_ITEM";
  return DefaultFocusState2;
})(DefaultFocusState || {});
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
class MDCMenuFoundation extends MDCFoundation {
  constructor(adapter) {
    super({ ...MDCMenuFoundation.defaultAdapter, ...adapter });
    this.defaultFocusState = DefaultFocusState.LIST_ROOT;
    this.selectedIndex = -1;
  }
  static get cssClasses() {
    return cssClasses$2;
  }
  static get strings() {
    return strings$2;
  }
  static get numbers() {
    return numbers$2;
  }
  /**
   * @see {@link MDCMenuAdapter} for typing information on parameters and return types.
   */
  static get defaultAdapter() {
    return {
      addClassToElementAtIndex: () => void 0,
      removeClassFromElementAtIndex: () => void 0,
      addAttributeToElementAtIndex: () => void 0,
      removeAttributeFromElementAtIndex: () => void 0,
      getAttributeFromElementAtIndex: () => null,
      elementContainsClass: () => false,
      closeSurface: () => void 0,
      getElementIndex: () => -1,
      notifySelected: () => void 0,
      getMenuItemCount: () => 0,
      focusItemAtIndex: () => void 0,
      focusListRoot: () => void 0,
      getSelectedSiblingOfItemAtIndex: () => -1,
      isSelectableItemAtIndex: () => false
    };
  }
  destroy() {
    this.adapter.closeSurface();
  }
  handleKeydown(event2) {
    const { key: key2, keyCode } = event2;
    const isTab = key2 === "Tab" || keyCode === 9;
    if (isTab) {
      this.adapter.closeSurface(
        /** skipRestoreFocus */
        true
      );
    }
  }
  handleItemAction(listItem) {
    const index2 = this.adapter.getElementIndex(listItem);
    if (index2 < 0) {
      return;
    }
    this.adapter.notifySelected({ index: index2 });
    const skipRestoreFocus = this.adapter.getAttributeFromElementAtIndex(
      index2,
      strings$2.SKIP_RESTORE_FOCUS
    ) === "true";
    this.adapter.closeSurface(skipRestoreFocus);
    if (this.adapter.isSelectableItemAtIndex(index2)) {
      this.setSelectedIndex(index2);
    }
  }
  handleMenuSurfaceOpened() {
    switch (this.defaultFocusState) {
      case DefaultFocusState.FIRST_ITEM:
        this.adapter.focusItemAtIndex(0);
        break;
      case DefaultFocusState.LAST_ITEM:
        this.adapter.focusItemAtIndex(this.adapter.getMenuItemCount() - 1);
        break;
      case DefaultFocusState.NONE:
        break;
      default:
        this.adapter.focusListRoot();
        break;
    }
  }
  /**
   * Sets default focus state where the menu should focus every time when menu
   * is opened. Focuses the list root (`DefaultFocusState.LIST_ROOT`) element by
   * default.
   */
  setDefaultFocusState(focusState) {
    this.defaultFocusState = focusState;
  }
  /** @return Index of the currently selected list item within the menu. */
  getSelectedIndex() {
    return this.selectedIndex;
  }
  /**
   * Selects the list item at `index` within the menu.
   * @param index Index of list item within the menu.
   */
  setSelectedIndex(index2) {
    this.validatedIndex(index2);
    if (!this.adapter.isSelectableItemAtIndex(index2)) {
      throw new Error(
        "MDCMenuFoundation: No selection group at specified index."
      );
    }
    const prevSelectedIndex = this.adapter.getSelectedSiblingOfItemAtIndex(index2);
    if (prevSelectedIndex >= 0) {
      this.adapter.removeAttributeFromElementAtIndex(
        prevSelectedIndex,
        strings$2.ARIA_CHECKED_ATTR
      );
      this.adapter.removeClassFromElementAtIndex(
        prevSelectedIndex,
        cssClasses$2.MENU_SELECTED_LIST_ITEM
      );
    }
    this.adapter.addClassToElementAtIndex(
      index2,
      cssClasses$2.MENU_SELECTED_LIST_ITEM
    );
    this.adapter.addAttributeToElementAtIndex(
      index2,
      strings$2.ARIA_CHECKED_ATTR,
      "true"
    );
    this.selectedIndex = index2;
  }
  /**
   * Sets the enabled state to isEnabled for the menu item at the given index.
   * @param index Index of the menu item
   * @param isEnabled The desired enabled state of the menu item.
   */
  setEnabled(index2, isEnabled) {
    this.validatedIndex(index2);
    if (isEnabled) {
      this.adapter.removeClassFromElementAtIndex(
        index2,
        cssClasses$4.LIST_ITEM_DISABLED_CLASS
      );
      this.adapter.addAttributeToElementAtIndex(
        index2,
        strings$2.ARIA_DISABLED_ATTR,
        "false"
      );
    } else {
      this.adapter.addClassToElementAtIndex(
        index2,
        cssClasses$4.LIST_ITEM_DISABLED_CLASS
      );
      this.adapter.addAttributeToElementAtIndex(
        index2,
        strings$2.ARIA_DISABLED_ATTR,
        "true"
      );
    }
  }
  validatedIndex(index2) {
    const menuSize = this.adapter.getMenuItemCount();
    const isIndexInRange = index2 >= 0 && index2 < menuSize;
    if (!isIndexInRange) {
      throw new Error("MDCMenuFoundation: No list item at specified index.");
    }
  }
}
var root$l = /* @__PURE__ */ from_html(`<div><!></div>`);
function MenuSurface($$anchor, $$props) {
  push($$props, true);
  let use = prop($$props, "use", 19, () => []), className = prop($$props, "class", 3, ""), style = prop($$props, "style", 3, ""), isStatic = prop($$props, "static", 3, false), anchor = prop($$props, "anchor", 3, true), fixed = prop($$props, "fixed", 3, false), open = prop($$props, "open", 31, () => proxy$1(isStatic())), managed = prop($$props, "managed", 3, false), fullWidth = prop($$props, "fullWidth", 3, false), quickOpen = prop($$props, "quickOpen", 3, false), anchorElement = prop($$props, "anchorElement", 15), anchorMargin = prop($$props, "anchorMargin", 19, () => ({ top: 0, right: 0, bottom: 0, left: 0 })), maxHeight = prop($$props, "maxHeight", 3, 0), horizontallyCenteredOnViewport = prop($$props, "horizontallyCenteredOnViewport", 3, false), openBottomBias = prop($$props, "openBottomBias", 3, 0), neverRestoreFocus = prop($$props, "neverRestoreFocus", 3, false), hoisted = prop($$props, "hoisted", 3, false), restProps = /* @__PURE__ */ rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "use",
    "class",
    "style",
    "static",
    "anchor",
    "fixed",
    "open",
    "managed",
    "fullWidth",
    "quickOpen",
    "anchorElement",
    "anchorCorner",
    "anchorMargin",
    "maxHeight",
    "horizontallyCenteredOnViewport",
    "openBottomBias",
    "neverRestoreFocus",
    "hoisted",
    "children"
  ]);
  let element2;
  let instance = /* @__PURE__ */ state(void 0);
  let internalClasses = proxy$1({});
  let internalStyles = proxy$1({});
  let previousFocus = /* @__PURE__ */ state(void 0);
  setContext("SMUI:list:role", "menu");
  setContext("SMUI:list:item:role", "menuitem");
  user_effect(() => {
    var _a3, _b3;
    if (element2 && anchor() && !((_a3 = element2.parentElement) == null ? void 0 : _a3.classList.contains("mdc-menu-surface--anchor"))) {
      (_b3 = element2.parentElement) == null ? void 0 : _b3.classList.add("mdc-menu-surface--anchor");
      anchorElement(element2.parentElement ?? void 0);
    }
  });
  user_effect(() => {
    if (get$1(instance) && get$1(instance).isOpen() !== open()) {
      if (open()) {
        get$1(instance).open();
      } else {
        get$1(instance).close();
      }
    }
  });
  user_effect(() => {
    if (hoisted() && get$1(instance)) {
      get$1(instance).setIsHoisted(hoisted());
    }
  });
  user_effect(() => {
    if (get$1(instance)) {
      get$1(instance).setQuickOpen(quickOpen());
    }
  });
  user_effect(() => {
    if (get$1(instance)) {
      get$1(instance).setFixedPosition(fixed());
    }
  });
  user_effect(() => {
    if (get$1(instance)) {
      get$1(instance).setMaxHeight(maxHeight());
    }
  });
  user_effect(() => {
    if (get$1(instance)) {
      get$1(instance).setIsHorizontallyCenteredOnViewport(horizontallyCenteredOnViewport());
    }
  });
  const iCorner = Corner;
  user_effect(() => {
    if (get$1(instance) && $$props.anchorCorner != null) {
      if (typeof $$props.anchorCorner === "string") {
        get$1(instance).setAnchorCorner(iCorner[$$props.anchorCorner]);
      } else {
        get$1(instance).setAnchorCorner($$props.anchorCorner);
      }
    }
  });
  user_effect(() => {
    if (get$1(instance)) {
      get$1(instance).setAnchorMargin(anchorMargin());
    }
  });
  user_effect(() => {
    if (get$1(instance)) {
      get$1(instance).setOpenBottomBias(openBottomBias());
    }
  });
  const SMUIMenuSurfaceMount = getContext("SMUI:menu-surface:mount");
  const SMUIMenuSurfaceUnmount = getContext("SMUI:menu-surface:unmount");
  onMount(() => {
    set(
      instance,
      new MDCMenuSurfaceFoundation({
        addClass,
        removeClass,
        hasClass,
        hasAnchor: () => !!anchorElement(),
        notifyClose: () => {
          if (!managed()) {
            open(isStatic());
          }
          if (!open()) {
            dispatch(getElement(), "SMUIMenuSurfaceClosed");
          }
        },
        notifyClosing: () => {
          if (!managed()) {
            open(isStatic());
          }
          if (!open()) {
            dispatch(getElement(), "SMUIMenuSurfaceClosing");
          }
        },
        notifyOpen: () => {
          if (!managed()) {
            open(true);
          }
          if (open()) {
            dispatch(getElement(), "SMUIMenuSurfaceOpened");
          }
        },
        notifyOpening: () => {
          if (!open()) {
            dispatch(getElement(), "SMUIMenuSurfaceOpening");
          }
        },
        isElementInContainer: (el) => getElement().contains(el),
        isRtl: () => getComputedStyle(getElement()).getPropertyValue("direction") === "rtl",
        setTransformOrigin: (origin) => {
          internalStyles["transform-origin"] = origin;
        },
        isFocused: () => document.activeElement === getElement(),
        saveFocus: () => {
          set(previousFocus, document.activeElement ?? void 0, true);
        },
        restoreFocus: () => {
          if (!neverRestoreFocus() && (!element2 || getElement().contains(document.activeElement)) && get$1(previousFocus) && document.contains(get$1(previousFocus)) && "focus" in get$1(previousFocus)) {
            get$1(previousFocus).focus();
          }
        },
        getInnerDimensions: () => {
          const el = getElement();
          const display = getComputedStyle(el).display;
          const displayNone = display === "none";
          if (displayNone) el.classList.add("smui-menu-surface--measure");
          let width = getElement().offsetWidth;
          let height = getElement().offsetHeight;
          if (displayNone) el.classList.remove("smui-menu-surface--measure");
          return { width, height };
        },
        getAnchorDimensions: () => anchorElement() ? anchorElement().getBoundingClientRect() : null,
        getViewportDimensions: () => {
          return { width: window.innerWidth, height: window.innerHeight };
        },
        getBodyDimensions: () => {
          return {
            width: document.body.clientWidth,
            height: document.body.clientHeight
          };
        },
        getWindowScroll: () => {
          return { x: window.pageXOffset, y: window.pageYOffset };
        },
        setPosition: (position) => {
          internalStyles.left = "left" in position ? `${position.left}px` : "";
          internalStyles.right = "right" in position ? `${position.right}px` : "";
          internalStyles.top = "top" in position ? `${position.top}px` : "";
          internalStyles.bottom = "bottom" in position ? `${position.bottom}px` : "";
        },
        setMaxHeight: (height) => {
          internalStyles["max-height"] = height;
        }
      }),
      true
    );
    const accessor = {
      get open() {
        return open();
      },
      set open(value) {
        open(value);
      },
      closeProgrammatic
    };
    SMUIMenuSurfaceMount && SMUIMenuSurfaceMount(accessor);
    get$1(instance).init();
    return () => {
      var _a3, _b3;
      SMUIMenuSurfaceUnmount && SMUIMenuSurfaceUnmount(accessor);
      const isHoisted = get$1(instance).isHoistedElement;
      (_a3 = get$1(instance)) == null ? void 0 : _a3.destroy();
      if (isHoisted) {
        (_b3 = getElement().parentNode) == null ? void 0 : _b3.removeChild(getElement());
      }
      element2 = null;
      set(instance, null);
    };
  });
  onMount(() => {
    document.body.addEventListener("pointerup", handleBodyClick, { capture: true });
    return () => {
      document.body.removeEventListener("pointerup", handleBodyClick, { capture: true });
    };
  });
  onDestroy(() => {
    var _a3;
    if (anchor()) {
      getElement() && ((_a3 = getElement().parentElement) == null ? void 0 : _a3.classList.remove("mdc-menu-surface--anchor"));
    }
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      internalClasses[className2] = true;
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      internalClasses[className2] = false;
    }
  }
  function closeProgrammatic(skipRestoreFocus) {
    var _a3;
    (_a3 = get$1(instance)) == null ? void 0 : _a3.close(skipRestoreFocus);
    open(false);
  }
  function handleBodyClick(event2) {
    if (get$1(instance) && open() && !managed()) {
      get$1(instance).handleBodyClick(event2);
    }
  }
  function isOpen() {
    return open();
  }
  function setOpen(value) {
    open(value);
  }
  function setAbsolutePosition(x2, y2) {
    if (get$1(instance) == null) {
      throw new Error("Instance is not defined.");
    }
    return get$1(instance).setAbsolutePosition(x2, y2);
  }
  function setIsHoisted(isHoisted) {
    if (get$1(instance) == null) {
      throw new Error("Instance is not defined.");
    }
    return get$1(instance).setIsHoisted(isHoisted);
  }
  function isFixed() {
    if (get$1(instance) == null) {
      throw new Error("Instance is not defined.");
    }
    return get$1(instance).isFixed();
  }
  function flipCornerHorizontally() {
    if (get$1(instance) == null) {
      throw new Error("Instance is not defined.");
    }
    return get$1(instance).flipCornerHorizontally();
  }
  function getElement() {
    return element2;
  }
  function getMDCMenuSurfaceFoundation() {
    return get$1(instance);
  }
  var div = root$l();
  var event_handler = (e2) => {
    var _a3;
    if (get$1(instance) && !managed()) {
      get$1(instance).handleKeydown(e2);
    }
    (_a3 = $$props.onkeydown) == null ? void 0 : _a3.call($$props, e2);
  };
  attribute_effect(
    div,
    ($0, $1) => ({
      class: $0,
      style: $1,
      role: "dialog",
      ...restProps,
      onkeydown: event_handler
    }),
    [
      () => classMap({
        [className()]: true,
        "mdc-menu-surface": true,
        "mdc-menu-surface--fixed": fixed(),
        "mdc-menu-surface--open": isStatic(),
        "smui-menu-surface--static": isStatic(),
        "mdc-menu-surface--fullwidth": fullWidth(),
        ...internalClasses
      }),
      () => Object.entries(internalStyles).map(([name, value]) => `${name}: ${value};`).concat([style()]).join(" ")
    ]
  );
  var node = child(div);
  snippet(node, () => $$props.children ?? noop$1);
  bind_this(div, ($$value) => element2 = $$value, () => element2);
  action(div, ($$node, $$action_arg) => useActions == null ? void 0 : useActions($$node, $$action_arg), use);
  append($$anchor, div);
  return pop({
    isOpen,
    setOpen,
    setAbsolutePosition,
    setIsHoisted,
    isFixed,
    flipCornerHorizontally,
    getElement,
    getMDCMenuSurfaceFoundation
  });
}
function Anchor(node, {
  addClass = (className) => node.classList.add(className),
  removeClass = (className) => node.classList.remove(className)
} = {}) {
  addClass("mdc-menu-surface--anchor");
  return {
    destroy() {
      removeClass("mdc-menu-surface--anchor");
    }
  };
}
function Menu($$anchor, $$props) {
  push($$props, true);
  const { closest: closest2 } = ponyfill;
  let use = prop($$props, "use", 19, () => []), className = prop($$props, "class", 3, ""), open = prop($$props, "open", 15, false), anchorElement = prop($$props, "anchorElement", 15), managed = prop($$props, "managed", 3, false), restProps = /* @__PURE__ */ rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "use",
    "class",
    "open",
    "anchorElement",
    "managed",
    "children"
  ]);
  let element2;
  let instance = /* @__PURE__ */ state(void 0);
  let menuSurfaceAccessor = /* @__PURE__ */ state(void 0);
  let listAccessor = /* @__PURE__ */ state(void 0);
  setContext("SMUI:menu-surface:mount", (accessor) => {
    if (!get$1(menuSurfaceAccessor)) {
      set(menuSurfaceAccessor, accessor, true);
    }
  });
  const SMUIListMount = getContext("SMUI:list:mount");
  setContext("SMUI:list:mount", (accessor) => {
    if (!get$1(listAccessor)) {
      set(listAccessor, accessor, true);
    }
    SMUIListMount == null ? void 0 : SMUIListMount(accessor);
  });
  const SMUIMenuMount = getContext("SMUI:menu:mount");
  const SMUIMenuUnmount = getContext("SMUI:menu:unmount");
  onMount(() => {
    set(
      instance,
      new MDCMenuFoundation({
        addClassToElementAtIndex: (index2, className2) => {
          if (get$1(listAccessor) == null) {
            throw new Error("List accessor is undefined.");
          }
          get$1(listAccessor).addClassForElementIndex(index2, className2);
        },
        removeClassFromElementAtIndex: (index2, className2) => {
          if (get$1(listAccessor) == null) {
            throw new Error("List accessor is undefined.");
          }
          get$1(listAccessor).removeClassForElementIndex(index2, className2);
        },
        addAttributeToElementAtIndex: (index2, attr, value) => {
          if (get$1(listAccessor) == null) {
            throw new Error("List accessor is undefined.");
          }
          get$1(listAccessor).setAttributeForElementIndex(index2, attr, value);
        },
        removeAttributeFromElementAtIndex: (index2, attr) => {
          if (get$1(listAccessor) == null) {
            throw new Error("List accessor is undefined.");
          }
          get$1(listAccessor).removeAttributeForElementIndex(index2, attr);
        },
        getAttributeFromElementAtIndex: (index2, attr) => {
          if (get$1(listAccessor) == null) {
            throw new Error("List accessor is undefined.");
          }
          return get$1(listAccessor).getAttributeFromElementIndex(index2, attr);
        },
        elementContainsClass: (element3, className2) => element3.classList.contains(className2),
        closeSurface: (skipRestoreFocus) => {
          var _a3;
          if (!managed()) {
            (_a3 = get$1(menuSurfaceAccessor)) == null ? void 0 : _a3.closeProgrammatic(skipRestoreFocus);
            const el = getElement();
            if (!el) return;
            dispatch(getElement(), "SMUIMenuClosedProgrammatically");
          }
        },
        getElementIndex: (element3) => {
          if (get$1(listAccessor) == null) {
            throw new Error("List accessor is undefined.");
          }
          return get$1(listAccessor).getOrderedList().map((accessor) => accessor.element).indexOf(element3);
        },
        notifySelected: (evtData) => {
          if (get$1(listAccessor) == null) {
            throw new Error("List accessor is undefined.");
          }
          dispatch(getElement(), "SMUIMenuSelected", {
            index: evtData.index,
            item: get$1(listAccessor).getOrderedList()[evtData.index].element
          });
        },
        getMenuItemCount: () => {
          if (get$1(listAccessor) == null) {
            throw new Error("List accessor is undefined.");
          }
          return get$1(listAccessor).items.length;
        },
        focusItemAtIndex: (index2) => {
          if (get$1(listAccessor) == null) {
            throw new Error("List accessor is undefined.");
          }
          get$1(listAccessor).focusItemAtIndex(index2);
        },
        focusListRoot: () => {
          if (get$1(listAccessor) == null) {
            throw new Error("List accessor is undefined.");
          }
          if ("focus" in get$1(listAccessor).element) {
            get$1(listAccessor).element.focus();
          }
        },
        isSelectableItemAtIndex: (index2) => {
          if (get$1(listAccessor) == null) {
            throw new Error("List accessor is undefined.");
          }
          return !!closest2(get$1(listAccessor).getOrderedList()[index2].element, `.${cssClasses$2.MENU_SELECTION_GROUP}`);
        },
        getSelectedSiblingOfItemAtIndex: (index2) => {
          if (get$1(listAccessor) == null) {
            throw new Error("List accessor is undefined.");
          }
          const orderedList = get$1(listAccessor).getOrderedList();
          const selectionGroupEl = closest2(orderedList[index2].element, `.${cssClasses$2.MENU_SELECTION_GROUP}`);
          const selectedItemEl = selectionGroupEl == null ? void 0 : selectionGroupEl.querySelector(`.${cssClasses$2.MENU_SELECTED_LIST_ITEM}`);
          return selectedItemEl ? orderedList.map((item) => item.element).indexOf(selectedItemEl) : -1;
        }
      }),
      true
    );
    SMUIMenuMount == null ? void 0 : SMUIMenuMount(get$1(instance));
    get$1(instance).init();
    return () => {
      var _a3;
      if (SMUIMenuUnmount && get$1(instance)) {
        SMUIMenuUnmount(get$1(instance));
      }
      (_a3 = get$1(instance)) == null ? void 0 : _a3.destroy();
      element2 = null;
      set(instance, null);
    };
  });
  function isOpen() {
    return open();
  }
  function setOpen(value) {
    open(value);
  }
  function setDefaultFocusState(focusState) {
    if (get$1(instance) == null) {
      throw new Error("Instance is undefined.");
    }
    get$1(instance).setDefaultFocusState(focusState);
  }
  function getSelectedIndex() {
    if (get$1(instance) == null) {
      throw new Error("Instance is undefined.");
    }
    return get$1(instance).getSelectedIndex();
  }
  function getMenuSurface() {
    return element2;
  }
  function getElement() {
    return element2.getElement();
  }
  {
    let $0 = /* @__PURE__ */ user_derived(() => classMap({ [className()]: true, "mdc-menu": true }));
    bind_this(
      MenuSurface($$anchor, spread_props(
        {
          get use() {
            return use();
          },
          get class() {
            return get$1($0);
          },
          get managed() {
            return managed();
          }
        },
        () => restProps,
        {
          onkeydown: (e2) => {
            var _a3;
            (_a3 = $$props.onkeydown) == null ? void 0 : _a3.call($$props, e2);
          },
          onSMUIMenuSurfaceOpened: (e2) => {
            var _a3;
            if (get$1(instance)) {
              get$1(instance).handleMenuSurfaceOpened();
            }
            (_a3 = $$props.onSMUIMenuSurfaceOpened) == null ? void 0 : _a3.call($$props, e2);
          },
          onSMUIListAction: (e2) => {
            var _a3;
            if (get$1(instance) && get$1(listAccessor)) {
              get$1(instance).handleItemAction(get$1(listAccessor).getOrderedList()[e2.detail.index].element);
            }
            (_a3 = $$props.onSMUIListAction) == null ? void 0 : _a3.call($$props, e2);
          },
          get open() {
            return open();
          },
          set open($$value) {
            open($$value);
          },
          get anchorElement() {
            return anchorElement();
          },
          set anchorElement($$value) {
            anchorElement($$value);
          },
          children: ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node = first_child(fragment_1);
            snippet(node, () => $$props.children ?? noop$1);
            append($$anchor2, fragment_1);
          },
          $$slots: { default: true }
        }
      )),
      ($$value) => element2 = $$value,
      () => element2
    );
  }
  return pop({
    isOpen,
    setOpen,
    setDefaultFocusState,
    getSelectedIndex,
    getMenuSurface,
    getElement
  });
}
var root_3$2 = /* @__PURE__ */ from_svg(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><path fill="currentColor" d="M22 9.06 11 20 6 14.7l1.09-1.02 3.94 4.16L20.94 8 22 9.06Z"></path></svg>`);
var root_2$9 = /* @__PURE__ */ from_html(`<div class="icon svelte-7noaux"><!></div> <div class="content svelte-7noaux"><span> </span> <span class="kb svelte-7noaux"> </span></div>`, 1);
const $$css$o = {
  hash: "svelte-7noaux",
  code: ".icon.svelte-7noaux {width:28px;height:28px;margin-left:8px;}.content.svelte-7noaux {flex-grow:1;display:flex;align-items:center;justify-content:space-between;padding:0 20px 0 6px;font-size:14px;}.kb.svelte-7noaux {font-size:12px;margin-left:10px;white-space:nowrap;color:var(--cl-listKeybinding-foreground);}"
};
function AxisMode($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$o);
  const [$$stores, $$cleanup] = setup_stores();
  const $priceScaleOptions = () => store_get(priceScaleOptions, "$priceScaleOptions", $$stores);
  const { t: t2 } = useTranslation();
  const chartManagementService = useService(IChartManagementService);
  const chartService = chartManagementService.chart($$props.chartIndex);
  const priceScaleOptions = derived(chartManagementService.store, (store) => store.instances[$$props.chartIndex].chartOptions.rightPriceScale);
  const chartContainer = chartService.getContainerDomElement();
  const container = ensure(chartContainer.querySelector("tr:last-of-type td:last-of-type"));
  Object.assign(container.style, { position: "relative" });
  const PriceScaleModes = [
    {
      label: "priceAxis.mode.regular",
      value: vi.Normal
    },
    {
      label: "priceAxis.mode.percent",
      value: vi.Percentage,
      kb: kbPercent
    },
    {
      label: "priceAxis.mode.log",
      value: vi.Logarithmic,
      kb: kbLog
    }
  ];
  const togglePriceScaleMode = (item) => {
    chartService.chartApi.applyOptions({
      rightPriceScale: {
        mode: get(priceScaleOptions).mode === item.value ? vi.Normal : item.value
      }
    });
  };
  var fragment = comment();
  var node = first_child(fragment);
  each(node, 17, () => PriceScaleModes, index, ($$anchor2, mode) => {
    {
      let $0 = /* @__PURE__ */ user_derived(() => get$1(mode).value === $priceScaleOptions().mode);
      let $1 = /* @__PURE__ */ user_derived(() => ifLeftClick(() => togglePriceScaleMode(get$1(mode))));
      Item($$anchor2, {
        class: "row",
        get selected() {
          return get$1($0);
        },
        get onpointerup() {
          return get$1($1);
        },
        children: ($$anchor3, $$slotProps) => {
          var fragment_2 = root_2$9();
          var div = first_child(fragment_2);
          var node_1 = child(div);
          {
            var consequent = ($$anchor4) => {
              var svg = root_3$2();
              append($$anchor4, svg);
            };
            if_block(node_1, ($$render) => {
              if (get$1(mode).value === $priceScaleOptions().mode) $$render(consequent);
            });
          }
          var div_1 = sibling(div, 2);
          var span = child(div_1);
          var text2 = child(span);
          var span_1 = sibling(span, 2);
          var text_1 = child(span_1);
          template_effect(
            ($02, $12) => {
              set_text(text2, $02);
              set_text(text_1, $12);
            },
            [
              () => t2(get$1(mode).label),
              () => get$1(mode).kb ? getKeybindingLabel(get$1(mode).kb) : ""
            ]
          );
          append($$anchor3, fragment_2);
        },
        $$slots: { default: true }
      });
    }
  });
  append($$anchor, fragment);
  pop();
  $$cleanup();
}
var root_1$i = /* @__PURE__ */ from_html(`<div class="content svelte-kbrhp8"> </div> <div class="chevron svelte-kbrhp8"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 16" width="10" height="16" class="svelte-kbrhp8"><path d="M.6 1.4l1.4-1.4 8 8-8 8-1.4-1.4 6.389-6.532-6.389-6.668z"></path></svg></div>`, 1);
var root_7$4 = /* @__PURE__ */ from_svg(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28" class="svelte-kbrhp8"><path fill="currentColor" d="M22 9.06 11 20 6 14.7l1.09-1.02 3.94 4.16L20.94 8 22 9.06Z"></path></svg>`);
var root_6$4 = /* @__PURE__ */ from_html(`<div class="icon svelte-kbrhp8"><!></div> <div class="tzTitle svelte-kbrhp8"> </div>`, 1);
var root$k = /* @__PURE__ */ from_html(`<!> <!>`, 1);
const $$css$n = {
  hash: "svelte-kbrhp8",
  code: '.content.svelte-kbrhp8 {flex-grow:1;display:flex;align-items:center;justify-content:space-between;margin-left:36px;padding:0 20px 0 6px;font-size:14px;}.chevron.svelte-kbrhp8 svg:where(.svelte-kbrhp8) {width:10px;height:10px;color:currentColor;} .cl-tz-dropdown {-webkit-font-smoothing:antialiased;-webkit-text-size-adjust:100%;font-variation-settings:normal;font-feature-settings:"tnum" on, "lnum" on, "rlig" 1, "calt" 1;font-family:var(--cl-font-family);border-radius:6px;box-shadow:var(--cl-dialog-shadow) 0px 2px 4px 0px;background-color:var(--cl-background);height:100%;overflow-x:hidden;overflow-y:auto;overscroll-behavior:contain;display:flex;flex-direction:column;background:var(--cl-background);user-select:none;cursor:default;z-index:2;padding:6px 0;} .cl-tz-dropdown::-webkit-scrollbar {-webkit-appearance:none;width:3px;height:3px;} .cl-tz-dropdown::-webkit-scrollbar-corner {display:none;} .cl-tz-dropdown::-webkit-scrollbar-thumb {background-clip:content-box;background-color:var(--cl-scrollbarThumb-background);border-radius:3px;} .cl-tz-dropdown::-webkit-scrollbar-track {background-color:initial;border-radius:3px;} .cl-tz-dropdown .mdc-deprecated-list {margin:0;padding:0;list-style:none;} .cl-tz-dropdown .row {height:32px;display:flex;flex-direction:row;align-items:center;flex-flow:row nowrap;color:var(--cl-listItem-foreground);}\n@media (hover: hover) and (pointer: fine) { .cl-tz-dropdown .row:hover:not(.mdc-deprecated-list-item--selected):not(.mdc-deprecated-list-item--disabled) {background-color:var(--cl-listItem-hoverBackground);}\n} .cl-tz-dropdown .mdc-deprecated-list-item--selected {color:var(--cl-listItem-selectedForeground);background:var(--cl-listItem-selectedBackground);}.icon.svelte-kbrhp8 {width:36px;padding-left:8px;}.icon.svelte-kbrhp8 svg:where(.svelte-kbrhp8) {width:28px;height:28px;}.tzTitle.svelte-kbrhp8 {padding-left:6px;padding-right:20px;font-size:14px;}'
};
function Timezone($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$n);
  const [$$stores, $$cleanup] = setup_stores();
  const $timezone = () => store_get(timezone, "$timezone", $$stores);
  let open = /* @__PURE__ */ state(false);
  let anchor;
  let subMenu;
  let anchorElement = /* @__PURE__ */ state(void 0);
  let anchorClasses = proxy$1({});
  function addClass(className) {
    if (!anchorClasses[className]) {
      anchorClasses[className] = true;
    }
  }
  function removeClass(className) {
    if (anchorClasses[className]) {
      delete anchorClasses[className];
    }
  }
  const { t: t2 } = useTranslation();
  const chartManagementService = useService(IChartManagementService);
  const guiService = useService(IGuiService);
  const chartService = chartManagementService.chart($$props.chartIndex);
  const timezone = derived(chartManagementService.store, (store) => store.instances[$$props.chartIndex].chartProperties.timezone);
  const list = chartService.getTimezoneApi().availableTimezones();
  const handleSelecte = (item) => {
    chartService.getTimezoneApi().setTimezone(item.id);
    subMenu.setOpen(false);
  };
  let cleanupLazyLeave = null;
  let cleanupLazyEnter = null;
  const show = () => {
    cleanupLazyEnter == null ? void 0 : cleanupLazyEnter();
    cleanupLazyLeave == null ? void 0 : cleanupLazyLeave();
    cleanupLazyEnter = scheduleTimeout(
      () => {
        if (!$$props.anchorOpen) return;
        set(open, true);
      },
      300
    );
  };
  const hide = () => {
    cleanupLazyLeave == null ? void 0 : cleanupLazyLeave();
    cleanupLazyEnter == null ? void 0 : cleanupLazyEnter();
    cleanupLazyLeave = scheduleTimeout(
      () => {
        set(open, false);
      },
      500
    );
  };
  onMount(() => {
    set(anchorElement, anchor.getElement(), true);
    const subMenuElement = subMenu.getElement();
    const cleanups = [
      on(get$1(anchorElement), "mouseenter", () => {
        show();
      }),
      on(subMenuElement, "mouseenter", () => {
        show();
      }),
      on(get$1(anchorElement), "mouseleave", (event2) => {
        if (subMenuElement == null ? void 0 : subMenuElement.contains(event2.relatedTarget)) {
          return;
        }
        hide();
      }),
      on(subMenuElement, "mouseleave", (event2) => {
        var _a3;
        if ((_a3 = get$1(anchorElement)) == null ? void 0 : _a3.contains(event2.relatedTarget)) {
          return;
        }
        hide();
      })
    ];
    return () => {
      cleanups.forEach((c2) => c2());
    };
  });
  const getLabel = (info) => {
    if (info.title) return info.title;
    if (info.offsetStr) {
      return `(${info.offsetStr}) ${t2(info.titleI18nKey)}`;
    } else {
      return t2(info.titleI18nKey);
    }
  };
  const handleToggle = () => {
    if (!get$1(open)) {
      show();
    }
  };
  var fragment = root$k();
  var node = first_child(fragment);
  {
    let $0 = /* @__PURE__ */ user_derived(() => ["row", ...Object.keys(anchorClasses)].join(" "));
    let $1 = /* @__PURE__ */ user_derived(() => [[Anchor, { addClass, removeClass }]]);
    bind_this(
      Item(node, {
        nonInteractive: true,
        get class() {
          return get$1($0);
        },
        get use() {
          return get$1($1);
        },
        onclick: handleToggle,
        children: ($$anchor2, $$slotProps) => {
          var fragment_1 = root_1$i();
          var div = first_child(fragment_1);
          var text2 = child(div);
          template_effect(($02) => set_text(text2, $02), [() => t2("setting.timezone")]);
          append($$anchor2, fragment_1);
        },
        $$slots: { default: true }
      }),
      ($$value) => anchor = $$value,
      () => anchor
    );
  }
  var node_1 = sibling(node, 2);
  Portal(node_1, {
    get target() {
      return guiService.root;
    },
    children: ($$anchor2, $$slotProps) => {
      bind_this(
        Menu($$anchor2, {
          hoisted: true,
          managed: true,
          anchor: false,
          quickOpen: true,
          get anchorElement() {
            return get$1(anchorElement);
          },
          anchorCorner: "TOP_RIGHT",
          class: "cl-tz-dropdown",
          get open() {
            return get$1(open);
          },
          set open($$value) {
            set(open, $$value, true);
          },
          children: ($$anchor3, $$slotProps2) => {
            List($$anchor3, {
              children: ($$anchor4, $$slotProps3) => {
                var fragment_4 = comment();
                var node_2 = first_child(fragment_4);
                each(node_2, 17, () => list, (item) => item.id, ($$anchor5, item) => {
                  {
                    let $0 = /* @__PURE__ */ user_derived(() => $timezone() === get$1(item).id);
                    Item($$anchor5, {
                      get selected() {
                        return get$1($0);
                      },
                      onclick: () => handleSelecte(get$1(item)),
                      class: "row",
                      children: ($$anchor6, $$slotProps4) => {
                        var fragment_6 = root_6$4();
                        var div_1 = first_child(fragment_6);
                        var node_3 = child(div_1);
                        {
                          var consequent = ($$anchor7) => {
                            var svg = root_7$4();
                            append($$anchor7, svg);
                          };
                          if_block(node_3, ($$render) => {
                            if ($timezone() === get$1(item).id) $$render(consequent);
                          });
                        }
                        var div_2 = sibling(div_1, 2);
                        var text_1 = child(div_2);
                        template_effect(($02) => set_text(text_1, $02), [() => getLabel(get$1(item))]);
                        append($$anchor6, fragment_6);
                      },
                      $$slots: { default: true }
                    });
                  }
                });
                append($$anchor4, fragment_4);
              },
              $$slots: { default: true }
            });
          },
          $$slots: { default: true }
        }),
        ($$value) => subMenu = $$value,
        () => subMenu
      );
    },
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  pop();
  $$cleanup();
}
var root_5$3 = /* @__PURE__ */ from_html(`<div class="separator svelte-8zsjyu"></div> <!>`, 1);
var root_4$7 = /* @__PURE__ */ from_html(`<!> <!>`, 1);
var root_3$1 = /* @__PURE__ */ from_html(`<div class="axisMenu svelte-8zsjyu"><!></div>`);
var root$j = /* @__PURE__ */ from_html(`<div class="anchor svelte-8zsjyu"><!></div>`);
const $$css$m = {
  hash: "svelte-8zsjyu",
  code: '.cl-axis-setting-dropdown {border-radius:6px;box-shadow:var(--cl-dialog-shadow) 0px 2px 4px 0px;background-color:var(--cl-background);-webkit-font-smoothing:antialiased;-webkit-text-size-adjust:100%;font-variation-settings:normal;font-feature-settings:"tnum" on, "lnum" on, "rlig" 1, "calt" 1;font-family:var(--cl-font-family);padding:6px 0;}.anchor.svelte-8zsjyu {position:absolute;top:0;bottom:0;left:0;width:0;}.axisMenu.svelte-8zsjyu {display:flex;flex-direction:column;background:var(--cl-background);user-select:none;cursor:default;z-index:2;}.axisMenu.svelte-8zsjyu .mdc-deprecated-list {margin:0;padding:0;list-style:none;} .axisMenu .row {height:32px;display:flex;flex-direction:row;align-items:center;padding-right:20px;color:var(--cl-listItem-foreground);background:var(--cl-listItem-background);white-space:nowrap;user-select:none;cursor:default;}\n@media (hover: hover) and (pointer: fine) { .axisMenu .row:hover {background-color:var(--cl-listItem-hoverBackground);}\n}.separator.svelte-8zsjyu {width:100%;height:1px;margin:6px 0;background:var(--cl-gutter-background);}'
};
function SettingMenu($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$m);
  let open = prop($$props, "open", 15, false);
  const configurationService = useService(IConfigurationService);
  const chartManagementService = useService(IChartManagementService);
  const guiService = useService(IGuiService);
  const chartService = chartManagementService.chart($$props.chartIndex);
  const chartContainer = chartService.getContainerDomElement();
  const container = ensure(chartContainer.querySelector("tr:last-of-type td:last-of-type"));
  const showTimezonEMenu = configurationService.featureEnabled("timezone_menu");
  Object.assign(container.style, { position: "relative" });
  let div;
  let anchorElement;
  user_effect(() => {
    if (div && !hasFingerprint(div)) {
      PartFingerprints.write(div, PartFingerprint.AxisSetting);
    }
  });
  var div_1 = root$j();
  var node = child(div_1);
  Portal(node, {
    get target() {
      return guiService.root;
    },
    children: ($$anchor2, $$slotProps) => {
      Scheduler($$anchor2, {
        macro: true,
        children: ($$anchor3, $$slotProps2) => {
          Menu($$anchor3, {
            anchor: false,
            get anchorElement() {
              return anchorElement;
            },
            quickOpen: true,
            hoisted: true,
            class: "cl-axis-setting-dropdown",
            get open() {
              return open();
            },
            set open($$value) {
              open($$value);
            },
            children: ($$anchor4, $$slotProps3) => {
              var div_2 = root_3$1();
              var node_1 = child(div_2);
              List(node_1, {
                children: ($$anchor5, $$slotProps4) => {
                  var fragment_2 = root_4$7();
                  var node_2 = first_child(fragment_2);
                  AxisMode(node_2, {
                    get chartIndex() {
                      return $$props.chartIndex;
                    }
                  });
                  var node_3 = sibling(node_2, 2);
                  {
                    var consequent = ($$anchor6) => {
                      var fragment_3 = root_5$3();
                      var node_4 = sibling(first_child(fragment_3), 2);
                      Timezone(node_4, {
                        get chartIndex() {
                          return $$props.chartIndex;
                        },
                        get anchorOpen() {
                          return open();
                        }
                      });
                      append($$anchor6, fragment_3);
                    };
                    if_block(node_3, ($$render) => {
                      if (showTimezonEMenu) $$render(consequent);
                    });
                  }
                  append($$anchor5, fragment_2);
                },
                $$slots: { default: true }
              });
              bind_this(div_2, ($$value) => div = $$value, () => div);
              append($$anchor4, div_2);
            },
            $$slots: { default: true }
          });
        },
        $$slots: { default: true }
      });
    },
    $$slots: { default: true }
  });
  bind_this(div_1, ($$value) => anchorElement = $$value, () => anchorElement);
  append($$anchor, div_1);
  pop();
}
const hoverColors = { light: "#F5F5F5", dark: "#212121" };
var root_3 = /* @__PURE__ */ from_html(`<div class="tipContent svelte-13gd5ze"> </div>`);
var root_2$8 = /* @__PURE__ */ from_html(`<button class="button svelte-13gd5ze" aria-label=""><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="24" height="24" fill="currentColor"><path fill-rule="evenodd" d="M18 14a4 4 0 1 1-8 0 4 4 0 0 1 8 0Zm-1 0a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"></path><path fill-rule="evenodd" d="M8.5 5h11l5 9-5 9h-11l-5-9 5-9Zm-3.86 9L9.1 6h9.82l4.45 8-4.45 8H9.1l-4.45-8Z"></path></svg></button> <!>`, 1);
var root_1$h = /* @__PURE__ */ from_html(`<div class="settingPortal svelte-13gd5ze"><!> <!></div>`);
const $$css$l = {
  hash: "svelte-13gd5ze",
  code: ".settingPortal.svelte-13gd5ze {position:absolute;top:0;left:0;right:0;bottom:0;z-index:2;user-select:none;display:flex;align-items:center;justify-content:center;cursor:default;}\n@media (hover: hover) and (pointer: fine) {.settingPortal.svelte-13gd5ze:hover {background:var(--cl-gutter-background);}\n}.button.svelte-13gd5ze {outline:none;border:none;background:none;padding-block:initial;padding-inline:initial;font-family:inherit;color:inherit;width:100%;height:100%;}.tipContent.svelte-13gd5ze {white-space:nowrap;text-wrap:nowrap;}"
};
function Setting$1($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$l);
  const [$$stores, $$cleanup] = setup_stores();
  const $tooltipContent = () => store_get(tooltipContent, "$tooltipContent", $$stores);
  let open = /* @__PURE__ */ state(false);
  const themeService = useService(IThemeService);
  const chartManagementService = useService(IChartManagementService);
  const chartService = chartManagementService.chart($$props.chartIndex);
  const chartContainer = chartService.getContainerDomElement();
  const container = ensure(chartContainer.querySelector("tr:last-of-type td:last-of-type"));
  Object.assign(container.style, { position: "relative" });
  const tooltipContent = derivedWithCache(chartService.getStore(), (store) => {
    const { symbolInfo } = store;
    return `${symbolInfo.name}·${symbolInfo.exchange}·${store.resolution}`;
  });
  const onmouseenter = () => {
    chartService.showPaneCursor(PaneCursor.arrow);
    chartService.chartApi.applyOptions({
      rightPriceScale: {
        background: {
          type: Oi.Solid,
          color: themeService.isDark() ? hoverColors.dark : hoverColors.light
        }
      }
    });
  };
  const onmouseleave = () => {
    chartService.showPaneCursor(PaneCursor.unset);
    chartService.chartApi.applyOptions({
      rightPriceScale: {
        background: themeService.isDark() ? cloneDeep(chartConfigDark.rightPriceScale.background) : cloneDeep(chartConfigLight.rightPriceScale.background)
      }
    });
  };
  const onTrigger = () => {
    set(open, true);
  };
  let button;
  onMount(() => {
    PartFingerprints.write(button, PartFingerprint.AxisSetting);
  });
  Portal($$anchor, {
    get target() {
      return container;
    },
    style: "position: absolute;top: 0;left: 0;right: 0;bottom: 0;z-index: 2;",
    children: ($$anchor2, $$slotProps) => {
      var div = root_1$h();
      var node = child(div);
      Wrapper(node, {
        children: ($$anchor3, $$slotProps2) => {
          var fragment_1 = root_2$8();
          var button_1 = first_child(fragment_1);
          var event_handler = /* @__PURE__ */ user_derived(() => ifLeftClick(onTrigger));
          button_1.__pointerup = function(...$$args) {
            var _a3;
            (_a3 = get$1(event_handler)) == null ? void 0 : _a3.apply(this, $$args);
          };
          bind_this(button_1, ($$value) => button = $$value, () => button);
          var node_1 = sibling(button_1, 2);
          Tooltip(node_1, {
            yPos: "above",
            children: ($$anchor4, $$slotProps3) => {
              var div_1 = root_3();
              var text2 = child(div_1);
              template_effect(() => set_text(text2, $tooltipContent()));
              append($$anchor4, div_1);
            },
            $$slots: { default: true }
          });
          event("mouseenter", button_1, onmouseenter);
          event("mouseleave", button_1, onmouseleave);
          append($$anchor3, fragment_1);
        },
        $$slots: { default: true }
      });
      var node_2 = sibling(node, 2);
      Scheduler(node_2, {
        get waitFor() {
          return get$1(open);
        },
        children: ($$anchor3, $$slotProps2) => {
          SettingMenu($$anchor3, {
            get chartIndex() {
              return $$props.chartIndex;
            },
            get open() {
              return get$1(open);
            },
            set open($$value) {
              set(open, $$value, true);
            }
          });
        },
        $$slots: { default: true }
      });
      append($$anchor2, div);
    },
    $$slots: { default: true }
  });
  pop();
  $$cleanup();
}
delegate(["pointerup"]);
var root_2$7 = /* @__PURE__ */ from_html(`<!> <!>`, 1);
var root_6$3 = /* @__PURE__ */ from_html(`<!> <!> <!>`, 1);
var root_1$g = /* @__PURE__ */ from_html(`<!> <!> <!>`, 1);
var root$i = /* @__PURE__ */ from_html(`<div><div class="isolate svelte-7dwz1w" tabindex="-1"></div> <!></div>`);
const $$css$k = {
  hash: "svelte-7dwz1w",
  code: '.slot.svelte-7dwz1w {position:relative;}.slot.multiple.active.svelte-7dwz1w::after {border:2px solid var(--cl-selectedForeground);bottom:0;box-sizing:border-box;content:"";display:block;left:0;pointer-events:none;position:absolute;right:0;top:0;z-index:1;}.isolate.svelte-7dwz1w {position:absolute;top:0px;right:0px;bottom:0px;left:0px;}'
};
function ChartSlot($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$k);
  const [$$stores, $$cleanup] = setup_stores();
  const $isMulti = () => store_get(isMulti, "$isMulti", $$stores);
  const $isActive = () => store_get(isActive, "$isActive", $$stores);
  const $studyIdList = () => store_get(studyIdList, "$studyIdList", $$stores);
  let mounted = /* @__PURE__ */ state(false);
  let div;
  const chartManagementService = useService(IChartManagementService);
  const chartIndex = $$props.chartIndex;
  const gridArea = String.fromCodePoint(Codepoint.a + $$props.chartIndex);
  const isActive = derivedWithCache(chartManagementService.store, (store) => store.activeIndex === $$props.chartIndex);
  const studyIdList = derivedWithCache(chartManagementService.store, (store) => {
    var _a3;
    return (((_a3 = store.instances[chartIndex]) == null ? void 0 : _a3.studyList) ?? []).filter((s2) => !s2.overlap).map((s2) => s2.id);
  });
  const isMulti = derivedWithCache(chartManagementService.store, (store) => {
    return chartLayoutRegistry.value(store.layout).slotCount > 1;
  });
  let chartService;
  onMount(() => {
    chartService = chartManagementService.handleCellMount(div, $$props.chartIndex);
    setContext(IChartService, chartService);
    set(mounted, true);
    PartFingerprints.write(div, PartFingerprint.Chart);
  });
  useNormalPriority(() => {
    chartService == null ? void 0 : chartService.startup();
  });
  onDestroy(() => {
    chartManagementService.handleCellDestory(div, $$props.chartIndex);
    div = null;
  });
  var div_1 = root$i();
  let styles;
  var div_2 = child(div_1);
  bind_this(div_2, ($$value) => div = $$value, () => div);
  var node = sibling(div_2, 2);
  {
    var consequent = ($$anchor2) => {
      var fragment = root_1$g();
      var node_1 = first_child(fragment);
      Scheduler(node_1, {
        idle: true,
        children: ($$anchor3, $$slotProps) => {
          var fragment_1 = root_2$7();
          var node_2 = first_child(fragment_1);
          MainPanePortal(node_2, {
            get chartIndex() {
              return $$props.chartIndex;
            }
          });
          var node_3 = sibling(node_2, 2);
          each(node_3, 1, $studyIdList, (studyId) => studyId, ($$anchor4, studyId) => {
            var fragment_2 = comment();
            var node_4 = first_child(fragment_2);
            key(node_4, () => $studyIdList().length, ($$anchor5) => {
              AuxPanePortal($$anchor5, {
                get chartIndex() {
                  return $$props.chartIndex;
                },
                get studyId() {
                  return get$1(studyId);
                }
              });
            });
            append($$anchor4, fragment_2);
          });
          append($$anchor3, fragment_1);
        },
        $$slots: { default: true }
      });
      var node_5 = sibling(node_1, 2);
      {
        let $0 = /* @__PURE__ */ user_derived(() => chartService == null ? void 0 : chartService.onDataLoaded);
        Scheduler(node_5, {
          get waitFor() {
            return get$1($0);
          },
          idle: true,
          children: ($$anchor3, $$slotProps) => {
            Setting$1($$anchor3, {
              get chartIndex() {
                return $$props.chartIndex;
              }
            });
          },
          $$slots: { default: true }
        });
      }
      var node_6 = sibling(node_5, 2);
      {
        let $0 = /* @__PURE__ */ user_derived(() => chartService == null ? void 0 : chartService.onDataLoaded);
        Scheduler(node_6, {
          get waitFor() {
            return get$1($0);
          },
          idle: true,
          children: ($$anchor3, $$slotProps) => {
            var fragment_5 = root_6$3();
            var node_7 = first_child(fragment_5);
            PaneTooltip(node_7, {});
            var node_8 = sibling(node_7, 2);
            CustomComponents$1(node_8, {});
            var node_9 = sibling(node_8, 2);
            ErrorCard(node_9, {
              get chartIndex() {
                return $$props.chartIndex;
              }
            });
            append($$anchor3, fragment_5);
          },
          $$slots: { default: true }
        });
      }
      append($$anchor2, fragment);
    };
    if_block(node, ($$render) => {
      if (get$1(mounted)) $$render(consequent);
    });
  }
  template_effect(
    ($0, $1) => {
      set_class(div_1, 1, $0, "svelte-7dwz1w");
      styles = set_style(div_1, "", styles, $1);
    },
    [
      () => clsx(clsx$1("slot", $isMulti() && "multiple", $isActive() && "active")),
      () => ({ "grid-area": gridArea })
    ]
  );
  append($$anchor, div_1);
  pop();
  $$cleanup();
}
var root$h = /* @__PURE__ */ from_html(`<div><!></div>`);
const $$css$j = {
  hash: "svelte-cpm446",
  code: ".center.svelte-cpm446 {flex-grow:1;width:100%;height:100%;display:grid;border-radius:4px;overflow:hidden;gap:0.5px;cursor:crosshair;}.pane--cursor-pointer.svelte-cpm446 {cursor:pointer;}.pane--cursor-arrow.svelte-cpm446 {cursor:default;}.pane--cursor-eraser.svelte-cpm446 {cursor:url(./assets/eraser.cur), default;}.pane--cursor-dot.svelte-cpm446 {cursor:url(./assets/dot.cur), default;}.pane--cursor-performance.svelte-cpm446 {cursor:url(./assets/performance.svg), default;}.pane--cursor-default.svelte-cpm446,\n.pane--cursor-demonstration.svelte-cpm446 {cursor:default;}.pane--cursor-grabbing.svelte-cpm446 {cursor:grabbing;}.pane--cursor-zoomIn.svelte-cpm446 {cursor:zoom-in;}.pane--cursor-ew.svelte-cpm446 {cursor:ew-resize;}.pane--cursor-ns.svelte-cpm446 {cursor:ns-resize;}.pane--cursor-nwse.svelte-cpm446 {cursor:nwse-resize;}.pane--cursor-nesw.svelte-cpm446 {cursor:nesw-resize;}.pane--cursor-text.svelte-cpm446 {cursor:text;}.pane--cursor-none.svelte-cpm446 {cursor:none;}"
};
function Center($$anchor, $$props) {
  push($$props, false);
  append_styles$1($$anchor, $$css$j);
  const [$$stores, $$cleanup] = setup_stores();
  const $cursor = () => store_get(cursor, "$cursor", $$stores);
  const $currentLayoutDeclaration = () => store_get(currentLayoutDeclaration, "$currentLayoutDeclaration", $$stores);
  const $slotRangeArr = () => store_get(slotRangeArr, "$slotRangeArr", $$stores);
  let div = /* @__PURE__ */ mutable_source();
  const chartManagementService = useService(IChartManagementService);
  const currentLayoutDeclaration = derived(chartManagementService.store, (store) => chartLayoutRegistry.value(store.layout).layout.gridTemplate);
  useNormalPriority(() => {
    chartManagementService.handleGridMount(get$1(div));
  });
  const slotRangeArr = derived(chartManagementService.store, (store) => {
    return Array.from({ length: chartLayoutRegistry.value(store.layout).slotCount }, (_2, i2) => i2);
  });
  const cursor = derivedWithCache(chartManagementService.store, (store) => getCursorString(store.cursor));
  onDestroy(() => {
    set(div, null);
  });
  init();
  var div_1 = root$h();
  let styles;
  var node = child(div_1);
  Scheduler(node, {
    macro: true,
    children: ($$anchor2, $$slotProps) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      each(node_1, 1, $slotRangeArr, index, ($$anchor3, index2) => {
        ChartSlot($$anchor3, {
          get chartIndex() {
            return get$1(index2);
          }
        });
      });
      append($$anchor2, fragment);
    },
    $$slots: { default: true }
  });
  bind_this(div_1, ($$value) => set(div, $$value), () => get$1(div));
  template_effect(
    ($0, $1) => {
      set_class(div_1, 1, $0, "svelte-cpm446");
      styles = set_style(div_1, "", styles, $1);
    },
    [
      () => clsx(clsx$1("center", `pane--cursor-${$cursor()}`)),
      () => ({ "grid-template": $currentLayoutDeclaration() })
    ]
  );
  append($$anchor, div_1);
  pop();
  $$cleanup();
}
function CustomComponents($$anchor, $$props) {
  push($$props, false);
  const [$$stores, $$cleanup] = setup_stores();
  const $components = () => store_get(components, "$components", $$stores);
  const guiService = useService(IGuiService);
  const components = derived(guiService.store, (store) => store.components);
  init();
  var fragment = comment();
  var node = first_child(fragment);
  each(node, 1, $components, (Entry) => Entry.id, ($$anchor2, Entry) => {
    get$1(Entry).Component($$anchor2, spread_props(() => get$1(Entry).props));
  });
  append($$anchor, fragment);
  pop();
  $$cleanup();
}
function ClassAdder($$anchor, $$props) {
  push($$props, true);
  let use = prop($$props, "use", 19, () => []), className = prop($$props, "class", 3, ""), MyComponent = prop($$props, "component", 3, SmuiElement), tag = prop($$props, "tag", 3, "div"), _smuiClass = prop($$props, "_smuiClass", 3, ""), _smuiClassMap = prop($$props, "_smuiClassMap", 23, () => ({})), _smuiContexts = prop($$props, "_smuiContexts", 19, () => ({})), _smuiProps = prop($$props, "_smuiProps", 19, () => ({})), restProps = /* @__PURE__ */ rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "use",
    "class",
    "component",
    "tag",
    "_smuiClass",
    "_smuiClassMap",
    "_smuiContexts",
    "_smuiProps",
    "children"
  ]);
  let element2;
  const smuiClassUnsubscribes = [];
  Object.entries(_smuiClassMap()).forEach(([name, context]) => {
    const store = getContext(context);
    if (store && "subscribe" in store) {
      smuiClassUnsubscribes.push(store.subscribe((value) => {
        _smuiClassMap()[name] = value;
      }));
    }
  });
  for (let context in _smuiContexts()) {
    if (_smuiContexts().hasOwnProperty(context)) {
      setContext(context, _smuiContexts()[context]);
    }
  }
  onDestroy(() => {
    for (const unsubscribe of smuiClassUnsubscribes) {
      unsubscribe();
    }
  });
  function getElement() {
    return element2.getElement();
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = /* @__PURE__ */ user_derived(() => classMap({
      [className()]: true,
      [_smuiClass()]: true,
      ..._smuiClassMap()
    }));
    component(node, MyComponent, ($$anchor2, MyComponent_1) => {
      bind_this(
        MyComponent_1($$anchor2, spread_props(
          {
            get tag() {
              return tag();
            },
            get use() {
              return use();
            },
            get class() {
              return get$1($0);
            }
          },
          _smuiProps,
          () => restProps,
          {
            children: ($$anchor3, $$slotProps) => {
              var fragment_1 = comment();
              var node_1 = first_child(fragment_1);
              snippet(node_1, () => $$props.children ?? noop$1);
              append($$anchor3, fragment_1);
            },
            $$slots: { default: true }
          }
        )),
        ($$value) => element2 = $$value,
        () => element2
      );
    });
  }
  append($$anchor, fragment);
  return pop({ getElement });
}
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$1 = {
  CLOSING: "mdc-snackbar--closing",
  OPEN: "mdc-snackbar--open",
  OPENING: "mdc-snackbar--opening"
};
var strings$1 = {
  ACTION_SELECTOR: ".mdc-snackbar__action",
  ARIA_LIVE_LABEL_TEXT_ATTR: "data-mdc-snackbar-label-text",
  CLOSED_EVENT: "MDCSnackbar:closed",
  CLOSING_EVENT: "MDCSnackbar:closing",
  DISMISS_SELECTOR: ".mdc-snackbar__dismiss",
  LABEL_SELECTOR: ".mdc-snackbar__label",
  OPENED_EVENT: "MDCSnackbar:opened",
  OPENING_EVENT: "MDCSnackbar:opening",
  REASON_ACTION: "action",
  REASON_DISMISS: "dismiss",
  SURFACE_SELECTOR: ".mdc-snackbar__surface"
};
var numbers$1 = {
  DEFAULT_AUTO_DISMISS_TIMEOUT_MS: 5e3,
  INDETERMINATE: -1,
  MAX_AUTO_DISMISS_TIMEOUT_MS: 1e4,
  MIN_AUTO_DISMISS_TIMEOUT_MS: 4e3,
  // These variables need to be kept in sync with the values in _variables.scss.
  SNACKBAR_ANIMATION_CLOSE_TIME_MS: 75,
  SNACKBAR_ANIMATION_OPEN_TIME_MS: 150,
  /**
   * Number of milliseconds to wait between temporarily clearing the label text
   * in the DOM and subsequently restoring it. This is necessary to force IE 11
   * to pick up the `aria-live` content change and announce it to the user.
   */
  ARIA_LIVE_DELAY_MS: 1e3
};
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var ARIA_LIVE_DELAY_MS = numbers$1.ARIA_LIVE_DELAY_MS;
var ARIA_LIVE_LABEL_TEXT_ATTR = strings$1.ARIA_LIVE_LABEL_TEXT_ATTR;
function announce(ariaEl, labelEl) {
  if (labelEl === void 0) {
    labelEl = ariaEl;
  }
  var priority = ariaEl.getAttribute("aria-live");
  var labelText = labelEl.textContent.trim();
  if (!labelText || !priority) {
    return;
  }
  ariaEl.setAttribute("aria-live", "off");
  labelEl.textContent = "";
  var span = document.createElement("span");
  span.setAttribute("style", "display: inline-block; width: 0; height: 1px;");
  span.textContent = " ";
  labelEl.appendChild(span);
  labelEl.setAttribute(ARIA_LIVE_LABEL_TEXT_ATTR, labelText);
  setTimeout(function() {
    ariaEl.setAttribute("aria-live", priority);
    labelEl.removeAttribute(ARIA_LIVE_LABEL_TEXT_ATTR);
    labelEl.textContent = labelText;
  }, ARIA_LIVE_DELAY_MS);
}
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var OPENING = cssClasses$1.OPENING, OPEN = cssClasses$1.OPEN, CLOSING = cssClasses$1.CLOSING;
var REASON_ACTION = strings$1.REASON_ACTION, REASON_DISMISS = strings$1.REASON_DISMISS;
var MDCSnackbarFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCSnackbarFoundation2, _super);
    function MDCSnackbarFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCSnackbarFoundation2.defaultAdapter), adapter)) || this;
      _this.opened = false;
      _this.animationFrame = 0;
      _this.animationTimer = 0;
      _this.autoDismissTimer = 0;
      _this.autoDismissTimeoutMs = numbers$1.DEFAULT_AUTO_DISMISS_TIMEOUT_MS;
      _this.closeOnEscape = true;
      return _this;
    }
    Object.defineProperty(MDCSnackbarFoundation2, "cssClasses", {
      get: function() {
        return cssClasses$1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCSnackbarFoundation2, "strings", {
      get: function() {
        return strings$1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCSnackbarFoundation2, "numbers", {
      get: function() {
        return numbers$1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCSnackbarFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          announce: function() {
            return void 0;
          },
          notifyClosed: function() {
            return void 0;
          },
          notifyClosing: function() {
            return void 0;
          },
          notifyOpened: function() {
            return void 0;
          },
          notifyOpening: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCSnackbarFoundation2.prototype.destroy = function() {
      this.clearAutoDismissTimer();
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = 0;
      clearTimeout(this.animationTimer);
      this.animationTimer = 0;
      this.adapter.removeClass(OPENING);
      this.adapter.removeClass(OPEN);
      this.adapter.removeClass(CLOSING);
    };
    MDCSnackbarFoundation2.prototype.open = function() {
      var _this = this;
      this.clearAutoDismissTimer();
      this.opened = true;
      this.adapter.notifyOpening();
      this.adapter.removeClass(CLOSING);
      this.adapter.addClass(OPENING);
      this.adapter.announce();
      this.runNextAnimationFrame(function() {
        _this.adapter.addClass(OPEN);
        _this.animationTimer = setTimeout(function() {
          var timeoutMs = _this.getTimeoutMs();
          _this.handleAnimationTimerEnd();
          _this.adapter.notifyOpened();
          if (timeoutMs !== numbers$1.INDETERMINATE) {
            _this.autoDismissTimer = setTimeout(function() {
              _this.close(REASON_DISMISS);
            }, timeoutMs);
          }
        }, numbers$1.SNACKBAR_ANIMATION_OPEN_TIME_MS);
      });
    };
    MDCSnackbarFoundation2.prototype.close = function(reason) {
      var _this = this;
      if (reason === void 0) {
        reason = "";
      }
      if (!this.opened) {
        return;
      }
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = 0;
      this.clearAutoDismissTimer();
      this.opened = false;
      this.adapter.notifyClosing(reason);
      this.adapter.addClass(cssClasses$1.CLOSING);
      this.adapter.removeClass(cssClasses$1.OPEN);
      this.adapter.removeClass(cssClasses$1.OPENING);
      clearTimeout(this.animationTimer);
      this.animationTimer = setTimeout(function() {
        _this.handleAnimationTimerEnd();
        _this.adapter.notifyClosed(reason);
      }, numbers$1.SNACKBAR_ANIMATION_CLOSE_TIME_MS);
    };
    MDCSnackbarFoundation2.prototype.isOpen = function() {
      return this.opened;
    };
    MDCSnackbarFoundation2.prototype.getTimeoutMs = function() {
      return this.autoDismissTimeoutMs;
    };
    MDCSnackbarFoundation2.prototype.setTimeoutMs = function(timeoutMs) {
      var minValue = numbers$1.MIN_AUTO_DISMISS_TIMEOUT_MS;
      var maxValue = numbers$1.MAX_AUTO_DISMISS_TIMEOUT_MS;
      var indeterminateValue = numbers$1.INDETERMINATE;
      if (timeoutMs === numbers$1.INDETERMINATE || timeoutMs <= maxValue && timeoutMs >= minValue) {
        this.autoDismissTimeoutMs = timeoutMs;
      } else {
        throw new Error("\n        timeoutMs must be an integer in the range " + minValue + "–" + maxValue + "\n        (or " + indeterminateValue + " to disable), but got '" + timeoutMs + "'");
      }
    };
    MDCSnackbarFoundation2.prototype.getCloseOnEscape = function() {
      return this.closeOnEscape;
    };
    MDCSnackbarFoundation2.prototype.setCloseOnEscape = function(closeOnEscape) {
      this.closeOnEscape = closeOnEscape;
    };
    MDCSnackbarFoundation2.prototype.handleKeyDown = function(evt) {
      var isEscapeKey = evt.key === "Escape" || evt.keyCode === 27;
      if (isEscapeKey && this.getCloseOnEscape()) {
        this.close(REASON_DISMISS);
      }
    };
    MDCSnackbarFoundation2.prototype.handleActionButtonClick = function(_evt) {
      this.close(REASON_ACTION);
    };
    MDCSnackbarFoundation2.prototype.handleActionIconClick = function(_evt) {
      this.close(REASON_DISMISS);
    };
    MDCSnackbarFoundation2.prototype.clearAutoDismissTimer = function() {
      clearTimeout(this.autoDismissTimer);
      this.autoDismissTimer = 0;
    };
    MDCSnackbarFoundation2.prototype.handleAnimationTimerEnd = function() {
      this.animationTimer = 0;
      this.adapter.removeClass(cssClasses$1.OPENING);
      this.adapter.removeClass(cssClasses$1.CLOSING);
    };
    MDCSnackbarFoundation2.prototype.runNextAnimationFrame = function(callback) {
      var _this = this;
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = requestAnimationFrame(function() {
        _this.animationFrame = 0;
        clearTimeout(_this.animationTimer);
        _this.animationTimer = setTimeout(callback, 0);
      });
    };
    return MDCSnackbarFoundation2;
  }(MDCFoundation)
);
let waiting = Promise.resolve();
var root$g = /* @__PURE__ */ from_html(`<aside><div><!></div></aside>`);
function Snackbar($$anchor, $$props) {
  push($$props, true);
  const { closest: closest2 } = ponyfill;
  let uninitializedValue = () => {
  };
  function isUninitializedValue(value) {
    return value === uninitializedValue;
  }
  let use = prop($$props, "use", 19, () => []), className = prop($$props, "class", 3, ""), openOnMount = prop($$props, "openOnMount", 3, false), leading = prop($$props, "leading", 3, false), timeoutMs = prop($$props, "timeoutMs", 3, 5e3), closeOnEscape = prop($$props, "closeOnEscape", 3, true), labelText = prop($$props, "labelText", 3, uninitializedValue), actionButtonText = prop($$props, "actionButtonText", 3, uninitializedValue), surface$use = prop($$props, "surface$use", 19, () => []), surface$class = prop($$props, "surface$class", 3, ""), restProps = /* @__PURE__ */ rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "use",
    "class",
    "variant",
    "openOnMount",
    "leading",
    "timeoutMs",
    "closeOnEscape",
    "labelText",
    "actionButtonText",
    "surface$use",
    "surface$class",
    "children"
  ]);
  let element2;
  let instance = /* @__PURE__ */ state(void 0);
  let internalClasses = proxy$1({});
  let closeResolve;
  let closePromise = new Promise((resolve) => closeResolve = resolve);
  setContext("SMUI:label:context", "snackbar");
  user_effect(() => {
    if (get$1(instance) && get$1(instance).getTimeoutMs() !== timeoutMs()) {
      get$1(instance).setTimeoutMs(timeoutMs());
    }
  });
  user_effect(() => {
    if (get$1(instance) && get$1(instance).getCloseOnEscape() !== closeOnEscape()) {
      get$1(instance).setCloseOnEscape(closeOnEscape());
    }
  });
  user_effect(() => {
    if (get$1(instance) && !isUninitializedValue(labelText()) && getLabelElement().textContent !== labelText()) {
      getLabelElement().textContent = labelText();
    }
  });
  user_effect(() => {
    if (get$1(instance) && !isUninitializedValue(actionButtonText()) && getActionButtonElement().textContent !== actionButtonText()) {
      getActionButtonElement().textContent = actionButtonText();
    }
  });
  onMount(() => {
    set(
      instance,
      new MDCSnackbarFoundation({
        addClass,
        announce: () => announce(getLabelElement()),
        notifyClosed: (reason) => dispatch(getElement(), "SMUISnackbarClosed", reason ? { reason } : {}),
        notifyClosing: (reason) => dispatch(getElement(), "SMUISnackbarClosing", reason ? { reason } : {}),
        notifyOpened: () => dispatch(getElement(), "SMUISnackbarOpened"),
        notifyOpening: () => dispatch(getElement(), "SMUISnackbarOpening"),
        removeClass
      }),
      true
    );
    get$1(instance).init();
    if (openOnMount()) {
      get$1(instance).open();
    }
    return () => {
      var _a3;
      (_a3 = get$1(instance)) == null ? void 0 : _a3.destroy();
    };
  });
  function addClass(className2) {
    if (!internalClasses[className2]) {
      internalClasses[className2] = true;
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      internalClasses[className2] = false;
    }
  }
  function handleSurfaceClick(event2) {
    const target = event2.target;
    if (get$1(instance)) {
      if (closest2(target, ".mdc-snackbar__action")) {
        get$1(instance).handleActionButtonClick(event2);
      } else if (closest2(target, ".mdc-snackbar__dismiss")) {
        get$1(instance).handleActionIconClick(event2);
      }
    }
  }
  function handleClosed() {
    closeResolve();
    closePromise = new Promise((resolve) => closeResolve = resolve);
  }
  function open() {
    waiting = waiting.then(() => {
      var _a3;
      (_a3 = get$1(instance)) == null ? void 0 : _a3.open();
      return closePromise;
    });
  }
  function forceOpen() {
    var _a3;
    return (_a3 = get$1(instance)) == null ? void 0 : _a3.open();
  }
  function close(reason) {
    var _a3;
    return (_a3 = get$1(instance)) == null ? void 0 : _a3.close(reason);
  }
  function isOpen() {
    if (get$1(instance) == null) {
      throw new Error("Instance is undefined.");
    }
    return get$1(instance).isOpen();
  }
  function getLabelElement() {
    return getElement().querySelector(".mdc-snackbar__label") ?? document.createElement("div");
  }
  function getActionButtonElement() {
    return getElement().querySelector(".mdc-snackbar__action") ?? document.createElement("button");
  }
  function getElement() {
    return element2;
  }
  var aside = root$g();
  var event_handler = (e2) => {
    var _a3;
    if (get$1(instance)) {
      get$1(instance).handleKeyDown(e2);
    }
    (_a3 = $$props.onkeydown) == null ? void 0 : _a3.call($$props, e2);
  };
  var event_handler_1 = (e2) => {
    var _a3;
    handleClosed();
    (_a3 = $$props.onSMUISnackbarClosed) == null ? void 0 : _a3.call($$props, e2);
  };
  attribute_effect(
    aside,
    ($0, $1) => ({
      class: $0,
      ...$1,
      onkeydown: event_handler,
      onSMUISnackbarClosed: event_handler_1
    }),
    [
      () => classMap({
        [className()]: true,
        "mdc-snackbar": true,
        "mdc-snackbar--stacked": $$props.variant === "stacked",
        "mdc-snackbar--leading": leading(),
        ...internalClasses
      }),
      () => exclude(restProps, ["surface$"])
    ]
  );
  var div = child(aside);
  var event_handler_2 = (e2) => {
    var _a3;
    handleSurfaceClick(e2);
    (_a3 = $$props.surface$onclick) == null ? void 0 : _a3.call($$props, e2);
  };
  attribute_effect(
    div,
    ($0, $1) => ({
      class: $0,
      role: "status",
      "aria-relevant": "additions",
      ...$1,
      onclick: event_handler_2
    }),
    [
      () => classMap({ [surface$class()]: true, "mdc-snackbar__surface": true }),
      () => prefixFilter(restProps, "surface$")
    ]
  );
  var node = child(div);
  snippet(node, () => $$props.children ?? noop$1);
  action(div, ($$node, $$action_arg) => useActions == null ? void 0 : useActions($$node, $$action_arg), surface$use);
  bind_this(aside, ($$value) => element2 = $$value, () => element2);
  action(aside, ($$node, $$action_arg) => useActions == null ? void 0 : useActions($$node, $$action_arg), use);
  append($$anchor, aside);
  return pop({
    open,
    forceOpen,
    close,
    isOpen,
    getLabelElement,
    getActionButtonElement,
    getElement
  });
}
var root_1$f = /* @__PURE__ */ from_html(`<div class="label svelte-1jhsad5"> </div> <div class="actions"><button aria-label="Close" class="button svelte-1jhsad5"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18"><path fill="currentColor" d="M9.707 9l4.647-4.646-.707-.708L9 8.293 4.354 3.646l-.708.708L8.293 9l-4.647 4.646.708.708L9 9.707l4.646 4.647.708-.707L9.707 9z"></path></svg></button></div>`, 1);
const $$css$i = {
  hash: "svelte-1jhsad5",
  code: ".button.svelte-1jhsad5 {outline:none;border:none;background:none;padding-block:initial;padding-inline:initial;font-family:inherit;color:inherit;display:flex;align-items:center;justify-content:center;color:inherit;}.label.svelte-1jhsad5 {font-size:14px;line-height:21px;padding:4px 8px;} .chartles .cl-toast--verbose {min-width:unset;display:flex;border-radius:4px;padding:8px;color:var(--cl-toast-verbose-foreground);background:var(--cl-toast-verbose-background);border:1px solid var(--cl-toast-verbose-border);} .chartles .cl-toast--info {min-width:unset;display:flex;border-radius:4px;padding:8px;color:var(--cl-toast-info-foreground);background:var(--cl-toast-info-background);}"
};
function Toast($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$i);
  const onClose = () => {
    $$props.item.close();
  };
  {
    let $0 = /* @__PURE__ */ user_derived(() => `cl-toast--${Severity.toString($$props.item.severity)}`);
    Snackbar($$anchor, {
      openOnMount: true,
      timeoutMs: -1,
      get surface$class() {
        return get$1($0);
      },
      children: ($$anchor2, $$slotProps) => {
        var fragment_1 = root_1$f();
        var div = first_child(fragment_1);
        var text2 = child(div);
        var div_1 = sibling(div, 2);
        var button = child(div_1);
        var event_handler = /* @__PURE__ */ user_derived(() => ifLeftClick(onClose));
        button.__pointerup = function(...$$args) {
          var _a3;
          (_a3 = get$1(event_handler)) == null ? void 0 : _a3.apply(this, $$args);
        };
        template_effect(() => set_text(text2, $$props.item.message.text));
        append($$anchor2, fragment_1);
      },
      $$slots: { default: true }
    });
  }
  pop();
}
delegate(["pointerup"]);
const _ToastsModel = class _ToastsModel extends Disposable {
  constructor(model) {
    super();
    __publicField(this, "mapNotificationToToast", /* @__PURE__ */ new Map());
    __publicField(this, "mapNotificationToDisposable", /* @__PURE__ */ new Map());
    __publicField(this, "addedToastsIntervalCounter", new IntervalCounter(
      _ToastsModel.SPAM_PROTECTION.interval
    ));
    __publicField(this, "store", writable([]));
    this.model = model;
    this._register(toDisposable(() => Reflect.set(this, "store", null)));
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.model.onDidChangeNotification((e2) => this.onDidChangeNotification(e2)));
  }
  onDidChangeNotification(e2) {
    switch (e2.kind) {
      case NotificationChangeType.ADD:
        return this.addToast(e2.item);
      case NotificationChangeType.REMOVE:
        return this.removeToast(e2.item);
    }
  }
  addToast(item) {
    if (this.addedToastsIntervalCounter.increment() > _ToastsModel.SPAM_PROTECTION.limit) {
      return;
    }
    const itemDisposables = new DisposableStore();
    this.mapNotificationToDisposable.set(item, itemDisposables);
    itemDisposables.add(scheduleAtNextAnimationFrame(() => this.doAddToast(item, itemDisposables)));
  }
  doAddToast(item, itemDisposables) {
    const toast = {
      item
    };
    this.mapNotificationToToast.set(item, toast);
    this.store.update((store) => {
      store.push(toast);
      return store;
    });
    once(item.onDidClose)(() => {
      this.removeToast(item);
    });
    this.purgeNotification(item, itemDisposables);
  }
  purgeNotification(item, disposables) {
    let purgeTimeoutHandle;
    let listener;
    const hideAfterTimeout = () => {
      purgeTimeoutHandle = setTimeout(() => {
        if (document.visibilityState === "hidden") {
          if (!listener) {
            listener = addDisposableListener(document, "visibilitychange", () => {
              if (document.visibilityState === "visible") {
                hideAfterTimeout();
              }
            });
            disposables.add(listener);
          }
        } else {
          this.removeToast(item);
        }
      }, _ToastsModel.PURGE_TIMEOUT[item.severity]);
    };
    hideAfterTimeout();
    disposables.add(toDisposable(() => clearTimeout(purgeTimeoutHandle)));
  }
  removeToast(item) {
    const notificationToast = this.mapNotificationToToast.get(item);
    if (notificationToast) {
      this.mapNotificationToToast.delete(item);
      this.store.update((store) => {
        const idx = store.findIndex((i2) => i2.item.equals(notificationToast.item));
        if (idx > -1) {
          store.splice(idx, 1);
        }
        return store;
      });
    }
    const notificationDisposables = this.mapNotificationToDisposable.get(item);
    if (notificationDisposables) {
      dispose(notificationDisposables);
      this.mapNotificationToDisposable.delete(item);
    }
  }
};
__publicField(_ToastsModel, "MAX_NOTIFICATIONS", 3);
__publicField(_ToastsModel, "PURGE_TIMEOUT", {
  [Severity.Verbose]: 3e3,
  [Severity.Info]: 15e3,
  [Severity.Warning]: 18e3,
  [Severity.Error]: 2e4
});
__publicField(_ToastsModel, "SPAM_PROTECTION", {
  // Count for the number of notifications over 800ms...
  interval: 800,
  // ...and ensure we are not showing more than MAX_NOTIFICATIONS
  limit: _ToastsModel.MAX_NOTIFICATIONS
});
let ToastsModel = _ToastsModel;
function Toasts($$anchor, $$props) {
  push($$props, false);
  const [$$stores, $$cleanup] = setup_stores();
  const $list = () => store_get(list, "$list", $$stores);
  const notificationService = useService(INotificationService);
  const notificationToasts = new ToastsModel(notificationService.model);
  useDisposable(notificationToasts);
  const list = derived(notificationToasts.store, (s2) => s2);
  init();
  var fragment = comment();
  var node = first_child(fragment);
  each(node, 1, $list, index, ($$anchor2, toast) => {
    Toast($$anchor2, {
      get item() {
        return get$1(toast).item;
      }
    });
  });
  append($$anchor, fragment);
  pop();
  $$cleanup();
}
var root$f = /* @__PURE__ */ from_html(`<!> <!>`, 1);
function Float($$anchor) {
  var fragment = root$f();
  var node = first_child(fragment);
  CustomComponents(node, {});
  var node_1 = sibling(node, 2);
  Toasts(node_1, {});
  append($$anchor, fragment);
}
var root_5$2 = /* @__PURE__ */ from_html(`<span></span>`);
function AsyncSvgIcon($$anchor, $$props) {
  push($$props, true);
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
    };
    var alternate_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          html(node_2, () => $$props.icon);
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var fragment_3 = comment();
          var node_3 = first_child(fragment_3);
          await_block(
            node_3,
            () => $$props.icon(),
            ($$anchor4) => {
              var span = root_5$2();
              append($$anchor4, span);
            },
            ($$anchor4, icon) => {
              var fragment_4 = comment();
              var node_4 = first_child(fragment_4);
              html(node_4, () => get$1(icon));
              append($$anchor4, fragment_4);
            }
          );
          append($$anchor3, fragment_3);
        };
        if_block(
          node_1,
          ($$render) => {
            if (isString($$props.icon)) $$render(consequent_1);
            else $$render(alternate, false);
          },
          true
        );
      }
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (!$$props.icon) $$render(consequent);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  pop();
}
var root_4$6 = /* @__PURE__ */ from_html(`<span class="rowIcon svelte-113baz"><!></span> <span class="rowLabel svelte-113baz"> </span>`, 1);
var root_1$e = /* @__PURE__ */ from_html(`<div class="styleMenu svelte-113baz"><!></div>`);
const $$css$h = {
  hash: "svelte-113baz",
  code: ".styleMenu.svelte-113baz {display:flex;flex-direction:column;background:var(--cl-background);user-select:none;cursor:default;z-index:2;}.styleMenu.svelte-113baz .mdc-deprecated-list {margin:0;padding:0;list-style:none;} .styleMenu .row {padding:6px 10px 6px 8px;display:flex;flex-direction:row;align-items:center;color:var(--cl-listItem-foreground);background:var(--cl-listItem-background);}\n@media (hover: hover) and (pointer: fine) { .styleMenu .row:hover:not(.disabled):not(.selected) {background-color:var(--cl-listItem-hoverBackground);}\n} .styleMenu .row.disabled {cursor:default;opacity:0.5;} .styleMenu .row.selected {background-color:var(--cl-listItem-selectedBackground);color:var(--cl-listItem-selectedForeground);}.rowIcon.svelte-113baz {width:28px;height:28px;margin-right:6px;}.rowLabel.svelte-113baz {font-size:14px;padding-right:12px;white-space:nowrap;user-select:none;cursor:default;}"
};
function ChartStyleMenu($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$h);
  const [$$stores, $$cleanup] = setup_stores();
  const $disabled = () => store_get(disabled, "$disabled", $$stores);
  const $currentStyle = () => store_get(currentStyle, "$currentStyle", $$stores);
  let open = prop($$props, "open", 15, false);
  const { t: t2 } = useTranslation();
  const chartManagementService = useService(IChartManagementService);
  const styles = chartStylePreset;
  const disabled = derived(chartManagementService.store, (store) => {
    const { activeIndex } = store;
    if (!isFinite(activeIndex)) return true;
    return store.instances[activeIndex].dataStatus < ChartDataStatus.symbolInfoResolved;
  });
  const currentStyle = derived(chartManagementService.store, (store) => {
    const { activeIndex } = store;
    if (!isFinite(activeIndex)) return null;
    const chartType = store.instances[activeIndex].chartProperties["mainSeriesProperties.style"];
    return chartStyleRegistry.value(chartType);
  });
  Menu($$anchor, {
    anchorCorner: "BOTTOM_LEFT",
    quickOpen: true,
    class: "cl-dropdown",
    get open() {
      return open();
    },
    set open($$value) {
      open($$value);
    },
    children: ($$anchor2, $$slotProps) => {
      var div = root_1$e();
      var node = child(div);
      List(node, {
        children: ($$anchor3, $$slotProps2) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          each(node_1, 17, () => styles, index, ($$anchor4, style) => {
            {
              let $0 = /* @__PURE__ */ user_derived(() => {
                var _a3;
                return get$1(style).id === ((_a3 = $currentStyle()) == null ? void 0 : _a3.id);
              });
              let $1 = /* @__PURE__ */ user_derived(() => {
                var _a3;
                return clsx$1("row", get$1(style).id === ((_a3 = $currentStyle()) == null ? void 0 : _a3.id) && "selected", $disabled() && "disabled");
              });
              let $2 = /* @__PURE__ */ user_derived(() => ifLeftClick(() => {
                if ($disabled()) return;
                chartManagementService.activeChart().setChartType(get$1(style).id);
              }));
              Item($$anchor4, {
                tag: "div",
                get disabled() {
                  return $disabled();
                },
                get selected() {
                  return get$1($0);
                },
                get class() {
                  return get$1($1);
                },
                get onpointerup() {
                  return get$1($2);
                },
                children: ($$anchor5, $$slotProps3) => {
                  var fragment_3 = root_4$6();
                  var span = first_child(fragment_3);
                  var node_2 = child(span);
                  AsyncSvgIcon(node_2, {
                    get icon() {
                      return get$1(style).icon;
                    }
                  });
                  var span_1 = sibling(span, 2);
                  var text2 = child(span_1);
                  template_effect(($02) => set_text(text2, $02), [() => t2(get$1(style).label)]);
                  append($$anchor5, fragment_3);
                },
                $$slots: { default: true }
              });
            }
          });
          append($$anchor3, fragment_1);
        },
        $$slots: { default: true }
      });
      append($$anchor2, div);
    },
    $$slots: { default: true }
  });
  pop();
  $$cleanup();
}
var root_2$6 = /* @__PURE__ */ from_html(`<div> </div>`);
var root_1$d = /* @__PURE__ */ from_html(`<button class="chartStyle svelte-ce2ax2"><!></button> <!>`, 1);
var root$e = /* @__PURE__ */ from_html(`<div><!> <!></div>`);
const $$css$g = {
  hash: "svelte-ce2ax2",
  code: '.chartStyle.svelte-ce2ax2 {outline:none;border:none;background:none;padding-block:initial;padding-inline:initial;font-family:inherit;color:inherit;height:100%;color:var(--cl-foreground);font-size:14px;display:flex;flex-direction:row;align-items:center;justify-content:center;cursor:default;position:relative;z-index:0;padding:0 5px;}\n@media (hover: hover) and (pointer: fine) {.chartStyle.svelte-ce2ax2:hover:before {position:absolute;top:2px;right:2px;bottom:2px;left:2px;z-index:-1;border-radius:4px;content:"";background-color:var(--cl-button-hoverBackground);}\n}'
};
function ChartStyle($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$g);
  const [$$stores, $$cleanup] = setup_stores();
  const $currentStyle = () => store_get(currentStyle, "$currentStyle", $$stores);
  const $label = () => store_get(label, "$label", $$stores);
  let open = /* @__PURE__ */ state(false);
  const { t: t2 } = useTranslation();
  const chartManagementService = useService(IChartManagementService);
  const currentStyle = derived(chartManagementService.store, (store) => {
    const { activeIndex } = store;
    if (!isFinite(activeIndex)) return null;
    const chartType = store.instances[activeIndex].chartProperties["mainSeriesProperties.style"];
    return chartStyleRegistry.value(chartType);
  });
  const label = derived(currentStyle, (style) => style == null ? void 0 : style.label);
  var div = root$e();
  var node = child(div);
  Wrapper(node, {
    children: ($$anchor2, $$slotProps) => {
      var fragment = root_1$d();
      var button = first_child(fragment);
      var event_handler = /* @__PURE__ */ user_derived(() => ifLeftClick(() => set(open, true)));
      button.__pointerup = function(...$$args) {
        var _a3;
        (_a3 = get$1(event_handler)) == null ? void 0 : _a3.apply(this, $$args);
      };
      var node_1 = child(button);
      {
        let $0 = /* @__PURE__ */ user_derived(() => {
          var _a3;
          return (_a3 = $currentStyle()) == null ? void 0 : _a3.icon;
        });
        AsyncSvgIcon(node_1, {
          get icon() {
            return get$1($0);
          }
        });
      }
      var node_2 = sibling(button, 2);
      Tooltip(node_2, {
        children: ($$anchor3, $$slotProps2) => {
          var div_1 = root_2$6();
          var text2 = child(div_1);
          template_effect(($0) => set_text(text2, $0), [() => t2($label())]);
          append($$anchor3, div_1);
        },
        $$slots: { default: true }
      });
      append($$anchor2, fragment);
    },
    $$slots: { default: true }
  });
  var node_3 = sibling(node, 2);
  Scheduler(node_3, {
    get waitFor() {
      return get$1(open);
    },
    children: ($$anchor2, $$slotProps) => {
      ChartStyleMenu($$anchor2, {
        get open() {
          return get$1(open);
        },
        set open($$value) {
          set(open, $$value, true);
        }
      });
    },
    $$slots: { default: true }
  });
  append($$anchor, div);
  pop();
  $$cleanup();
}
delegate(["pointerup"]);
var root_2$5 = /* @__PURE__ */ from_html(`<span> </span>`);
var root_4$5 = /* @__PURE__ */ from_html(`<div> </div>`);
var root_1$c = /* @__PURE__ */ from_html(`<button class="customButton svelte-1pu4aed"><!></button> <!>`, 1);
var root$d = /* @__PURE__ */ from_html(`<div><!></div>`);
const $$css$f = {
  hash: "svelte-1pu4aed",
  code: '.customButton.svelte-1pu4aed {outline:none;border:none;background:none;padding-block:initial;padding-inline:initial;font-family:inherit;color:inherit;height:100%;color:var(--cl-foreground);font-size:14px;display:flex;flex-direction:row;align-items:center;justify-content:center;cursor:default;position:relative;z-index:0;padding:0 10px;}\n@media (hover: hover) and (pointer: fine) {.customButton.svelte-1pu4aed:hover:before {position:absolute;top:2px;right:2px;bottom:2px;left:2px;z-index:-1;border-radius:4px;content:"";background-color:var(--cl-button-hoverBackground);}\n}'
};
function CustomButton($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$f);
  const guiService = useService(IGuiService);
  let el;
  onMount(() => {
    guiService.setButtonReady($$props.id, el);
  });
  onDestroy(() => {
    el = null;
  });
  var div = root$d();
  var node = child(div);
  Wrapper(node, {
    children: ($$anchor2, $$slotProps) => {
      var fragment = root_1$c();
      var button = first_child(fragment);
      var event_handler = /* @__PURE__ */ user_derived(() => ifLeftClick(() => {
        var _a3;
        return (_a3 = $$props.onClick) == null ? void 0 : _a3.call($$props);
      }));
      button.__pointerup = function(...$$args) {
        var _a3;
        (_a3 = get$1(event_handler)) == null ? void 0 : _a3.apply(this, $$args);
      };
      var node_1 = child(button);
      {
        var consequent = ($$anchor3) => {
          var span = root_2$5();
          var text2 = child(span);
          template_effect(() => set_text(text2, $$props.text));
          append($$anchor3, span);
        };
        if_block(node_1, ($$render) => {
          if ($$props.text) $$render(consequent);
        });
      }
      bind_this(button, ($$value) => el = $$value, () => el);
      var node_2 = sibling(button, 2);
      {
        var consequent_1 = ($$anchor3) => {
          Tooltip($$anchor3, {
            children: ($$anchor4, $$slotProps2) => {
              var div_1 = root_4$5();
              var text_1 = child(div_1);
              template_effect(() => set_text(text_1, $$props.title));
              append($$anchor4, div_1);
            },
            $$slots: { default: true }
          });
        };
        if_block(node_2, ($$render) => {
          if ($$props.title) $$render(consequent_1);
        });
      }
      append($$anchor2, fragment);
    },
    $$slots: { default: true }
  });
  append($$anchor, div);
  pop();
}
delegate(["pointerup"]);
var root_1$b = /* @__PURE__ */ from_html(`<span class="separator svelte-enlgwa"></span> <span> </span>`, 1);
var root_2$4 = /* @__PURE__ */ from_html(`<span> </span>`);
var root$c = /* @__PURE__ */ from_html(`<div class="tipContent svelte-enlgwa"><span> </span> <!> <!></div>`);
const $$css$e = {
  hash: "svelte-enlgwa",
  code: ".tipContent.svelte-enlgwa {width:fit-content;height:fit-content;display:flex;flex-direction:row;align-items:center;cursor:default;user-select:none;}.separator.svelte-enlgwa {width:1px;height:20px;margin:0 6px;background:var(--cl-gutter-background);}"
};
function TooltipContent($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$e);
  var div = root$c();
  var span = child(div);
  var text2 = child(span);
  var node = sibling(span, 2);
  {
    var consequent = ($$anchor2) => {
      var fragment = root_1$b();
      var span_1 = sibling(first_child(fragment), 2);
      var text_1 = child(span_1);
      template_effect(($0) => set_text(text_1, $0), [() => getKeybindingLabel($$props.keybinding)]);
      append($$anchor2, fragment);
    };
    if_block(node, ($$render) => {
      if ($$props.keybinding) $$render(consequent);
    });
  }
  var node_1 = sibling(node, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var span_2 = root_2$4();
      var text_2 = child(span_2);
      template_effect(() => set_text(text_2, $$props.contentAfter));
      append($$anchor2, span_2);
    };
    if_block(node_1, ($$render) => {
      if ($$props.contentAfter) $$render(consequent_1);
    });
  }
  template_effect(() => set_text(text2, $$props.content));
  append($$anchor, div);
  pop();
}
var root_1$a = /* @__PURE__ */ from_html(`<button aria-label="Full screen" class="fullscreen svelte-eor01u"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28" class="svelte-eor01u"><path fill="currentColor" d="M8.5 6A2.5 2.5 0 0 0 6 8.5V11h1V8.5C7 7.67 7.67 7 8.5 7H11V6H8.5zM6 17v2.5A2.5 2.5 0 0 0 8.5 22H11v-1H8.5A1.5 1.5 0 0 1 7 19.5V17H6zM19.5 7H17V6h2.5A2.5 2.5 0 0 1 22 8.5V11h-1V8.5c0-.83-.67-1.5-1.5-1.5zM22 19.5V17h-1v2.5c0 .83-.67 1.5-1.5 1.5H17v1h2.5a2.5 2.5 0 0 0 2.5-2.5z"></path></svg></button> <!>`, 1);
var root$b = /* @__PURE__ */ from_html(`<div><!></div>`);
const $$css$d = {
  hash: "svelte-eor01u",
  code: '.fullscreen.svelte-eor01u {outline:none;border:none;background:none;padding-block:initial;padding-inline:initial;font-family:inherit;color:inherit;height:100%;color:var(--cl-foreground);font-size:14px;display:flex;flex-direction:row;align-items:center;justify-content:center;cursor:default;position:relative;z-index:0;padding:0 5px;}\n@media (hover: hover) and (pointer: fine) {.fullscreen.svelte-eor01u:hover:before {position:absolute;top:2px;right:2px;bottom:2px;left:2px;z-index:-1;border-radius:4px;content:"";background-color:var(--cl-button-hoverBackground);}\n}.fullscreen.svelte-eor01u > svg:where(.svelte-eor01u) {width:28px;height:28px;color:var(--cl-foreground);}'
};
function Fullscreen($$anchor, $$props) {
  push($$props, false);
  append_styles$1($$anchor, $$css$d);
  const { t: t2 } = useTranslation();
  const kb = KeyCode.KeyF | KeyMod.Shift;
  const chartManagementService = useService(IChartManagementService);
  const keybindingsRegistry = useService(IKeybindingsRegistry);
  const enterFullScreen = () => {
    const el = chartManagementService.getDomElement();
    if (!el) return;
    const enterFullScreen2 = el.requestFullscreen ?? el.webkitRequestFullscreen ?? el.mozRequestFullScreen ?? el.msRequestFullscreen;
    enterFullScreen2.call(el);
  };
  useDisposable(keybindingsRegistry.registerCommandAndKeybindingRule({
    id: "ui.fullscreen",
    primary: kb,
    weight: KeybindingWeight.WorkbenchContrib,
    handler: () => {
      enterFullScreen();
    }
  }));
  init();
  var div = root$b();
  var node = child(div);
  Wrapper(node, {
    children: ($$anchor2, $$slotProps) => {
      var fragment = root_1$a();
      var button = first_child(fragment);
      var event_handler = /* @__PURE__ */ user_derived(() => ifLeftClick(enterFullScreen));
      button.__pointerup = function(...$$args) {
        var _a3;
        (_a3 = get$1(event_handler)) == null ? void 0 : _a3.apply(this, $$args);
      };
      var node_1 = sibling(button, 2);
      Tooltip(node_1, {
        children: ($$anchor3, $$slotProps2) => {
          {
            let $0 = /* @__PURE__ */ derived_safe_equal(() => t2("topToolbar.fullscreen"));
            TooltipContent($$anchor3, {
              get content() {
                return get$1($0);
              },
              get keybinding() {
                return kb;
              }
            });
          }
        },
        $$slots: { default: true }
      });
      append($$anchor2, fragment);
    },
    $$slots: { default: true }
  });
  append($$anchor, div);
  pop();
}
delegate(["pointerup"]);
function compareAnything(one, other, lookFor) {
  const elementAName = one.toLowerCase();
  const elementBName = other.toLowerCase();
  const prefixCompare = compareByPrefix(one, other, lookFor);
  if (prefixCompare) {
    return prefixCompare;
  }
  const elementASuffixMatch = elementAName.endsWith(lookFor);
  const elementBSuffixMatch = elementBName.endsWith(lookFor);
  if (elementASuffixMatch !== elementBSuffixMatch) {
    return elementASuffixMatch ? -1 : 1;
  }
  return elementAName.localeCompare(elementBName);
}
function compareByPrefix(one, other, lookFor) {
  const elementAName = one.toLowerCase();
  const elementBName = other.toLowerCase();
  const elementAPrefixMatch = elementAName.startsWith(lookFor);
  const elementBPrefixMatch = elementBName.startsWith(lookFor);
  if (elementAPrefixMatch !== elementBPrefixMatch) {
    return elementAPrefixMatch ? -1 : 1;
  } else if (elementAPrefixMatch && elementBPrefixMatch) {
    if (elementAName.length < elementBName.length) {
      return -1;
    }
    if (elementAName.length > elementBName.length) {
      return 1;
    }
  }
  return 0;
}
const matchesPrefix = _matchesPrefix.bind(void 0, true);
function _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {
  if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {
    return null;
  }
  let matches2;
  if (ignoreCase) {
    matches2 = startsWithIgnoreCase(wordToMatchAgainst, word);
  } else {
    matches2 = wordToMatchAgainst.indexOf(word) === 0;
  }
  if (!matches2) {
    return null;
  }
  return word.length > 0 ? [{ start: 0, end: word.length }] : [];
}
function isUpper(code) {
  return CharCode.A <= code && code <= CharCode.Z;
}
const wordSeparators = /* @__PURE__ */ new Set();
"()[]{}<>`'\"-/;:,.?!".split("").forEach((s2) => wordSeparators.add(s2.charCodeAt(0)));
const _maxLen = 128;
function initTable() {
  const table = [];
  const row = [];
  for (let i2 = 0; i2 <= _maxLen; i2++) {
    row[i2] = 0;
  }
  for (let i2 = 0; i2 <= _maxLen; i2++) {
    table.push(row.slice(0));
  }
  return table;
}
initTable();
initTable();
initTable();
var FuzzyScore;
((FuzzyScore2) => {
  FuzzyScore2.Default = [-100, 0];
  function isDefault(score) {
    return !score || score.length === 2 && score[0] === -100 && score[1] === 0;
  }
  FuzzyScore2.isDefault = isDefault;
})(FuzzyScore || (FuzzyScore = {}));
function hash(obj) {
  return doHash(obj, 0);
}
function doHash(obj, hashVal) {
  switch (typeof obj) {
    case "object":
      if (obj === null) {
        return numberHash(349, hashVal);
      } else if (Array.isArray(obj)) {
        return arrayHash(obj, hashVal);
      }
      return objectHash(obj, hashVal);
    case "string":
      return stringHash(obj, hashVal);
    case "boolean":
      return booleanHash(obj, hashVal);
    case "number":
      return numberHash(obj, hashVal);
    case "undefined":
      return numberHash(937, hashVal);
    default:
      return numberHash(617, hashVal);
  }
}
function numberHash(val, initialHashVal) {
  return (initialHashVal << 5) - initialHashVal + val | 0;
}
function booleanHash(b2, initialHashVal) {
  return numberHash(b2 ? 433 : 863, initialHashVal);
}
function stringHash(s2, hashVal) {
  hashVal = numberHash(149417, hashVal);
  for (let i2 = 0, length = s2.length; i2 < length; i2++) {
    hashVal = numberHash(s2.charCodeAt(i2), hashVal);
  }
  return hashVal;
}
function arrayHash(arr, initialHashVal) {
  initialHashVal = numberHash(104579, initialHashVal);
  return arr.reduce((hashVal, item) => doHash(item, hashVal), initialHashVal);
}
function objectHash(obj, initialHashVal) {
  initialHashVal = numberHash(181387, initialHashVal);
  return Object.keys(obj).sort().reduce((hashVal, key2) => {
    hashVal = stringHash(key2, hashVal);
    return doHash(obj[key2], hashVal);
  }, initialHashVal);
}
const NO_MATCH = 0;
const NO_SCORE = [NO_MATCH, []];
function scoreFuzzy(target, query, queryLower, allowNonContiguousMatches) {
  if (!target || !query) {
    return NO_SCORE;
  }
  const targetLength = target.length;
  const queryLength = query.length;
  if (targetLength < queryLength) {
    return NO_SCORE;
  }
  const targetLower = target.toLowerCase();
  const res = doScoreFuzzy(
    query,
    queryLower,
    queryLength,
    target,
    targetLower,
    targetLength,
    allowNonContiguousMatches
  );
  return res;
}
function doScoreFuzzy(query, queryLower, queryLength, target, targetLower, targetLength, allowNonContiguousMatches) {
  const scores = [];
  const matches2 = [];
  for (let queryIndex2 = 0; queryIndex2 < queryLength; queryIndex2++) {
    const queryIndexOffset = queryIndex2 * targetLength;
    const queryIndexPreviousOffset = queryIndexOffset - targetLength;
    const queryIndexGtNull = queryIndex2 > 0;
    const queryCharAtIndex = query[queryIndex2];
    const queryLowerCharAtIndex = queryLower[queryIndex2];
    for (let targetIndex2 = 0; targetIndex2 < targetLength; targetIndex2++) {
      const targetIndexGtNull = targetIndex2 > 0;
      const currentIndex = queryIndexOffset + targetIndex2;
      const leftIndex = currentIndex - 1;
      const diagIndex = queryIndexPreviousOffset + targetIndex2 - 1;
      const leftScore = targetIndexGtNull ? scores[leftIndex] : 0;
      const diagScore = queryIndexGtNull && targetIndexGtNull ? scores[diagIndex] : 0;
      const matchesSequenceLength = queryIndexGtNull && targetIndexGtNull ? matches2[diagIndex] : 0;
      let score;
      if (!diagScore && queryIndexGtNull) {
        score = 0;
      } else {
        score = computeCharScore(
          queryCharAtIndex,
          queryLowerCharAtIndex,
          target,
          targetLower,
          targetIndex2,
          matchesSequenceLength
        );
      }
      const isValidScore = score && diagScore + score >= leftScore;
      if (isValidScore && // We don't need to check if it's contiguous if we allow non-contiguous matches
      (allowNonContiguousMatches || // We must be looking for a contiguous match.
      // Looking at an index higher than 0 in the query means we must have already
      // found out this is contiguous otherwise there wouldn't have been a score
      queryIndexGtNull || // lastly check if the query is completely contiguous at this index in the target
      targetLower.startsWith(queryLower, targetIndex2))) {
        matches2[currentIndex] = matchesSequenceLength + 1;
        scores[currentIndex] = diagScore + score;
      } else {
        matches2[currentIndex] = NO_MATCH;
        scores[currentIndex] = leftScore;
      }
    }
  }
  const positions = [];
  let queryIndex = queryLength - 1;
  let targetIndex = targetLength - 1;
  while (queryIndex >= 0 && targetIndex >= 0) {
    const currentIndex = queryIndex * targetLength + targetIndex;
    const match2 = matches2[currentIndex];
    if (match2 === NO_MATCH) {
      targetIndex--;
    } else {
      positions.push(targetIndex);
      queryIndex--;
      targetIndex--;
    }
  }
  return [scores[queryLength * targetLength - 1], positions.reverse()];
}
function computeCharScore(queryCharAtIndex, queryLowerCharAtIndex, target, targetLower, targetIndex, matchesSequenceLength) {
  let score = 0;
  if (!considerAsEqual(queryLowerCharAtIndex, targetLower[targetIndex])) {
    return score;
  }
  score += 1;
  if (matchesSequenceLength > 0) {
    score += matchesSequenceLength * 5;
  }
  if (queryCharAtIndex === target[targetIndex]) {
    score += 1;
  }
  if (targetIndex === 0) {
    score += 8;
  } else {
    const separatorBonus = scoreSeparatorAtPos(target.charCodeAt(targetIndex - 1));
    if (separatorBonus) {
      score += separatorBonus;
    } else if (isUpper(target.charCodeAt(targetIndex)) && matchesSequenceLength === 0) {
      score += 2;
    }
  }
  return score;
}
function considerAsEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (a2 === "/" || a2 === "\\") {
    return b2 === "/" || b2 === "\\";
  }
  return false;
}
function scoreSeparatorAtPos(charCode) {
  switch (charCode) {
    case CharCode.Slash:
    case CharCode.Backslash:
      return 5;
    // prefer path separators...
    case CharCode.Underline:
    case CharCode.Dash:
    case CharCode.Period:
    case CharCode.Space:
    case CharCode.SingleQuote:
    case CharCode.DoubleQuote:
    case CharCode.Colon:
      return 4;
    // ...over other separators
    default:
      return 0;
  }
}
const NO_ITEM_SCORE = Object.freeze({ score: 0 });
const LABEL_PREFIX_SCORE_THRESHOLD = 1 << 17;
const LABEL_SCORE_THRESHOLD = 1 << 16;
function getCacheHash(label, description, allowNonContiguousMatches, query) {
  const values2 = query.values ? query.values : [query];
  const cacheHash = hash({
    [query.normalized]: {
      values: values2.map((v2) => ({
        value: v2.normalized,
        expectContiguousMatch: v2.expectContiguousMatch
      })),
      label,
      description,
      allowNonContiguousMatches
    }
  });
  return cacheHash;
}
function scoreItemFuzzy(item, query, allowNonContiguousMatches, accessor, cache2) {
  if (!item || !query.normalized) {
    return NO_ITEM_SCORE;
  }
  const label = accessor.getItemLabel(item);
  if (!label) {
    return NO_ITEM_SCORE;
  }
  const description = accessor.getItemDescription(item);
  const cacheHash = getCacheHash(label, description, allowNonContiguousMatches, query);
  const cached = cache2[cacheHash];
  if (cached) {
    return cached;
  }
  const itemScore = doScoreItemFuzzy(label, description, query);
  cache2[cacheHash] = itemScore;
  return itemScore;
}
function doScoreItemFuzzy(label, description, query, allowNonContiguousMatches) {
  if (query.values && query.values.length > 1) {
    return doScoreItemFuzzyMultiple(
      label,
      description,
      query.values
    );
  }
  return doScoreItemFuzzySingle(
    label,
    description,
    query
  );
}
function doScoreItemFuzzyMultiple(label, description, query, preferLabelMatches, allowNonContiguousMatches) {
  let totalScore = 0;
  const totalLabelMatches = [];
  const totalDescriptionMatches = [];
  for (const queryPiece of query) {
    const { score, labelMatch, descriptionMatch } = doScoreItemFuzzySingle(
      label,
      description,
      queryPiece
    );
    if (score === NO_MATCH) {
      return NO_ITEM_SCORE;
    }
    totalScore += score;
    if (labelMatch) {
      totalLabelMatches.push(...labelMatch);
    }
    if (descriptionMatch) {
      totalDescriptionMatches.push(...descriptionMatch);
    }
  }
  return {
    score: totalScore,
    labelMatch: normalizeMatches(totalLabelMatches),
    descriptionMatch: normalizeMatches(totalDescriptionMatches)
  };
}
function doScoreItemFuzzySingle(label, description, query, preferLabelMatches, allowNonContiguousMatches) {
  {
    const [labelScore, labelPositions] = scoreFuzzy(
      label,
      query.normalized,
      query.normalizedLowercase,
      !query.expectContiguousMatch
    );
    if (labelScore) {
      const labelPrefixMatch = matchesPrefix(query.normalized, label);
      let baseScore;
      if (labelPrefixMatch) {
        baseScore = LABEL_PREFIX_SCORE_THRESHOLD;
        const prefixLengthBoost = Math.round(query.normalized.length / label.length * 100);
        baseScore += prefixLengthBoost;
      } else {
        baseScore = LABEL_SCORE_THRESHOLD;
      }
      return {
        score: baseScore + labelScore,
        labelMatch: labelPrefixMatch || createMatches(labelPositions)
      };
    }
  }
  if (description) {
    const descriptionPrefix = description;
    const descriptionPrefixLength = descriptionPrefix.length;
    const descriptionAndLabel = `${descriptionPrefix}${label}`;
    const [labelDescriptionScore, labelDescriptionPositions] = scoreFuzzy(
      descriptionAndLabel,
      query.normalized,
      query.normalizedLowercase,
      !query.expectContiguousMatch
    );
    if (labelDescriptionScore) {
      const labelDescriptionMatches = createMatches(labelDescriptionPositions);
      const labelMatch = [];
      const descriptionMatch = [];
      labelDescriptionMatches.forEach((h2) => {
        if (h2.start < descriptionPrefixLength && h2.end > descriptionPrefixLength) {
          labelMatch.push({ start: 0, end: h2.end - descriptionPrefixLength });
          descriptionMatch.push({ start: h2.start, end: descriptionPrefixLength });
        } else if (h2.start >= descriptionPrefixLength) {
          labelMatch.push({
            start: h2.start - descriptionPrefixLength,
            end: h2.end - descriptionPrefixLength
          });
        } else {
          descriptionMatch.push(h2);
        }
      });
      return { score: labelDescriptionScore, labelMatch, descriptionMatch };
    }
  }
  return NO_ITEM_SCORE;
}
function createMatches(offsets) {
  const ret = [];
  if (!offsets) {
    return ret;
  }
  let last2;
  for (const pos of offsets) {
    if (last2 && last2.end === pos) {
      last2.end += 1;
    } else {
      last2 = { start: pos, end: pos + 1 };
      ret.push(last2);
    }
  }
  return ret;
}
function normalizeMatches(matches2) {
  const sortedMatches = matches2.sort((matchA, matchB) => {
    return matchA.start - matchB.start;
  });
  const normalizedMatches = [];
  let currentMatch = void 0;
  for (const match2 of sortedMatches) {
    if (!currentMatch || !matchOverlaps(currentMatch, match2)) {
      currentMatch = match2;
      normalizedMatches.push(match2);
    } else {
      currentMatch.start = Math.min(currentMatch.start, match2.start);
      currentMatch.end = Math.max(currentMatch.end, match2.end);
    }
  }
  return normalizedMatches;
}
function matchOverlaps(matchA, matchB) {
  if (matchA.end < matchB.start) {
    return false;
  }
  if (matchB.end < matchA.start) {
    return false;
  }
  return true;
}
function compareItemsByFuzzyScore(itemA, itemB, query, allowNonContiguousMatches, accessor, cache2) {
  const itemScoreA = scoreItemFuzzy(itemA, query, allowNonContiguousMatches, accessor, cache2);
  const itemScoreB = scoreItemFuzzy(itemB, query, allowNonContiguousMatches, accessor, cache2);
  const scoreA = itemScoreA.score;
  const scoreB = itemScoreB.score;
  if (scoreA > LABEL_SCORE_THRESHOLD || scoreB > LABEL_SCORE_THRESHOLD) {
    if (scoreA !== scoreB) {
      return scoreA > scoreB ? -1 : 1;
    }
    if (scoreA < LABEL_PREFIX_SCORE_THRESHOLD && scoreB < LABEL_PREFIX_SCORE_THRESHOLD) {
      const comparedByMatchLength = compareByMatchLength(
        itemScoreA.labelMatch,
        itemScoreB.labelMatch
      );
      if (comparedByMatchLength !== 0) {
        return comparedByMatchLength;
      }
    }
    const labelA = accessor.getItemLabel(itemA) || "";
    const labelB = accessor.getItemLabel(itemB) || "";
    if (labelA.length !== labelB.length) {
      return labelA.length - labelB.length;
    }
  }
  if (scoreA !== scoreB) {
    return scoreA > scoreB ? -1 : 1;
  }
  const itemAHasLabelMatches = Array.isArray(itemScoreA.labelMatch) && itemScoreA.labelMatch.length > 0;
  const itemBHasLabelMatches = Array.isArray(itemScoreB.labelMatch) && itemScoreB.labelMatch.length > 0;
  if (itemAHasLabelMatches && !itemBHasLabelMatches) {
    return -1;
  } else if (itemBHasLabelMatches && !itemAHasLabelMatches) {
    return 1;
  }
  const itemAMatchDistance = computeLabelAndDescriptionMatchDistance(itemA, itemScoreA, accessor);
  const itemBMatchDistance = computeLabelAndDescriptionMatchDistance(itemB, itemScoreB, accessor);
  if (itemAMatchDistance && itemBMatchDistance && itemAMatchDistance !== itemBMatchDistance) {
    return itemBMatchDistance > itemAMatchDistance ? -1 : 1;
  }
  return fallbackCompare(itemA, itemB, query, accessor);
}
function computeLabelAndDescriptionMatchDistance(item, score, accessor) {
  let matchStart = -1;
  let matchEnd = -1;
  if (score.descriptionMatch && score.descriptionMatch.length) {
    matchStart = score.descriptionMatch[0].start;
  } else if (score.labelMatch && score.labelMatch.length) {
    matchStart = score.labelMatch[0].start;
  }
  if (score.labelMatch && score.labelMatch.length) {
    matchEnd = score.labelMatch[score.labelMatch.length - 1].end;
    if (score.descriptionMatch && score.descriptionMatch.length) {
      const itemDescription = accessor.getItemDescription(item);
      if (itemDescription) {
        matchEnd += itemDescription.length;
      }
    }
  } else if (score.descriptionMatch && score.descriptionMatch.length) {
    matchEnd = score.descriptionMatch[score.descriptionMatch.length - 1].end;
  }
  return matchEnd - matchStart;
}
function compareByMatchLength(matchesA, matchesB) {
  if (!matchesA && !matchesB || (!matchesA || !matchesA.length) && (!matchesB || !matchesB.length)) {
    return 0;
  }
  if (!matchesB || !matchesB.length) {
    return -1;
  }
  if (!matchesA || !matchesA.length) {
    return 1;
  }
  const matchStartA = matchesA[0].start;
  const matchEndA = matchesA[matchesA.length - 1].end;
  const matchLengthA = matchEndA - matchStartA;
  const matchStartB = matchesB[0].start;
  const matchEndB = matchesB[matchesB.length - 1].end;
  const matchLengthB = matchEndB - matchStartB;
  return matchLengthA === matchLengthB ? 0 : matchLengthB < matchLengthA ? 1 : -1;
}
function fallbackCompare(itemA, itemB, query, accessor) {
  const labelA = accessor.getItemLabel(itemA) || "";
  const labelB = accessor.getItemLabel(itemB) || "";
  const descriptionA = accessor.getItemDescription(itemA);
  const descriptionB = accessor.getItemDescription(itemB);
  const labelDescriptionALength = labelA.length + (descriptionA ? descriptionA.length : 0);
  const labelDescriptionBLength = labelB.length + (descriptionB ? descriptionB.length : 0);
  if (labelDescriptionALength !== labelDescriptionBLength) {
    return labelDescriptionALength - labelDescriptionBLength;
  }
  if (labelA !== labelB) {
    return compareAnything(labelA, labelB, query.normalized);
  }
  if (descriptionA && descriptionB && descriptionA !== descriptionB) {
    return compareAnything(descriptionA, descriptionB, query.normalized);
  }
  return 0;
}
function queryExpectsExactMatch(query) {
  return query.startsWith('"') && query.endsWith('"');
}
const MULTIPLE_QUERY_VALUES_SEPARATOR = " ";
function prepareQuery(original) {
  if (typeof original !== "string") {
    original = "";
  }
  const originalLowercase = original.toLowerCase();
  const { normalized, normalizedLowercase } = normalizeQuery(original);
  const containsPathSeparator = false;
  const expectExactMatch = queryExpectsExactMatch(original);
  let values2 = void 0;
  const originalSplit = original.split(MULTIPLE_QUERY_VALUES_SEPARATOR);
  if (originalSplit.length > 1) {
    for (const originalPiece of originalSplit) {
      const expectExactMatchPiece = queryExpectsExactMatch(originalPiece);
      const { normalized: normalizedPiece, normalizedLowercase: normalizedLowercasePiece } = normalizeQuery(originalPiece);
      if (normalizedPiece) {
        if (!values2) {
          values2 = [];
        }
        values2.push({
          original: originalPiece,
          originalLowercase: originalPiece.toLowerCase(),
          normalized: normalizedPiece,
          normalizedLowercase: normalizedLowercasePiece,
          expectContiguousMatch: expectExactMatchPiece
        });
      }
    }
  }
  return {
    original,
    originalLowercase,
    normalized,
    normalizedLowercase,
    values: values2,
    containsPathSeparator,
    expectContiguousMatch: expectExactMatch
  };
}
function normalizeQuery(original) {
  const normalized = stripWildcards(original).replace(/\s|"/g, "");
  return {
    normalized,
    normalizedLowercase: normalized.toLowerCase()
  };
}
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
function isScrollable(el) {
  return el ? el.scrollHeight > el.offsetHeight : false;
}
function isScrollAtTop(el) {
  return el ? el.scrollTop === 0 : false;
}
function isScrollAtBottom(el) {
  return el ? Math.ceil(el.scrollHeight - el.scrollTop) === el.clientHeight : false;
}
function areTopsMisaligned(els) {
  const tops = /* @__PURE__ */ new Set();
  [].forEach.call(els, (el) => tops.add(el.offsetTop));
  return tops.size > 1;
}
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
const cssClasses = {
  CLOSING: "mdc-dialog--closing",
  OPEN: "mdc-dialog--open",
  OPENING: "mdc-dialog--opening",
  SCROLLABLE: "mdc-dialog--scrollable",
  SCROLL_LOCK: "mdc-dialog-scroll-lock",
  STACKED: "mdc-dialog--stacked",
  FULLSCREEN: "mdc-dialog--fullscreen",
  // Class for showing a scroll divider on full-screen dialog header element.
  // Should only be displayed on scrollable content, when the dialog content is
  // scrolled "underneath" the header.
  SCROLL_DIVIDER_HEADER: "mdc-dialog-scroll-divider-header",
  // Class for showing a scroll divider on a full-screen dialog footer element.
  // Should only be displayed on scrolalble content, when the dialog content is
  // obscured "underneath" the footer.
  SCROLL_DIVIDER_FOOTER: "mdc-dialog-scroll-divider-footer",
  // The "surface scrim" is a scrim covering only the surface of a dialog. This
  // is used in situations where a confirmation dialog is shown over an already
  // opened full-screen dialog. On larger screen-sizes, the full-screen dialog
  // is sized as a modal and so in these situations we display a "surface scrim"
  // to prevent a "double scrim" (where the scrim from the secondary
  // confirmation dialog would overlap with the scrim from the full-screen
  // dialog).
  SURFACE_SCRIM_SHOWN: "mdc-dialog__surface-scrim--shown",
  // "Showing" animating class for the surface-scrim.
  SURFACE_SCRIM_SHOWING: "mdc-dialog__surface-scrim--showing",
  // "Hiding" animating class for the surface-scrim.
  SURFACE_SCRIM_HIDING: "mdc-dialog__surface-scrim--hiding",
  // Class to hide a dialog's scrim (used in conjunction with a surface-scrim).
  // Note that we only hide the original scrim rather than removing it entirely
  // to prevent interactions with the content behind this scrim, and to capture
  // scrim clicks.
  SCRIM_HIDDEN: "mdc-dialog__scrim--hidden"
};
const strings = {
  ACTION_ATTRIBUTE: "data-mdc-dialog-action",
  BUTTON_DEFAULT_ATTRIBUTE: "data-mdc-dialog-button-default",
  BUTTON_SELECTOR: ".mdc-dialog__button",
  CLOSED_EVENT: "MDCDialog:closed",
  CLOSE_ACTION: "close",
  CLOSING_EVENT: "MDCDialog:closing",
  CONTAINER_SELECTOR: ".mdc-dialog__container",
  CONTENT_SELECTOR: ".mdc-dialog__content",
  DESTROY_ACTION: "destroy",
  INITIAL_FOCUS_ATTRIBUTE: "data-mdc-dialog-initial-focus",
  OPENED_EVENT: "MDCDialog:opened",
  OPENING_EVENT: "MDCDialog:opening",
  SCRIM_SELECTOR: ".mdc-dialog__scrim",
  SUPPRESS_DEFAULT_PRESS_SELECTOR: [
    "textarea",
    ".mdc-menu .mdc-list-item",
    ".mdc-menu .mdc-deprecated-list-item"
  ].join(", "),
  SURFACE_SELECTOR: ".mdc-dialog__surface"
};
const numbers = {
  DIALOG_ANIMATION_CLOSE_TIME_MS: 75,
  DIALOG_ANIMATION_OPEN_TIME_MS: 150
};
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
class MDCDialogFoundation extends MDCFoundation {
  constructor(adapter) {
    super({ ...MDCDialogFoundation.defaultAdapter, ...adapter });
    this.dialogOpen = false;
    this.isFullscreen = false;
    this.animationFrame = 0;
    this.animationTimer = 0;
    this.escapeKeyAction = strings.CLOSE_ACTION;
    this.scrimClickAction = strings.CLOSE_ACTION;
    this.autoStackButtons = true;
    this.areButtonsStacked = false;
    this.suppressDefaultPressSelector = strings.SUPPRESS_DEFAULT_PRESS_SELECTOR;
    this.animFrame = new AnimationFrame();
    this.contentScrollHandler = () => {
      this.handleScrollEvent();
    };
    this.windowResizeHandler = () => {
      this.layout();
    };
    this.windowOrientationChangeHandler = () => {
      this.layout();
    };
  }
  static get cssClasses() {
    return cssClasses;
  }
  static get strings() {
    return strings;
  }
  static get numbers() {
    return numbers;
  }
  static get defaultAdapter() {
    return {
      addBodyClass: () => void 0,
      addClass: () => void 0,
      areButtonsStacked: () => false,
      clickDefaultButton: () => void 0,
      eventTargetMatches: () => false,
      getActionFromEvent: () => "",
      getInitialFocusEl: () => null,
      hasClass: () => false,
      isContentScrollable: () => false,
      notifyClosed: () => void 0,
      notifyClosing: () => void 0,
      notifyOpened: () => void 0,
      notifyOpening: () => void 0,
      releaseFocus: () => void 0,
      removeBodyClass: () => void 0,
      removeClass: () => void 0,
      reverseButtons: () => void 0,
      trapFocus: () => void 0,
      registerContentEventHandler: () => void 0,
      deregisterContentEventHandler: () => void 0,
      isScrollableContentAtTop: () => false,
      isScrollableContentAtBottom: () => false,
      registerWindowEventHandler: () => void 0,
      deregisterWindowEventHandler: () => void 0
    };
  }
  init() {
    if (this.adapter.hasClass(cssClasses.STACKED)) {
      this.setAutoStackButtons(false);
    }
    this.isFullscreen = this.adapter.hasClass(cssClasses.FULLSCREEN);
  }
  destroy() {
    if (this.animationTimer) {
      clearTimeout(this.animationTimer);
      this.handleAnimationTimerEnd();
    }
    if (this.isFullscreen) {
      this.adapter.deregisterContentEventHandler("scroll", this.contentScrollHandler);
    }
    this.animFrame.cancelAll();
    this.adapter.deregisterWindowEventHandler("resize", this.windowResizeHandler);
    this.adapter.deregisterWindowEventHandler(
      "orientationchange",
      this.windowOrientationChangeHandler
    );
  }
  open(dialogOptions) {
    this.dialogOpen = true;
    this.adapter.notifyOpening();
    this.adapter.addClass(cssClasses.OPENING);
    if (this.isFullscreen) {
      this.adapter.registerContentEventHandler("scroll", this.contentScrollHandler);
    }
    if (dialogOptions && dialogOptions.isAboveFullscreenDialog) {
      this.adapter.addClass(cssClasses.SCRIM_HIDDEN);
    }
    this.adapter.registerWindowEventHandler("resize", this.windowResizeHandler);
    this.adapter.registerWindowEventHandler(
      "orientationchange",
      this.windowOrientationChangeHandler
    );
    this.runNextAnimationFrame(() => {
      this.adapter.addClass(cssClasses.OPEN);
      if (!dialogOptions || !dialogOptions.isScrimless) {
        this.adapter.addBodyClass(cssClasses.SCROLL_LOCK);
      }
      this.layout();
      this.animationTimer = setTimeout(() => {
        this.handleAnimationTimerEnd();
        this.adapter.trapFocus(this.adapter.getInitialFocusEl());
        this.adapter.notifyOpened();
      }, numbers.DIALOG_ANIMATION_OPEN_TIME_MS);
    });
  }
  close(action2 = "") {
    if (!this.dialogOpen) {
      return;
    }
    this.dialogOpen = false;
    this.adapter.notifyClosing(action2);
    this.adapter.addClass(cssClasses.CLOSING);
    this.adapter.removeClass(cssClasses.OPEN);
    this.adapter.removeBodyClass(cssClasses.SCROLL_LOCK);
    if (this.isFullscreen) {
      this.adapter.deregisterContentEventHandler("scroll", this.contentScrollHandler);
    }
    this.adapter.deregisterWindowEventHandler("resize", this.windowResizeHandler);
    this.adapter.deregisterWindowEventHandler(
      "orientationchange",
      this.windowOrientationChangeHandler
    );
    cancelAnimationFrame(this.animationFrame);
    this.animationFrame = 0;
    clearTimeout(this.animationTimer);
    this.animationTimer = setTimeout(() => {
      this.adapter.releaseFocus();
      this.handleAnimationTimerEnd();
      this.adapter.notifyClosed(action2);
    }, numbers.DIALOG_ANIMATION_CLOSE_TIME_MS);
  }
  /**
   * Used only in instances of showing a secondary dialog over a full-screen
   * dialog. Shows the "surface scrim" displayed over the full-screen dialog.
   */
  showSurfaceScrim() {
    this.adapter.addClass(cssClasses.SURFACE_SCRIM_SHOWING);
    this.runNextAnimationFrame(() => {
      this.adapter.addClass(cssClasses.SURFACE_SCRIM_SHOWN);
    });
  }
  /**
   * Used only in instances of showing a secondary dialog over a full-screen
   * dialog. Hides the "surface scrim" displayed over the full-screen dialog.
   */
  hideSurfaceScrim() {
    this.adapter.removeClass(cssClasses.SURFACE_SCRIM_SHOWN);
    this.adapter.addClass(cssClasses.SURFACE_SCRIM_HIDING);
  }
  /**
   * Handles `transitionend` event triggered when surface scrim animation is
   * finished.
   */
  handleSurfaceScrimTransitionEnd() {
    this.adapter.removeClass(cssClasses.SURFACE_SCRIM_HIDING);
    this.adapter.removeClass(cssClasses.SURFACE_SCRIM_SHOWING);
  }
  isOpen() {
    return this.dialogOpen;
  }
  getEscapeKeyAction() {
    return this.escapeKeyAction;
  }
  setEscapeKeyAction(action2) {
    this.escapeKeyAction = action2;
  }
  getScrimClickAction() {
    return this.scrimClickAction;
  }
  setScrimClickAction(action2) {
    this.scrimClickAction = action2;
  }
  getAutoStackButtons() {
    return this.autoStackButtons;
  }
  setAutoStackButtons(autoStack) {
    this.autoStackButtons = autoStack;
  }
  getSuppressDefaultPressSelector() {
    return this.suppressDefaultPressSelector;
  }
  setSuppressDefaultPressSelector(selector) {
    this.suppressDefaultPressSelector = selector;
  }
  layout() {
    this.animFrame.request("poll_layout_change", () => {
      this.layoutInternal();
    });
  }
  /** Handles click on the dialog root element. */
  handleClick(event2) {
    const isScrim = this.adapter.eventTargetMatches(event2.target, strings.SCRIM_SELECTOR);
    if (isScrim && this.scrimClickAction !== "") {
      this.close(this.scrimClickAction);
    } else {
      const action2 = this.adapter.getActionFromEvent(event2);
      if (action2) {
        this.close(action2);
      }
    }
  }
  /** Handles keydown on the dialog root element. */
  handleKeydown(event2) {
    const isEnter = event2.key === "Enter" || event2.keyCode === 13;
    if (!isEnter) {
      return;
    }
    const action2 = this.adapter.getActionFromEvent(event2);
    if (action2) {
      return;
    }
    const target = event2.composedPath ? event2.composedPath()[0] : event2.target;
    const isDefault = this.suppressDefaultPressSelector ? !this.adapter.eventTargetMatches(target, this.suppressDefaultPressSelector) : true;
    if (isEnter && isDefault) {
      this.adapter.clickDefaultButton();
    }
  }
  /** Handles keydown on the document. */
  handleDocumentKeydown(event2) {
    const isEscape = event2.key === "Escape" || event2.keyCode === 27;
    if (isEscape && this.escapeKeyAction !== "") {
      this.close(this.escapeKeyAction);
    }
  }
  /**
   * Handles scroll event on the dialog's content element -- showing a scroll
   * divider on the header or footer based on the scroll position. This handler
   * should only be registered on full-screen dialogs with scrollable content.
   */
  handleScrollEvent() {
    this.animFrame.request("poll_scroll_position", () => {
      this.toggleScrollDividerHeader();
      this.toggleScrollDividerFooter();
    });
  }
  layoutInternal() {
    if (this.autoStackButtons) {
      this.detectStackedButtons();
    }
    this.toggleScrollableClasses();
  }
  handleAnimationTimerEnd() {
    this.animationTimer = 0;
    this.adapter.removeClass(cssClasses.OPENING);
    this.adapter.removeClass(cssClasses.CLOSING);
  }
  /**
   * Runs the given logic on the next animation frame, using setTimeout to
   * factor in Firefox reflow behavior.
   */
  runNextAnimationFrame(callback) {
    cancelAnimationFrame(this.animationFrame);
    this.animationFrame = requestAnimationFrame(() => {
      this.animationFrame = 0;
      clearTimeout(this.animationTimer);
      this.animationTimer = setTimeout(callback, 0);
    });
  }
  detectStackedButtons() {
    this.adapter.removeClass(cssClasses.STACKED);
    const areButtonsStacked = this.adapter.areButtonsStacked();
    if (areButtonsStacked) {
      this.adapter.addClass(cssClasses.STACKED);
    }
    if (areButtonsStacked !== this.areButtonsStacked) {
      this.adapter.reverseButtons();
      this.areButtonsStacked = areButtonsStacked;
    }
  }
  toggleScrollableClasses() {
    this.adapter.removeClass(cssClasses.SCROLLABLE);
    if (this.adapter.isContentScrollable()) {
      this.adapter.addClass(cssClasses.SCROLLABLE);
      if (this.isFullscreen) {
        this.toggleScrollDividerHeader();
        this.toggleScrollDividerFooter();
      }
    }
  }
  toggleScrollDividerHeader() {
    if (!this.adapter.isScrollableContentAtTop()) {
      this.adapter.addClass(cssClasses.SCROLL_DIVIDER_HEADER);
    } else if (this.adapter.hasClass(cssClasses.SCROLL_DIVIDER_HEADER)) {
      this.adapter.removeClass(cssClasses.SCROLL_DIVIDER_HEADER);
    }
  }
  toggleScrollDividerFooter() {
    if (!this.adapter.isScrollableContentAtBottom()) {
      this.adapter.addClass(cssClasses.SCROLL_DIVIDER_FOOTER);
    } else if (this.adapter.hasClass(cssClasses.SCROLL_DIVIDER_FOOTER)) {
      this.adapter.removeClass(cssClasses.SCROLL_DIVIDER_FOOTER);
    }
  }
}
var root_1$9 = /* @__PURE__ */ from_html(`<div class="mdc-dialog__surface-scrim"></div>`);
var root$a = /* @__PURE__ */ from_html(`<div><div><div><!> <!></div></div> <div class="mdc-dialog__scrim"></div></div> <!>`, 1);
function Dialog($$anchor, $$props) {
  push($$props, true);
  const [$$stores, $$cleanup] = setup_stores();
  const $aboveFullscreenShown = () => store_get(aboveFullscreenShown, "$aboveFullscreenShown", $$stores);
  const { FocusTrap: FocusTrap2 } = domFocusTrap;
  const { closest: closest2, matches: matches2 } = ponyfill;
  let use = prop($$props, "use", 19, () => []), className = prop($$props, "class", 3, ""), open = prop($$props, "open", 15, false), selection = prop($$props, "selection", 3, false), escapeKeyAction = prop($$props, "escapeKeyAction", 3, "close"), scrimClickAction = prop($$props, "scrimClickAction", 3, "close"), autoStackButtons = prop($$props, "autoStackButtons", 3, true), fullscreen = prop($$props, "fullscreen", 3, false), sheet = prop($$props, "sheet", 3, false), noContentPadding = prop($$props, "noContentPadding", 3, false), container$class = prop($$props, "container$class", 3, ""), surface$class = prop($$props, "surface$class", 3, ""), restProps = /* @__PURE__ */ rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "use",
    "class",
    "open",
    "selection",
    "escapeKeyAction",
    "scrimClickAction",
    "autoStackButtons",
    "fullscreen",
    "sheet",
    "noContentPadding",
    "container$class",
    "surface$class",
    "children",
    "over"
  ]);
  let element2;
  let instance = /* @__PURE__ */ state(void 0);
  let eventManager = new SvelteEventManager();
  let internalClasses = proxy$1({});
  let focusTrap = null;
  let actionButtonsReversed = writable(false);
  let aboveFullscreen = getContext("SMUI:dialog:aboveFullscreen");
  let aboveFullscreenShown = getContext("SMUI:dialog:aboveFullscreenShown") ?? writable(false);
  let addLayoutListener = getContext("SMUI:addLayoutListener");
  let removeLayoutListener;
  let layoutListeners = [];
  let addLayoutListenerFn = (listener) => {
    layoutListeners.push(listener);
    return () => {
      const idx = layoutListeners.indexOf(listener);
      if (idx >= 0) {
        layoutListeners.splice(idx, 1);
      }
    };
  };
  setContext("SMUI:dialog:actions:reversed", actionButtonsReversed);
  setContext("SMUI:addLayoutListener", addLayoutListenerFn);
  setContext("SMUI:dialog:selection", selection());
  setContext("SMUI:dialog:aboveFullscreen", aboveFullscreen || fullscreen());
  setContext("SMUI:dialog:aboveFullscreenShown", aboveFullscreenShown);
  if (sheet()) {
    setContext("SMUI:icon-button:context", "dialog:sheet");
  }
  user_effect(() => {
    if (get$1(instance) && get$1(instance).getEscapeKeyAction() !== escapeKeyAction()) {
      get$1(instance).setEscapeKeyAction(escapeKeyAction());
    }
  });
  user_effect(() => {
    if (get$1(instance) && get$1(instance).getScrimClickAction() !== scrimClickAction()) {
      get$1(instance).setScrimClickAction(scrimClickAction());
    }
  });
  user_effect(() => {
    if (get$1(instance) && get$1(instance).getAutoStackButtons() !== autoStackButtons()) {
      get$1(instance).setAutoStackButtons(autoStackButtons());
    }
  });
  user_effect(() => {
    if (!autoStackButtons()) {
      store_set(actionButtonsReversed, true);
    }
  });
  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }
  user_effect(() => {
    if (get$1(instance) && get$1(instance).isOpen() !== open()) {
      if (open()) {
        get$1(instance).open({ isAboveFullscreenDialog: !!aboveFullscreen });
      } else {
        get$1(instance).close();
      }
    }
  });
  let previousAboveFullscreenShown = $aboveFullscreenShown();
  user_effect(() => {
    if (fullscreen() && get$1(instance) && previousAboveFullscreenShown !== $aboveFullscreenShown()) {
      previousAboveFullscreenShown = $aboveFullscreenShown();
      if ($aboveFullscreenShown()) {
        get$1(instance).showSurfaceScrim();
      } else {
        get$1(instance).hideSurfaceScrim();
      }
    }
  });
  onMount(() => {
    focusTrap = new FocusTrap2(element2, { initialFocusEl: getInitialFocusEl() ?? void 0 });
    set(
      instance,
      new MDCDialogFoundation({
        addBodyClass: (className2) => document.body.classList.add(className2),
        addClass,
        areButtonsStacked: () => areTopsMisaligned(getButtonEls()),
        clickDefaultButton: () => {
          const defaultButton = getDefaultButtonEl();
          if (defaultButton) {
            defaultButton.click();
          }
        },
        eventTargetMatches: (target, selector) => target ? matches2(target, selector) : false,
        getActionFromEvent: (evt) => {
          if (!evt.target) {
            return "";
          }
          const element3 = closest2(evt.target, "[data-mdc-dialog-action]");
          return element3 && element3.getAttribute("data-mdc-dialog-action");
        },
        getInitialFocusEl,
        hasClass,
        isContentScrollable: () => isScrollable(getContentEl()),
        notifyClosed: (action2) => {
          open(false);
          dispatch(getElement(), "SMUIDialogClosed", action2 ? { action: action2 } : {});
        },
        notifyClosing: (action2) => dispatch(getElement(), "SMUIDialogClosing", action2 ? { action: action2 } : {}),
        notifyOpened: () => dispatch(getElement(), "SMUIDialogOpened", {}),
        notifyOpening: () => dispatch(getElement(), "SMUIDialogOpening", {}),
        releaseFocus: () => focusTrap == null ? void 0 : focusTrap.releaseFocus(),
        removeBodyClass: (className2) => document.body.classList.remove(className2),
        removeClass,
        reverseButtons: () => {
          store_set(actionButtonsReversed, true);
        },
        trapFocus: () => focusTrap == null ? void 0 : focusTrap.trapFocus(),
        registerContentEventHandler: (evt, handler) => {
          const content = getContentEl();
          if (content instanceof HTMLElement) {
            eventManager.on(content, evt, handler);
          }
        },
        deregisterContentEventHandler: (evt, handler) => {
          const content = getContentEl();
          if (content instanceof HTMLElement) {
            eventManager.off(content, evt, handler);
          }
        },
        isScrollableContentAtTop: () => {
          return isScrollAtTop(getContentEl());
        },
        isScrollableContentAtBottom: () => {
          return isScrollAtBottom(getContentEl());
        },
        registerWindowEventHandler: (evt, handler) => eventManager.on(window, evt, handler),
        deregisterWindowEventHandler: (evt, handler) => eventManager.off(window, evt, handler)
      }),
      true
    );
    get$1(instance).init();
    return () => {
      var _a3;
      (_a3 = get$1(instance)) == null ? void 0 : _a3.destroy();
      set(instance, void 0);
      eventManager.clear();
      focusTrap == null ? void 0 : focusTrap.releaseFocus();
      focusTrap = null;
    };
  });
  onMount(() => {
    const onkeydown = (e2) => get$1(instance) && get$1(instance).handleDocumentKeydown(e2);
    document.body.addEventListener("keydown", onkeydown);
    const onresize = () => open() && get$1(instance) && get$1(instance).layout();
    window.addEventListener("resize", onresize);
    const onorientationchange = () => open() && get$1(instance) && get$1(instance).layout();
    window.addEventListener("orientationchange", onorientationchange);
    return () => {
      document.body.removeEventListener("keydown", onkeydown);
      window.removeEventListener("resize", onresize);
      window.removeEventListener("orientationchange", onorientationchange);
    };
  });
  onDestroy(() => {
    if (removeLayoutListener) {
      removeLayoutListener();
    }
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      internalClasses[className2] = true;
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      internalClasses[className2] = false;
    }
  }
  function getButtonEls() {
    return [].slice.call(getElement().querySelectorAll(".mdc-dialog__button"));
  }
  function getDefaultButtonEl() {
    return getElement().querySelector("[data-mdc-dialog-button-default]");
  }
  function getContentEl() {
    return getElement().querySelector(".mdc-dialog__content");
  }
  function getInitialFocusEl() {
    return getElement().querySelector("[data-mdc-dialog-initial-focus]");
  }
  function handleDialogOpening() {
    if (aboveFullscreen) {
      store_set(aboveFullscreenShown, true);
    }
    requestAnimationFrame(() => {
      layoutListeners.forEach((listener) => listener());
    });
  }
  function handleDialogOpened() {
    layoutListeners.forEach((listener) => listener());
  }
  function handleDialogClosed() {
    if (aboveFullscreen) {
      store_set(aboveFullscreenShown, false);
    }
  }
  function isOpen() {
    return open();
  }
  function setOpen(value) {
    open(value);
  }
  function layout() {
    var _a3;
    return (_a3 = get$1(instance)) == null ? void 0 : _a3.layout();
  }
  function getElement() {
    return element2;
  }
  var fragment = root$a();
  var div = first_child(fragment);
  var event_handler = (e2) => {
    var _a3;
    handleDialogOpening();
    (_a3 = $$props.onSMUIDialogOpening) == null ? void 0 : _a3.call($$props, e2);
  };
  var event_handler_1 = (e2) => {
    var _a3;
    handleDialogOpened();
    (_a3 = $$props.onSMUIDialogOpened) == null ? void 0 : _a3.call($$props, e2);
  };
  var event_handler_2 = (e2) => {
    var _a3;
    handleDialogClosed();
    (_a3 = $$props.onSMUIDialogClosed) == null ? void 0 : _a3.call($$props, e2);
  };
  var event_handler_3 = (e2) => {
    var _a3;
    if (get$1(instance)) {
      get$1(instance).handleClick(e2);
    }
    (_a3 = $$props.onclick) == null ? void 0 : _a3.call($$props, e2);
  };
  var event_handler_4 = (e2) => {
    var _a3;
    if (get$1(instance)) {
      get$1(instance).handleKeydown(e2);
    }
    (_a3 = $$props.onkeydown) == null ? void 0 : _a3.call($$props, e2);
  };
  attribute_effect(
    div,
    ($0, $1) => ({
      class: $0,
      role: "alertdialog",
      "aria-modal": "true",
      ...$1,
      onSMUIDialogOpening: event_handler,
      onSMUIDialogOpened: event_handler_1,
      onSMUIDialogClosed: event_handler_2,
      onclick: event_handler_3,
      onkeydown: event_handler_4
    }),
    [
      () => classMap({
        [className()]: true,
        "mdc-dialog": true,
        "mdc-dialog--stacked": !autoStackButtons(),
        "mdc-dialog--fullscreen": fullscreen(),
        "mdc-dialog--sheet": sheet(),
        "mdc-dialog--no-content-padding": noContentPadding(),
        "smui-dialog--selection": selection(),
        ...internalClasses
      }),
      () => exclude(restProps, ["container$", "surface$"])
    ]
  );
  var div_1 = child(div);
  attribute_effect(div_1, ($0, $1) => ({ class: $0, ...$1 }), [
    () => classMap({ [container$class()]: true, "mdc-dialog__container": true }),
    () => prefixFilter(restProps, "container$")
  ]);
  var div_2 = child(div_1);
  attribute_effect(div_2, ($0, $1) => ({ class: $0, role: "alertdialog", "aria-modal": "true", ...$1 }), [
    () => classMap({ [surface$class()]: true, "mdc-dialog__surface": true }),
    () => prefixFilter(restProps, "surface$")
  ]);
  var node = child(div_2);
  snippet(node, () => $$props.children ?? noop$1);
  var node_1 = sibling(node, 2);
  {
    var consequent = ($$anchor2) => {
      var div_3 = root_1$9();
      event("transitionend", div_3, () => get$1(instance) && get$1(instance).handleSurfaceScrimTransitionEnd());
      append($$anchor2, div_3);
    };
    if_block(node_1, ($$render) => {
      if (fullscreen()) $$render(consequent);
    });
  }
  bind_this(div, ($$value) => element2 = $$value, () => element2);
  action(div, ($$node, $$action_arg) => useActions == null ? void 0 : useActions($$node, $$action_arg), use);
  var node_2 = sibling(div, 2);
  snippet(node_2, () => $$props.over ?? noop$1);
  append($$anchor, fragment);
  var $$pop = pop({ isOpen, setOpen, layout, getElement });
  $$cleanup();
  return $$pop;
}
function Title($$anchor, $$props) {
  push($$props, true);
  let restProps = /* @__PURE__ */ rest_props($$props, ["$$slots", "$$events", "$$legacy", "children"]);
  let element2;
  function getElement() {
    return element2.getElement();
  }
  bind_this(
    ClassAdder($$anchor, spread_props({ _smuiClass: "mdc-dialog__title", tag: "h2" }, () => restProps, {
      children: ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node = first_child(fragment_1);
        snippet(node, () => $$props.children ?? noop$1);
        append($$anchor2, fragment_1);
      },
      $$slots: { default: true }
    })),
    ($$value) => element2 = $$value,
    () => element2
  );
  return pop({ getElement });
}
function Content($$anchor, $$props) {
  push($$props, true);
  let restProps = /* @__PURE__ */ rest_props($$props, ["$$slots", "$$events", "$$legacy", "children"]);
  let element2;
  function getElement() {
    return element2.getElement();
  }
  bind_this(
    ClassAdder($$anchor, spread_props({ _smuiClass: "mdc-dialog__content", tag: "div" }, () => restProps, {
      children: ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node = first_child(fragment_1);
        snippet(node, () => $$props.children ?? noop$1);
        append($$anchor2, fragment_1);
      },
      $$slots: { default: true }
    })),
    ($$value) => element2 = $$value,
    () => element2
  );
  return pop({ getElement });
}
function InitialFocus(node) {
  node.setAttribute("data-mdc-dialog-initial-focus", "");
  return {
    destroy() {
      node.removeAttribute("data-mdc-dialog-initial-focus");
    }
  };
}
const ao = {
  id: "Awesome Oscillator",
  name: "Awesome Oscillator",
  abbr: "AO",
  overlap: false,
  optionInfos: [
    {
      name: "shortPeriod",
      displayName: "Short Period",
      defaultValue: 5,
      type: "Integer",
      range: {
        min: 2,
        max: 1e5
      }
    },
    {
      name: "longPeriod",
      displayName: "Long Period",
      defaultValue: 5,
      type: "Integer",
      range: {
        min: 2,
        max: 1e5
      }
    }
  ],
  styleValues: {
    plots: {
      plot: {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(41, 98, 255)"
      }
    }
  },
  outputs: ["plot"],
  cal: async (worker, inputs, opt = /* @__PURE__ */ Object.create(null)) => {
    const options = opt;
    ao.optionInfos.forEach((opt2) => {
      options[opt2.name] = opt2.defaultValue;
    });
    return worker.ao(inputs, opt);
  },
  format: {
    type: "price",
    precision: 2
  }
};
const bbi = {
  id: "Bull and Bear Index",
  name: "Bull and Bear Index",
  abbr: "BBI",
  overlap: true,
  optionInfos: [
    {
      name: "n1",
      displayName: "N1",
      defaultValue: 3,
      type: "Integer",
      range: {
        min: 2,
        max: 1e5
      }
    },
    {
      name: "n2",
      displayName: "N2",
      defaultValue: 6,
      type: "Integer",
      range: {
        min: 2,
        max: 1e5
      }
    },
    {
      name: "n3",
      displayName: "N3",
      defaultValue: 12,
      type: "Integer",
      range: {
        min: 2,
        max: 1e5
      }
    },
    {
      name: "n4",
      displayName: "N4",
      defaultValue: 6,
      type: "Integer",
      range: {
        min: 2,
        max: 1e5
      }
    }
  ],
  styleValues: {
    plots: {
      plot: {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(41, 98, 255)"
      }
    }
  },
  outputs: ["plot"],
  cal: async (worker, inputs, opt = /* @__PURE__ */ Object.create(null)) => {
    const options = opt;
    bbi.optionInfos.forEach((opt2) => {
      options[opt2.name] = opt2.defaultValue;
    });
    return worker.bbi(inputs, opt);
  },
  format: {
    type: "inherit"
  }
};
const bias = {
  id: "Bias Ratio(Price Oscillator)",
  name: "Bias Ratio(Price Oscillator)",
  abbr: "BIAS",
  overlap: false,
  optionInfos: [],
  styleValues: {
    plots: {
      bias6: {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(41, 98, 255)"
      },
      bias12: {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(8, 153, 129)"
      },
      bias24: {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(255, 152, 0)"
      }
    }
  },
  outputs: ["bias6", "bias12", "bias24"],
  cal: async (worker, inputs) => {
    return worker.bias(inputs, /* @__PURE__ */ Object.create(null));
  },
  format: {
    type: "price",
    precision: 2
  }
};
const brar = {
  id: "BRAR",
  name: "BRAR",
  abbr: "BRAR",
  overlap: false,
  optionInfos: [],
  styleValues: {
    plots: {
      br: {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(41, 98, 255)"
      },
      ar: {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(255, 152, 0)"
      }
    }
  },
  outputs: ["br", "ar"],
  cal: async (worker, inputs) => {
    return worker.brar(inputs, /* @__PURE__ */ Object.create(null));
  },
  format: {
    type: "price",
    precision: 2
  }
};
const cr = {
  id: "CR",
  name: "CR",
  abbr: "CR",
  overlap: false,
  optionInfos: [],
  styleValues: {
    plots: {
      cr: {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(41, 98, 255)"
      },
      ma1: {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(255, 152, 0)"
      },
      ma2: {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(36,214,200)"
      },
      ma3: {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(255,38,0)"
      },
      ma4: {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(255,0,242)"
      }
    }
  },
  outputs: ["cr, ma1", "ma2", "ma3", "ma4"],
  cal: async (worker, inputs) => {
    return worker.cr(inputs, /* @__PURE__ */ Object.create(null));
  },
  format: {
    type: "price",
    precision: 2
  }
};
const dmi = {
  id: "Directional Movement Index",
  name: "Directional Movement Index",
  abbr: "DMI",
  overlap: false,
  optionInfos: [],
  styleValues: {
    plots: {
      "+di": {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(33, 150, 243)"
      },
      "-di": {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(255, 109, 0)"
      },
      // dx: {
      //   linewidth: 1,
      //   plotType: 'line',
      //   color: 'rgb(255, 167, 38)',
      // },
      adx: {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(245, 0, 87)"
      }
      // adxr: {
      //   linewidth: 1,
      //   plotType: 'line',
      //   color: 'rgb(171, 71, 188)',
      // },
    }
  },
  outputs: ["+di", "-di", "adx"],
  cal: async (worker, inputs) => {
    return worker.dmi(inputs, /* @__PURE__ */ Object.create(null));
  },
  format: {
    type: "price",
    precision: 2
  }
};
const ema = {
  id: "Exponential Moving Average",
  name: "Exponential Moving Average",
  abbr: "EMA",
  overlap: true,
  optionInfos: [],
  styleValues: {
    plots: {
      ema5: {
        lineWidth: 1,
        plotType: "line",
        color: "#e39336",
        title: "EMA5"
      },
      ema10: {
        lineWidth: 1,
        plotType: "line",
        color: "#9f63dd",
        title: "EMA10"
      },
      ema30: {
        lineWidth: 1,
        plotType: "line",
        color: "#388def",
        title: "EMA30"
      },
      ema60: {
        lineWidth: 1,
        plotType: "line",
        color: "#cf3673",
        title: "EMA60"
      }
    }
  },
  outputs: ["ema5", "ema10", "ema30", "ema60"],
  cal: (worker, inputs) => {
    return worker.ema(inputs, /* @__PURE__ */ Object.create(null));
  },
  format: {
    type: "inherit"
  }
};
const emv = {
  id: "Ease of Movement Value",
  name: "Ease of Movement Value",
  abbr: "EMV",
  overlap: false,
  optionInfos: [],
  styleValues: {
    plots: {
      emv: {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(41, 98, 255)"
      },
      ma: {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(255, 152, 0)"
      }
    }
  },
  outputs: ["emv", "ma"],
  cal: async (worker, inputs) => {
    return worker.emv(inputs, /* @__PURE__ */ Object.create(null));
  },
  format: {
    type: "price",
    precision: 2
  }
};
const kdj = {
  id: "Stochastic Indicator",
  name: "Stochastic Indicator",
  abbr: "KDJ",
  overlap: false,
  optionInfos: [
    {
      name: "timePeriod",
      defaultValue: 9,
      type: "Integer",
      range: {
        min: 1,
        max: 1e5
      }
    },
    {
      name: "k_Period",
      defaultValue: 3,
      type: "Integer",
      range: {
        min: 1,
        max: 1e5
      }
    },
    {
      name: "D_Period",
      displayName: "Fast-K Period",
      defaultValue: 3,
      hint: "Time period for building the Fast-K line",
      type: "Integer",
      range: {
        min: 1,
        max: 1e5
      }
    }
  ],
  styleValues: {
    plots: {
      k: {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(255, 152, 0)",
        title: "K"
      },
      d: {
        lineWidth: 1,
        plotType: "line",
        color: "#A77DC9",
        title: "D"
      },
      j: {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(41, 98, 255)",
        title: "J"
      }
    }
  },
  outputs: ["k", "d", "j"],
  cal: async (worker, inputs) => {
    return worker.kdj(inputs, /* @__PURE__ */ Object.create(null));
  },
  format: {
    type: "price",
    precision: 2
  }
};
const ma = {
  id: "Moving Average",
  name: "Moving Average",
  abbr: "MA",
  overlap: true,
  optionInfos: [],
  styleValues: {
    plots: {
      ma5: {
        lineWidth: 1,
        plotType: "line",
        color: "#e39336",
        title: "MA5"
      },
      ma10: {
        lineWidth: 1,
        plotType: "line",
        color: "#9f63dd",
        title: "MA10"
      },
      ma30: {
        lineWidth: 1,
        plotType: "line",
        color: "#388def",
        title: "MA30"
      },
      ma60: {
        lineWidth: 1,
        plotType: "line",
        color: "#cf3673",
        title: "MA60"
      }
    }
  },
  outputs: ["ma5", "ma10", "ma30", "ma60"],
  cal: async (worker, inputs) => {
    return worker.ma(inputs, /* @__PURE__ */ Object.create(null));
  },
  format: {
    type: "inherit"
  }
};
const mtm = {
  id: "Momentum Index",
  name: "Momentum Index",
  abbr: "MTM",
  overlap: false,
  optionInfos: [],
  styleValues: {
    plots: {
      mtm: {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(41, 98, 255)"
      },
      ma: {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(255, 152, 0)"
      }
    }
  },
  outputs: ["mtm", "ma"],
  cal: async (worker, inputs) => {
    return worker.mtm(inputs, /* @__PURE__ */ Object.create(null));
  },
  format: {
    type: "price",
    precision: 2
  }
};
const psy = {
  id: "Psychological Line",
  name: "Psychological Line",
  abbr: "PSY",
  overlap: false,
  optionInfos: [],
  styleValues: {
    plots: {
      psy: {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(41, 98, 255)"
      },
      ma: {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(255, 152, 0)"
      }
    }
  },
  outputs: ["psy", "ma"],
  cal: async (worker, inputs) => {
    return worker.psy(inputs, /* @__PURE__ */ Object.create(null));
  },
  format: {
    type: "price",
    precision: 2
  }
};
const pvt = {
  id: "Price and Volume Trend",
  name: "Price and Volume Trend",
  abbr: "PVT",
  overlap: false,
  optionInfos: [],
  styleValues: {
    plots: {
      plot: {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(41, 98, 255)"
      }
    }
  },
  outputs: ["plot"],
  cal: async (worker, inputs) => {
    return worker.pvt(inputs, /* @__PURE__ */ Object.create(null));
  },
  format: {
    type: "price",
    precision: 2
  }
};
const sar = {
  id: "Parabolic Stop and Reverse",
  name: "Parabolic Stop and Reverse",
  abbr: "SAR",
  overlap: true,
  optionInfos: [
    {
      name: "start",
      displayName: "start",
      defaultValue: 0.02,
      type: "Double",
      range: { min: 0, max: 3e37 }
    },
    {
      name: "increment",
      displayName: "increment",
      defaultValue: 0.02,
      type: "Double",
      range: { min: 0, max: 3e37 }
    },
    {
      name: "maximum",
      displayName: "maximum",
      defaultValue: 0.2,
      type: "Double",
      range: { min: 0, max: 3e37 }
    }
  ],
  styleValues: {
    plots: {
      plot: {
        lineWidth: 1,
        plotType: "cross",
        color: "#2196F3",
        title: "SAR"
      }
    }
  },
  outputs: ["plot"],
  cal: async (worker, inputs) => {
    return worker.sar(inputs, /* @__PURE__ */ Object.create(null));
  },
  format: {
    type: "inherit"
  }
};
const stochRsi = {
  id: "Stochastic RSI",
  name: "Stochastic RSI",
  abbr: "STOCHRSI",
  overlap: false,
  optionInfos: [],
  styleValues: {
    plots: {
      k: {
        lineWidth: 1,
        plotType: "line",
        color: "#2962FF",
        title: "%K"
      },
      d: {
        lineWidth: 1,
        plotType: "line",
        color: "#FF6D00",
        title: "%D"
      }
    },
    bands: {
      hline_0: {
        id: "hline_0",
        color: "#787B86",
        lineStyle: LineStyleType.dashed,
        lineWidth: 1,
        value: 80
      },
      hline_1: {
        id: "hline_1",
        color: "#787B86",
        lineStyle: LineStyleType.dashed,
        lineWidth: 1,
        value: 20
      }
    },
    filledAreas: {
      fill_0: {
        id: "fill_0",
        objAId: "hline_0",
        objBId: "hline_1",
        type: "hline_hline",
        fillType: "solid",
        color: "#2196F3",
        transparency: 90
      }
    }
  },
  outputs: ["k", "d"],
  cal: async (worker, inputs) => {
    return worker.stochrsi(inputs, /* @__PURE__ */ Object.create(null));
  },
  format: {
    type: "price",
    precision: 2
  }
};
const trix = {
  id: "TRIX",
  name: "TRIX",
  abbr: "TRIX",
  overlap: false,
  optionInfos: [],
  styleValues: {
    plots: {
      plot: {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(244, 67, 54)"
      }
    }
  },
  outputs: ["plot"],
  cal: async (worker, inputs) => {
    return worker.trix(inputs, /* @__PURE__ */ Object.create(null));
  },
  format: {
    type: "price",
    precision: 2
  }
};
const vr = {
  id: "Volatility Volume Ratio",
  name: "Volatility Volume Ratio",
  abbr: "VR",
  overlap: false,
  optionInfos: [],
  styleValues: {
    plots: {
      vr: {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(41, 98, 255)"
      },
      ma: {
        lineWidth: 1,
        plotType: "line",
        color: "rgb(255, 152, 0)"
      }
    }
  },
  outputs: ["vr", "ma"],
  cal: async (worker, inputs) => {
    return worker.vr(inputs, /* @__PURE__ */ Object.create(null));
  },
  format: {
    type: "price",
    precision: 2
  }
};
function enumToOptions(e2) {
  return Object.keys(e2).filter((key2) => isNaN(Number(key2))).map((key2) => ({
    title: key2,
    value: e2[key2]
  }));
}
var MAType = /* @__PURE__ */ ((MAType2) => {
  MAType2[MAType2["SMA"] = 0] = "SMA";
  MAType2[MAType2["EMA"] = 1] = "EMA";
  MAType2[MAType2["WMA"] = 2] = "WMA";
  MAType2[MAType2["DEMA"] = 3] = "DEMA";
  MAType2[MAType2["TEMA"] = 4] = "TEMA";
  MAType2[MAType2["TRIMA"] = 5] = "TRIMA";
  MAType2[MAType2["KAMA"] = 6] = "KAMA";
  MAType2[MAType2["MAMA"] = 7] = "MAMA";
  MAType2[MAType2["T3"] = 8] = "T3";
  return MAType2;
})(MAType || {});
function extractSource(input, source2) {
  return input.map((d3) => d3.customValues[source2]);
}
enumToOptions(MAType);
const infos = [
  {
    id: "Acceleration Bands",
    name: "Acceleration Bands",
    abbr: "ACCBANDS",
    overlap: true,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 20,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        upperBand: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(242, 54, 69)",
          title: "upperBand"
        },
        middleBand: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: "middleBand"
        },
        lowerBand: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(8, 153, 129)",
          title: "lowerBand"
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "upperBand",
        chartKey: "upperBand"
      },
      {
        taKey: "middleBand",
        chartKey: "middleBand"
      },
      {
        taKey: "lowerBand",
        chartKey: "lowerBand"
      }
    ],
    inputs: [
      {
        name: "high",
        type: "Double[]"
      },
      {
        name: "low",
        type: "Double[]"
      },
      {
        name: "close",
        type: "Double[]"
      }
    ],
    funcName: "ACCBANDS",
    format: {
      type: "inherit"
    }
  },
  {
    id: "Chaikin A/D Line",
    name: "Chaikin A/D Line",
    abbr: "AD",
    overlap: false,
    optionInfos: [],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "high",
        type: "Double[]"
      },
      {
        name: "low",
        type: "Double[]"
      },
      {
        name: "close",
        type: "Double[]"
      },
      {
        name: "volume",
        type: "Double[]"
      }
    ],
    funcName: "AD",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Chaikin A/D Oscillator",
    name: "Chaikin A/D Oscillator",
    abbr: "ADOSC",
    overlap: false,
    optionInfos: [
      {
        name: "fastPeriod",
        displayName: "Fast Period",
        defaultValue: 3,
        hint: "Number of period for the fast MA",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      },
      {
        name: "slowPeriod",
        displayName: "Slow Period",
        defaultValue: 10,
        hint: "Number of period for the slow MA",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "high",
        type: "Double[]"
      },
      {
        name: "low",
        type: "Double[]"
      },
      {
        name: "close",
        type: "Double[]"
      },
      {
        name: "volume",
        type: "Double[]"
      }
    ],
    funcName: "ADOSC",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Average Directional Index",
    name: "Average Directional Index",
    abbr: "ADX",
    overlap: false,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 14,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "high",
        type: "Double[]"
      },
      {
        name: "low",
        type: "Double[]"
      },
      {
        name: "close",
        type: "Double[]"
      }
    ],
    funcName: "ADX",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Average Directional Movement Index Rating",
    name: "Average Directional Movement Index Rating",
    abbr: "ADXR",
    overlap: false,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 14,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "high",
        type: "Double[]"
      },
      {
        name: "low",
        type: "Double[]"
      },
      {
        name: "close",
        type: "Double[]"
      }
    ],
    funcName: "ADXR",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Absolute Price Oscillator",
    name: "Absolute Price Oscillator",
    abbr: "APO",
    overlap: false,
    optionInfos: [
      {
        name: "fastPeriod",
        displayName: "Fast Period",
        defaultValue: 12,
        hint: "Number of period for the fast MA",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      },
      {
        name: "slowPeriod",
        displayName: "Slow Period",
        defaultValue: 26,
        hint: "Number of period for the slow MA",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      },
      {
        name: "MAType",
        displayName: "MA Type",
        defaultValue: 0,
        hint: "Type of Moving Average",
        type: "MAType"
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "APO",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Aroon",
    name: "Aroon",
    abbr: "AROON",
    overlap: false,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 14,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        aroonDown: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: "aroonDown"
        },
        aroonUp: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(251, 140, 0)",
          title: "aroonUp"
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "aroonDown",
        chartKey: "aroonDown"
      },
      {
        taKey: "aroonUp",
        chartKey: "aroonUp"
      }
    ],
    inputs: [
      {
        name: "high",
        type: "Double[]"
      },
      {
        name: "low",
        type: "Double[]"
      }
    ],
    funcName: "AROON",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Aroon Oscillator",
    name: "Aroon Oscillator",
    abbr: "AROONOSC",
    overlap: false,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 14,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "high",
        type: "Double[]"
      },
      {
        name: "low",
        type: "Double[]"
      }
    ],
    funcName: "AROONOSC",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Average True Range",
    name: "Average True Range",
    abbr: "ATR",
    overlap: false,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 14,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 1,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "high",
        type: "Double[]"
      },
      {
        name: "low",
        type: "Double[]"
      },
      {
        name: "close",
        type: "Double[]"
      }
    ],
    funcName: "ATR",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Average Deviation",
    name: "Average Deviation",
    abbr: "AVGDEV",
    overlap: false,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 14,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "AVGDEV",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Average Price",
    name: "Average Price",
    abbr: "AVGPRICE",
    overlap: false,
    optionInfos: [],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "open",
        type: "Double[]"
      },
      {
        name: "high",
        type: "Double[]"
      },
      {
        name: "low",
        type: "Double[]"
      },
      {
        name: "close",
        type: "Double[]"
      }
    ],
    funcName: "AVGPRICE",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Bollinger Bands",
    name: "Bollinger Bands",
    abbr: "BOLL",
    overlap: true,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 20,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      },
      {
        name: "nbDevUp",
        displayName: "Deviations up",
        defaultValue: 2,
        hint: "Deviation multiplier for upper band",
        type: "Double",
        range: {
          min: -3e37,
          max: 3e37
        }
      },
      {
        name: "nbDevDn",
        displayName: "Deviations down",
        defaultValue: 2,
        hint: "Deviation multiplier for lower band",
        type: "Double",
        range: {
          min: -3e37,
          max: 3e37
        },
        hidden: true
      },
      {
        name: "MAType",
        displayName: "MA Type",
        defaultValue: 0,
        hint: "Type of Moving Average",
        type: "MAType",
        hidden: true
      }
    ],
    styleValues: {
      plots: {
        upperBand: {
          lineWidth: 1,
          plotType: "line",
          color: "#2196F3",
          title: "UPPER"
        },
        middleBand: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(255, 109, 0)",
          title: "MID"
        },
        lowerBand: {
          lineWidth: 1,
          plotType: "line",
          color: "#2196F3",
          title: "LOWER"
        }
      },
      filledAreas: {
        fill_0: {
          id: "fill_0",
          objAId: "upperBand",
          objBId: "lowerBand",
          type: "plot_plot",
          fillType: "solid",
          color: "#2196F3",
          transparency: 95
        }
      }
    },
    outputs: [
      {
        taKey: "upperBand",
        chartKey: "upperBand"
      },
      {
        taKey: "middleBand",
        chartKey: "middleBand"
      },
      {
        taKey: "lowerBand",
        chartKey: "lowerBand"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "BBANDS",
    format: {
      type: "inherit"
    }
  },
  {
    id: "Balance Of Power",
    name: "Balance Of Power",
    abbr: "BOP",
    overlap: false,
    optionInfos: [],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "open",
        type: "Double[]"
      },
      {
        name: "high",
        type: "Double[]"
      },
      {
        name: "low",
        type: "Double[]"
      },
      {
        name: "close",
        type: "Double[]"
      }
    ],
    funcName: "BOP",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Commodity Channel Index",
    name: "Commodity Channel Index",
    abbr: "CCI",
    overlap: false,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 14,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "#2196F3",
          title: ""
        }
      },
      bands: {
        hline_0: {
          id: "hline_0",
          color: "#787B86",
          lineStyle: LineStyleType.dashed,
          lineWidth: 1,
          value: 100
        },
        hline_1: {
          id: "hline_1",
          color: "#787B86",
          lineStyle: LineStyleType.dashed,
          lineWidth: 1,
          value: -100
        }
      },
      filledAreas: {
        fill_0: {
          id: "fill_0",
          objAId: "hline_0",
          objBId: "hline_1",
          type: "hline_hline",
          fillType: "solid",
          color: "#2196F3",
          transparency: 90
        }
      }
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "high",
        type: "Double[]"
      },
      {
        name: "low",
        type: "Double[]"
      },
      {
        name: "close",
        type: "Double[]"
      }
    ],
    funcName: "CCI",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Chande Momentum Oscillator",
    name: "Chande Momentum Oscillator",
    abbr: "CMO",
    overlap: false,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 14,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "CMO",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Double Exponential Moving Average",
    name: "Double Exponential Moving Average",
    abbr: "DEMA",
    overlap: true,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 30,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(67, 160, 71)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "DEMA",
    format: {
      type: "inherit"
    }
  },
  {
    id: "Hilbert Transform - Dominant Cycle Period",
    name: "Hilbert Transform - Dominant Cycle Period",
    abbr: "HT_DCPERIOD",
    overlap: false,
    optionInfos: [],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "HT_DCPERIOD",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Hilbert Transform - Dominant Cycle Phase",
    name: "Hilbert Transform - Dominant Cycle Phase",
    abbr: "HT_DCPHASE",
    overlap: false,
    optionInfos: [],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "HT_DCPHASE",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Hilbert Transform - Phasor Components",
    name: "Hilbert Transform - Phasor Components",
    abbr: "HT_PHASOR",
    overlap: false,
    optionInfos: [],
    styleValues: {
      plots: {
        inPhase: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: "inPhase"
        },
        quadrature: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(251, 140, 0)",
          title: "quadrature"
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "inPhase",
        chartKey: "inPhase"
      },
      {
        taKey: "quadrature",
        chartKey: "quadrature"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "HT_PHASOR",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Hilbert Transform - SineWave",
    name: "Hilbert Transform - SineWave",
    abbr: "HT_SINE",
    overlap: false,
    optionInfos: [],
    styleValues: {
      plots: {
        sine: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: "sine"
        },
        leadSine: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: "leadSine"
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "sine",
        chartKey: "sine"
      },
      {
        taKey: "leadSine",
        chartKey: "leadSine"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "HT_SINE",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Hilbert Transform - Instantaneous Trendline",
    name: "Hilbert Transform - Instantaneous Trendline",
    abbr: "HT_TRENDLINE",
    overlap: true,
    optionInfos: [],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "HT_TRENDLINE",
    format: {
      type: "inherit"
    }
  },
  {
    id: "Hilbert Transform - Trend vs Cycle Mode",
    name: "Hilbert Transform - Trend vs Cycle Mode",
    abbr: "HT_TRENDMODE",
    overlap: false,
    optionInfos: [],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "HT_TRENDMODE",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Intraday Momentum Index",
    name: "Intraday Momentum Index",
    abbr: "IMI",
    overlap: false,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 14,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "open",
        type: "Double[]"
      },
      {
        name: "close",
        type: "Double[]"
      }
    ],
    funcName: "IMI",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Kaufman Adaptive Moving Average",
    name: "Kaufman Adaptive Moving Average",
    abbr: "KAMA",
    overlap: true,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 30,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "KAMA",
    format: {
      type: "inherit"
    }
  },
  {
    id: "Moving Average Convergence Divergence",
    name: "Moving Average Convergence Divergence",
    abbr: "MACD",
    overlap: false,
    optionInfos: [
      {
        name: "fastPeriod",
        displayName: "Fast Period",
        defaultValue: 12,
        hint: "Number of period for the fast MA",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      },
      {
        name: "fastMAType",
        displayName: "Fast MA",
        defaultValue: 0,
        hint: "Type of Moving Average for fast MA",
        type: "MAType"
      },
      {
        name: "slowPeriod",
        displayName: "Slow Period",
        defaultValue: 26,
        hint: "Number of period for the slow MA",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      },
      {
        name: "slowMAType",
        displayName: "Slow MA",
        defaultValue: 0,
        hint: "Type of Moving Average for slow MA",
        type: "MAType"
      },
      {
        name: "signalPeriod",
        displayName: "Signal Period",
        defaultValue: 9,
        hint: "Smoothing for the signal line (nb of period)",
        type: "Integer",
        range: {
          min: 1,
          max: 1e5
        }
      },
      {
        name: "signalMAType",
        displayName: "Signal MA",
        defaultValue: 0,
        hint: "Type of Moving Average for signal line",
        type: "MAType"
      }
    ],
    styleValues: {
      plots: {
        histogram: {
          color: ["#22ab94", "#ace5dc", "#fccbcd", "#ff5252"],
          plotType: "columns",
          title: "MACD"
        },
        macd: {
          lineWidth: 1,
          color: "#2196F3",
          plotType: "line",
          title: "DIF"
        },
        signal: {
          lineWidth: 1,
          color: "#FF6D00",
          plotType: "line",
          title: "DEA"
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "MACDHist",
        chartKey: "histogram"
      },
      {
        taKey: "MACD",
        chartKey: "macd"
      },
      {
        taKey: "MACDSignal",
        chartKey: "signal"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "MACDEXT",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "MESA Adaptive Moving Average",
    name: "MESA Adaptive Moving Average",
    abbr: "MAMA",
    overlap: true,
    optionInfos: [
      {
        name: "fastLimit",
        displayName: "Fast Limit",
        defaultValue: 0.5,
        hint: "Upper limit use in the adaptive algorithm",
        type: "Double",
        range: {
          min: 0.01,
          max: 0.99
        }
      },
      {
        name: "slowLimit",
        displayName: "Slow Limit",
        defaultValue: 0.05,
        hint: "Lower limit use in the adaptive algorithm",
        type: "Double",
        range: {
          min: 0.01,
          max: 0.99
        }
      }
    ],
    styleValues: {
      plots: {
        MAMA: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(0, 0, 255)",
          title: "MAMA"
        },
        FAMA: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(128, 0, 0)",
          title: "FAMA"
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "MAMA",
        chartKey: "MAMA"
      },
      {
        taKey: "FAMA",
        chartKey: "FAMA"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "MAMA",
    format: {
      type: "inherit"
    }
  },
  {
    id: "Median Price",
    name: "Median Price",
    abbr: "MEDPRICE",
    overlap: false,
    optionInfos: [],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "high",
        type: "Double[]"
      },
      {
        name: "low",
        type: "Double[]"
      }
    ],
    funcName: "MEDPRICE",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Money Flow Index",
    name: "Money Flow Index",
    abbr: "MFI",
    overlap: false,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 14,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "high",
        type: "Double[]"
      },
      {
        name: "low",
        type: "Double[]"
      },
      {
        name: "close",
        type: "Double[]"
      },
      {
        name: "volume",
        type: "Double[]"
      }
    ],
    funcName: "MFI",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "MidPoint over period",
    name: "MidPoint over period",
    abbr: "MIDPOINT",
    overlap: true,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 14,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "MIDPOINT",
    format: {
      type: "inherit"
    }
  },
  {
    id: "Midpoint Price over period",
    name: "Midpoint Price over period",
    abbr: "MIDPRICE",
    overlap: true,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 14,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "high",
        type: "Double[]"
      },
      {
        name: "low",
        type: "Double[]"
      }
    ],
    funcName: "MIDPRICE",
    format: {
      type: "inherit"
    }
  },
  {
    id: "Minus Directional Indicator",
    name: "Minus Directional Indicator",
    abbr: "MINUS_DI",
    overlap: false,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 14,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 1,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "high",
        type: "Double[]"
      },
      {
        name: "low",
        type: "Double[]"
      },
      {
        name: "close",
        type: "Double[]"
      }
    ],
    funcName: "MINUS_DI",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Minus Directional Movement",
    name: "Minus Directional Movement",
    abbr: "MINUS_DM",
    overlap: false,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 14,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 1,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "high",
        type: "Double[]"
      },
      {
        name: "low",
        type: "Double[]"
      }
    ],
    funcName: "MINUS_DM",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Momentum",
    name: "Momentum",
    abbr: "MOM",
    overlap: false,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 10,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 1,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "MOM",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "On Balance Volume",
    name: "On Balance Volume",
    abbr: "OBV",
    overlap: false,
    optionInfos: [],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      },
      {
        name: "volume",
        type: "Double[]"
      }
    ],
    funcName: "OBV",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Plus Directional Indicator",
    name: "Plus Directional Indicator",
    abbr: "PLUS_DI",
    overlap: false,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 14,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 1,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "high",
        type: "Double[]"
      },
      {
        name: "low",
        type: "Double[]"
      },
      {
        name: "close",
        type: "Double[]"
      }
    ],
    funcName: "PLUS_DI",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Plus Directional Movement",
    name: "Plus Directional Movement",
    abbr: "PLUS_DM",
    overlap: false,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 14,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 1,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "high",
        type: "Double[]"
      },
      {
        name: "low",
        type: "Double[]"
      }
    ],
    funcName: "PLUS_DM",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Percentage Price Oscillator",
    name: "Percentage Price Oscillator",
    abbr: "PPO",
    overlap: false,
    optionInfos: [
      {
        name: "fastPeriod",
        displayName: "Fast Period",
        defaultValue: 12,
        hint: "Number of period for the fast MA",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      },
      {
        name: "slowPeriod",
        displayName: "Slow Period",
        defaultValue: 26,
        hint: "Number of period for the slow MA",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      },
      {
        name: "MAType",
        displayName: "MA Type",
        defaultValue: 0,
        hint: "Type of Moving Average",
        type: "MAType"
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "PPO",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Rate of Change",
    name: "Rate of Change",
    abbr: "ROC",
    overlap: false,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 9,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 1,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {
        hline_0: {
          id: "hline_0",
          color: "#787B86",
          lineStyle: LineStyleType.dashed,
          lineWidth: 1,
          value: 0
        }
      },
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "ROC",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Rate of change Percentage: (price-prevPrice)/prevPrice",
    name: "Rate of change Percentage: (price-prevPrice)/prevPrice",
    abbr: "ROCP",
    overlap: false,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 10,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 1,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "ROCP",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Rate of change ratio: (price/prevPrice)",
    name: "Rate of change ratio: (price/prevPrice)",
    abbr: "ROCR",
    overlap: false,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 10,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 1,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "ROCR",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Rate of change ratio 100 scale: (price/prevPrice)*100",
    name: "Rate of change ratio 100 scale: (price/prevPrice)*100",
    abbr: "ROCR100",
    overlap: false,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 10,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 1,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "ROCR100",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Relative Strength Index",
    name: "Relative Strength Index",
    abbr: "RSI",
    overlap: false,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 14,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {
        hline_0: {
          id: "hline_0",
          color: "#787B86",
          lineStyle: LineStyleType.dashed,
          lineWidth: 1,
          value: 70
        },
        hline_1: {
          id: "hline_1",
          color: "#787B86",
          lineStyle: LineStyleType.dashed,
          lineWidth: 1,
          value: 30
        }
      },
      filledAreas: {
        fill_0: {
          id: "fill_0",
          objAId: "hline_0",
          objBId: "hline_1",
          type: "hline_hline",
          fillType: "solid",
          color: "#7E57C2",
          transparency: 90
        }
      }
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "RSI",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Simple Moving Average",
    name: "Simple Moving Average",
    abbr: "SMA",
    overlap: true,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 30,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "SMA",
    format: {
      type: "inherit"
    }
  },
  {
    id: "Standard Deviation",
    name: "Standard Deviation",
    abbr: "STDDEV",
    overlap: false,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 5,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      },
      {
        name: "nbDev",
        displayName: "Deviations",
        defaultValue: 1,
        hint: "Nb of deviations",
        type: "Double",
        range: {
          min: -3e37,
          max: 3e37
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "STDDEV",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Stochastic Oscillator",
    name: "Stochastic Oscillator",
    abbr: "STOCH",
    overlap: false,
    optionInfos: [
      {
        name: "fastK_Period",
        displayName: "Fast-K Period",
        defaultValue: 14,
        hint: "Time period for building the Fast-K line",
        type: "Integer",
        range: {
          min: 1,
          max: 1e5
        }
      },
      {
        name: "slowK_Period",
        displayName: "Slow-K Period",
        defaultValue: 1,
        hint: "Smoothing for making the Slow-K line. Usually set to 3",
        type: "Integer",
        range: {
          min: 1,
          max: 1e5
        }
      },
      {
        name: "slowK_MAType",
        displayName: "Slow-K MA",
        defaultValue: 0,
        hint: "Type of Moving Average for Slow-K",
        type: "MAType",
        hidden: true
      },
      {
        name: "slowD_Period",
        displayName: "Slow-D Period",
        defaultValue: 3,
        hint: "Smoothing for making the Slow-D line",
        type: "Integer",
        range: {
          min: 1,
          max: 1e5
        }
      },
      {
        name: "slowD_MAType",
        displayName: "Slow-D MA",
        defaultValue: 0,
        hint: "Type of Moving Average for Slow-D",
        type: "MAType",
        hidden: true
      }
    ],
    styleValues: {
      plots: {
        slowK: {
          lineWidth: 1,
          plotType: "line",
          color: "#2962FF",
          title: "%K"
        },
        slowD: {
          lineWidth: 1,
          plotType: "line",
          color: "#FF6D00",
          title: "%D"
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "slowK",
        chartKey: "slowK"
      },
      {
        taKey: "slowD",
        chartKey: "slowD"
      }
    ],
    inputs: [
      {
        name: "high",
        type: "Double[]"
      },
      {
        name: "low",
        type: "Double[]"
      },
      {
        name: "close",
        type: "Double[]"
      }
    ],
    funcName: "STOCH",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Stochastic Fast",
    name: "Stochastic Fast",
    abbr: "STOCHF",
    overlap: false,
    optionInfos: [
      {
        name: "fastK_Period",
        displayName: "Fast-K Period",
        defaultValue: 5,
        hint: "Time period for building the Fast-K line",
        type: "Integer",
        range: {
          min: 1,
          max: 1e5
        }
      },
      {
        name: "fastD_Period",
        displayName: "Fast-D Period",
        defaultValue: 3,
        hint: "Smoothing for making the Fast-D line. Usually set to 3",
        type: "Integer",
        range: {
          min: 1,
          max: 1e5
        }
      },
      {
        name: "fastD_MAType",
        displayName: "Fast-D MA",
        defaultValue: 0,
        hint: "Type of Moving Average for Fast-D",
        type: "MAType"
      }
    ],
    styleValues: {
      plots: {
        fastK: {
          lineWidth: 1,
          plotType: "line",
          color: "#2962FF",
          title: "fastK"
        },
        fastD: {
          lineWidth: 1,
          plotType: "line",
          color: "#FF6D00",
          title: "fastD"
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "fastK",
        chartKey: "fastK"
      },
      {
        taKey: "fastD",
        chartKey: "fastD"
      }
    ],
    inputs: [
      {
        name: "high",
        type: "Double[]"
      },
      {
        name: "low",
        type: "Double[]"
      },
      {
        name: "close",
        type: "Double[]"
      }
    ],
    funcName: "STOCHF",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Tillson T3 Moving Average",
    name: "Tillson T3 Moving Average",
    abbr: "T3MA",
    overlap: true,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 5,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      },
      {
        name: "VFactor",
        displayName: "Volume Factor",
        defaultValue: 0.7,
        hint: "Volume Factor",
        type: "Double",
        range: {
          min: 0,
          max: 1
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "T3",
    format: {
      type: "inherit"
    }
  },
  {
    id: "Triple Exponential Moving Average",
    name: "Triple Exponential Moving Average",
    abbr: "TEMA",
    overlap: true,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 30,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "TEMA",
    format: {
      type: "inherit"
    }
  },
  {
    id: "True Range",
    name: "True Range",
    abbr: "TRANGE",
    overlap: false,
    optionInfos: [],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "high",
        type: "Double[]"
      },
      {
        name: "low",
        type: "Double[]"
      },
      {
        name: "close",
        type: "Double[]"
      }
    ],
    funcName: "TRANGE",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Triangular Moving Average",
    name: "Triangular Moving Average",
    abbr: "TRIMA",
    overlap: true,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 30,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "TRIMA",
    format: {
      type: "inherit"
    }
  },
  {
    id: "1-day Rate-Of-Change (ROC) of a Triple Smooth EMA",
    name: "1-day Rate-Of-Change (ROC) of a Triple Smooth EMA",
    abbr: "TRIX",
    overlap: false,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 30,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 1,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "TRIX",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Time Series Forecast",
    name: "Time Series Forecast",
    abbr: "TSF",
    overlap: false,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 14,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "TSF",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Typical Price",
    name: "Typical Price",
    abbr: "TYPPRICE",
    overlap: false,
    optionInfos: [],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "high",
        type: "Double[]"
      },
      {
        name: "low",
        type: "Double[]"
      },
      {
        name: "close",
        type: "Double[]"
      }
    ],
    funcName: "TYPPRICE",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Ultimate Oscillator",
    name: "Ultimate Oscillator",
    abbr: "ULTOSC",
    overlap: false,
    optionInfos: [
      {
        name: "timePeriod1",
        displayName: "First Period",
        defaultValue: 7,
        hint: "Number of bars for 1st period.",
        type: "Integer",
        range: {
          min: 1,
          max: 1e5
        }
      },
      {
        name: "timePeriod2",
        displayName: "Second Period",
        defaultValue: 14,
        hint: "Number of bars fro 2nd period",
        type: "Integer",
        range: {
          min: 1,
          max: 1e5
        }
      },
      {
        name: "timePeriod3",
        displayName: "Third Period",
        defaultValue: 28,
        hint: "Number of bars for 3rd period",
        type: "Integer",
        range: {
          min: 1,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "high",
        type: "Double[]"
      },
      {
        name: "low",
        type: "Double[]"
      },
      {
        name: "close",
        type: "Double[]"
      }
    ],
    funcName: "ULTOSC",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Variance",
    name: "Variance",
    abbr: "VAR",
    overlap: false,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 5,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 1,
          max: 1e5
        }
      },
      {
        name: "nbDev",
        displayName: "Deviations",
        defaultValue: 1,
        hint: "Nb of deviations",
        type: "Double",
        range: {
          min: -3e37,
          max: 3e37
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "VAR",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Weighted Close Price",
    name: "Weighted Close Price",
    abbr: "WCLPRICE",
    overlap: false,
    optionInfos: [],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "high",
        type: "Double[]"
      },
      {
        name: "low",
        type: "Double[]"
      },
      {
        name: "close",
        type: "Double[]"
      }
    ],
    funcName: "WCLPRICE",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Williams %R",
    name: "Williams %R",
    abbr: "WMSR",
    overlap: false,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 14,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "#7E57C2",
          title: ""
        }
      },
      bands: {
        hline_0: {
          id: "hline_0",
          color: "#787B86",
          lineStyle: LineStyleType.dashed,
          lineWidth: 1,
          value: -20
        },
        hline_1: {
          id: "hline_1",
          color: "#787B86",
          lineStyle: LineStyleType.dashed,
          lineWidth: 1,
          value: -80
        }
      },
      filledAreas: {
        fill_0: {
          id: "fill_0",
          objAId: "hline_0",
          objBId: "hline_1",
          type: "hline_hline",
          fillType: "solid",
          color: "#7E57C2",
          transparency: 90
        }
      }
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "high",
        type: "Double[]"
      },
      {
        name: "low",
        type: "Double[]"
      },
      {
        name: "close",
        type: "Double[]"
      }
    ],
    funcName: "WILLR",
    format: {
      type: "price",
      precision: 2
    }
  },
  {
    id: "Weighted Moving Average",
    name: "Weighted Moving Average",
    abbr: "WMA",
    overlap: true,
    optionInfos: [
      {
        name: "timePeriod",
        displayName: "Time Period",
        defaultValue: 30,
        hint: "Number of period",
        type: "Integer",
        range: {
          min: 2,
          max: 1e5
        }
      }
    ],
    styleValues: {
      plots: {
        plot: {
          lineWidth: 1,
          plotType: "line",
          color: "rgb(41, 98, 255)",
          title: ""
        }
      },
      bands: {},
      filledAreas: {}
    },
    outputs: [
      {
        taKey: "output",
        chartKey: "plot"
      }
    ],
    inputs: [
      {
        name: "inReal",
        type: "Double[]"
      }
    ],
    funcName: "WMA",
    format: {
      type: "inherit"
    }
  }
];
const arrayInputType = "Double[]";
const numberInputType = "Integer";
const talibIndicators = infos.map((item) => {
  const spec = {
    id: item.id,
    name: item.name,
    abbr: item.abbr,
    overlap: item.overlap,
    optionInfos: item.optionInfos,
    styleValues: item.styleValues,
    outputs: item.outputs.map((output) => output.chartKey),
    coloring: item.abbr === "MACD" ? macdColoring : void 0,
    cal: async (worker, inputs, options = /* @__PURE__ */ Object.create(null)) => {
      const args = /* @__PURE__ */ Object.create(null);
      item.inputs.forEach((input) => {
        switch (input.type) {
          case numberInputType: {
            args[input.name] = options[input.name];
            break;
          }
          case arrayInputType: {
            args[input.name] = extractSource(
              inputs,
              input.name === "inReal" ? "close" : input.name
            );
          }
        }
      });
      item.optionInfos.forEach((opt) => {
        args[opt.name] = options[opt.name] ?? opt.defaultValue;
      });
      return worker.calcTA(item.funcName, inputs, item.outputs, args);
    },
    format: item.format
  };
  return spec;
});
function macdColoring(input, styleValues) {
  const key2 = "histogram";
  const histogramStyles = ensure(styleValues.plots[key2]);
  should(isStudyLinePlotMultiColorPreferences(histogramStyles));
  const colors = histogramStyles.color;
  let prev = Number.NaN;
  input.forEach((bar) => {
    var _a3;
    if (isUndefinedOrNull((_a3 = bar.study) == null ? void 0 : _a3[key2])) return;
    const val = bar.study[key2];
    const aboveZero = val > 0;
    const ltPrev = isFinite(prev) && Math.abs(val) < Math.abs(prev);
    let color;
    if (aboveZero) {
      color = ltPrev ? colors[1] : colors[0];
    } else {
      color = ltPrev ? colors[2] : colors[3];
    }
    bar.color = color;
    prev = val;
  });
}
const indicators = talibIndicators.concat(ao, bbi, bias, brar, cr, dmi, ema, emv, kdj, ma, mtm, psy, pvt, sar, stochRsi, trix, vr).sort((a2, b2) => a2.name.localeCompare(b2.name));
indicators.forEach((i2) => studyRegistry.add(i2));
var root_1$8 = /* @__PURE__ */ from_html(`<div class="titleText svelte-1cp2oja"> </div> <button class="titleClose svelte-1cp2oja"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 17 17" width="17" height="17" fill="currentColor"><path d="m.58 1.42.82-.82 15 15-.82.82z"></path><path d="m.58 15.58 15-15 .82.82-15 15z"></path></svg></button>`, 1);
const $$css$c = {
  hash: "svelte-1cp2oja",
  code: ' .chartles .cl-title-block {align-items:center;cursor:default;display:flex;flex-direction:row;flex:0 0 auto;height:68px;padding:0 20px;border-bottom:1px solid var(--cl-gutter-background);} .chartles .cl-title-block__no-border {border:none;}.titleText.svelte-1cp2oja {color:var(--cl-foreground);flex-grow:1;font-size:20px;font-weight:600;line-height:28px;min-width:0;padding:17px 0;}.titleClose.svelte-1cp2oja {outline:none;border:none;background:none;padding-block:initial;padding-inline:initial;font-family:inherit;color:inherit;pointer-events:auto;position:relative;padding:8px;display:flex;align-items:center;width:fit-content;height:fit-content;z-index:0;color:var(--cl-foreground);}\n@media (hover: hover) and (pointer: fine) {.titleClose.svelte-1cp2oja:hover::before {position:absolute;content:"";inset:0;border-radius:8px;background-color:var(--cl-button-hoverBackground);z-index:-1;}\n}'
};
function DialogTitle($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$c);
  const handleClose = () => {
    var _a3;
    const event2 = new KeyboardEvent("keydown", {
      key: "Escape",
      code: "Escape",
      which: 27,
      // Esc键的键码
      bubbles: true,
      // 事件是否冒泡
      cancelable: true
      // 事件是否可取消
    });
    document.body.dispatchEvent(event2);
    (_a3 = $$props.handleClose) == null ? void 0 : _a3.call($$props);
  };
  {
    let $0 = /* @__PURE__ */ user_derived(() => clsx$1("cl-title-block", $$props.noBorder && "cl-title-block__no-border"));
    Title($$anchor, {
      get class() {
        return get$1($0);
      },
      children: ($$anchor2, $$slotProps) => {
        var fragment_1 = root_1$8();
        var div = first_child(fragment_1);
        var text2 = child(div);
        var button = sibling(div, 2);
        var event_handler = /* @__PURE__ */ user_derived(() => ifLeftClick(handleClose));
        button.__pointerup = function(...$$args) {
          var _a3;
          (_a3 = get$1(event_handler)) == null ? void 0 : _a3.apply(this, $$args);
        };
        template_effect(() => set_text(text2, $$props.title));
        append($$anchor2, fragment_1);
      },
      $$slots: { default: true }
    });
  }
  pop();
}
delegate(["pointerup"]);
var root_6$2 = /* @__PURE__ */ from_html(`<span> </span>`);
var root_4$4 = /* @__PURE__ */ from_html(`<div class="groupName svelte-16m6fce"> </div> <!>`, 1);
var root_1$7 = /* @__PURE__ */ from_html(`<!> <div class="searchWrapper svelte-16m6fce"><div class="inputContainer svelte-16m6fce"><input type="text" class="input svelte-16m6fce" autocomplete="off" data-role="search" placeholder="Search"/></div> <div class="searchIcon svelte-16m6fce"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="none"><path stroke="currentColor" d="M12.4 12.5a7 7 0 1 0-4.9 2 7 7 0 0 0 4.9-2zm0 0l5.101 5"></path></svg></div></div> <!>`, 1);
const $$css$b = {
  hash: "svelte-16m6fce",
  code: " .indicatorDialog::-webkit-scrollbar {-webkit-appearance:none;width:3px;height:3px;} .indicatorDialog::-webkit-scrollbar-corner {display:none;} .indicatorDialog::-webkit-scrollbar-thumb {background-clip:content-box;background-color:var(--cl-scrollbarThumb-background);border-radius:3px;} .indicatorDialog::-webkit-scrollbar-track {background-color:initial;border-radius:3px;} .indicatorDialog .content {padding:0;} .indicatorDialog .list {margin:0;padding:0;list-style:none;height:310px;width:420px;} .indicatorDialog .item {align-items:center;box-sizing:border-box;cursor:default;display:flex;height:32px;padding-left:32px;padding-right:16px;font-size:14px;color:var(--cl-listItem-foreground);}\n@media (hover: hover) and (pointer: fine) { .indicatorDialog .item:hover {background-color:var(--cl-listItem-hoverBackground);}\n}.searchWrapper.svelte-16m6fce {align-items:center;border-bottom:1px solid var(--cl-gutter-background);cursor:default;display:flex;flex-shrink:0;position:relative;}.inputContainer.svelte-16m6fce {height:24px;padding:8px 16px 8px 47px;width:100%;}.input.svelte-16m6fce {background-color:initial;border:none;color:var(--input-foreground);font-size:16px;height:100%;margin:0;padding:0;width:100%;outline:none;}.input.svelte-16m6fce::placeholder {color:var(--cl-inputPlaceholder-foreground);}.searchIcon.svelte-16m6fce {color:var(--cl-inputPlaceholder-foreground);height:18px;left:20px;pointer-events:none;position:absolute;top:calc(50% - 9px);}.groupName.svelte-16m6fce {padding:16px 84px 8px 32px;user-select:none;cursor:default;color:var(--cl-listTitle-foreground);font-size:11px;font-weight:400;letter-spacing:0.4px;line-height:16px;margin:0;text-transform:uppercase;white-space:nowrap;}"
};
function IndicatorDialog($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$b);
  const { t: t2 } = useTranslation();
  const chartManagementService = useService(IChartManagementService);
  const configurationService = useService(IConfigurationService);
  let open = prop($$props, "open", 15, false);
  let inputEl;
  let headEl;
  const studiesAccessType = configurationService.getValue("studiesAccessType");
  const studiesAccess = configurationService.getValue("studiesAccess");
  const accessableList = function() {
    switch (studiesAccessType) {
      case "white": {
        return indicators.filter((i2) => studiesAccess[i2.name] === "white");
      }
      case "black": {
        return indicators.filter((i2) => studiesAccess[i2.name] !== "black");
      }
      default: {
        return indicators;
      }
    }
  }();
  let displayList = /* @__PURE__ */ state(proxy$1(accessableList));
  const indicatorMatchItemAccessor = {
    getItemLabel(item) {
      return `${item.abbr} ${item.name}`;
    },
    getItemDescription(item) {
      return item.abbr;
    }
  };
  const scorerCache = /* @__PURE__ */ Object.create(null);
  const handleInput = (e2) => {
    const target = e2.target;
    const val = target.value;
    headEl == null ? void 0 : headEl.scrollIntoView();
    updateList(val);
  };
  const updateList = (val) => {
    if (val) {
      const query = prepareQuery(val);
      const compare = (matchA, matchB) => {
        return compareItemsByFuzzyScore(matchA, matchB, query, true, indicatorMatchItemAccessor, scorerCache);
      };
      set(displayList, top(accessableList, compare, 15), true);
    } else {
      set(displayList, accessableList, true);
    }
  };
  function handleClose() {
    open(false);
    inputEl.value = "";
    updateList("");
  }
  async function handleSelect(item) {
    chartManagementService.activeChart().createStudy(item.id);
    handleClose();
  }
  Dialog($$anchor, {
    onSMUIDialogClosed: handleClose,
    class: "indicatorDialog",
    get open() {
      return open();
    },
    set open($$value) {
      open($$value);
    },
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = root_1$7();
      var node = first_child(fragment_1);
      {
        let $0 = /* @__PURE__ */ user_derived(() => t2("indicator.dialog.title"));
        DialogTitle(node, {
          get title() {
            return get$1($0);
          }
        });
      }
      var div = sibling(node, 2);
      var div_1 = child(div);
      var input = child(div_1);
      input.__input = handleInput;
      bind_this(input, ($$value) => inputEl = $$value, () => inputEl);
      action(input, ($$node) => InitialFocus == null ? void 0 : InitialFocus($$node));
      var node_1 = sibling(div, 2);
      Content(node_1, {
        class: "content",
        children: ($$anchor3, $$slotProps2) => {
          Scheduler($$anchor3, {
            idle: true,
            children: ($$anchor4, $$slotProps3) => {
              List($$anchor4, {
                class: "list",
                children: ($$anchor5, $$slotProps4) => {
                  var fragment_4 = root_4$4();
                  var div_2 = first_child(fragment_4);
                  var text2 = child(div_2);
                  bind_this(div_2, ($$value) => headEl = $$value, () => headEl);
                  var node_2 = sibling(div_2, 2);
                  each(node_2, 17, () => get$1(displayList), (indicator) => indicator.id, ($$anchor6, indicator) => {
                    {
                      let $0 = /* @__PURE__ */ user_derived(() => ifLeftClick(() => handleSelect(get$1(indicator))));
                      Item($$anchor6, {
                        class: "item",
                        get onpointerup() {
                          return get$1($0);
                        },
                        children: ($$anchor7, $$slotProps5) => {
                          var span = root_6$2();
                          var text_1 = child(span);
                          template_effect(() => set_text(text_1, get$1(indicator).name));
                          append($$anchor7, span);
                        },
                        $$slots: { default: true }
                      });
                    }
                  });
                  template_effect(($0) => set_text(text2, $0), [() => t2("indicator.dialog.script")]);
                  append($$anchor5, fragment_4);
                },
                $$slots: { default: true }
              });
            },
            $$slots: { default: true }
          });
        },
        $$slots: { default: true }
      });
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  });
  pop();
}
delegate(["input"]);
var root_1$6 = /* @__PURE__ */ from_html(`<button class="indicator svelte-eipwer"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28" fill="none" class="svelte-eipwer"><path stroke="currentColor" d="M20 17l-5 5M15 17l5 5M9 11.5h7M17.5 8a2.5 2.5 0 0 0-5 0v11a2.5 2.5 0 0 1-5 0"></path></svg> <span class="svelte-eipwer"> </span></button> <!>`, 1);
var root$9 = /* @__PURE__ */ from_html(`<div class="indicatorWrapper"><!> <!></div>`);
const $$css$a = {
  hash: "svelte-eipwer",
  code: '.indicator.svelte-eipwer {outline:none;border:none;background:none;padding-block:initial;padding-inline:initial;font-family:inherit;color:inherit;height:100%;color:var(--cl-foreground);font-size:14px;display:flex;flex-direction:row;align-items:center;justify-content:center;cursor:default;position:relative;z-index:0;padding:0 10px 0 5px;}\n@media (hover: hover) and (pointer: fine) {.indicator.svelte-eipwer:hover:before {position:absolute;top:2px;right:2px;bottom:2px;left:2px;z-index:-1;border-radius:4px;content:"";background-color:var(--cl-button-hoverBackground);}\n}.indicator.svelte-eipwer > svg:where(.svelte-eipwer) {width:28px;height:28px;color:var(--cl-foreground);}.indicator.svelte-eipwer > span:where(.svelte-eipwer) {margin-left:2px;}'
};
function Indicator($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$a);
  const { t: t2 } = useTranslation();
  const keybindingsRegistry = useService(IKeybindingsRegistry);
  const kb = KeyCode.Slash;
  let open = /* @__PURE__ */ state(false);
  function handleOpen() {
    set(open, true);
  }
  useDisposable(keybindingsRegistry.registerCommandAndKeybindingRule({
    id: "ui.indicator.showDialog",
    primary: KeyCode.Slash,
    weight: KeybindingWeight.ChartCore,
    handler: () => {
      handleOpen();
    }
  }));
  var div = root$9();
  var node = child(div);
  Wrapper(node, {
    children: ($$anchor2, $$slotProps) => {
      var fragment = root_1$6();
      var button = first_child(fragment);
      var event_handler = /* @__PURE__ */ user_derived(() => ifLeftClick(handleOpen));
      button.__pointerup = function(...$$args) {
        var _a3;
        (_a3 = get$1(event_handler)) == null ? void 0 : _a3.apply(this, $$args);
      };
      var span = sibling(child(button), 2);
      var text2 = child(span);
      var node_1 = sibling(button, 2);
      Tooltip(node_1, {
        children: ($$anchor3, $$slotProps2) => {
          {
            let $0 = /* @__PURE__ */ user_derived(() => t2("topToolbar.indicator.tip"));
            TooltipContent($$anchor3, {
              get content() {
                return get$1($0);
              },
              get keybinding() {
                return kb;
              }
            });
          }
        },
        $$slots: { default: true }
      });
      template_effect(($0) => set_text(text2, $0), [() => t2("topToolbar.indicator")]);
      append($$anchor2, fragment);
    },
    $$slots: { default: true }
  });
  var node_2 = sibling(node, 2);
  Scheduler(node_2, {
    get waitFor() {
      return get$1(open);
    },
    children: ($$anchor2, $$slotProps) => {
      IndicatorDialog($$anchor2, {
        get open() {
          return get$1(open);
        },
        set open($$value) {
          set(open, $$value, true);
        }
      });
    },
    $$slots: { default: true }
  });
  append($$anchor, div);
  pop();
}
delegate(["pointerup"]);
var root_2$3 = /* @__PURE__ */ from_html(`<div> </div>`);
var root_1$5 = /* @__PURE__ */ from_html(`<button class="chartInterval svelte-8a4xyd"><span> </span></button> <!>`, 1);
var root_7$3 = /* @__PURE__ */ from_html(`<div class="separator svelte-8a4xyd"></div>`);
var root_6$1 = /* @__PURE__ */ from_html(`<!> <div class="sectionTitle svelte-8a4xyd"> </div> <!>`, 1);
var root_4$3 = /* @__PURE__ */ from_html(`<div class="intervalMenu svelte-8a4xyd"><!></div>`);
var root$8 = /* @__PURE__ */ from_html(`<div><!> <!></div>`);
const $$css$9 = {
  hash: "svelte-8a4xyd",
  code: '.chartInterval.svelte-8a4xyd {outline:none;border:none;background:none;padding-block:initial;padding-inline:initial;font-family:inherit;color:inherit;height:100%;color:var(--cl-foreground);font-size:14px;display:flex;flex-direction:row;align-items:center;justify-content:center;cursor:default;position:relative;z-index:0;padding:0 10px;}\n@media (hover: hover) and (pointer: fine) {.chartInterval.svelte-8a4xyd:hover:before {position:absolute;top:2px;right:2px;bottom:2px;left:2px;z-index:-1;border-radius:4px;content:"";background-color:var(--cl-button-hoverBackground);}\n}.intervalMenu.svelte-8a4xyd {display:flex;flex-direction:column;background:var(--cl-background);user-select:none;cursor:default;z-index:2;min-width:190px;}.intervalMenu.svelte-8a4xyd .mdc-deprecated-list {margin:0;padding:0;list-style:none;}.sectionTitle.svelte-8a4xyd {font-size:11px;letter-spacing:0.4px;line-height:16px;padding:0 8px 0 12px;margin-bottom:4px;color:var(--cl-listTitle-foreground);}.separator.svelte-8a4xyd {height:1px;margin:6px 0;background-color:var(--cl-gutter-background);} .intervalMenu .row {height:28px;font-size:14px;padding:2px 10px 2px 12px;white-space:nowrap;display:flex;align-items:center;color:var(--cl-listItem-foreground);background:var(--cl-listItem-background);}\n@media (hover: hover) and (pointer: fine) { .intervalMenu .row:hover:not(.disabled):not(.selected) {background-color:var(--cl-listItem-hoverBackground);}\n} .intervalMenu .row.disabled {cursor:default;opacity:0.5;} .intervalMenu .row.selected {background-color:var(--cl-listItem-selectedBackground);color:var(--cl-listItem-selectedForeground);}'
};
function Interval2($$anchor, $$props) {
  push($$props, false);
  append_styles$1($$anchor, $$css$9);
  const [$$stores, $$cleanup] = setup_stores();
  const $labelShort = () => store_get(labelShort, "$labelShort", $$stores);
  const $labelLong = () => store_get(labelLong, "$labelLong", $$stores);
  const $resolutionGroups = () => store_get(resolutionGroups, "$resolutionGroups", $$stores);
  const $disabled = () => store_get(disabled, "$disabled", $$stores);
  const $currentInterval = () => store_get(currentInterval, "$currentInterval", $$stores);
  const { t: t2 } = useTranslation();
  const chartManagementService = useService(IChartManagementService);
  const configurationService = useService(IConfigurationService);
  const chartResolutionRegistry = useService(IChartResolutionRegistry);
  const resolutionGroups = derived(chartResolutionRegistry.store, (store) => store.groups);
  const disabled = derived(chartManagementService.store, (store) => {
    const { activeIndex } = store;
    if (!isFinite(activeIndex)) return true;
    return store.instances[activeIndex].dataStatus < ChartDataStatus.symbolInfoResolved;
  });
  const currentInterval = derived([chartManagementService.store, chartResolutionRegistry.store], ([store]) => {
    const { activeIndex } = store;
    const resolution = isFinite(activeIndex) ? store.instances[activeIndex].resolution : configurationService.getValue("interval");
    return chartResolutionRegistry.value(resolution);
  });
  const labelShort = derived(currentInterval, (interval) => interval == null ? void 0 : interval.labelShort);
  const labelLong = derived(currentInterval, (interval) => interval ? toLabel(interval) : "");
  const toLabel = (item) => {
    const label = item.label;
    return t2(label, { count: item.value });
  };
  let menu = /* @__PURE__ */ mutable_source();
  onDestroy(() => {
    set(menu, null);
  });
  init();
  var div = root$8();
  var node = child(div);
  Wrapper(node, {
    children: ($$anchor2, $$slotProps) => {
      var fragment = root_1$5();
      var button = first_child(fragment);
      var event_handler = /* @__PURE__ */ user_derived(() => ifLeftClick(() => get$1(menu).setOpen(true)));
      button.__pointerup = function(...$$args) {
        var _a3;
        (_a3 = get$1(event_handler)) == null ? void 0 : _a3.apply(this, $$args);
      };
      var span = child(button);
      var text2 = child(span);
      var node_1 = sibling(button, 2);
      Tooltip(node_1, {
        children: ($$anchor3, $$slotProps2) => {
          var div_1 = root_2$3();
          var text_1 = child(div_1);
          template_effect(() => set_text(text_1, $labelLong()));
          append($$anchor3, div_1);
        },
        $$slots: { default: true }
      });
      template_effect(() => set_text(text2, $labelShort()));
      append($$anchor2, fragment);
    },
    $$slots: { default: true }
  });
  var node_2 = sibling(node, 2);
  Scheduler(node_2, {
    idle: true,
    children: ($$anchor2, $$slotProps) => {
      bind_this(
        Menu($$anchor2, {
          anchorCorner: "BOTTOM_LEFT",
          quickOpen: true,
          class: "cl-dropdown",
          children: ($$anchor3, $$slotProps2) => {
            var div_2 = root_4$3();
            var node_3 = child(div_2);
            List(node_3, {
              children: ($$anchor4, $$slotProps3) => {
                var fragment_2 = comment();
                var node_4 = first_child(fragment_2);
                each(node_4, 1, $resolutionGroups, index, ($$anchor5, group, groupIndex) => {
                  var fragment_3 = root_6$1();
                  var node_5 = first_child(fragment_3);
                  {
                    var consequent = ($$anchor6) => {
                      var div_3 = root_7$3();
                      append($$anchor6, div_3);
                    };
                    if_block(node_5, ($$render) => {
                      if (groupIndex !== 0) $$render(consequent);
                    });
                  }
                  var div_4 = sibling(node_5, 2);
                  var text_2 = child(div_4);
                  var node_6 = sibling(div_4, 2);
                  each(node_6, 1, () => get$1(group).items, index, ($$anchor6, interval) => {
                    {
                      let $0 = /* @__PURE__ */ derived_safe_equal(() => {
                        var _a3;
                        return get$1(interval).resolutionString === ((_a3 = $currentInterval()) == null ? void 0 : _a3.resolutionString);
                      });
                      let $1 = /* @__PURE__ */ derived_safe_equal(() => {
                        var _a3;
                        return clsx$1("row", get$1(interval).resolutionString === ((_a3 = $currentInterval()) == null ? void 0 : _a3.resolutionString) && "selected", $disabled() && "disabled");
                      });
                      let $2 = /* @__PURE__ */ derived_safe_equal(() => ifLeftClick(() => {
                        if ($disabled()) return;
                        chartManagementService.activeChart().setResolution(get$1(interval).resolutionString);
                      }));
                      Item($$anchor6, {
                        tag: "div",
                        get disabled() {
                          return $disabled();
                        },
                        get selected() {
                          return get$1($0);
                        },
                        get class() {
                          return get$1($1);
                        },
                        get onpointerup() {
                          return get$1($2);
                        },
                        children: ($$anchor7, $$slotProps4) => {
                          var text_3 = text();
                          template_effect(($02) => set_text(text_3, $02), [() => toLabel(get$1(interval))]);
                          append($$anchor7, text_3);
                        },
                        $$slots: { default: true }
                      });
                    }
                  });
                  template_effect(($0) => set_text(text_2, $0), [() => t2(get$1(group).i18nKey)]);
                  append($$anchor5, fragment_3);
                });
                append($$anchor4, fragment_2);
              },
              $$slots: { default: true }
            });
            append($$anchor3, div_2);
          },
          $$slots: { default: true },
          $$legacy: true
        }),
        ($$value) => set(menu, $$value),
        () => get$1(menu)
      );
    },
    $$slots: { default: true }
  });
  append($$anchor, div);
  pop();
  $$cleanup();
}
delegate(["pointerup"]);
var root_7$2 = /* @__PURE__ */ from_html(`<div class="separator svelte-1eyo688"></div>`);
var root_4$2 = /* @__PURE__ */ from_html(`<div class="row svelte-1eyo688"><div class="rowInner svelte-1eyo688"><div class="rowLabel svelte-1eyo688"></div> <!></div> <!></div>`);
var root_1$4 = /* @__PURE__ */ from_html(`<div class="layoutMenu svelte-1eyo688"><!></div>`);
const $$css$8 = {
  hash: "svelte-1eyo688",
  code: ".layoutMenu.svelte-1eyo688 {display:flex;flex-direction:column;background:var(--cl-background);user-select:none;cursor:default;z-index:2;}.layoutMenu.svelte-1eyo688 .mdc-deprecated-list {margin:0;padding:0;list-style:none;}.row.svelte-1eyo688 {padding:0 12px;}.rowInner.svelte-1eyo688 {align-items:center;display:flex;padding-top:1px;}.rowLabel.svelte-1eyo688 {color:var(--cl-listItem-foreground);font-size:13px;width:18px;} .layoutMenu .layoutButton {outline:none;border:none;background:none;padding-block:initial;padding-inline:initial;font-family:inherit;color:inherit;display:flex;margin-right:10px;position:relative;padding:4px;border-radius:4px;color:var(--cl-listItem-foreground);}\n@media (hover: hover) and (pointer: fine) { .layoutMenu .layoutButton:not(.disabled):not(.selected):hover {background-color:var(--cl-listItem-hoverBackground);}\n} .layoutMenu .layoutButton.selected {background-color:var(--cl-listItem-selectedBackground);color:var(--cl-listItem-selectedForeground);} .layoutMenu .layoutButton.disabled {cursor:not-allowed;color:var(--cl-listItem-disabledForeground);} .layoutMenu .layoutButton svg {width:21px;height:19px;}.separator.svelte-1eyo688 {background-color:var(--cl-gutter-background);height:1px;margin:6px 0;}"
};
function LayoutMenu($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$8);
  const [$$stores, $$cleanup] = setup_stores();
  const $layouts = () => store_get(layouts, "$layouts", $$stores);
  const $currentLayout = () => store_get(currentLayout, "$currentLayout", $$stores);
  const $lastLayoutPresetIndex = () => store_get(lastLayoutPresetIndex, "$lastLayoutPresetIndex", $$stores);
  let open = prop($$props, "open", 15, false);
  const chartManagementService = useService(IChartManagementService);
  const configurationService = useService(IConfigurationService);
  const layouts = derivedWithCache(configurationService.store, (store) => {
    if (!store.layoutAccessType) return layoutPresets;
    let ret = [];
    Array.from(layoutPresets).forEach((items, key2) => {
      if (!items) return;
      const enabled = items.filter((item) => store.layoutAccess[item.id] === "white");
      if (enabled.length) {
        ret[key2] = enabled;
      }
    });
    return ret;
  });
  const lastLayoutPresetIndex = derivedWithCache(layouts, (layouts2) => layouts2.length - 1);
  const currentLayout = derived(chartManagementService.store, (store) => {
    return store.layout;
  });
  function handleSelect(layout) {
    chartManagementService.setLayout(layout.id);
    open(false);
  }
  Menu($$anchor, {
    anchorCorner: "BOTTOM_LEFT",
    quickOpen: true,
    class: "cl-dropdown",
    get open() {
      return open();
    },
    set open($$value) {
      open($$value);
    },
    children: ($$anchor2, $$slotProps) => {
      var div = root_1$4();
      var node = child(div);
      List(node, {
        children: ($$anchor3, $$slotProps2) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          each(node_1, 1, $layouts, index, ($$anchor4, arr, row) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            {
              var consequent_1 = ($$anchor5) => {
                var div_1 = root_4$2();
                var div_2 = child(div_1);
                var div_3 = child(div_2);
                div_3.textContent = row;
                var node_3 = sibling(div_3, 2);
                each(node_3, 17, () => get$1(arr), index, ($$anchor6, layout) => {
                  {
                    let $0 = /* @__PURE__ */ user_derived(() => clsx$1("layoutButton", get$1(layout).id === $currentLayout() && "selected", get$1(layout).disabled && "disabled"));
                    let $1 = /* @__PURE__ */ user_derived(() => ifLeftClick(() => handleSelect(get$1(layout))));
                    Item($$anchor6, {
                      get class() {
                        return get$1($0);
                      },
                      get onpointerup() {
                        return get$1($1);
                      },
                      tag: "button",
                      children: ($$anchor7, $$slotProps3) => {
                        AsyncSvgIcon($$anchor7, {
                          get icon() {
                            return get$1(layout).icon;
                          }
                        });
                      },
                      $$slots: { default: true }
                    });
                  }
                });
                var node_4 = sibling(div_2, 2);
                {
                  var consequent = ($$anchor6) => {
                    var div_4 = root_7$2();
                    append($$anchor6, div_4);
                  };
                  if_block(node_4, ($$render) => {
                    if (row !== $lastLayoutPresetIndex()) $$render(consequent);
                  });
                }
                append($$anchor5, div_1);
              };
              if_block(node_2, ($$render) => {
                if (!!get$1(arr)) $$render(consequent_1);
              });
            }
            append($$anchor4, fragment_2);
          });
          append($$anchor3, fragment_1);
        },
        $$slots: { default: true }
      });
      append($$anchor2, div);
    },
    $$slots: { default: true }
  });
  pop();
  $$cleanup();
}
var root_2$2 = /* @__PURE__ */ from_html(`<div> </div>`);
var root_1$3 = /* @__PURE__ */ from_html(`<button class="layout svelte-e0as8d"><span class="wrapper svelte-e0as8d"><!></span></button> <!>`, 1);
var root$7 = /* @__PURE__ */ from_html(`<div><!> <!></div>`);
const $$css$7 = {
  hash: "svelte-e0as8d",
  code: '.layout.svelte-e0as8d {outline:none;border:none;background:none;padding-block:initial;padding-inline:initial;font-family:inherit;color:inherit;height:100%;color:var(--cl-foreground);font-size:14px;display:flex;flex-direction:row;align-items:center;justify-content:center;cursor:default;position:relative;z-index:0;padding:0 5px;}\n@media (hover: hover) and (pointer: fine) {.layout.svelte-e0as8d:hover:before {position:absolute;top:2px;right:2px;bottom:2px;left:2px;z-index:-1;border-radius:4px;content:"";background-color:var(--cl-button-hoverBackground);}\n}.wrapper.svelte-e0as8d {width:28px;height:28px;display:flex;align-items:center;justify-content:center;}'
};
function Layout($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$7);
  const [$$stores, $$cleanup] = setup_stores();
  const $currentLayoutIcon = () => store_get(currentLayoutIcon, "$currentLayoutIcon", $$stores);
  const { t: t2 } = useTranslation();
  const chartManagementService = useService(IChartManagementService);
  const currentLayoutIcon = derivedWithCache(chartManagementService.store, (store) => chartLayoutRegistry.value(store.layout).icon);
  let open = /* @__PURE__ */ state(false);
  var div = root$7();
  var node = child(div);
  Wrapper(node, {
    children: ($$anchor2, $$slotProps) => {
      var fragment = root_1$3();
      var button = first_child(fragment);
      var event_handler = /* @__PURE__ */ user_derived(() => ifLeftClick(() => set(open, true)));
      button.__pointerup = function(...$$args) {
        var _a3;
        (_a3 = get$1(event_handler)) == null ? void 0 : _a3.apply(this, $$args);
      };
      var span = child(button);
      var node_1 = child(span);
      AsyncSvgIcon(node_1, {
        get icon() {
          return $currentLayoutIcon();
        }
      });
      var node_2 = sibling(button, 2);
      Tooltip(node_2, {
        children: ($$anchor3, $$slotProps2) => {
          var div_1 = root_2$2();
          var text2 = child(div_1);
          template_effect(($0) => set_text(text2, $0), [() => t2("topToolbar.layout")]);
          append($$anchor3, div_1);
        },
        $$slots: { default: true }
      });
      append($$anchor2, fragment);
    },
    $$slots: { default: true }
  });
  var node_3 = sibling(node, 2);
  Scheduler(node_3, {
    get waitFor() {
      return get$1(open);
    },
    children: ($$anchor2, $$slotProps) => {
      LayoutMenu($$anchor2, {
        get open() {
          return get$1(open);
        },
        set open($$value) {
          set(open, $$value, true);
        }
      });
    },
    $$slots: { default: true }
  });
  append($$anchor, div);
  pop();
  $$cleanup();
}
delegate(["pointerup"]);
var root$6 = /* @__PURE__ */ from_html(`<div class="separator svelte-16cftpq"><div class="inner svelte-16cftpq"></div></div>`);
const $$css$6 = {
  hash: "svelte-16cftpq",
  code: ".separator.svelte-16cftpq {height:100%;display:flex;flex-direction:column;}.inner.svelte-16cftpq {margin:8px 4px;width:1px;flex-grow:1;box-sizing:border-box;background-color:var(--cl-gutter-background);}"
};
function Separator($$anchor) {
  append_styles$1($$anchor, $$css$6);
  var div = root$6();
  append($$anchor, div);
}
var root$5 = /* @__PURE__ */ from_html(`<button><!></button>`);
const $$css$5 = {
  hash: "svelte-25z81x",
  code: ".button.svelte-25z81x {outline:none;border:none;background:none;padding-block:initial;padding-inline:initial;font-family:inherit;color:inherit;border-radius:8px;height:34px;padding:0 15px;display:flex;align-items:center;font-size:16px;}.secondary.svelte-25z81x {border:1px solid var(--cl-button-secondary-border);color:var(--cl-button-secondary-foreground);}\n@media (hover: hover) and (pointer: fine) {.secondary.svelte-25z81x:hover {color:var(--cl-button-secondary-hoverForeground);background-color:var(--cl-button-secondary-hoverBackground);}\n}.primary.svelte-25z81x {color:var(--cl-button-primary-foreground);background-color:var(--cl-button-primary-background);}"
};
function Button($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$5);
  const props = /* @__PURE__ */ rest_props($$props, ["$$slots", "$$events", "$$legacy"]);
  const { btnType, ...domProps } = props;
  var button = root$5();
  attribute_effect(button, ($0) => ({ class: $0, ...domProps }), [() => clsx$1("button", btnType)], void 0, "svelte-25z81x");
  var node = child(button);
  snippet(node, () => domProps.children ?? noop$1);
  append($$anchor, button);
  pop();
}
var root$4 = /* @__PURE__ */ from_html(`<div class="dialog-footer svelte-1a2g0d7"><!> <!></div>`);
const $$css$4 = {
  hash: "svelte-1a2g0d7",
  code: ".dialog-footer.svelte-1a2g0d7 {padding:16px 20px;border-top:1px solid var(--cl-gutter-background);display:flex;align-items:center;justify-content:flex-end;gap:10px;}"
};
function DialogFooter($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$4);
  var div = root$4();
  var node = child(div);
  {
    let $0 = /* @__PURE__ */ user_derived(() => ifLeftClick(() => {
      var _a3;
      return (_a3 = $$props.onCancel) == null ? void 0 : _a3.call($$props);
    }));
    Button(node, {
      btnType: "secondary",
      get onpointerup() {
        return get$1($0);
      },
      children: ($$anchor2, $$slotProps) => {
        var text$1 = text();
        template_effect(() => set_text(text$1, $$props.cancelButtonText));
        append($$anchor2, text$1);
      },
      $$slots: { default: true }
    });
  }
  var node_1 = sibling(node, 2);
  {
    let $0 = /* @__PURE__ */ user_derived(() => ifLeftClick(() => {
      var _a3;
      return (_a3 = $$props.onConfirm) == null ? void 0 : _a3.call($$props);
    }));
    Button(node_1, {
      btnType: "primary",
      get onpointerup() {
        return get$1($0);
      },
      children: ($$anchor2, $$slotProps) => {
        var text_1 = text();
        template_effect(() => set_text(text_1, $$props.mainButtonText));
        append($$anchor2, text_1);
      },
      $$slots: { default: true }
    });
  }
  append($$anchor, div);
  pop();
}
var root_2$1 = /* @__PURE__ */ from_html(`<div> </div>`);
var root_1$2 = /* @__PURE__ */ from_html(`<button aria-label="Settings" class="setting svelte-1x8jemh"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28" fill="currentColor" class="svelte-1x8jemh"><path fill-rule="evenodd" d="M18 14a4 4 0 1 1-8 0 4 4 0 0 1 8 0Zm-1 0a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"></path><path fill-rule="evenodd" d="M8.5 5h11l5 9-5 9h-11l-5-9 5-9Zm-3.86 9L9.1 6h9.82l4.45 8-4.45 8H9.1l-4.45-8Z"></path></svg></button> <!>`, 1);
var root_4$1 = /* @__PURE__ */ from_html(`<!> <!> <!>`, 1);
var root$3 = /* @__PURE__ */ from_html(`<div><!> <!></div>`);
const $$css$3 = {
  hash: "svelte-1x8jemh",
  code: '.setting.svelte-1x8jemh {outline:none;border:none;background:none;padding-block:initial;padding-inline:initial;font-family:inherit;color:inherit;height:100%;color:var(--cl-foreground);font-size:14px;display:flex;flex-direction:row;align-items:center;justify-content:center;cursor:default;position:relative;z-index:0;padding:0 5px;}\n@media (hover: hover) and (pointer: fine) {.setting.svelte-1x8jemh:hover:before {position:absolute;top:2px;right:2px;bottom:2px;left:2px;z-index:-1;border-radius:4px;content:"";background-color:var(--cl-button-hoverBackground);}\n}.setting.svelte-1x8jemh > svg:where(.svelte-1x8jemh) {width:28px;height:28px;color:var(--cl-foreground);}'
};
function Setting($$anchor, $$props) {
  push($$props, true);
  append_styles$1($$anchor, $$css$3);
  const { t: t2 } = useTranslation();
  let open = /* @__PURE__ */ state(false);
  function handleOpen() {
    set(open, true);
  }
  function handleClose() {
    set(open, false);
  }
  var div = root$3();
  var node = child(div);
  Wrapper(node, {
    children: ($$anchor2, $$slotProps) => {
      var fragment = root_1$2();
      var button = first_child(fragment);
      var event_handler = /* @__PURE__ */ user_derived(() => ifLeftClick(handleOpen));
      button.__pointerup = function(...$$args) {
        var _a3;
        (_a3 = get$1(event_handler)) == null ? void 0 : _a3.apply(this, $$args);
      };
      var node_1 = sibling(button, 2);
      Tooltip(node_1, {
        children: ($$anchor3, $$slotProps2) => {
          var div_1 = root_2$1();
          var text2 = child(div_1);
          template_effect(($0) => set_text(text2, $0), [() => t2("topToolbar.setting")]);
          append($$anchor3, div_1);
        },
        $$slots: { default: true }
      });
      append($$anchor2, fragment);
    },
    $$slots: { default: true }
  });
  var node_2 = sibling(node, 2);
  Scheduler(node_2, {
    low: true,
    children: ($$anchor2, $$slotProps) => {
      Dialog($$anchor2, {
        get open() {
          return get$1(open);
        },
        set open($$value) {
          set(open, $$value, true);
        },
        children: ($$anchor3, $$slotProps2) => {
          var fragment_2 = root_4$1();
          var node_3 = first_child(fragment_2);
          {
            let $0 = /* @__PURE__ */ user_derived(() => t2("setting.title"));
            DialogTitle(node_3, {
              get title() {
                return get$1($0);
              }
            });
          }
          var node_4 = sibling(node_3, 2);
          Content(node_4, {
            children: ($$anchor4, $$slotProps3) => {
              var text_1 = text("empty");
              append($$anchor4, text_1);
            },
            $$slots: { default: true }
          });
          var node_5 = sibling(node_4, 2);
          {
            let $0 = /* @__PURE__ */ user_derived(() => t2("common.ok"));
            let $1 = /* @__PURE__ */ user_derived(() => t2("common.cancel"));
            DialogFooter(node_5, {
              get mainButtonText() {
                return get$1($0);
              },
              get cancelButtonText() {
                return get$1($1);
              },
              onConfirm: handleClose,
              onCancel: handleClose
            });
          }
          append($$anchor3, fragment_2);
        },
        $$slots: { default: true }
      });
    },
    $$slots: { default: true }
  });
  append($$anchor, div);
  pop();
}
delegate(["pointerup"]);
var root_1$1 = /* @__PURE__ */ from_html(`<button class="snapshot svelte-1cijlm1"><svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" fill="currentColor" class="svelte-1cijlm1"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.118 6a.5.5 0 0 0-.447.276L9.809 8H5.5A1.5 1.5 0 0 0 4 9.5v10A1.5 1.5 0 0 0 5.5 21h16a1.5 1.5 0 0 0 1.5-1.5v-10A1.5 1.5 0 0 0 21.5 8h-4.309l-.862-1.724A.5.5 0 0 0 15.882 6h-4.764zm-1.342-.17A1.5 1.5 0 0 1 11.118 5h4.764a1.5 1.5 0 0 1 1.342.83L17.809 7H21.5A2.5 2.5 0 0 1 24 9.5v10a2.5 2.5 0 0 1-2.5 2.5h-16A2.5 2.5 0 0 1 3 19.5v-10A2.5 2.5 0 0 1 5.5 7h3.691l.585-1.17z"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M13.5 18a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7zm0 1a4.5 4.5 0 1 0 0-9 4.5 4.5 0 0 0 0 9z"></path></svg></button> <!>`, 1);
var root_6 = /* @__PURE__ */ from_html(`<span class="rowIcon svelte-1cijlm1"><svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" fill="none"><path stroke="currentColor" d="M6.5 16v4.5a1 1 0 001 1h14a1 1 0 001-1V16M14.5 5V17m-4-3.5l4 4l4-4"></path></svg></span> <span class="rowLabel svelte-1cijlm1"> </span> <span class="keyBinding svelte-1cijlm1"> </span>`, 1);
var root_7$1 = /* @__PURE__ */ from_html(`<span class="rowIcon svelte-1cijlm1"><svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><g fill="none" fill-rule="evenodd" stroke="currentColor"><path d="M13.111 18.5H10.5a1 1 0 0 1-1-1v-11a1 1 0 0 1 1-1h11a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1h-8.389z"></path><path d="M18.5 20v1.5a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1v-11a1 1 0 0 1 1-1H8"></path></g></svg></span> <span class="rowLabel svelte-1cijlm1"> </span> <span class="keyBinding svelte-1cijlm1"> </span>`, 1);
var root_5$1 = /* @__PURE__ */ from_html(`<div class="title svelte-1cijlm1"> </div> <!> <!>`, 1);
var root_4 = /* @__PURE__ */ from_html(`<div class="menu svelte-1cijlm1"><!></div>`);
var root$2 = /* @__PURE__ */ from_html(`<div><!> <!></div>`);
const $$css$2 = {
  hash: "svelte-1cijlm1",
  code: '.snapshot.svelte-1cijlm1 {outline:none;border:none;background:none;padding-block:initial;padding-inline:initial;font-family:inherit;color:inherit;height:100%;color:var(--cl-foreground);font-size:14px;display:flex;flex-direction:row;align-items:center;justify-content:center;cursor:default;position:relative;z-index:0;padding:0 5px;}\n@media (hover: hover) and (pointer: fine) {.snapshot.svelte-1cijlm1:hover:before {position:absolute;top:2px;right:2px;bottom:2px;left:2px;z-index:-1;border-radius:4px;content:"";background-color:var(--cl-button-hoverBackground);}\n}.snapshot.svelte-1cijlm1 > svg:where(.svelte-1cijlm1) {width:28px;height:28px;color:var(--cl-foreground);}.snapshot.svelte-1cijlm1 .cl-dropdown {padding:0;}.menu.svelte-1cijlm1 {display:flex;flex-direction:column;background:var(--cl-background);user-select:none;cursor:default;z-index:2;}.menu.svelte-1cijlm1 .mdc-deprecated-list {margin:0;padding:0;list-style:none;}.title.svelte-1cijlm1 {font-size:11px;letter-spacing:0.4px;line-height:16px;margin:6px 0;padding:0 12px;color:var(--cl-listTitle-foreground);}.menu.svelte-1cijlm1 .row {display:flex;flex-direction:row;align-items:center;justify-content:flex-start;padding:2px 10px 2px 8px;}\n@media (hover: hover) and (pointer: fine) {.menu.svelte-1cijlm1 .row:hover {background-color:var(--cl-listItem-hoverBackground);}\n}.rowIcon.svelte-1cijlm1 {width:28px;height:28px;margin-right:6px;color:var(--cl-foreground);}.rowLabel.svelte-1cijlm1 {font-size:14px;padding-right:12px;white-space:nowrap;user-select:none;cursor:default;flex:0 1 100%;color:var(--cl-foreground);}.keyBinding.svelte-1cijlm1 {font-size:12px;margin-left:20px;text-align:right;color:var(--cl-listKeybinding-foreground);justify-self:flex-end;}'
};
function Snapshot($$anchor, $$props) {
  push($$props, false);
  append_styles$1($$anchor, $$css$2);
  const { t: t2 } = useTranslation();
  const chartManagementService = useService(IChartManagementService);
  const clipboardService = useService(IClipboardService);
  const notificationService = useService(INotificationService);
  const keybindingsRegistry = useService(IKeybindingsRegistry);
  const onpointerup = () => {
    get$1(menu).setOpen(true);
  };
  const downloadKb = KeyCode.KeyS | KeyMod.Alt | KeyMod.CtrlCmd;
  const download = async () => {
    const el = chartManagementService.getDomElement();
    if (!el) return;
    const { domToPng } = await __vitePreload(async () => {
      const { domToPng: domToPng2 } = await import("./index-D1qIiuzn.js");
      return { domToPng: domToPng2 };
    }, true ? [] : void 0, import.meta.url);
    domToPng(el).then((dataUrl) => {
      const link2 = document.createElement("a");
      link2.download = "screenshot.png";
      link2.href = dataUrl;
      link2.click();
    });
  };
  useDisposable(keybindingsRegistry.registerCommandAndKeybindingRule({
    id: "snapshot.download",
    primary: downloadKb,
    weight: KeybindingWeight.ChartContrib,
    handler() {
      download();
    }
  }));
  const copyKb = KeyCode.KeyS | KeyMod.Shift | KeyMod.CtrlCmd;
  const copy = async () => {
    const el = chartManagementService.getDomElement();
    if (!el) return;
    const { domToBlob } = await __vitePreload(async () => {
      const { domToBlob: domToBlob2 } = await import("./index-D1qIiuzn.js");
      return { domToBlob: domToBlob2 };
    }, true ? [] : void 0, import.meta.url);
    domToBlob(el).then((blob) => {
      const file = new File([blob], "screenshot.png", { type: "image/png", lastModified: Date.now() });
      clipboardService.writeClipboard({ files: [file] });
      notificationService.verbose(t2("topToolbar.snapshot.copyImage.success"));
    });
  };
  useDisposable(keybindingsRegistry.registerCommandAndKeybindingRule({
    id: "snapshot.copy",
    primary: copyKb,
    weight: KeybindingWeight.ChartContrib,
    handler() {
      copy();
    }
  }));
  let menu = /* @__PURE__ */ mutable_source();
  onDestroy(() => {
    set(menu, null);
  });
  init();
  var div = root$2();
  var node = child(div);
  Wrapper(node, {
    children: ($$anchor2, $$slotProps) => {
      var fragment = root_1$1();
      var button = first_child(fragment);
      var event_handler = /* @__PURE__ */ user_derived(() => ifLeftClick(onpointerup));
      button.__pointerup = function(...$$args) {
        var _a3;
        (_a3 = get$1(event_handler)) == null ? void 0 : _a3.apply(this, $$args);
      };
      var node_1 = sibling(button, 2);
      Tooltip(node_1, {
        children: ($$anchor3, $$slotProps2) => {
          {
            let $0 = /* @__PURE__ */ derived_safe_equal(() => t2("topToolbar.snapshot"));
            TooltipContent($$anchor3, {
              get content() {
                return get$1($0);
              }
            });
          }
        },
        $$slots: { default: true }
      });
      append($$anchor2, fragment);
    },
    $$slots: { default: true }
  });
  var node_2 = sibling(node, 2);
  Scheduler(node_2, {
    low: true,
    children: ($$anchor2, $$slotProps) => {
      bind_this(
        Menu($$anchor2, {
          anchorCorner: "BOTTOM_LEFT",
          quickOpen: true,
          class: "cl-dropdown",
          children: ($$anchor3, $$slotProps2) => {
            var div_1 = root_4();
            var node_3 = child(div_1);
            List(node_3, {
              children: ($$anchor4, $$slotProps3) => {
                var fragment_3 = root_5$1();
                var div_2 = first_child(fragment_3);
                var text2 = child(div_2);
                var node_4 = sibling(div_2, 2);
                {
                  let $0 = /* @__PURE__ */ derived_safe_equal(() => ifLeftClick(download));
                  Item(node_4, {
                    tag: "div",
                    class: "row",
                    get onpointerup() {
                      return get$1($0);
                    },
                    children: ($$anchor5, $$slotProps4) => {
                      var fragment_4 = root_6();
                      var span = sibling(first_child(fragment_4), 2);
                      var text_1 = child(span);
                      var span_1 = sibling(span, 2);
                      var text_2 = child(span_1);
                      template_effect(
                        ($02, $1) => {
                          set_text(text_1, $02);
                          set_text(text_2, $1);
                        },
                        [
                          () => t2("topToolbar.snapshot.downloadImage"),
                          () => getKeybindingLabel(downloadKb)
                        ]
                      );
                      append($$anchor5, fragment_4);
                    },
                    $$slots: { default: true }
                  });
                }
                var node_5 = sibling(node_4, 2);
                {
                  let $0 = /* @__PURE__ */ derived_safe_equal(() => ifLeftClick(copy));
                  Item(node_5, {
                    tag: "div",
                    class: "row",
                    get onpointerup() {
                      return get$1($0);
                    },
                    children: ($$anchor5, $$slotProps4) => {
                      var fragment_5 = root_7$1();
                      var span_2 = sibling(first_child(fragment_5), 2);
                      var text_3 = child(span_2);
                      var span_3 = sibling(span_2, 2);
                      var text_4 = child(span_3);
                      template_effect(
                        ($02, $1) => {
                          set_text(text_3, $02);
                          set_text(text_4, $1);
                        },
                        [
                          () => t2("topToolbar.snapshot.copyImage"),
                          () => getKeybindingLabel(copyKb)
                        ]
                      );
                      append($$anchor5, fragment_5);
                    },
                    $$slots: { default: true }
                  });
                }
                template_effect(($0) => set_text(text2, $0), [() => t2("topToolbar.snapshot.menu.title")]);
                append($$anchor4, fragment_3);
              },
              $$slots: { default: true }
            });
            append($$anchor3, div_1);
          },
          $$slots: { default: true },
          $$legacy: true
        }),
        ($$value) => set(menu, $$value),
        () => get$1(menu)
      );
    },
    $$slots: { default: true }
  });
  append($$anchor, div);
  pop();
}
delegate(["pointerup"]);
var root_7 = /* @__PURE__ */ from_html(`<!> <!>`, 1);
var root_9 = /* @__PURE__ */ from_html(`<!> <!>`, 1);
var root_11 = /* @__PURE__ */ from_html(`<!> <!>`, 1);
var root_19 = /* @__PURE__ */ from_html(`<!> <!>`, 1);
var root_1 = /* @__PURE__ */ from_html(`<!> <!> <!> <!> <div class="space svelte-3jg4ln"></div> <!> <!> <!> <!> <!>`, 1);
var root$1 = /* @__PURE__ */ from_html(`<div class="top svelte-3jg4ln"><!></div>`);
const $$css$1 = {
  hash: "svelte-3jg4ln",
  code: ".top.svelte-3jg4ln {display:flex;flex-direction:row;align-items:stretch;height:38px;width:100%;box-sizing:border-box;background-color:var(--cl-background);padding-right:5px;margin-bottom:4px;}.top.svelte-3jg4ln [data-dropdown-menu-trigger] {height:100%;}.top.svelte-3jg4ln [data-tooltip-trigger] {height:100%;}.space.svelte-3jg4ln {margin-left:auto;}"
};
function Top($$anchor, $$props) {
  push($$props, false);
  append_styles$1($$anchor, $$css$1);
  const [$$stores, $$cleanup] = setup_stores();
  const $leftButtons = () => store_get(leftButtons, "$leftButtons", $$stores);
  const $rightButtons = () => store_get(rightButtons, "$rightButtons", $$stores);
  const guiService = useService(IGuiService);
  const configurationService = useService(IConfigurationService);
  const leftButtons = derived(guiService.store, (store) => {
    return store.leftButtons;
  });
  const rightButtons = derived(guiService.store, (store) => {
    return store.rightButtons;
  });
  onMount(() => {
    guiService.setHeaderReady();
  });
  init();
  var div = root$1();
  var node = child(div);
  Scheduler(node, {
    idle: true,
    children: ($$anchor2, $$slotProps) => {
      var fragment = root_1();
      var node_1 = first_child(fragment);
      {
        var consequent = ($$anchor3) => {
          Scheduler($$anchor3, {
            idle: true,
            children: ($$anchor4, $$slotProps2) => {
              Interval2($$anchor4, {});
            },
            $$slots: { default: true }
          });
        };
        if_block(node_1, ($$render) => {
          if (configurationService.featureEnabled("header_resolutions")) $$render(consequent);
        });
      }
      var node_2 = sibling(node_1, 2);
      {
        var consequent_1 = ($$anchor3) => {
          Scheduler($$anchor3, {
            idle: true,
            children: ($$anchor4, $$slotProps2) => {
              ChartStyle($$anchor4, {});
            },
            $$slots: { default: true }
          });
        };
        if_block(node_2, ($$render) => {
          if (configurationService.featureEnabled("header_chart_type")) $$render(consequent_1);
        });
      }
      var node_3 = sibling(node_2, 2);
      {
        var consequent_2 = ($$anchor3) => {
          Scheduler($$anchor3, {
            idle: true,
            children: ($$anchor4, $$slotProps2) => {
              var fragment_6 = root_7();
              var node_4 = first_child(fragment_6);
              Separator(node_4);
              var node_5 = sibling(node_4, 2);
              Indicator(node_5, {});
              append($$anchor4, fragment_6);
            },
            $$slots: { default: true }
          });
        };
        if_block(node_3, ($$render) => {
          if (configurationService.featureEnabled("header_indicators")) $$render(consequent_2);
        });
      }
      var node_6 = sibling(node_3, 2);
      Scheduler(node_6, {
        idle: true,
        children: ($$anchor3, $$slotProps2) => {
          var fragment_7 = comment();
          var node_7 = first_child(fragment_7);
          each(node_7, 1, $leftButtons, (button) => button.id, ($$anchor4, button) => {
            var fragment_8 = root_9();
            var node_8 = first_child(fragment_8);
            Separator(node_8);
            var node_9 = sibling(node_8, 2);
            CustomButton(node_9, spread_props(() => get$1(button)));
            append($$anchor4, fragment_8);
          });
          append($$anchor3, fragment_7);
        },
        $$slots: { default: true }
      });
      var node_10 = sibling(node_6, 4);
      {
        var consequent_3 = ($$anchor3) => {
          Scheduler($$anchor3, {
            idle: true,
            children: ($$anchor4, $$slotProps2) => {
              var fragment_10 = root_11();
              var node_11 = first_child(fragment_10);
              Layout(node_11, {});
              var node_12 = sibling(node_11, 2);
              Separator(node_12);
              append($$anchor4, fragment_10);
            },
            $$slots: { default: true }
          });
        };
        if_block(node_10, ($$render) => {
          if (configurationService.featureEnabled("header_layouttoggle")) $$render(consequent_3);
        });
      }
      var node_13 = sibling(node_10, 2);
      {
        var consequent_4 = ($$anchor3) => {
          Scheduler($$anchor3, {
            idle: true,
            children: ($$anchor4, $$slotProps2) => {
              Setting($$anchor4, {});
            },
            $$slots: { default: true }
          });
        };
        if_block(node_13, ($$render) => {
          if (configurationService.featureEnabled("header_settings")) $$render(consequent_4);
        });
      }
      var node_14 = sibling(node_13, 2);
      {
        var consequent_5 = ($$anchor3) => {
          Scheduler($$anchor3, {
            idle: true,
            children: ($$anchor4, $$slotProps2) => {
              Fullscreen($$anchor4, {});
            },
            $$slots: { default: true }
          });
        };
        if_block(node_14, ($$render) => {
          if (configurationService.featureEnabled("header_fullscreen_button")) $$render(consequent_5);
        });
      }
      var node_15 = sibling(node_14, 2);
      {
        var consequent_6 = ($$anchor3) => {
          Scheduler($$anchor3, {
            idle: true,
            children: ($$anchor4, $$slotProps2) => {
              Snapshot($$anchor4, {});
            },
            $$slots: { default: true }
          });
        };
        if_block(node_15, ($$render) => {
          if (configurationService.featureEnabled("header_screenshot")) $$render(consequent_6);
        });
      }
      var node_16 = sibling(node_15, 2);
      Scheduler(node_16, {
        idle: true,
        children: ($$anchor3, $$slotProps2) => {
          var fragment_17 = comment();
          var node_17 = first_child(fragment_17);
          each(node_17, 1, $rightButtons, (button) => button.id, ($$anchor4, button) => {
            var fragment_18 = root_19();
            var node_18 = first_child(fragment_18);
            Separator(node_18);
            var node_19 = sibling(node_18, 2);
            CustomButton(node_19, spread_props(() => get$1(button)));
            append($$anchor4, fragment_18);
          });
          append($$anchor3, fragment_17);
        },
        $$slots: { default: true }
      });
      append($$anchor2, fragment);
    },
    $$slots: { default: true }
  });
  append($$anchor, div);
  pop();
  $$cleanup();
}
var root_2 = /* @__PURE__ */ from_html(`<div class="top svelte-12x4dtb"></div>`);
var root_5 = /* @__PURE__ */ from_html(`<div class="left svelte-12x4dtb"></div>`);
var root = /* @__PURE__ */ from_html(`<div class="chartles"><!> <div class="contentWrap svelte-12x4dtb"><!> <div class="centerWrap svelte-12x4dtb"><!></div></div> <!></div>`);
const $$css = {
  hash: "svelte-12x4dtb",
  code: ' .chartles {height:100%;width:100%;position:relative;display:flex;flex-direction:column;color:var(--cl-foreground);background-color:var(--cl-global-background);user-select:none;-webkit-font-smoothing:antialiased;-webkit-text-size-adjust:100%;font-variation-settings:normal;font-feature-settings:"tnum" on, "lnum" on, "rlig" 1, "calt" 1;font-family:var(--cl-font-family);} .chartles * {overscroll-behavior:contain;}.contentWrap.svelte-12x4dtb {width:100%;height:calc(100% - 38px);display:flex;flex-direction:row;}.centerWrap.svelte-12x4dtb {display:flex;flex-direction:column;flex-grow:1;}.top.svelte-12x4dtb {height:38px;width:100%;box-sizing:border-box;background-color:var(--cl-background);padding-right:5px;margin-bottom:4px;}.left.svelte-12x4dtb {width:52px;height:100%;background-color:var(--cl-background);border-top-right-radius:4px;margin-right:4px;box-sizing:border-box;}'
};
function App($$anchor, $$props) {
  push($$props, false);
  append_styles$1($$anchor, $$css);
  const [$$stores, $$cleanup] = setup_stores();
  const $features = () => store_get(features, "$features", $$stores);
  const configurationService = useService(IConfigurationService);
  const features = derived(configurationService.store, (store) => store.chartFeatures);
  const lazyLeft = useLazyComponent(__vitePreload(() => import("./Left-DFGFkdAK.js"), true ? __vite__mapDeps([0,1,2]) : void 0, import.meta.url).then((module2) => module2.default), schedulerExports.unstable_IdlePriority);
  const lazyCenter = useLazyComponent(Center);
  const lazyFloat = useLazyComponent(Float, schedulerExports.unstable_IdlePriority);
  const lazyTop = useLazyComponent(Top, schedulerExports.unstable_IdlePriority);
  init();
  var div = root();
  var node = child(div);
  await_block(
    node,
    () => lazyTop,
    ($$anchor2) => {
      var div_1 = root_2();
      append($$anchor2, div_1);
    },
    ($$anchor2, Top2) => {
      get$1(Top2)($$anchor2, {});
    }
  );
  var div_2 = sibling(node, 2);
  var node_1 = child(div_2);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      await_block(
        node_2,
        () => lazyLeft,
        ($$anchor3) => {
          var div_3 = root_5();
          append($$anchor3, div_3);
        },
        ($$anchor3, Left) => {
          get$1(Left)($$anchor3, {});
        }
      );
      append($$anchor2, fragment_1);
    };
    if_block(node_1, ($$render) => {
      if ($features().left_toolbar) $$render(consequent);
    });
  }
  var div_4 = sibling(node_1, 2);
  var node_3 = child(div_4);
  await_block(node_3, () => lazyCenter, null, ($$anchor2, Center2) => {
    get$1(Center2)($$anchor2, {});
  });
  var node_4 = sibling(div_2, 2);
  await_block(node_4, () => lazyFloat, null, ($$anchor2, Float2) => {
    get$1(Float2)($$anchor2, {});
  });
  append($$anchor, div);
  pop();
  $$cleanup();
}
const baseStyle = '.chartles .mdc-dialog__scrim {\n  background-color: unset;\n}\n.chartles .mdc-dialog__surface {\n  border: none;\n  border-radius: 6px;\n  background: var(--cl-dialog-background);\n  box-shadow: var(--cl-dialog-shadow) 0px 2px 4px 0px;\n}\n.chartles :focus-visible {\n  outline: none;\n}\n.chartles .cl-dropdown {\n  border-radius: 6px;\n  box-shadow: var(--cl-dialog-shadow) 0px 2px 4px 0px;\n  padding: 10px 0;\n  background-color: var(--cl-background);\n}\n\n.cl-tooltip {\n  -webkit-font-smoothing: antialiased;\n  -webkit-text-size-adjust: 100%;\n  font-variation-settings: normal;\n  font-feature-settings: "tnum" on, "lnum" on, "rlig" 1, "calt" 1;\n  font-family: var(--cl-font-family);\n}\n.cl-tooltip > .mdc-tooltip__surface {\n  max-width: unset;\n  background-color: var(--cl-tooltip-background);\n}';
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key2, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key2) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam = (index2, decorator) => (target, key2) => decorator(target, key2, index2);
let Workbench = class extends Disposable {
  constructor(_container, configurationService, chartManagementService, instantiationService, i18nService) {
    super();
    __publicField(this, "_app", null);
    __publicField(this, "whenRestoredPromise", new DeferredPromise$1());
    __publicField(this, "whenRestored", this.whenRestoredPromise.p);
    this._container = _container;
    this.configurationService = configurationService;
    this.chartManagementService = chartManagementService;
    this.instantiationService = instantiationService;
    this.i18nService = i18nService;
  }
  dispose() {
    super.dispose();
    this.whenRestoredPromise = null;
    this.whenRestored = null;
  }
  startup() {
    const context = /* @__PURE__ */ new Map();
    context.set(IConfigurationService, this.configurationService);
    context.set(IInstantiationService, this.instantiationService);
    context.set(IIntlService, this.i18nService);
    this._register(
      toDisposable(() => {
        context.clear();
      })
    );
    const layoutRestoredPromises = [];
    layoutRestoredPromises.push(this.chartManagementService.whenRestored);
    this._app = mount(App, {
      target: this._container,
      context
    });
    [smuiStyle, baseStyle].forEach((text2) => {
      const s2 = document.createElement("style");
      s2.append(document.createTextNode(text2));
      this._container.append(s2);
    });
    Promises.settled(layoutRestoredPromises).finally(() => {
      this.whenRestoredPromise.complete();
    });
  }
  async teardown() {
    if (this._app) {
      deepTraverseAndClean(ensure(this._container.firstElementChild));
      await unmount(this._app);
      clear_event_propagation();
      this._app = null;
    }
    this.dispose();
  }
};
Workbench = __decorateClass([
  __decorateParam(1, IConfigurationService),
  __decorateParam(2, IChartManagementService),
  __decorateParam(3, IInstantiationService),
  __decorateParam(4, IIntlService)
], Workbench);
function deepTraverseAndClean(rootNode) {
  const visited = /* @__PURE__ */ new WeakSet();
  function traverse(node) {
    if (!node || typeof node !== "object" || visited.has(node)) {
      return;
    }
    visited.add(node);
    try {
      Object.keys(node).forEach((k2) => {
        if (k2 === "__cleanup") {
          Reflect.get(node, k2).forEach((cleanup) => {
            cleanup();
          });
        }
        try {
          Reflect.deleteProperty(node, k2);
        } catch {
        }
      });
    } catch {
    }
    if (node.childNodes && node.childNodes.length > 0) {
      node.childNodes.forEach((child2) => traverse(child2));
    }
  }
  traverse(rootNode);
}
let Widget$1 = class Widget extends Disposable {
  constructor(options) {
    var _a3, _b3, _c2;
    super();
    __publicField(this, "workbench");
    __publicField(this, "instantiationService");
    __publicField(this, "guiService");
    __publicField(this, "lifecycleService");
    __publicField(this, "datafeedService");
    __publicField(this, "configurationService");
    __publicField(this, "startupTask", null);
    __publicField(this, "host");
    __publicField(this, "tradeApi", null);
    const container = isString$1(options.container) ? document.querySelector(options.container) : options.container;
    should(container);
    const host = document.createElement("div");
    Object.assign(host.style, {
      width: "100%",
      height: "100%"
    });
    host.tabIndex = -1;
    container.append(host);
    this.host = host;
    const shadowRoot = host.attachShadow({ mode: "open" });
    this.guiService = this._register(new GuiService(shadowRoot));
    this.lifecycleService = this._register(new LifecycleService());
    this.lifecycleService.phase = LifecyclePhase.Ready;
    this.datafeedService = this._register(new DatafeedService(options.datafeed));
    this.configurationService = this._register(new ConfigurationService(options));
    const serviceCollection = new ServiceCollection();
    serviceCollection.set(ILifecycleService, this.lifecycleService);
    serviceCollection.set(IGuiService, this.guiService);
    serviceCollection.set(IDatafeedService, this.datafeedService);
    serviceCollection.set(
      IStoreService,
      new SyncDescriptor(StoreService, [(_a3 = options.savedData) == null ? void 0 : _a3.stores])
    );
    serviceCollection.set(IConfigurationService, this.configurationService);
    serviceCollection.set(
      IThemeService,
      new SyncDescriptor(ThemeService, [
        shadowRoot,
        {
          "font-family": options.customFontFamily ?? ChartFontFamily,
          "--cl-font-family": options.customFontFamily ?? ChartFontFamily
        }
      ])
    );
    serviceCollection.set(
      IClipboardService,
      new SyncDescriptor(ClipboardService, [host, shadowRoot])
    );
    serviceCollection.set(IContextKeyService, new SyncDescriptor(ContextKeyService));
    serviceCollection.set(
      IChartManagementService,
      new SyncDescriptor(ChartManagementService, [
        ((_b3 = options.savedData) == null ? void 0 : _b3.charts.layout) ?? options.layout ?? "s",
        (_c2 = options.savedData) == null ? void 0 : _c2.charts
      ])
    );
    serviceCollection.set(IStudyService, new SyncDescriptor(StudyService));
    serviceCollection.set(ILogService, new SyncDescriptor(LogService, [new ConsoleLogger()]));
    serviceCollection.set(ICommandService, new SyncDescriptor(CommandService));
    serviceCollection.set(IIntlService, new SyncDescriptor(IntlService, [options.locale]));
    serviceCollection.set(IToolService, new SyncDescriptor(ToolService));
    serviceCollection.set(
      ITradeService,
      new SyncDescriptor(TradeService, [options.brokerFactory, options.brokerConfig])
    );
    serviceCollection.set(
      IKeybindingService,
      new SyncDescriptor(KeybindingService, [host, shadowRoot])
    );
    serviceCollection.set(INotificationService, new SyncDescriptor(NotificationService));
    serviceCollection.set(IUndoRedoService, new SyncDescriptor(UndoRedoService));
    serviceCollection.set(
      IWorkbenchContributionsRegistry,
      new SyncDescriptor(WorkbenchContributionsRegistry)
    );
    serviceCollection.set(
      IChartContributionRegistry,
      new SyncDescriptor(ChartContributionRegistry)
    );
    const chartResolutionRegistry = new ChartResolutionRegistry();
    serviceCollection.set(IChartResolutionRegistry, chartResolutionRegistry);
    serviceCollection.set(ICommandRegistry, new SyncDescriptor(CommandRegistry));
    serviceCollection.set(IKeybindingsRegistry, new SyncDescriptor(KeybindingsRegistry));
    serviceCollection.set(IToolRegistry, new SyncDescriptor(ToolRegistry));
    const instantiationService = new InstantiationService(serviceCollection, true);
    serviceCollection.set(IInstantiationService, instantiationService);
    serviceCollection.set(IInputService, instantiationService.createInstance(InputService));
    this.instantiationService = this._register(instantiationService);
    this.workbench = this._register(instantiationService.createInstance(Workbench, shadowRoot));
    this.startupTask = schedulerExports.unstable_scheduleCallback(schedulerExports.unstable_NormalPriority, () => {
      this.workbench.startup();
      this.startupTask = null;
    });
    this.workbench.whenRestored.then(() => {
      this.lifecycleService.phase = LifecyclePhase.Restored;
    });
    const eventuallyPhaseScheduler = this._register(
      new RunOnceScheduler(() => {
        this._register(
          runWhenIdle(() => this.lifecycleService.phase = LifecyclePhase.Eventually, 1e3)
        );
      }, 1e3)
    );
    eventuallyPhaseScheduler.schedule();
    this._register(
      this.datafeedService.onReady((conf) => {
        if (Array.isArray(conf.supported_resolutions)) {
          conf.supported_resolutions.forEach((res) => {
            chartResolutionRegistry.registerResolution(res);
          });
        }
      })
    );
    this.registerConributions();
  }
  registerConributions() {
    this.instantiationService.invokeFunction((accessor) => {
      const wR = accessor.get(IWorkbenchContributionsRegistry);
      wR.register(
        "keybinding.priceScale",
        () => Promise.resolve(PriceScaleKeybindingContrib),
        LifecyclePhase.Restored
      );
      wR.register(
        "keybinding.study",
        () => Promise.resolve(StudyKeybindingContrib),
        LifecyclePhase.Restored
      );
      wR.register(
        "keybinding.timeScale",
        () => Promise.resolve(TimeScaleKeybindingContrib),
        LifecyclePhase.Restored
      );
      wR.register(
        "keybinding.undoRedo",
        () => Promise.resolve(UndoRedoKeybindingContrib),
        LifecyclePhase.Restored
      );
      wR.register(
        DrawingContribId,
        () => Promise.resolve(
          __vitePreload(() => import("./index-DMTsRJKV.js"), true ? __vite__mapDeps([3,4,2,1,5]) : void 0, import.meta.url).then((module2) => {
            return module2.DrawingContrib;
          })
        ),
        LifecyclePhase.Restored
      );
      wR.start(accessor);
      const cR = accessor.get(IChartContributionRegistry);
      const tradeService = accessor.get(ITradeService);
      if (tradeService.isTradeEnabled()) {
        cR.register(
          "tradeLine",
          () => Promise.resolve(
            __vitePreload(() => import("./index-Dzc6L2mL.js"), true ? __vite__mapDeps([6,4,2,7,5,8,9,10,11]) : void 0, import.meta.url).then((module2) => module2.TradeLineContrib)
          ),
          ChartContributionInstantiation.Eager
        );
      }
      cR.register(
        "scrollToRealTime",
        () => Promise.resolve(
          __vitePreload(() => import("./index-_tjyXy7U.js"), true ? [] : void 0, import.meta.url).then(
            (module2) => module2.ScrollToRealTimeContrib
          )
        ),
        ChartContributionInstantiation.Eventually
      );
    });
  }
  async remove() {
    if (this.startupTask) {
      schedulerExports.unstable_cancelCallback(this.startupTask);
    }
    await this.workbench.teardown();
    this.host.remove();
    this.dispose();
  }
  headerReady() {
    return this.guiService.headerReady();
  }
  onChartReady(callback) {
    this.instantiationService.invokeFunction(async (accessor) => {
      const chartManagementService = accessor.get(IChartManagementService);
      chartManagementService.whenRestored.then(callback);
    });
  }
  createButton(options) {
    return this.guiService.createButton(options);
  }
  applyOverrides(overrides) {
    this.configurationService.applyOverrides(overrides);
  }
  applyStudiesOverrides(overrides) {
    this.configurationService.applyStudiesOverrides(overrides);
  }
  getTheme() {
    return this.instantiationService.invokeFunction((accessor) => {
      const themeService = accessor.get(IThemeService);
      return themeService.getColorTheme().type;
    });
  }
  async changeTheme(themeName) {
    return this.instantiationService.invokeFunction((accessor) => {
      const themeService = accessor.get(IThemeService);
      return themeService.setTheme(themeName);
    });
  }
  defineTheme(themeName, themeData) {
    return this.instantiationService.invokeFunction((accessor) => {
      const themeService = accessor.get(IThemeService);
      return themeService.defineTheme(themeName, themeData);
    });
  }
  activeChart() {
    return this.instantiationService.invokeFunction((accessor) => {
      const chartManagementService = accessor.get(IChartManagementService);
      return chartManagementService.activeChart();
    });
  }
  resetCache() {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  save(options) {
    return this.instantiationService.invokeFunction((accessor) => {
      const storeService = accessor.get(IStoreService);
      const configService = accessor.get(IConfigurationService);
      const chartsService = accessor.get(IChartManagementService);
      const ret = {
        id: generateUuid(),
        createdAt: (/* @__PURE__ */ new Date()).getTime(),
        stores: storeService.save(),
        configs: configService.save(),
        charts: chartsService.save()
      };
      return ret;
    });
  }
  getTradeApi() {
    if (!this.tradeApi) {
      this._register(this.tradeApi = this.instantiationService.createInstance(TradeApi));
    }
    return this.tradeApi;
  }
  getChartApi() {
    return this.instantiationService.invokeFunction((accessor) => {
      return accessor.get(IChartManagementService);
    });
  }
};
const Widget2 = Widget$1;
var Side = /* @__PURE__ */ ((Side2) => {
  Side2[Side2["Buy"] = 1] = "Buy";
  Side2[Side2["Sell"] = -1] = "Sell";
  return Side2;
})(Side || {});
var OrderType = /* @__PURE__ */ ((OrderType2) => {
  OrderType2[OrderType2["Limit"] = 1] = "Limit";
  OrderType2[OrderType2["Market"] = 2] = "Market";
  OrderType2[OrderType2["Stop"] = 3] = "Stop";
  OrderType2[OrderType2["StopLimit"] = 4] = "StopLimit";
  return OrderType2;
})(OrderType || {});
var OrderStatus = /* @__PURE__ */ ((OrderStatus2) => {
  OrderStatus2[OrderStatus2["Canceled"] = 1] = "Canceled";
  OrderStatus2[OrderStatus2["Filled"] = 2] = "Filled";
  OrderStatus2[OrderStatus2["Inactive"] = 3] = "Inactive";
  OrderStatus2[OrderStatus2["Placing"] = 4] = "Placing";
  OrderStatus2[OrderStatus2["Rejected"] = 5] = "Rejected";
  OrderStatus2[OrderStatus2["Working"] = 6] = "Working";
  return OrderStatus2;
})(OrderStatus || {});
var ParentType = /* @__PURE__ */ ((ParentType2) => {
  ParentType2[ParentType2["Order"] = 1] = "Order";
  ParentType2[ParentType2["Position"] = 2] = "Position";
  return ParentType2;
})(ParentType || {});
function isBracketOrder(order) {
  return !!order.parentId;
}
function isTakeProfitOrder(order) {
  return order.parentId && order.type === 1;
}
class Broker {
  constructor(host) {
    __publicField(this, "_orders", []);
    __publicField(this, "_positions", []);
    __publicField(this, "_executions", []);
    this.host = host;
  }
  async orders() {
    return this._orders;
  }
  async positions() {
    return this._positions;
  }
  async executions() {
    return this._executions;
  }
  async cancelOrder(orderId) {
    const order = ensure(this._orders.find((o2) => o2.id === orderId));
    order.status = OrderStatus.Canceled;
    const bracketOrders = this._orders.filter((o2) => o2.parentId === orderId);
    bracketOrders.forEach((o2) => {
      if (o2.status !== OrderStatus.Canceled) {
        o2.status = OrderStatus.Canceled;
        this.host.orderUpdate(o2);
      }
    });
    this.host.orderUpdate(order);
  }
  async modifyOrder(order) {
    const prev = ensure(this._orders.find((o2) => o2.id === order.id));
    if (order.price === prev.price) order.qty += 1;
    this.host.orderUpdate(order);
  }
  async closePosition(positionId, amount) {
    alert("close position: " + positionId);
    return NOTIMPLEMENTED(positionId, amount);
  }
  async placeOrder(preOrder) {
    const orderId = generateUuid();
    const newOrder = {
      id: orderId,
      qty: preOrder.qty,
      side: preOrder.side,
      status: OrderStatus.Working,
      symbol: preOrder.symbol,
      type: preOrder.type,
      price: preOrder.price,
      leverage: 50,
      parentType: preOrder.parentType,
      parentId: preOrder.parentId,
      takeProfitPrice: preOrder.price + 10,
      takeProfitPnl: "+100",
      stopLossPrice: preOrder.price - 10,
      stopLossPnl: "-100"
    };
    this._orders.push(newOrder);
    setTimeout(() => {
      if (!isBracketOrder(newOrder) && newOrder.status !== OrderStatus.Canceled && newOrder.price) {
        const newPosition = {
          id: generateUuid(),
          symbol: preOrder.symbol,
          qty: preOrder.qty,
          side: preOrder.side,
          avgPrice: newOrder.price,
          leverage: 50,
          pnlText: "100USD",
          pnl: 100
        };
        this._positions.push(newPosition);
        this.host.positionUpdate(newPosition);
        newOrder.status = OrderStatus.Filled;
        const bracketOrders = this._orders.filter((o2) => o2.parentId === orderId);
        bracketOrders.forEach((o2) => {
          if (o2.status !== OrderStatus.Canceled) {
            o2.status = OrderStatus.Canceled;
            this.host.orderUpdate(o2);
          }
        });
        this.host.orderUpdate(newOrder);
        const newExection = {
          time: Math.floor(Date.now() / 1e3),
          symbol: preOrder.symbol,
          qty: preOrder.qty,
          side: preOrder.side,
          price: newOrder.price
        };
        this._executions.push(newExection);
        this.host.executionUpdate(newExection);
        const tp = {
          id: generateUuid(),
          qty: preOrder.qty,
          side: Side.Buy,
          status: OrderStatus.Working,
          symbol: preOrder.symbol,
          type: OrderType.Limit,
          price: preOrder.price + 200,
          leverage: 50,
          parentType: ParentType.Position,
          parentId: newPosition.id
        };
        this._orders.push(tp);
        this.host.orderUpdate(tp);
        const sl = {
          id: generateUuid(),
          qty: preOrder.qty,
          side: Side.Sell,
          status: OrderStatus.Working,
          symbol: preOrder.symbol,
          type: OrderType.Stop,
          price: preOrder.price - 200,
          leverage: 50,
          parentType: ParentType.Position,
          parentId: newPosition.id
        };
        this._orders.push(sl);
        this.host.orderUpdate(sl);
      }
    }, 2e6);
    this.host.orderUpdate(newOrder);
    return { orderId };
  }
}
const TIMES_TAMP = 60 * 1e3;
const BASE_URL$1 = "https://api.itick.org";
class Request {
  constructor(token) {
    __publicField(this, "token");
    __publicField(this, "resolutionsMap", {
      1: TIMES_TAMP,
      2: 5 * TIMES_TAMP,
      3: 10 * TIMES_TAMP,
      4: 30 * TIMES_TAMP,
      5: 60 * TIMES_TAMP,
      6: 120 * TIMES_TAMP,
      7: 240 * TIMES_TAMP,
      8: 24 * 60 * TIMES_TAMP,
      9: 7 * 24 * 60 * TIMES_TAMP,
      10: 30 * 24 * 60 * TIMES_TAMP
    });
    this.token = token;
  }
  getKline(params) {
    return new Promise((resolve, reject) => {
      const { symbolType, region, symbol, resolution, et: et2, limit } = params;
      fetch(
        `${BASE_URL$1}/${symbolType}/kline?region=${region}&code=${symbol}&kType=${resolution}&et=${et2}&limit=${limit}`,
        { headers: { token: this.token } }
      ).then((res) => res.json()).then((res) => {
        const { code, data } = res;
        const bars = [];
        const meta = { noData: code !== 0 };
        for (const { t: t2, c: c2, o: o2, h: h2, l: l2, v: v2 } of data)
          bars.push({ time: t2, close: c2, open: o2, high: h2, low: l2, volume: v2 });
        resolve({ bars, meta });
      }).catch((err) => reject(err));
    });
  }
  getSymbolList(params) {
    let url = `${BASE_URL$1}/symbol/list?`;
    for (const val in params) url += `${val}=${params[val]}&`;
    url = url.slice(0, -1);
    return new Promise((resolve, reject) => {
      fetch(url, { headers: { token: this.token } }).then((res) => res.json()).then((res) => {
        const { code, data } = res;
        if (code === 200) resolve(data);
        else reject("查询失败");
      });
    });
  }
  getSymbolInfo(symbolName) {
    const [exchange, symbol] = symbolName.split(":");
    return new Promise((resolve, reject) => {
      fetch(
        `${BASE_URL$1}/symbol/info?code=${symbol}&exchange=${exchange === "BINANCE" ? "Binance" : exchange}`,
        { headers: { token: this.token } }
      ).then((res) => res.json()).then((res) => {
        const { code, msg, data } = res;
        if (code === 200 || msg === "ok") resolve(data);
        else reject("查询失败");
      });
    });
  }
}
const TYPE_MAP = {
  crypto: "cws",
  stock: "sws",
  forex: "fws",
  indices: "iws"
};
const BASE_URL = "wss://api.itick.org";
const _SingletonSocket = class _SingletonSocket {
  //上一根K线
  constructor(token) {
    __publicField(this, "token", "");
    __publicField(this, "resolution", "1");
    __publicField(this, "socket", null);
    __publicField(this, "type", "");
    __publicField(this, "symbol", "");
    __publicField(this, "region", "");
    __publicField(this, "reconnectMaxTimes", 10);
    //最大重连次数
    __publicField(this, "reconnectInterval", 5e3);
    // 5秒重连间隔
    __publicField(this, "heartbeatInterval", 3e4);
    // 30秒心跳间隔
    __publicField(this, "reconnectTimes", 0);
    // 重连次数
    __publicField(this, "heartbeatTimer", null);
    __publicField(this, "onmessage", null);
    __publicField(this, "dataMap", /* @__PURE__ */ new Map());
    __publicField(this, "lastBar", null);
    this.token = token;
  }
  static getInstance(token) {
    if (!_SingletonSocket.instance) {
      _SingletonSocket.instance = new _SingletonSocket(token);
    }
    return _SingletonSocket.instance;
  }
  // 连接
  connect(type, symbol, region, resolution, lastBar) {
    this.resolution = resolution;
    this.region = region;
    this.lastBar = lastBar;
    this.dataMap.clear();
    const flag = ["1", "5", "10", "30"].includes(resolution);
    if (!flag) {
      if (this.socket && this.socket.readyState === WebSocket.OPEN) this.close();
      return;
    }
    if (this.symbol === symbol && this.socket && this.socket.readyState === WebSocket.OPEN) return;
    if (this.socket && this.socket.readyState === WebSocket.OPEN) this.close();
    this.socket = new WebSocket(`${BASE_URL}/${TYPE_MAP[type]}`);
    this.symbol = symbol;
    this.type = type;
    this.reconnectTimes = 0;
    this.socket.onopen = () => {
      console.log("WebSocket 连接成功", symbol);
      this.send({ ac: "auth", params: this.token });
      this.startHeartbeat();
    };
    this.socket.onmessage = (event2) => {
      try {
        const data = JSON.parse(event2.data);
        this.handleMessage(data);
      } catch (error) {
        console.log("消息解析错误:", error);
      }
    };
    this.socket.onclose = (event2) => {
      if (event2.code === 1e3) return;
      console.log("WebSocket 连接异常关闭 将尝试重新连接:", event2.code);
      this.reconnect();
    };
    this.socket.onerror = (error) => {
      console.error("WebSocket 连接发生错误:", error);
    };
  }
  // 设置心跳
  startHeartbeat() {
    this.heartbeatTimer = setInterval(() => {
      if (this.socket && this.socket.readyState === WebSocket.OPEN) {
        this.send({ ac: "ping", params: Date.now() });
      }
    }, this.heartbeatInterval);
  }
  // 停止心跳
  stopHeartbeat() {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
  }
  // 重连
  reconnect() {
    this.stopHeartbeat();
    this.reconnectTimes++;
    if (this.reconnectTimes > this.reconnectMaxTimes) return;
    const timeOut = setTimeout(() => {
      console.log("重新连接中...");
      this.connect(this.type, this.symbol, this.region, this.resolution, this.lastBar);
      clearTimeout(timeOut);
    }, this.reconnectInterval);
  }
  handleSymbolName() {
    return this.symbol;
  }
  // 获取上一根K线时间戳
  getPreviousNearestFiveOrTenMinutesTimestamp(timestamp, resolution) {
    const now2 = new Date(timestamp);
    if (resolution === "1") {
      now2.setSeconds(0, 0);
      return now2.getTime();
    }
    const minutes = now2.getMinutes();
    const resolutionInMinutes = parseInt(resolution);
    const targetMinutes = Math.floor(minutes / resolutionInMinutes) * resolutionInMinutes;
    const targetTime = new Date(now2);
    targetTime.setMinutes(targetMinutes);
    targetTime.setSeconds(0);
    targetTime.setMilliseconds(0);
    return targetTime.getTime();
  }
  // 处理消息
  handleMessage(res) {
    var _a3, _b3;
    const { code, data, resAc } = res;
    if (code === 1 && resAc === "auth") {
      this.send({ ac: "subscribe", params: this.handleSymbolName(), types: "tick" });
      return;
    }
    if (code === 1 && data) {
      const { t: t2, ld, v: v2 } = data;
      const time = this.getPreviousNearestFiveOrTenMinutesTimestamp(t2, this.resolution);
      const lastData = this.dataMap.get(time) || (((_a3 = this.lastBar) == null ? void 0 : _a3.time) === time ? this.lastBar : void 0);
      if (lastData) {
        this.dataMap.set(time, {
          time,
          close: ld,
          open: lastData.open,
          high: ld > lastData.high ? ld : lastData.high,
          low: ld < lastData.low ? ld : lastData.low,
          volume: v2 + lastData.volume
        });
      } else {
        this.dataMap.clear();
        this.dataMap.set(time, {
          time,
          close: ld,
          open: ld,
          high: ld,
          low: ld,
          volume: v2
        });
      }
      (_b3 = this.onmessage) == null ? void 0 : _b3.call(this, this.dataMap.get(time));
    }
  }
  // 发送消息
  send(params) {
    var _a3;
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      this.socket.send(JSON.stringify(params));
    } else {
      console.log("WebSocket 未连接成功， 状态码:", (_a3 = this.socket) == null ? void 0 : _a3.readyState);
    }
  }
  // 监听消息
  onMessage(callback) {
    this.onmessage = callback;
  }
  // 关闭连接
  close() {
    if (this.socket) {
      this.socket.close();
      this.stopHeartbeat();
    }
  }
};
__publicField(_SingletonSocket, "instance", null);
let SingletonSocket = _SingletonSocket;
class Datafeed {
  constructor(token) {
    __publicField(this, "token", "");
    __publicField(this, "symbolInfo", {});
    __publicField(this, "configuration");
    __publicField(this, "request");
    __publicField(this, "lastBar");
    __publicField(this, "subscription", /* @__PURE__ */ new Map());
    this.token = token;
    this.request = new Request(token);
    this.configuration = this.defaultConfiguration();
  }
  onReady(callback) {
    setTimeout(() => {
      callback(this.configuration);
    }, 0);
  }
  // 搜索产品
  async searchSymbols(userInput, exchange, symbolType, onResult) {
    const [type, region] = symbolType.split("_");
    const params = {
      ...userInput ? { code: userInput } : {},
      ...type ? { type } : {},
      ...region ? { region } : {}
    };
    const data = await this.request.getSymbolList(params);
    const res = data.slice(0, 50);
    const result = [];
    for (const item of res) {
      result.push({
        symbol: item.c,
        exchange: item.e,
        description: item.n,
        type: item.t,
        ticker: `${item.e}:${item.c}`
      });
    }
    onResult(result);
  }
  // 获取产品信息
  async resolveSymbol(symbolName, onResolve, onError, token) {
    const [exchange] = symbolName.split(":");
    if (this.symbolInfo[symbolName]) {
      const timer = setTimeout(() => {
        onResolve(this.symbolInfo[symbolName]);
        clearTimeout(timer);
      }, 0);
      return;
    }
    const result = await this.request.getSymbolInfo(symbolName);
    if (token == null ? void 0 : token.isCancellationRequested) {
      return;
    }
    if (!result) {
      onError("查找不到产品");
      return;
    }
    const data = {
      name: result.n,
      region: result.r,
      timezone: result.tz,
      exchange: result.e,
      type: result.t,
      subsessions: result.sb,
      session: result.sb.find((v2) => v2.id === result.si).session,
      minmov: result.m,
      subsession_id: result.si,
      description: result.b ?? result.d,
      format: "price",
      visible_plots_set: "ohlcv",
      variable_tick_size: "",
      listed_exchange: exchange,
      pricescale: 100,
      full_name: symbolName,
      pro_name: symbolName,
      base_name: [symbolName],
      ticker: symbolName,
      supported_resolutions: this.configuration.supported_resolutions,
      has_daily: true,
      has_intraday: true,
      daily_multipliers: ["1"],
      has_weekly_and_monthly: true,
      weekly_multipliers: ["1"],
      monthly_multipliers: ["1", "12"],
      intraday_multipliers: ["1", "5", "10", "30", "60"],
      data_status: "streaming"
    };
    this.symbolInfo[symbolName] = data;
    onResolve(data);
  }
  // 获取K线数据
  async getBars(symbolInfo, resolution, periodParams, onResult, token) {
    const { name, type, region } = symbolInfo;
    const { countBack, firstDataRequest, to } = periodParams;
    try {
      const params = {
        symbolType: type,
        region: this.getSymbolRegion(type, region),
        symbol: name,
        et: to * 1e3,
        limit: countBack,
        resolution: this.getResolution(resolution)
      };
      const data = await this.request.getKline(params);
      if (token == null ? void 0 : token.isCancellationRequested) {
        return;
      }
      if (firstDataRequest) this.lastBar = data.bars[data.bars.length - 1];
      onResult(data.bars, data.meta);
    } catch (err) {
      console.error(err);
      if (token == null ? void 0 : token.isCancellationRequested) {
        return;
      }
      onResult([], { noData: true });
    }
  }
  getSymbolRegion(type, region) {
    if (type === "crypto") return "BA";
    if (type === "stock") return region || "";
    return "gb";
  }
  getResolution(resolutions) {
    const resolutionsMap = {
      1: 1,
      5: 2,
      10: 3,
      30: 4,
      60: 5,
      120: 6,
      240: 7,
      "1D": 8,
      "1W": 9,
      "1M": 10
    };
    return resolutionsMap[resolutions];
  }
  unsubscribeBars(listenerGuid) {
    const socket = this.subscription.get(listenerGuid);
    if (!socket) return;
    socket.onMessage(() => {
    });
    this.subscription.delete(listenerGuid);
  }
  subscribeBars(symbolInfo, resolution, onRealtimeCallback, listenerGuid) {
    const { region, type, name } = symbolInfo;
    const socket = SingletonSocket.getInstance(this.token);
    socket.connect(type, name, region, resolution, this.lastBar);
    socket.onMessage((data) => {
      if (data) {
        onRealtimeCallback(data);
      }
    });
    this.subscription.set(listenerGuid, socket);
  }
  /**
   * 默认参数
   * @returns
   */
  defaultConfiguration() {
    return {
      supported_resolutions: ["1", "5", "10", "30", "60", "1D", "1W", "1M"],
      supports_marks: false,
      supports_timescale_marks: false,
      supports_time: false,
      symbols_types: [
        { name: "全部", value: "" },
        { name: "加密货币", value: "crypto" },
        { name: "SH股", value: "stock_sh" },
        { name: "SZ股", value: "stock_sz" },
        { name: "港股", value: "stock_hk" },
        { name: "SG股", value: "stock_sg" },
        { name: "美股", value: "stock_us" },
        { name: "日股", value: "stock_jp" },
        { name: "外汇", value: "forex" },
        { name: "指数", value: "indices" }
      ]
    };
  }
}
const instances = [];
const start = () => {
  const div = document.createElement("div");
  document.body.appendChild(div);
  const config2 = {
    container: div,
    interval: "5",
    symbol: "BINANCE:BTCUSDT",
    datafeed: new Datafeed("a5ca43babf5e49c4b734bdcb6f51a4a4465d52bd3fbe48e1847ac9259ae290c8"),
    locale: "en-US",
    theme: "light",
    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    // 时区
    brokerFactory: (host) => new Broker(host),
    brokerConfig: {
      customUI: {
        async showOrderDialog() {
          await showDialog("Order dialog");
          return true;
        },
        async showCancelOrderDialog() {
          await showDialog("Cancel order dialog");
          return true;
        },
        async showClosePositionDialog() {
          await showDialog("Close position dialog");
          return true;
        },
        async showPositionDialog() {
          await showDialog("Position dialog");
          return true;
        }
      }
    }
  };
  const widget = new Widget2(config2);
  instances.push(widget);
};
Reflect.set(window, "start", start);
Reflect.set(window, "ww", instances);
Reflect.set(window, "oo", async () => {
  const apis = [];
  instances.forEach(async (widget) => {
    const api = await widget.getTradeApi().preOrder();
    api.onDone(() => {
      apis.forEach((api2) => api2.dispose());
    });
    api.onChange((e2) => {
      apis.forEach((a2) => {
        if (a2 !== api) {
          a2.updateProps({ price: e2.price });
        }
      });
    });
    apis.push(api);
  });
});
start();
function showDialog(content) {
  const promise = new DeferredPromise$1();
  const dialog = document.createElement("dialog");
  const p2 = document.createElement("p");
  p2.append(document.createTextNode(content));
  dialog.append(p2);
  const desc = document.createElement("p");
  desc.append(document.createTextNode("对话框由图表使用方实现，由图表调起"));
  dialog.append(desc);
  document.body.append(dialog);
  dialog.showModal();
  dialog.addEventListener("click", () => {
    dialog.close();
    promise.complete();
  });
  return promise.p;
}
export {
  Menu as $,
  AnchorPoint as A,
  BitmapCoordinatesPaneRenderer as B,
  CopyDrawingCommand as C,
  DrawingFragmentBrand as D,
  ExitDrawingCommand as E,
  FileNameKey as F,
  PaneCursor as G,
  HorizontalLineRenderer as H,
  ImageToolType as I,
  AnchorResizeVert as J,
  KeybindingWeight as K,
  LineStyleType as L,
  AreaName as M,
  clamp as N,
  NOTREACHED as O,
  PreOrderToolType as P,
  OrderType as Q,
  RemoveDrawingCommand as R,
  Side as S,
  TriggerSource as T,
  append_styles$1 as U,
  useTranslation as V,
  useService as W,
  proxy$1 as X,
  from_html as Y,
  bind_this as Z,
  __vitePreload as _,
  isFiniteNumber as a,
  ToolInvocationPhase as a$,
  template_effect as a0,
  append as a1,
  pop as a2,
  push as a3,
  toPX as a4,
  tick as a5,
  child as a6,
  set_style as a7,
  ITradeService as a8,
  List as a9,
  delegate as aA,
  PartFingerprint as aB,
  isNil as aC,
  merge as aD,
  isAnchorDetails as aE,
  isUndefinedOrNull as aF,
  InputEventType as aG,
  getXCoordinate as aH,
  omit as aI,
  FocusEventSource as aJ,
  IThemeService as aK,
  LineAnchorRenderer as aL,
  EmojiToolType as aM,
  IconToolType as aN,
  MeasureToolType as aO,
  ArrowMarkDownToolType as aP,
  ArrowMarkUpToolType as aQ,
  HorizontalLineToolType as aR,
  VerticalLineToolType as aS,
  LongPositionToolType as aT,
  ShortPositionToolType as aU,
  FlagMarkToolType as aV,
  PinToolType as aW,
  PinFixedToolType as aX,
  TextToolType as aY,
  AnchoredTextToolType as aZ,
  generateUuid as a_,
  first_child as aa,
  if_block as ab,
  sibling as ac,
  ParentType as ad,
  Item as ae,
  set_text as af,
  get$1 as ag,
  user_derived as ah,
  ifLeftClick as ai,
  OrderStatus as aj,
  isBracketOrder as ak,
  isTakeProfitOrder as al,
  memoize$1 as am,
  IChartService as an,
  IChartGuiService as ao,
  IIntlService as ap,
  IConfigurationService as aq,
  PartFingerprints as ar,
  useDisposable as as,
  Wrapper as at,
  action as au,
  Tooltip as av,
  TooltipContent as aw,
  clsx as ax,
  clsx$1 as ay,
  set_class as az,
  IChartManagementService as b,
  SelectionRenderer as b$,
  CallbackHitTestObject as b0,
  rt as b1,
  drawRoundRect as b2,
  setLineStyle as b3,
  pointInPolygon as b4,
  isEqual as b5,
  NOTIMPLEMENTED as b6,
  isString$1 as b7,
  upperbound as b8,
  isMacintosh as b9,
  HidePositionsAndOrdersBit as bA,
  writable as bB,
  useIdlePriority as bC,
  onDestroy as bD,
  event as bE,
  Dialog as bF,
  DialogTitle as bG,
  Content as bH,
  DialogFooter as bI,
  MediaCoordinatesPaneRenderer as bJ,
  DeferredPromise$1 as bK,
  AnchorStyle as bL,
  generateColor as bM,
  LineEnd as bN,
  addExclusionAreaByScope as bO,
  addPixelPerfectLineToPath as bP,
  interactionTolerance as bQ,
  distanceToSegment as bR,
  arePointsEqual as bS,
  intersectLineAndBox as bT,
  lineThroughPoints as bU,
  intersectRayAndBox as bV,
  lineSegment as bW,
  intersectLineSegmentAndBox as bX,
  euclideanDistanceBetweenPoints as bY,
  fillRectWithBorder as bZ,
  midPoint as b_,
  teardown as ba,
  IGuiService as bb,
  DeferredPromise2 as bc,
  AsyncSvgIcon as bd,
  set as be,
  state as bf,
  Scheduler as bg,
  Portal as bh,
  comment as bi,
  snippet as bj,
  useNormalPriority as bk,
  set_attribute as bl,
  each as bm,
  index as bn,
  html as bo,
  derived as bp,
  setup_stores as bq,
  store_get as br,
  init as bs,
  MagnetMode as bt,
  derived_safe_equal as bu,
  IStoreService as bv,
  getKeybindingLabel as bw,
  spread_props as bx,
  HideDrawingsBit as by,
  HideIndicatorsBit as bz,
  cloneDeep as c,
  isFunction$1 as c0,
  size as c1,
  onMount as c2,
  rest_props as c3,
  StandardKeyboardEvent as c4,
  getLightenRGBA as c5,
  isObjectLike as c6,
  baseGetTag as c7,
  isInteger as c8,
  isEven as c9,
  drawLine as cA,
  isSeriesData as cB,
  AnchorResizeAll as cC,
  ceiledEven as ca,
  last$1 as cb,
  pointInCircle as cc,
  dpr1PixelRatioInfo as cd,
  distanceToLine as ce,
  intersectLines as cf,
  CanvasRenderingTarget2D as cg,
  clipPolygonByEdge as ch,
  createLine as ci,
  halfplaneThroughPoint as cj,
  intersectPolygonAndHalfplane as ck,
  drawPixelPerfectLine as cl,
  computeDashPattern as cm,
  resetTransparency as cn,
  drawVerticalLine as co,
  sign as cp,
  vi as cq,
  drawHorizontalLine as cr,
  AnchorResizeHorz as cs,
  intersectLineSegments as ct,
  ye as cu,
  z as cv,
  Te as cw,
  Tt as cx,
  TwoPI as cy,
  createCircle as cz,
  Disposable as d,
  ensure as e,
  KeyCode as f,
  get as g,
  KeyMod as h,
  isValidPosition as i,
  CloneDrawingCommand as j,
  PasteImageToolType as k,
  IInstantiationService as l,
  IToolService as m,
  IClipboardService as n,
  IKeybindingsRegistry as o,
  ICommandService as p,
  IToolRegistry as q,
  ChartFontFamily as r,
  should as s,
  toString as t,
  Point as u,
  pointInBox$1 as v,
  box as w,
  drawRoundRectWithBorder as x,
  HitTestResult as y,
  HitTarget as z
};
