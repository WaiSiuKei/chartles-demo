var t=Object.defineProperty,e=(e,i,s)=>((e,i,s)=>i in e?t(e,i,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[i]=s)(e,"symbol"!=typeof i?i+"":i,s);import{T as i,a as s,A as r,c as o,D as n}from"./toolPaneView-BkZhzbTB.js";import{af as l}from"./index-iNH1zFVl.js";import{B as a,y as h,z as c,co as d,e as u,bK as _,cp as p,cq as b,bH as f,L as g,A as m}from"./index-5gyre0hA.js";import{P as w,T as M}from"./axisPaneView-B6qY_qE1.js";import{C as x}from"./composite-CCMtJLBO.js";import{L as P}from"./line-BKuOqRrm.js";import"./baseTool-BM5mqL4_.js";class C extends a{constructor(){super(...arguments),e(this,"_bars",[])}hitTest(t){const e=this._bars;if(0===e.length)return null;const i=this._getTolerance(),s=e[0],r=e[e.length-1];if(t.x<s.left-i||t.x>r.right+i)return null;let o=0,n=e.length-1,l=-1;for(;o<=n;){const i=Math.floor((o+n)/2),s=e[i];if(t.x>=s.left&&t.x<=s.right){l=i;break}t.x>s.right?o=i+1:n=i-1}if(-1===l)return null;if(this._isPointAtBar(e[l],t.y,i))return this._getHitTest();let a=l;for(;a>=1&&t.x-e[a-1].right<i;)a--;let h=l;for(;h<=e.length-2&&e[h+1].left-t.x<i;)h++;for(let c=a;c<=h;c++)if(c!==l&&this._isPointAtBar(e[c],t.y,i))return this._getHitTest();return null}_getHitTest(){return new h(c.Regular)}_isPointAtBar(t,e,i){const s=Math.min(t.high,t.low),r=Math.max(t.high,t.low);return s-i<=e&&e<=r+i}}class V extends C{constructor(){super(...arguments),e(this,"_scaleCoeff",1),e(this,"_borderVisible",!1),e(this,"_wickVisible",!1),e(this,"_bodyVisible",!0),e(this,"_borderColor"),e(this,"_wickColor"),e(this,"_isPriceScaleInverted",!1)}setData(t){super.setData(t),this._bars=t.bars,this._scaleCoeff=t.scaleCoeff??1,this._borderVisible=t.borderVisible,this._bodyVisible=t.bodyVisible,this._wickVisible=t.wickVisible,this._borderColor=t.borderColor,this._wickColor=t.wickColor,this._hitTest=t.hittest,this._isPriceScaleInverted=t.isPriceScaleInverted}hitTest(t){return this._wickVisible||this._borderVisible||this._bodyVisible?super.hitTest(t):null}drawImpl(t){var e;const{context:i,horizontalPixelRatio:s,verticalPixelRatio:r}=t;if(!this._data)return;if(0===(null==(e=this._bars)?void 0:e.length))return;const o=function(t,e,i,s){const r=Math.floor(e);return t.map((t=>{let o=b((t.right-t.left)*s,e);o>=2&&r%2!=o%2&&o--;const n=Math.floor(.5*o),l=function(t,e){let i=Math.floor(1*e);t<=2*i&&(i=Math.floor(.5*(t-1)));const s=Math.max(Math.floor(e),i);return t<=2*s?Math.max(Math.floor(e),Math.floor(1*e)):s}(o,e),a=Math.round(t.center*e),h=a-n,c=h+o-1,d=Math.abs(Math.max(t.open,t.close)-Math.min(t.open,t.close))*i,u=Math.round(Math.min(t.open,t.close)*i),_=Math.round(Math.max(t.open,t.close)*i);let p=Math.min(Math.floor(e),Math.floor(o*e));p=Math.max(Math.floor(e),Math.min(p,o));const f=Math.floor(.5*p);return{rawBodyHeight:d,top:u,bottom:_,center:a,left:h,right:c,candleWidth:o,high:Math.round(t.high*i),low:Math.round(t.low*i),wickWidth:p,wickOffset:f,borderWidth:l}}))}(this._bars,s,r,this._scaleCoeff);this._wickVisible&&this._drawWicks(i,o),this._borderVisible&&this._drawBorder(i,o),this._bodyVisible&&this._drawCandles(i,o)}_calcBarWidth(t){const e=Math.floor(t);return Math.max(e,Math.floor(d(u(this._data).barSpacing,t)))}_getTolerance(){return _().series}_getHitTest(){return this._hitTest||new h(c.Regular)}_isPointAtBar(t,e,i){const s=this._bodyVisible||this._borderVisible,r=this._wickVisible;if(!s&&!r)return!1;if(s){const s=r?Math.min(t.high,t.low):Math.min(t.open,t.close),o=r?Math.max(t.high,t.low):Math.max(t.open,t.close);return s-i<=e&&e<=o+i}{const s=Math.min(t.open,t.close),r=Math.max(t.open,t.close);return t.high-i<=e&&e<=s+i||r-i<=e&&e<=t.low+i}}_drawWicks(t,e){let i="",s=null;this._bars.forEach(((r,o)=>{const n=r.wickColor??u(this._wickColor);n!==i&&(t.fillStyle=n,i=n);let{top:l,bottom:a}=e[o];const{rawBodyHeight:h,borderWidth:c,center:d,high:_,low:p,wickWidth:b,wickOffset:f}=e[o];this._isPriceScaleInverted&&([l,a]=[a,l]);let g=d-f;const m=g+b-1;null!==s&&(g=Math.max(s+1,g),g=Math.min(g,m));const w=m-g+1;h<=c&&(l!==_&&(l=Math.round(l-.5*c)),a=a!==p?Math.round(l-.5*c)+c-1:p-1),l!==_&&t.fillRect(g,_,w,l-_),p-a-1&&t.fillRect(g,a+1,w,p-a-1),s=m}))}_drawBorder(t,e){let i="",s=null;this._bars.forEach(((r,o)=>{const n=r.borderColor??u(this._borderColor);if(n!==i&&(t.fillStyle=n,i=n),this._bodyVisible&&r.hollow)return;let{left:l}=e[o];const{rawBodyHeight:a,top:h,bottom:c,right:d,borderWidth:_}=e[o];null!==s&&(l=Math.max(s+1,l),l=Math.min(l,d));const b=d-l+1;a<=_?t.fillRect(l,Math.round(h-.5*_),b,_):b>2*_?p(t,l,h,b,c-h+1,_):t.fillRect(l,h,b,c-h+1),s=d}))}_drawCandles(t,e){let i="";this._bars.forEach(((s,r)=>{let{top:o,bottom:n,left:l,right:a}=e[r];const{rawBodyHeight:h,borderWidth:c,candleWidth:d}=e[r],u=a-l+1;if(!(this._borderVisible&&d<=2*c)||s.hollow)if(s.color!==i&&(t.fillStyle=s.color,i=s.color),s.hollow)t.fillStyle=s.color,h<=c?t.fillRect(l,Math.round(o-.5*c),d,c):p(t,l,o,u,n-o+1,c);else if(!this._borderVisible&&h<=c)t.fillRect(l,Math.round(o-.5*c),d,c);else{if(this._borderVisible&&(l+=c,o+=c,a-=c,n-=c),o>n)return;t.fillRect(l,o,a-l+1,n-o+1)}}))}}class y extends i{constructor(){super(...arguments),e(this,"_renderer",new x(this._hitTestCollector))}renderer(){return this._renderer}_updateImpl(){this._renderer.clear();const t=this.points();if(!(null==t?void 0:t.length))return;const e=this._source.priceScale(),i=this._source.properties(),s=i.candleStyle,r=s.upColor,o=s.downColor,n=s.borderUpColor,l=s.borderDownColor,a=this._source.timeScale().barSpacing(),d=a,_=this._data.segments.map(((i,s)=>{if(s>=t.length-1)return null;let a=t[s],h=t[s+1],c=this._source.controlPoints[s],_=this._source.controlPoints[s+1],p=this._source.controlPoints[s].price,b=this._source.controlPoints[s+1].price,f=1;a.x>h.x&&([a,h]=[h,a],[p,b]=[b,p],[c,_]=[_,c],f=-1);const g=u(this._source.timeScale().timeToIndexEx(c.time)),m=u(e.priceToCoordinate(p)),w=u(e.priceToCoordinate(b)),M=i.bars(),x=M.length,P=(w-m)/(x-1),C=[];let V=f>0?0:x-1;const y=f>0?x:-1;for(let t=0;V!==y;V+=f,t++){const i=m+t*P,s=u(e.coordinateToPrice(i)),a=M[V],h=a.c>=a.o,c=u(this._source.timeScale().logicalToCoordinate(g+t));C.push({open:u(e.priceToCoordinate(s+a.o)),high:u(e.priceToCoordinate(s+a.h)),low:u(e.priceToCoordinate(s+a.l)),close:u(e.priceToCoordinate(s+a.c)),color:h?r:o,borderColor:h?n:l,hollow:!1,center:c,left:c-d/2,right:c+d/2,timePointIndex:g+t})}return{bars:C}})).filter((t=>null!==t));for(let u=1;u<this.points().length;u++){const t={points:[this.points()[u-1],this.points()[u]],lineColor:"#000",lineWidth:1,lineStyle:g.solid,extendLeft:!1,extendRight:!1,leftEnd:f.Normal,rightEnd:f.Normal},e=new P;e.setData(t),e.setHitTest(new h(c.MovePoint)),this._renderer.append(e)}const p=s.drawWick,b=s.drawBorder,m=s.borderColor,w=s.wickColor,M=1-i.transparency/100,C=new x;C.setGlobalAlpha(M);for(const u of _){const t=new V;t.setData({bars:u.bars,barSpacing:a,wickVisible:p,bodyVisible:!0,borderVisible:b,borderColor:m,wickColor:w,barWidth:d,hittest:new h(c.MovePoint),isPriceScaleInverted:!1}),C.append(t)}this._renderer.append(C),this.addAnchors(this._renderer)}}class T{constructor(t,e,i=[]){this._source=t,this._segmentIndex=e,this._bars=i}setBars(t){this._bars=t}generate(){this._bars=[];const t=this._source.controlPoints,e=t[this._segmentIndex],i=t[this._segmentIndex+1];if(!e)return;if(!i)return;const s=this._source.getIndex(e),r=this._source.getIndex(i);if(s===r)return;const o=this._segmentIndex?s+1:s,n=Math.sign(r-s);for(let l=o;l!==r;l+=n)this._bars.push(this._createBar())}bars(){return this._bars}setSize(t){if(t<this._bars.length)this._bars.splice(t,this._bars.length-t);else for(;this._bars.length<t;)this._bars.push(this._createBar())}_createBar(){const t=this._source.properties().averageHL,e=this._source.properties().variance/100,i=this._source.properties().base;let s=Math.random();const r=t*(1-2*s)*e;s=Math.random();const o=t*(1+(.5-s)*e),n=r-o/2,l=n+o;return{o:(n+Math.random()*o)/i,h:l/i,l:n/i,c:(n+Math.random()*o)/i}}}class S extends s{constructor(){super(...arguments),e(this,"_lines",new y(this,this.model)),e(this,"_paneView",[this._lines]),e(this,"_priceAxisPaneViews",[new w(Object.create(null))]),e(this,"_timeAxisPaneViews",[new M(Object.create(null))]),e(this,"_segments",[])}pointsCount(){return 1/0}addPoint(t,e){return super.addPoint(t,e),this.controlPoints.length>2&&this._generateBars(this.controlPoints.length-3),r.Accept}setPoint(t,e,i){if(super.setPoint(t,e,i),t>0){const e=this.getIndex(this.controlPoints[t])-this.getIndex(this.controlPoints[t-1]);this._segments[t-1].setSize(Math.abs(e))}if(t<this.controlPoints.length-1){const e=this.getIndex(this.controlPoints[t+1])-this.getIndex(this.controlPoints[t]);this._segments[t].setSize(Math.abs(e))}}_generateBars(t){this._segments.length<=t&&(this._segments.push(new T(this,t)),this._segments[t].generate())}abort(){return this.model.markCreatingFinishedOrAborted(this),this.controlPoints.pop(),this._props.points.length<2?o.Remove:o.None}updateAllViews(){if(!this.controlPoints.length)return;const t=[];for(let s=0;s<this.controlPoints.length;s++){const e=this.controlPoints[s],i=this.pointToScreenPoint(e);if(!i)return;t.push(new m(i,{pointIndex:s}))}const e=t.map((t=>t.x)),i=t.map((t=>t.y));e.length>1&&this._timeAxisPaneViews[0].update(this._calculateTimeAxisPaneViewsData(Math.min.apply(null,e),Math.max.apply(null,e))),i.length>1&&this._priceAxisPaneViews[0].update(this._calculatePriceAxisPaneViewData(Math.min.apply(null,i),Math.max.apply(null,i))),this._paneView[0].update({points:t,segments:this._segments})}}class k extends n{constructor(){super(...arguments),e(this,"type",l)}createPrimitive(t){const e=this._calculateATR(t),i=t.chartService.symbolInfo().pricescale;return new S({id:this.id,points:[],base:i,averageHL:e*i,variance:50,candleStyle:{upColor:"#ACE5DC",downColor:"#FAA1A4",drawWick:!0,drawBorder:!0,borderColor:"#378658",borderUpColor:"#089981",borderDownColor:"#F23645",wickColor:"#808080"},transparency:50},...this.resetArgs)}_calculateATR(t){const e=(i=t,i.chartService.mainSeriesApi.getSeries()).data();var i;const s=[];e.forEach((t=>{const{high:e,low:i}=t.customValues;s.push(e-i)}));return 0===s.length?0:s.reduce(((t,e)=>t+e),0)/s.length}onlyDrawingOnMainSeries(){return!0}}export{k as GhostFeedTool};
