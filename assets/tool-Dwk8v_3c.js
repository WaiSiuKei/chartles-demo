var t=Object.defineProperty,e=(e,n,i)=>((e,n,i)=>n in e?t(e,n,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[n]=i)(e,"symbol"!=typeof n?n+"":n,i);import{T as n,a as i,D as s}from"./toolPaneView-BkZhzbTB.js";import{ap as o}from"./index-iNH1zFVl.js";import{c8 as r,bH as a,L as l,u as c,A as h,e as p}from"./index-5gyre0hA.js";import{P as d,T as u}from"./axisPaneView-B6qY_qE1.js";import{t as m}from"./handle-C11jaV9I.js";import{C as P}from"./composite-CCMtJLBO.js";import{L as g}from"./line-BKuOqRrm.js";import{P as f}from"./polygon-D49cV0Ps.js";import"./baseTool-BM5mqL4_.js";class _ extends n{constructor(){super(...arguments),e(this,"_renderer",new P(this._hitTestCollector)),e(this,"_poligonRenderer",new f)}renderer(){return this._renderer}_updateImpl(){this._renderer.clear();const t=this.points();if(!(null==t?void 0:t.length))return;let e=0;3===t.length&&(e=r(t[0],t[1],t[2]).distance);const n=this._source.properties(),[i,s]=t,o=[];if(o.push(i),s&&o.push(s),2===t.length){const e={points:t,lineColor:n.color,lineWidth:1,lineStyle:l.solid,extendLeft:!1,extendRight:!1,leftEnd:a.Normal,rightEnd:a.Normal},i=new g;i.setData(e),this._renderer.append(i)}else if(3===t.length){const t=s.subtract(i),r=new c(t.y,-t.x).normalized().scaled(e),a=r.scaled(-1),p={points:[i.add(r),s.add(r),s.add(a),i.add(a)],lineColor:n.color,lineWidth:n.linewidth,lineStyle:l.solid,filled:n.fillBackground,background:n.backgroundColor,transparency:n.transparency};this._poligonRenderer.setData(p),this._renderer.append(this._poligonRenderer);const d=m(i,s);o.push(...p.points.map((t=>new h(t,{pointIndex:2,cursorType:d}))))}const p=this.createLineAnchor({points:o},0);this._renderer.append(p)}}class w extends i{constructor(){super(...arguments),e(this,"_lines",new _(this,this.model)),e(this,"_paneView",[this._lines]),e(this,"_priceAxisPaneViews",[new d(Object.create(null))]),e(this,"_timeAxisPaneViews",[new u(Object.create(null))]),e(this,"_distance",null)}pointsCount(){return 3}startChanging(t){if(super.startChanging(t),0===t||1===t){const t=p(this.pointToScreenPoint(this.controlPoints[0])),e=p(this.pointToScreenPoint(this.controlPoints[1])),n=p(this.pointToScreenPoint(this.controlPoints[2]));this._distance=r(t,e,n).distance}}endChanging(){this._distance=null}setPoint(t,e,n){if(super.setPoint(t,e,n),0==t||1===t){const t=this.controlPoints,e=p(this.pointToScreenPoint(t[0])),n=p(this.pointToScreenPoint(t[1])).subtract(e),i=new c(n.y,-n.x).normalized().scaled(p(this._distance)),s=e.add(i),o=p(this.screenPointToPoint(s));this.controlPoints[2]=o}}updateAllViews(){if(!this.controlPoints.length)return;const t=[],e=[],n=[];for(let i=0;i<this.controlPoints.length;i++){const t=this.controlPoints[i],e=this.pointToScreenPoint(t);if(!e)return;n.push(new h(e,{pointIndex:i}))}t.length&&this._timeAxisPaneViews[0].update(this._calculateTimeAxisPaneViewsData(Math.min.apply(null,t),Math.max.apply(null,t))),e.length&&this._priceAxisPaneViews[0].update(this._calculatePriceAxisPaneViewData(Math.min.apply(null,e),Math.max.apply(null,e))),this._lines.update({points:n})}}class x extends s{constructor(){super(...arguments),e(this,"type",o)}createPrimitive(){return new w({id:this.id,points:[],backgroundColor:"#4caf50",color:"#4caf50",fillBackground:!0,linewidth:2,transparency:80},...this.resetArgs)}}export{x as RotatedRectangleTool};
